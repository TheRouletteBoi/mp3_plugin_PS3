# 1 "C:\\Users\\USER\\Documents\\Visual Studio 2013\\Projects\\mp3_plugin_PS3\\mp3_plugin_PS3\\main.cpp"






# 1 "C:/usr/local/cell\\target\\ppu\\include/sys/ppu_thread.h" 3
/*   SCE CONFIDENTIAL                                       */
/*   PlayStation(R)3 Programmer Tool Runtime Library 475.001 */
/*   Copyright (C) 2009 Sony Computer Entertainment Inc.    */
/*   All Rights Reserved.                                   */

/* $Id: ppu_thread.h 39303 2009-04-16 06:13:51Z haya $ */

/**
 * \ingroup all_syscall
 * \defgroup pu_thread PPU Threads
 * \brief system calls defined in sys/ppu_thread.h
 */
/*@{*/




# 1 "C:/usr/local/cell\\target\\ppu\\include/sys/cdefs.h" 3
/*   SCE CONFIDENTIAL                                       */
/*   PlayStation(R)3 Programmer Tool Runtime Library 475.001 */
/*   Copyright (C) 2006 Sony Computer Entertainment Inc.    */
/*   All Rights Reserved.                                   */




# 20 "C:/usr/local/cell\\target\\ppu\\include/sys/cdefs.h" 3

# 32 "C:/usr/local/cell\\target\\ppu\\include/sys/cdefs.h" 3






# 19 "C:/usr/local/cell\\target\\ppu\\include/sys/ppu_thread.h" 3
# 1 "C:/usr/local/cell\\target\\ppu\\include/sys/syscall.h" 3
/*   SCE CONFIDENTIAL                                       */
/*   PlayStation(R)3 Programmer Tool Runtime Library 475.001 */
/*   Copyright (C) 2005 Sony Computer Entertainment Inc.    */
/*   All Rights Reserved.                                   */




# 248 "C:/usr/local/cell\\target\\ppu\\include/sys/syscall.h" 3



/* The following macros represent the numbers for the SPU library functions. */
# 262 "C:/usr/local/cell\\target\\ppu\\include/sys/syscall.h" 3

# 1 "C:/usr/local/cell\\target\\ppu\\include/sys/types.h" 3
/*   SCE CONFIDENTIAL                                       */
/*   PlayStation(R)3 Programmer Tool Runtime Library 475.001 */
/*   Copyright (C) 2008 Sony Computer Entertainment Inc.    */
/*   All Rights Reserved.                                   */




# 1 "C:/usr/local/cell\\target\\ppu\\include/sys/syscall.h" 3
/*   SCE CONFIDENTIAL                                       */
/*   PlayStation(R)3 Programmer Tool Runtime Library 475.001 */
/*   Copyright (C) 2005 Sony Computer Entertainment Inc.    */
/*   All Rights Reserved.                                   */

# 10 "C:/usr/local/cell\\target\\ppu\\include/sys/types.h" 3
# 1 "C:/usr/local/cell\\target\\common\\include/sys/sys_types.h" 3
/*   SCE CONFIDENTIAL                                       */
/*   PlayStation(R)3 Programmer Tool Runtime Library 475.001 */
/*   Copyright (C) 2009 Sony Computer Entertainment Inc.    */
/*   All Rights Reserved.                                   */




# 1 "C:/usr/local/cell\\target\\ppu\\include/sys/integertypes.h" 3
/*   SCE CONFIDENTIAL                                       */
/*   PlayStation(R)3 Programmer Tool Runtime Library 475.001 */
/*   Copyright (C) 2005 Sony Computer Entertainment Inc.    */
/*   All Rights Reserved.                                   */






namespace std { typedef signed char int8_t;
typedef unsigned char uint8_t;
typedef signed short int16_t;
typedef unsigned short uint16_t;
typedef signed int int32_t;
typedef unsigned int uint32_t;


typedef signed long long int64_t;
typedef unsigned long long uint64_t;
typedef signed int intptr_t;
typedef unsigned int uintptr_t;
# 29 "C:/usr/local/cell\\target\\ppu\\include/sys/integertypes.h" 3

}

	using ::std:: int8_t;
using ::std:: uint8_t;
using ::std:: int16_t;
using ::std:: uint16_t;
using ::std:: int32_t;
using ::std:: uint32_t;
using ::std:: int64_t;
using ::std:: uint64_t;
using ::std:: intptr_t;
using ::std:: uintptr_t;



# 11 "C:/usr/local/cell\\target\\common\\include/sys/sys_types.h" 3





/*
 * Timer
 */
typedef ::std:: uint64_t callout_t;
typedef ::std:: uint64_t timer_t;

/*
 * Data types
 */
namespace std {
# 35 "C:/usr/local/cell\\target\\common\\include/sys/sys_types.h" 3
typedef ::std:: uint32_t size_t;
typedef ::std:: int32_t off_t;




typedef ::std:: int64_t off64_t;
typedef ::std:: int64_t time_t;




}
/*
 * Process
 */
/** \brief process id (opaque value) */
typedef ::std:: uint32_t sys_pid_t;

/* \brief program segment id (opaque value) */
typedef ::std:: uint32_t sys_program_segment_t;

/* \brief overlay module id (opaque value) */
typedef ::std:: uint32_t sys_overlay_t;


/*
 * PPU thread
 */
typedef ::std:: uint64_t sys_ppu_thread_t;

/** \brief interrupt tag id (opaque value for users) */
typedef ::std:: uint32_t sys_interrupt_tag_t;

/*
 * Synchronization
 */
typedef ::std:: uint32_t sys_mutex_t;
typedef ::std:: uint32_t sys_cond_t;
typedef ::std:: uint32_t sys_shared_mutex_t;
typedef ::std:: uint32_t sys_sync_point_t;
typedef ::std:: uint32_t sys_rwlock_t;

typedef ::std:: uint32_t sys_protocol_t;
typedef ::std:: uint32_t sys_recursive_t;
typedef ::std:: uint32_t sys_process_shared_t;
typedef ::std:: uint32_t sys_adaptive_t;

typedef ::std:: uint32_t _sys_sleep_queue_t;
typedef ::std:: uint32_t _sys_lwcond_queue_t;
typedef ::std:: uint32_t sys_semaphore_t;
typedef ::std:: uint32_t sys_event_flag_t;


/*
 * Event 
 */
typedef ::std:: uint32_t sys_event_queue_t;
typedef ::std:: uint32_t sys_event_port_t;
typedef ::std:: uint32_t sys_event_type_t;

/* 
 * SPU Thread
 */
typedef ::std:: uint32_t sys_spu_thread_group_t;
typedef ::std:: uint32_t sys_spu_thread_t;

/*
 * SPU System Module
 */
typedef ::std:: uint32_t sys_spu_system_module_t;


/*
 * Invalid values for IDs
 */





/*
 * timer
 */
typedef ::std:: uint32_t sys_timer_t;


/*
 * Time
 */
typedef ::std:: int64_t system_time_t;
typedef ::std:: uint64_t usecond_t;
typedef ::std:: uint32_t second_t;

/* IPC key */
typedef ::std:: uint64_t sys_ipc_key_t;

/*
 * Addresses and memory
 */
typedef ::std:: uintptr_t lparaddr_t;
typedef ::std:: uintptr_t sys_addr_t;
typedef ::std:: uint32_t sys_memory_t;
typedef ::std:: uint32_t sys_memory_container_t;


/*
 * System call trace
 */
typedef ::std:: uint32_t sys_trace_t;
typedef ::std:: uint32_t sys_trace_buffer_t;



/*
 * Data type for PPU GUID information
 */
namespace std { typedef struct sys_ppu_guid_info {
	const char magic[5];		/*  5 bytes : '\177'GUID              */
	const ::std:: uint8_t id_revision;	/*  1 byte  : PPU GUID revision (0x1) */
	const ::std:: uint16_t reserved1;	/*  2 bytes : Reserved (0x0)          */
	const ::std:: uint32_t ppu_guid[5];	/* 20 bytes : PPU GUID                */
	const ::std:: uint32_t reserved2;	/*  4 bytes : Reserved (0x0)          */
} sys_ppu_guid_info_t;

}
/*
 * Data types for SDK Library
 */
	namespace std {


typedef int32_t ssize_t;



typedef int mode_t;
typedef long int useconds_t;
typedef long key_t;
typedef uint32_t pid_t;
typedef unsigned long dev_t;
typedef unsigned long ino_t;
typedef unsigned long nlink_t;
typedef long blkcnt_t;
typedef long blksize_t;


}

	using ::std:: size_t;

using ::std:: off_t;
using ::std:: off64_t;
using ::std:: ssize_t;
using ::std:: mode_t;
using ::std:: useconds_t;
using ::std:: key_t;
using ::std:: dev_t;
using ::std:: ino_t;
using ::std:: nlink_t;
using ::std:: blkcnt_t;
using ::std:: blksize_t;
using ::std:: time_t;

using ::std:: sys_ppu_guid_info_t;




# 11 "C:/usr/local/cell\\target\\ppu\\include/sys/types.h" 3

/* PPU specific type declarations */

# 264 "C:/usr/local/cell\\target\\ppu\\include/sys/syscall.h" 3




/* __system_call_NNN is converted to an inline "sc" instruction */






































/*
 * Calling this macro lets the stub return to the user program.
 * 
 * \param ret_type The return parameter type
 */


/*
 * Macros to obtain the register passing return arguments.
 * 
 * __reg( n ) intrinsic gets the returned register value from the previous call/syscall
 */
# 326 "C:/usr/local/cell\\target\\ppu\\include/sys/syscall.h" 3

# 525 "C:/usr/local/cell\\target\\ppu\\include/sys/syscall.h" 3

/*
 * Macros used for register passing output arguments.
 */







# 20 "C:/usr/local/cell\\target\\ppu\\include/sys/ppu_thread.h" 3

# 1 "C:/usr/local/cell\\target\\ppu\\include/sys/return_code.h" 3
/*   SCE CONFIDENTIAL                                       */
/*   PlayStation(R)3 Programmer Tool Runtime Library 475.001 */
/*   Copyright (C) 2007 Sony Computer Entertainment Inc.    */
/*   All Rights Reserved.                                   */

/** 
 * \defgroup error_code  Error Codes
 * \brief The error codes used by Cell OS Lv-2
 */
/*@{*/



# 1 "C:/usr/local/cell\\target\\common\\include/cell/error.h" 3
/*   SCE CONFIDENTIAL
PlayStation(R)3 Programmer Tool Runtime Library 475.001
*   Copyright (C) 2009 Sony Computer Entertainment Inc.
*   All Rights Reserved.
*/





extern "C" {


/*J
 * CELL エラーコードの構造
 *
 *  0   1         3 4               15 16                   31
 * +---+-----------+------------------+-----------------------+
 * | E | Reserved  | F A C I L I T Y  |  E R R O R   C O D E  |
 * +---+-----------+------------------+-----------------------+
 *
 *  bit 0: エラーの有無(Error)
 *      1= エラー(bit 0〜31は以下の定義に従う)
 *      0= 成功(bit 0〜31も 0 にする)
 *
 *  bit 1-3: Reserved
 *      00= 常にゼロ固定
 *
 *  bit 4-15: ファシリティ(Facility)
 *      0x000= CELL_ERROR_FACILITY_NULL
 *      0x001= CELL_ERROR_FACILITY_SYSTEM_SERVICE
 *      0x002= CELL_ERROR_FACILITY_SYSTEM_UTILITY
 *         :
 *      0x800〜 予約領域
 *
 *  bit 16-31: エラーコード
 *      具体的な意味は、ファシリティコードごとに異なります。
 *      エラーコード部の値が同じでも、ファシリティコードが異なれば
 *      別個のエラーナンバーとして扱われることにご注意ください。
 */
/*E
 * CELL error code structure
 *
 *  0   1         3 4               15 16                   31
 * +---+-----------+------------------+-----------------------+
 * | E | Reserved  | F A C I L I T Y  |  E R R O R   C O D E  |
 * +---+-----------+------------------+-----------------------+
 *
 *  bit 0: Error
 *      1= Error
 *      0= Success
 *
 *  bit 1-3: Reserved
 *      00= always zero
 *
 *  bit 4-15: Facility
 *      0x000= CELL_ERROR_FACILITY_NULL
 *      0x001= CELL_ERROR_FACILITY_SYSTEM_SERVICE
 *      0x002= CELL_ERROR_FACILITY_SYSTEM_UTILITY
 *         :
 *      0x800- Reserved
 *
 *  bit 16-31: Error code
 *      Concrete meanings differ for every facility code.
 *      If facility codes differ, with the same value of an error code part
 *      must be treated as a different meanings.
 */


typedef int CellError;


/*J
 * 汎用正常終了の値
 */
/*E
 * Generic succeeded code
 */


/*J
 * エラーフラグの値
 */
/*E
 * Error flag and Critical Error flag
 */


/*J
 * ユーティリティマクロ
 */
/*E
 * Utility macro
 */

	/* Static-cast for C++ */
# 105 "C:/usr/local/cell\\target\\common\\include/cell/error.h" 3







/*J
 * ファシリティコードの定義
 */
/*E
 * Definition of facility codes
 */




























# 154 "C:/usr/local/cell\\target\\common\\include/cell/error.h" 3






}




# 15 "C:/usr/local/cell\\target\\ppu\\include/sys/return_code.h" 3

/* error code definition */


extern "C" {


/** The operation is successfully executed.*/




/** The resource is temporarily unavailable. 
 *
 * e.g. The number of threads in the system is exceeding the limit.
 */


/** An invalid argument value is specified.
 *
 * e.g. An out-of-range argument or an invalid flag.
 */


/** The feature is not yet implemented. */


/** Memory allocation failure */


/** The resource (process, thread, synchronous object, etc) with the
 * specified identifier does not exist.
 */


/** The file does not exist. */


/**  The file is not a valid ELF file. (The file is in unrecognized format.) */


/** Resource deadlock is avoided. */


/** The operation is not permitted. */


/** The device or resource is busy */


/** The operation is timed out */


/** The operation is aborted */


/** Invalid memory access */



/** State of the target thread is invalid. */


/** Alignment is invalid. */


/** Shortage of the kernel resources */


/** The file is a directory */


/** Operation canceled */


/** Entry already exists */


/** Port is already connected */


/** Port is not connected */


/** Program authentication fail */


/** The file is not a MSELF */


/** System version error */


/** Fatal system error */


# 144 "C:/usr/local/cell\\target\\ppu\\include/sys/return_code.h" 3

/** SDK version error */





}


/*@}*/
# 24 "C:/usr/local/cell\\target\\ppu\\include/sys/ppu_thread.h" 3

extern "C" {



/* An option for _sys_ppu_thread_create() */


/* An option for _sys_ppu_thread_create() */


/* Invalid PPU thread ID*/



/* this is an tls variable */
extern __declspec(thread) sys_ppu_thread_t _sys_ppu_thread_id;


typedef struct {
	sys_addr_t pst_addr;	 /**< stack address */
	::std:: size_t pst_size;		 /**< stack size    */
} sys_ppu_thread_stack_t;

/**
 * PPU Stack Information structure type
 *
 * \see sys_ppu_thread_get_stack_information
 */

typedef void (*__ppu_thread_entry) (::std:: uint64_t, ::std:: uint64_t);


typedef struct {
	sys_addr_t entry;
	sys_addr_t tls_mem_addr;
} sys_ppu_thread_init;



/**
 * The type of PPU thread context.  Integer registers only.
 */
typedef struct {
	uint64_t gpr[32];
	uint32_t cr;
	uint32_t rsv1;				/* shim */
	uint64_t xer;
	uint64_t lr;
	uint64_t ctr;
	uint64_t pc;
} sys_ppu_thread_icontext_t;




/** \brief create a PPU thread.
 *
 * The sys_ppu_thread_create() system call creates a PPU thread.  
 * The created PPU thread ID will be stored in \a thread_id.  
 *
 * The created PPU thread will execute codes in \a entry with an 
 * argument \a arg.
 *
 * \a prio specifies the priority value of the PPU thread within the 
 * range from 0 to 3071 where 0 is the highest.
 *
 * The value of \a flags is an OR of zero or the following options.
 *
 * - 0 \n
 *   non-joinable non-interrupt thread 
 * - SYS_PPU_THREAD_CREATE_JOINABLE \n
 *   Create a joinable thread 
 * - SYS_PPU_THREAD_CREATE_INTERRUPT \n
 *   Create an interrupt thread 
 * 
 * The behavior of this function is undefined, if invalid value is specified in
 * \a flags.
 *
 * If a joinable PPU thread is able to join with another PPU thread which 
 * calls sys_ppu_thread_join() as it exits.  Some of the resources of a 
 * joinable PPU thread will be left unallocated until it is joined.
 * If a non-joinable thread exits, on the other hand, its resources are 
 * immediately deallocated. 
 *
 * The SYS_PPU_THREAD_CREATE_INTERRUPT option is used only when an 
 * interrupt PPU thread is created.  
 *
 * Name of the PPU thread can be specified in \a threadname, with upto 27 
 * characters (excluding the null-terminator).
 *
 * \param thread_id      (OUT) A pointer to the storage for the PPU thread 
 *                      ID
 * \param entry         The entry point.  Pointer of entry function.
 * \param arg           An argument
 * \param prio          Priority of the thread in range 0 (highest) from 3071
 * \param stacksize     Stack size in bytes
 * \param flags         PPU thread flags 
 * \param threadname    The name of this thread (used by debugger)
 *
 * \retval CELL_OK      Success
 * \retval ENOMEM       User memory shortage for user stack area
 * \retval EAGAIN       Thread ID shortage or kernel memory shortage
 * \retval EINVAL       Priority out of range
 */
int sys_ppu_thread_create(sys_ppu_thread_t * thread_id,
						  void (*entry) (::std:: uint64_t),
						  ::std:: uint64_t arg,
						  int prio, ::std:: size_t stacksize,
						  ::std:: uint64_t flags, const char *threadname);


extern void sys_ppu_thread_exit(::std:: uint64_t val);

extern int sys_ppu_thread_get_id(sys_ppu_thread_t * thread_id);



extern void sys_ppu_thread_once(int *once_ctrl, void (*init) (void));


extern inline void sys_ppu_thread_yield(void);

extern inline void sys_ppu_thread_yield(void)
{
	extern uint64_t __system_call_43(void); uint64_t p1 = __system_call_43();;





}

extern inline int sys_ppu_thread_join(sys_ppu_thread_t thread_id,
									  ::std:: uint64_t * vptr);

extern inline int sys_ppu_thread_join(sys_ppu_thread_t thread_id,
									  ::std:: uint64_t * vptr)
{
	extern uint64_t __system_call_44(uint64_t, uint64_t); uint64_t p1 = __system_call_44(thread_id, (uint32_t) vptr);;




	return (int)(p1);
}

extern inline int sys_ppu_thread_detach(sys_ppu_thread_t thread_id);

extern inline int sys_ppu_thread_detach(sys_ppu_thread_t thread_id)
{
	extern uint64_t __system_call_45(uint64_t); uint64_t p1 = __system_call_45(thread_id);;




	return (int)(p1);
}

extern inline void sys_ppu_thread_get_join_state(int *isjoinable);

extern inline void sys_ppu_thread_get_join_state(int *isjoinable)
{
	extern uint64_t __system_call_46(uint64_t); uint64_t p1 = __system_call_46((uint32_t) isjoinable);;





}

extern inline int sys_ppu_thread_set_priority(sys_ppu_thread_t thread_id,
											  int prio);

extern inline int sys_ppu_thread_set_priority(sys_ppu_thread_t thread_id,
											  int prio)
{
	extern uint64_t __system_call_47(uint64_t, uint64_t); uint64_t p1 = __system_call_47(thread_id, prio);;




	return (int)(p1);
}

extern inline int sys_ppu_thread_get_priority(sys_ppu_thread_t thread_id,
											  int *priop);

extern inline int sys_ppu_thread_get_priority(sys_ppu_thread_t thread_id,
											  int *priop)
{
	extern uint64_t __system_call_48(uint64_t, uint64_t); uint64_t p1 = __system_call_48(thread_id, (uint32_t) priop);;




	return (int)(p1);
}

extern inline int sys_ppu_thread_get_stack_information(sys_ppu_thread_stack_t *
													   sp);

extern inline int sys_ppu_thread_get_stack_information(sys_ppu_thread_stack_t *
													   sp)
{
	extern uint64_t __system_call_49(uint64_t); uint64_t p1 = __system_call_49((uint32_t) sp);;




	return (int)(p1);
}


extern inline int sys_ppu_thread_recover_page_fault(sys_ppu_thread_t thread_id);

extern inline int sys_ppu_thread_recover_page_fault(sys_ppu_thread_t thread_id)
{
	extern uint64_t __system_call_57(uint64_t); uint64_t p1 = __system_call_57(thread_id);;




	return (int)(p1);
}

extern inline int sys_ppu_thread_get_page_fault_context(sys_ppu_thread_t
														thread_id,
														sys_ppu_thread_icontext_t
														* ctxp);

extern inline int sys_ppu_thread_get_page_fault_context(sys_ppu_thread_t
														thread_id,
														sys_ppu_thread_icontext_t
														* ctxp)
{
	extern uint64_t __system_call_58(uint64_t, uint64_t); uint64_t p1 = __system_call_58(thread_id, (uint32_t) ctxp);;





	return (int)(p1);
}




extern inline int sys_ppu_thread_rename(sys_ppu_thread_t thread_id,
										const char *name);

extern inline int sys_ppu_thread_rename(sys_ppu_thread_t thread_id,
										const char *name)
{
	extern uint64_t __system_call_56(uint64_t, uint64_t); uint64_t p1 = __system_call_56(thread_id, (uint32_t) name);;




	return (int)(p1);
}


}


/*@}*/
# 8 "C:\\Users\\USER\\Documents\\Visual Studio 2013\\Projects\\mp3_plugin_PS3\\mp3_plugin_PS3\\main.cpp"
# 1 "C:/usr/local/cell\\target\\ppu\\include/sys/sys_time.h" 3
/*   SCE CONFIDENTIAL                                       */
/*   PlayStation(R)3 Programmer Tool Runtime Library 475.001 */
/*   Copyright (C) 2006 Sony Computer Entertainment Inc.    */
/*   All Rights Reserved.                                   */

/**
 * \ingroup all_syscall
 * \defgroup sys_time System Time
 * \brief system calls defined in sys/sys_time.h
 *  
 * Interfaces defined in sys/sys_time.h
 *
 * Refer to <i>Cell OS Lv-2 User's Manual</i> for the detailed description. 
 */
/*@{*/











typedef ::std:: int64_t sys_time_sec_t;
typedef ::std:: int64_t sys_time_nsec_t;
typedef ::std:: int32_t sys_time_min_t;
typedef sys_time_min_t sys_time_timezone_t;
typedef sys_time_min_t sys_time_summertime_t;


extern "C" {

extern system_time_t sys_time_get_system_time(void);
extern inline ::std:: uint64_t sys_time_get_timebase_frequency(void);

extern inline ::std:: uint64_t sys_time_get_timebase_frequency(void)
{
	extern uint64_t __system_call_147(void); uint64_t p1 = __system_call_147();;




	return (::std:: uint64_t)(p1);
}

extern inline int sys_time_get_current_time(sys_time_sec_t * sec,
											sys_time_nsec_t * nsec);

extern inline int sys_time_get_current_time(sys_time_sec_t * sec,
											sys_time_nsec_t * nsec)
{
	extern uint64_t __system_call_145(uint64_t, uint64_t); uint64_t p1 = __system_call_145((uint32_t) sec, (uint32_t) nsec);;




	return (int)(p1);
}



}


/*@}*/
# 9 "C:\\Users\\USER\\Documents\\Visual Studio 2013\\Projects\\mp3_plugin_PS3\\mp3_plugin_PS3\\main.cpp"
# 1 "C:/usr/local/cell\\target\\ppu\\include/sys/time_util.h" 3
/*   SCE CONFIDENTIAL                                       */
/*   PlayStation(R)3 Programmer Tool Runtime Library 475.001 */
/*   Copyright (C) 2008 Sony Computer Entertainment Inc.    */
/*   All Rights Reserved.                                   */

/**
 * \ingroup lib_all_library
 * \defgroup lib_time Time Facility Functions
 * \brief Library calls defined in time_util.h
 * 
 * Interfaces defined in time_util.h
 */

/*@{*/





/**
 * Get the current timebase.
 *
 * <b>Example:</b>\n
 * \code
 *   uint64_t cur_tb;
 *   SYS_TIMEBASE_GET(cur_tb);
 * \endcode
 */


# 40 "C:/usr/local/cell\\target\\ppu\\include/sys/time_util.h" 3

# 53 "C:/usr/local/cell\\target\\ppu\\include/sys/time_util.h" 3


/*@}*/
# 10 "C:\\Users\\USER\\Documents\\Visual Studio 2013\\Projects\\mp3_plugin_PS3\\mp3_plugin_PS3\\main.cpp"
# 1 "C:/usr/local/cell\\target\\ppu\\include/sys/process.h" 3
/*   SCE CONFIDENTIAL                                       */
/*   PlayStation(R)3 Programmer Tool Runtime Library 475.001 */
/*   Copyright (C) 2010 Sony Computer Entertainment Inc.    */
/*   All Rights Reserved.                                   */

/**
 * \defgroup all_syscall System Calls
 */

/**
 * \ingroup all_syscall
 * \defgroup proc Process Management
 * \brief system calls defined in sys/process.h
 */
/*@{*/










# 1 "C:/usr/local/cell\\target\\common\\include/sdk_version.h" 3
/* SCE CONFIDENTIAL
PlayStation(R)3 Programmer Tool Runtime Library 475.001
* Copyright (C) 2015 Sony Computer Entertainment Inc.
* All Rights Reserved.
*/
 


 

 

 

# 27 "C:/usr/local/cell\\target\\ppu\\include/sys/process.h" 3

extern "C" {



/* \brief option flag for sys_game_process_exitspawn API */
# 40 "C:/usr/local/cell\\target\\ppu\\include/sys/process.h" 3



























/*
 * Process Local Object
 *
 */
# 89 "C:/usr/local/cell\\target\\ppu\\include/sys/process.h" 3


extern void __sys_process_crash_dump_param(void) __attribute__ ((weak));


/* \brief process parameters */
typedef struct {
	uint32_t size;
	uint32_t magic;
	uint32_t version;
	uint32_t sdk_version;
	int32_t primary_prio;
	uint32_t primary_stacksize;
	uint32_t malloc_pagesize;
	uint32_t ppc_seg;
	uint32_t crash_dump_param_addr;
} sys_process_param_t;




# 157 "C:/usr/local/cell\\target\\ppu\\include/sys/process.h" 3


/** \brief check whether an address is in stack or not */
extern int sys_process_is_stack(const void *p);


/** \brief section specifiers
 *
 * There macros provide an access control for variables.  To specify these macro
 * to a tail of a variable,  user can change an access authority of the variable.
 *
 *                          PPU     SPU     RSX
 * _PPU_PRIVATE_DATA_       RW-     ---     ---
 * _PPU_PRIVATE_CONST_      R--     ---     ---
 * _RSX_IMAGE_              RW-     RW-     RW-
 *
 * For example;
 *
 *  char ppu_local_data[256] _PPU_PRIVATE_DATA_;
 *  static const char ppu_local_ro_data[] _PPU_PRIVATE_CONST_ = "secret-key";
 *
 * Note that these macro can not be used for auto variables.
 *
 */





/** \brief memory mapping in the process address space (32-bit mode)
 * <PRE>
 *
 *   0xFFFF_FFFF           +-------------------------------+
 *                         | SPU Thread Mapping Area       |
 *   SPU_THREAD_BASE_ADDR  +-------------------------------+
 *                         | Raw SPU Mapping Area          |
 *   RAW_SPU_BASE_ADDR     +-------------------------------+
 *                         | User Area                     |
 *   0xD000_0000           +-------------------------------+
 *                         | RSX Frame Buffer Mapping Area |
 *   RSX_FB_BASE_ADDR      +-------------------------------+
 *                         |                               |
 *                         | User Area (heap, ...)         |
 *                         |                               |
 *                         |                               |
 *                         |                               |
 *                         +-------------------------------+
 *                         | PPU/SPU/RSX Shared Segment    |
 *                         | (.rsx_image)                  |
 *                         +-------------------------------+
 *                         | PPU Local Segment             |
 *                         | (.ppu_rodata, .ppu_data)      |
 *                         +-------------------------------+
 *                         | PPU/SPU Shared Segment        |
 *                         | (.text, .data, .bss, ...)     |
 *  TEXT_SEGMENT_BASE_ADDR +-------------------------------+
 *                         | Unmapped Area                 |
 *  0x0000_0000            +-------------------------------+
 *
 * </PRE>
 */

/** \brief  get the process id */
extern inline sys_pid_t sys_process_getpid(void);

extern inline sys_pid_t sys_process_getpid(void)
{
	extern uint64_t __system_call_1(void); uint64_t p1 = __system_call_1();;




	return (sys_pid_t)(p1);
}


/** \brief get the parent process id */
extern inline sys_pid_t sys_process_getppid(void);

extern inline sys_pid_t sys_process_getppid(void)
{
	extern uint64_t __system_call_18(void); uint64_t p1 = __system_call_18();;




	return (sys_pid_t)(p1);
}


/** \brief terminate a calling game process and create a new game process */
extern void sys_game_process_exitspawn(const char *path,
									   char const *argv[], char const *envp[],
									   sys_addr_t data, size_t data_size,
									   int prio, uint64_t flags);

/** \brief terminate a calling game process and create a new game process (2) */
extern void sys_game_process_exitspawn2(const char *path,
										char const *argv[], char const *envp[],
										sys_addr_t data,
										::std:: size_t data_size, int prio,
										::std:: uint64_t flags);

/** \brief terminate a process */
extern void sys_process_exit(int status);


extern inline int sys_process_get_number_of_object(uint32_t object,
												   size_t * nump);

extern inline int sys_process_get_number_of_object(uint32_t object,
												   size_t * nump)
{
	extern uint64_t __system_call_12(uint64_t, uint64_t); uint64_t p1 = __system_call_12(object, (uint32_t) nump);;




	return (int)(p1);
}


extern inline int sys_process_get_id(uint32_t object, uint32_t * buff,
									 size_t size, size_t * set_size);

extern inline int sys_process_get_id(uint32_t object, uint32_t * buff,
									 size_t size, size_t * set_size)
{
	extern uint64_t __system_call_13(uint64_t, uint64_t, uint64_t, uint64_t); uint64_t p1 = __system_call_13(object, (uint32_t) buff, size, (uint32_t) set_size);;





	return (int)(p1);
}


extern inline int sys_process_is_spu_lock_line_reservation_address(sys_addr_t
																   addr,
																   uint64_t
																   flags);

extern inline int sys_process_is_spu_lock_line_reservation_address(sys_addr_t
																   addr,
																   uint64_t
																   flags)
{
	extern uint64_t __system_call_14(uint64_t, uint64_t); uint64_t p1 = __system_call_14(addr, flags);;





	return (int)(p1);
}


extern inline sys_addr_t sys_process_get_ppu_guid(void);

extern inline sys_addr_t sys_process_get_ppu_guid(void)
{
	extern uint64_t __system_call_31(void); uint64_t p1 = __system_call_31();;




	return (sys_addr_t)(p1);
}


}


/*@}*/
# 11 "C:\\Users\\USER\\Documents\\Visual Studio 2013\\Projects\\mp3_plugin_PS3\\mp3_plugin_PS3\\main.cpp"
# 1 "C:/usr/local/cell\\target\\ppu\\include/sys/memory.h" 3
/*   SCE CONFIDENTIAL                                       */
/*   PlayStation(R)3 Programmer Tool Runtime Library 475.001 */
/*   Copyright (C) 2008 Sony Computer Entertainment Inc.    */
/*   All Rights Reserved.                                   */

/**
 * \ingroup all_syscall
 * \defgroup memory Process Address Space Management 
 * \brief system calls defined in sys/memory.h
 *
 * Interfaces defined in sys/memory.h
 *
 * Refer to <i>Cell OS Lv-2 User's Manual</i> for the detailed description.
 *
 */
/*@{*/














extern "C" {

/***
 *** type definition
 ***/

typedef struct sys_page_attr {
	::std:: uint64_t attribute;
	::std:: uint64_t access_right;
	::std:: size_t page_size;
	::std:: uint32_t pad;
} sys_page_attr_t;


typedef struct sys_memory_info {
	::std:: size_t total_user_memory;
	::std:: size_t available_user_memory;
} sys_memory_info_t;





/***
 *** macro definition
 ***/
/* page size flags */




/* access right flags */
# 73 "C:/usr/local/cell\\target\\ppu\\include/sys/memory.h" 3




/* user handling page fault flags */
# 84 "C:/usr/local/cell\\target\\ppu\\include/sys/memory.h" 3

/* accessor for user handling page fault event */






/* memory granularity flags */




/* mapping attribute */




/* invalid memory ID */





/***
 *** API declaration
 ***/
extern inline int sys_mmapper_allocate_address(::std:: size_t size,
											   ::std:: uint64_t flags,
											   ::std:: size_t alignment,
											   sys_addr_t * alloc_addr);

extern inline int sys_mmapper_allocate_address(::std:: size_t size,
											   ::std:: uint64_t flags,
											   ::std:: size_t alignment,
											   sys_addr_t * alloc_addr)
{
	extern uint64_t __system_call_330(uint64_t, uint64_t, uint64_t, uint64_t); uint64_t p1 = __system_call_330(size, flags, alignment, (uint32_t) alloc_addr);;





	return (int)(p1);
}


extern inline int sys_mmapper_allocate_fixed_address(void);

extern inline int sys_mmapper_allocate_fixed_address(void)
{
	extern uint64_t __system_call_326(void); uint64_t p1 = __system_call_326();;




	return (int)(p1);
}


extern inline int sys_mmapper_free_address(sys_addr_t start_addr);

extern inline int sys_mmapper_free_address(sys_addr_t start_addr)
{
	extern uint64_t __system_call_331(uint64_t); uint64_t p1 = __system_call_331(start_addr);;




	return (int)(p1);
}



extern inline int sys_mmapper_change_address_access_right(sys_addr_t start_addr,
														  ::std:: uint64_t
														  flags);

extern inline int sys_mmapper_change_address_access_right(sys_addr_t start_addr,
														  ::std:: uint64_t flags)
{
	extern uint64_t __system_call_336(uint64_t, uint64_t); uint64_t p1 = __system_call_336(start_addr, flags);;




	return (int)(p1);
}


extern inline int sys_mmapper_search_and_map(sys_addr_t start_addr,
											 sys_memory_t mem_id,
											 ::std:: uint64_t flags,
											 sys_addr_t * alloc_addr);

extern inline int sys_mmapper_search_and_map(sys_addr_t start_addr,
											 sys_memory_t mem_id,
											 ::std:: uint64_t flags,
											 sys_addr_t * alloc_addr)
{
	extern uint64_t __system_call_337(uint64_t, uint64_t, uint64_t, uint64_t); uint64_t p1 = __system_call_337(start_addr, mem_id, flags, (uint32_t) alloc_addr);;





	return (int)(p1);
}


extern int sys_mmapper_allocate_memory(::std:: size_t size,
									   ::std:: uint64_t flags,
									   sys_memory_t * mem_id);

extern int sys_mmapper_allocate_memory_from_container(size_t size,
													  sys_memory_container_t
													  container, uint64_t flags,
													  sys_memory_t * mem_id);


extern int sys_mmapper_free_memory(sys_memory_t mem_id);

extern int sys_mmapper_map_memory(sys_addr_t start_addr,
								  sys_memory_t mem_id, ::std:: uint64_t flags);

extern int sys_mmapper_unmap_memory(sys_addr_t start_addr,
									sys_memory_t * mem_id);

extern inline int sys_memory_get_page_attribute(sys_addr_t addr,
												sys_page_attr_t * attr);

extern inline int sys_memory_get_page_attribute(sys_addr_t addr,
												sys_page_attr_t * attr)
{
	extern uint64_t __system_call_351(uint64_t, uint64_t); uint64_t p1 = __system_call_351(addr, (uint32_t) attr);;




	return (int)(p1);
}


extern inline int sys_memory_get_user_memory_size(sys_memory_info_t * mem_info);

extern inline int sys_memory_get_user_memory_size(sys_memory_info_t * mem_info)
{
	extern uint64_t __system_call_352(uint64_t); uint64_t p1 = __system_call_352((uint32_t) mem_info);;




	return (int)(p1);
}


extern inline int sys_memory_allocate(::std:: size_t size, ::std:: uint64_t flags,
									  sys_addr_t * alloc_addr);

extern inline int sys_memory_allocate(::std:: size_t size, ::std:: uint64_t flags,
									  sys_addr_t * alloc_addr)
{
	extern uint64_t __system_call_348(uint64_t, uint64_t, uint64_t); uint64_t p1 = __system_call_348(size, flags, (uint32_t) alloc_addr);;




	return (int)(p1);
}

extern inline int sys_memory_allocate_from_container(::std:: size_t size,
													 sys_memory_container_t
													 container,
													 ::std:: uint64_t flags,
													 sys_addr_t * alloc_addr);

extern inline int sys_memory_allocate_from_container(::std:: size_t size,
													 sys_memory_container_t
													 container,
													 ::std:: uint64_t flags,
													 sys_addr_t * alloc_addr)
{
	extern uint64_t __system_call_350(uint64_t, uint64_t, uint64_t, uint64_t); uint64_t p1 = __system_call_350(size, container, flags, (uint32_t) alloc_addr);;





	return (int)(p1);
}


extern inline int sys_memory_free(sys_addr_t start_addr);

extern inline int sys_memory_free(sys_addr_t start_addr)
{
	extern uint64_t __system_call_349(uint64_t); uint64_t p1 = __system_call_349(start_addr);;




	return (int)(p1);
}



extern inline int sys_memory_container_create(sys_memory_container_t * cid,
											  ::std:: size_t yield_size);

extern inline int sys_memory_container_create(sys_memory_container_t * cid,
											  ::std:: size_t yield_size)
{
	extern uint64_t __system_call_324(uint64_t, uint64_t); uint64_t p1 = __system_call_324((uint32_t) cid, yield_size);;




	return (int)(p1);
}

extern inline int sys_memory_container_destroy(sys_memory_container_t cid);

extern inline int sys_memory_container_destroy(sys_memory_container_t cid)
{
	extern uint64_t __system_call_325(uint64_t); uint64_t p1 = __system_call_325(cid);;




	return (int)(p1);
}



extern inline int sys_memory_container_get_size(sys_memory_info_t * mem_info,
												sys_memory_container_t cid);

extern inline int sys_memory_container_get_size(sys_memory_info_t * mem_info,
												sys_memory_container_t cid)
{
	extern uint64_t __system_call_343(uint64_t, uint64_t); uint64_t p1 = __system_call_343((uint32_t) mem_info, cid);;




	return (int)(p1);
}
















extern inline int sys_mmapper_enable_page_fault_notification(sys_addr_t
															 start_addr,
															 sys_event_queue_t
															 queue_id);

extern inline int sys_mmapper_enable_page_fault_notification(sys_addr_t
															 start_addr,
															 sys_event_queue_t
															 queue_id)
{
	extern uint64_t __system_call_327(uint64_t, uint64_t); uint64_t p1 = __system_call_327(start_addr, queue_id);;





	return (int)(p1);
}




}


/*@}*/
# 12 "C:\\Users\\USER\\Documents\\Visual Studio 2013\\Projects\\mp3_plugin_PS3\\mp3_plugin_PS3\\main.cpp"
# 1 "C:/usr/local/cell\\target\\ppu\\include/sys/timer.h" 3
/*   SCE CONFIDENTIAL                                       */
/*   PlayStation(R)3 Programmer Tool Runtime Library 475.001 */
/*   Copyright (C) 2008 Sony Computer Entertainment Inc.    */
/*   All Rights Reserved.                                   */

/**
 * \ingroup all_syscall
 * \defgroup timer Timer
 * \brief system calls defined in sys/timer.h
 *  
 * Interfaces defined in sys/timer.h
 *
 * Refer to <i>Cell OS Lv-2 User's Manual</i> for the detailed description. 
 */
/*@{*/









extern "C" {


extern inline int sys_timer_usleep(usecond_t sleep_time);

extern inline int sys_timer_usleep(usecond_t sleep_time)
{
	extern uint64_t __system_call_141(uint64_t); uint64_t p1 = __system_call_141(sleep_time);;




	return (int)(p1);
}

extern inline int sys_timer_sleep(second_t sleep_time);

extern inline int sys_timer_sleep(second_t sleep_time)
{
	extern uint64_t __system_call_142(uint64_t); uint64_t p1 = __system_call_142(sleep_time);;




	return (int)(p1);
}









typedef struct {
	system_time_t next_expiration_time;
	usecond_t period;
	::std:: uint32_t timer_state;
	::std:: uint32_t pad;
} sys_timer_information_t;

extern inline int sys_timer_create(sys_timer_t * timer_id);

extern inline int sys_timer_create(sys_timer_t * timer_id)
{
	extern uint64_t __system_call_70(uint64_t); uint64_t p1 = __system_call_70((uint32_t) timer_id);;




	return (int)(p1);
}


extern inline int sys_timer_destroy(sys_timer_t timer_id);

extern inline int sys_timer_destroy(sys_timer_t timer_id)
{
	extern uint64_t __system_call_71(uint64_t); uint64_t p1 = __system_call_71(timer_id);;




	return (int)(p1);
}


extern inline int sys_timer_get_information(sys_timer_t timer_id,
											sys_timer_information_t * info);

extern inline int sys_timer_get_information(sys_timer_t timer_id,
											sys_timer_information_t * info)
{
	extern uint64_t __system_call_72(uint64_t, uint64_t); uint64_t p1 = __system_call_72(timer_id, (uint32_t) info);;




	return (int)(p1);
}


extern inline int _sys_timer_start(sys_timer_t timer_id,
								   system_time_t base_time, usecond_t period);

extern inline int _sys_timer_start(sys_timer_t timer_id,
								   system_time_t base_time, usecond_t period)
{
	extern uint64_t __system_call_73(uint64_t, uint64_t, uint64_t); uint64_t p1 = __system_call_73(timer_id, base_time, period);;




	return (int)(p1);
}


extern inline int sys_timer_stop(sys_timer_t timer_id);

extern inline int sys_timer_stop(sys_timer_t timer_id)
{
	extern uint64_t __system_call_74(uint64_t); uint64_t p1 = __system_call_74(timer_id);;




	return (int)(p1);
}



extern inline int sys_timer_start_oneshot(sys_timer_t timer_id,
										  system_time_t expiration_time);

extern inline int sys_timer_start_oneshot(sys_timer_t timer_id,
										  system_time_t expiration_time)
{
	return _sys_timer_start(timer_id, expiration_time, 0);
}

extern inline int sys_timer_start_periodic(sys_timer_t timer_id,
										   usecond_t period);

extern inline int sys_timer_start_periodic(sys_timer_t timer_id,
										   usecond_t period)
{
	return _sys_timer_start(timer_id, 0, period);
}

extern inline int sys_timer_start_periodic_absolute(sys_timer_t timer_id,
													system_time_t exp_time,
													usecond_t period);

extern inline int sys_timer_start_periodic_absolute(sys_timer_t timer_id,
													system_time_t exp_time,
													usecond_t period)
{
	return _sys_timer_start(timer_id, exp_time, period);
}

extern inline int sys_timer_connect_event_queue(sys_timer_t timer_id,
												sys_event_queue_t queue_id,
												::std:: uint64_t name,
												::std:: uint64_t data1,
												::std:: uint64_t data2);

extern inline int sys_timer_connect_event_queue(sys_timer_t timer_id,
												sys_event_queue_t queue_id,
												::std:: uint64_t name,
												::std:: uint64_t data1,
												::std:: uint64_t data2)
{
	extern uint64_t __system_call_75(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t); uint64_t p1 = __system_call_75(timer_id, queue_id, name, data1, data2);;





	return (int)(p1);
}


extern inline int sys_timer_disconnect_event_queue(sys_timer_t timer_id);

extern inline int sys_timer_disconnect_event_queue(sys_timer_t timer_id)
{
	extern uint64_t __system_call_76(uint64_t); uint64_t p1 = __system_call_76(timer_id);;




	return (int)(p1);
}


}


/*@}*/
# 13 "C:\\Users\\USER\\Documents\\Visual Studio 2013\\Projects\\mp3_plugin_PS3\\mp3_plugin_PS3\\main.cpp"
# 1 "C:/usr/local/cell\\target\\ppu\\include/sys/prx.h" 3
/*   SCE CONFIDENTIAL                                       */
/*   PlayStation(R)3 Programmer Tool Runtime Library 475.001 */
/*   Copyright (C) 2009 Sony Computer Entertainment Inc.    */
/*   All Rights Reserved.                                   */








# 1 "C:/usr/local/cell\\target\\ppu\\include/sys/moduleexport.h" 3
/*   SCE CONFIDENTIAL                                       */
/*   PlayStation(R)3 Programmer Tool Runtime Library 475.001 */
/*   Copyright (C) 2008 Sony Computer Entertainment Inc.    */
/*   All Rights Reserved.                                   */

/*                 -*- mode: c; tab-width: 4; indent-tabs-mode: nil; -*- */
/* SCE CONFIDENTIAL
 PlayStation(R)3 Programmer Tool Runtime Library 475.001
 *
 *      Copyright (C) 2008 Sony Computer Entertainment Inc.
 *                        All Rights Reserved.
 *
 */
/*
 * $Id: moduleexport.h 33871 2006-05-30 18:46:04Z tei $
 *
 * module - moduleexport.h
 *   module export macros
 *
 *      Date            Design      Log
 *  -------------------------------------------------------------------------
 *      2004-05-10      isii        initial implementation
 *      2004-09-22      isii        change '__asm__' to variable declare
 *      2004-10-14      isii        add variable export
 *      2004-11-03      isii        separate GCC and other
 *      2004-12-22      isii        refine __asm__ and defined(__GNUC__)
 *      2005-01-10      kono        suppress warning
 *      2005-07-22      isii        add nidname for calculate NID
 *                                  SCE_LIB_EXPORT_OTHER_NID(), etc
 *                                  SCE_LIB_EXPORT_VAR_OTHER_NID(), etc
 *                                  refine __asm__ and defined(__GNUC__)
 *      2005-08-12      isii        add SCE_LIB_DECLARE_WITH_STUB_NSUFFIX()
 *                                  add SCE_LIB_DECLARE_WITH_NID_SUFFIX()
 *      2006-02-13      isii        for PS3/PPU
 *      2006-05-12      isii        macro prefix 'SCE' change to 'SYS'
 *      2007-11-28      ten         add SYS_MODULE_EXIT
 */












/* ------------ basic macros ------------ */

















# 84 "C:/usr/local/cell\\target\\ppu\\include/sys/moduleexport.h" 3

# 100 "C:/usr/local/cell\\target\\ppu\\include/sys/moduleexport.h" 3

# 118 "C:/usr/local/cell\\target\\ppu\\include/sys/moduleexport.h" 3

# 134 "C:/usr/local/cell\\target\\ppu\\include/sys/moduleexport.h" 3



















# 176 "C:/usr/local/cell\\target\\ppu\\include/sys/moduleexport.h" 3

# 200 "C:/usr/local/cell\\target\\ppu\\include/sys/moduleexport.h" 3

# 231 "C:/usr/local/cell\\target\\ppu\\include/sys/moduleexport.h" 3





























































/* ------------ module entry macros ------------ */
typedef struct _scemoduleinfo {
	unsigned short modattribute;
	unsigned char modversion[2];	/* minor, major, etc... */
	char modname[27];
	char terminal;
	void *gp_value;
	const void *ent_top;
	const void *ent_end;
	const void *stub_top;
	const void *stub_end;
} _sceModuleInfo;

typedef const _sceModuleInfo SceModuleInfo;






# 333 "C:/usr/local/cell\\target\\ppu\\include/sys/moduleexport.h" 3

# 356 "C:/usr/local/cell\\target\\ppu\\include/sys/moduleexport.h" 3














































/* for compatbility */





















# 14 "C:/usr/local/cell\\target\\ppu\\include/sys/prx.h" 3







extern "C" {














typedef int32_t sys_prx_id_t;
typedef uint64_t sys_prx_flags_t;

/* segment information */
typedef struct {
	uint64_t base;				/* segment base */
	uint64_t filesz;			/* segment size */
	uint64_t memsz;				/* segment size */
	uint64_t index;				/* segment index */
	uint64_t type;				/* segment type == ELF type */
} sys_prx_segment_info_t;

/* .lib.ent section information */
typedef struct sys_prx_libent32_t {
	unsigned char structsize;	/* 28 */
	unsigned char reserved1[1];
	unsigned short version;
	unsigned short attribute;
	unsigned short nfunc;
	unsigned short nvar;
	unsigned short ntls;
	unsigned char hashinfo;		/* funchashinfo + (varhashinfo << 4) */
	unsigned char hashinfo2;	/* tls */
	unsigned char reserved2[1];
	unsigned char nidaltsets;	/* number of alternate nid set */
	uint32_t libname;
	uint32_t nidtable;
	uint32_t addtable;
} sys_prx_libent32_t;

/* .lib.stub section information */
typedef struct sys_prx_libstub32_t {
	unsigned char structsize;	/* 44 */
	unsigned char reserved1[1];
	unsigned short version;
	unsigned short attribute;
	unsigned short nfunc;
	unsigned short nvar;
	unsigned short ntls;
	unsigned char reserved2[4];
	uint32_t libname;
	uint32_t func_nidtable;
	uint32_t func_table;
	uint32_t var_nidtable;
	uint32_t var_table;
	uint32_t tls_nidtable;
	uint32_t tls_table;
} sys_prx_libstub32_t;



/* PowerPC relocations defined by the ABIs */





# 99 "C:/usr/local/cell\\target\\ppu\\include/sys/prx.h" 3

typedef struct sys_prx_link32_t {
	uint32_t type;				/* relocation type */
	uint32_t address;			/* target address */
	uint32_t addend;			/* addend */
} sys_prx_link32_t;


/* this type is mode dependent */
typedef int (*sys_prx_entry_t) (size_t args, void *argv);

typedef int (*sys_prx_entry_pe_t) (uint64_t entry, size_t args, void *argv);

typedef struct sys_prx_start_option_t {
	uint64_t size;				/* sizeof(this) */
} sys_prx_start_option_t;

typedef struct sys_prx_stop_option_t {
	uint64_t size;				/* sizeof(this) */
} sys_prx_stop_option_t;

typedef struct sys_prx_load_module_option_t {
	uint64_t size;				/* sizeof(this) */
} sys_prx_load_module_option_t;

typedef struct sys_prx_load_module_list_option_t {
	uint64_t size;				/* sizeof(this) */
} sys_prx_load_module_list_option_t;

typedef struct sys_prx_start_module_option_t {
	uint64_t size;				/* sizeof(this) */
} sys_prx_start_module_option_t;

typedef struct sys_prx_stop_module_option_t {
	uint64_t size;				/* sizeof(this) */
} sys_prx_stop_module_option_t;

typedef struct sys_prx_unload_module_option_t {
	uint64_t size;				/* sizeof(this) */
} sys_prx_unload_module_option_t;

typedef struct sys_prx_register_module_option_t {
	uint64_t size;				/* sizeof(this) */
} sys_prx_register_module_option_t;

typedef struct sys_prx_get_module_id_by_name_option_t {
	uint64_t size;				/* sizeof(this) */
} sys_prx_get_module_id_by_name_option_t;

# 157 "C:/usr/local/cell\\target\\ppu\\include/sys/prx.h" 3
typedef char *sys_prx_user_pchar_t;
typedef sys_prx_segment_info_t *sys_prx_user_segment_vector_t;
typedef sys_prx_libent32_t *sys_prx_user_libent_addr_t;
typedef sys_prx_libstub32_t *sys_prx_user_libstub_addr_t;
typedef sys_prx_id_t *sys_prx_user_p_prx_id_t;
typedef const void *sys_prx_user_p_const_void_t;
typedef const void *sys_prx_user_p_stop_level_t;


typedef struct sys_prx_get_module_list_t {
	uint64_t size;				/* sizeof(this) *//* 8 */
	uint32_t max;
	uint32_t count;				/* 16 */
	sys_prx_user_p_prx_id_t idlist;
	sys_prx_user_p_stop_level_t levellist;	/* 24 */
} sys_prx_get_module_list_t;

typedef struct sys_prx_module_info_t {
	uint64_t size;
	char name[30];
	char version[2];
	uint32_t modattribute;
	uint32_t start_entry;
	uint32_t stop_entry;
	uint32_t all_segments_num;
	sys_prx_user_pchar_t filename;
	uint32_t filename_size;
	sys_prx_user_segment_vector_t segments;
	uint32_t segments_num;
} sys_prx_module_info_t;

typedef struct sys_prx_module_info_v2_t {
	uint64_t size;
	char name[30];
	char version[2];
	uint32_t modattribute;
	uint32_t start_entry;
	uint32_t stop_entry;
	uint32_t all_segments_num;
	sys_prx_user_pchar_t filename;
	uint32_t filename_size;
	sys_prx_user_segment_vector_t segments;
	uint32_t segments_num;

	/* add (ver.2) */
	sys_prx_user_libent_addr_t libent_addr;
	uint32_t libent_size;
	sys_prx_user_libstub_addr_t libstub_addr;
	uint32_t libstub_size;
} sys_prx_module_info_v2_t;

/* PRX (shared) library interface */
extern int sys_prx_version;




sys_prx_id_t sys_prx_load_module(const char *path, uint64_t flags,
								 sys_prx_load_module_option_t * pOpt);
sys_prx_id_t sys_prx_load_module_on_memcontainer(const char *path,
												 sys_memory_container_t
												 mem_container, uint64_t flags,
												 sys_prx_load_module_option_t *
												 pOpt);
sys_prx_id_t sys_prx_load_module_by_fd(int fd, off64_t offset, uint64_t flags,
									   sys_prx_load_module_option_t * pOpt);
sys_prx_id_t sys_prx_load_module_on_memcontainer_by_fd(int fd, off64_t offset,
													   sys_memory_container_t
													   mem_container,
													   uint64_t flags,
													   sys_prx_load_module_option_t
													   * pOpt);

int sys_prx_load_module_list(int n, const char **path_list, uint64_t flags,
							 sys_prx_load_module_list_option_t * pOpt,
							 sys_prx_id_t * idlist);
int sys_prx_load_module_list_on_memcontainer(int n, const char **path_list,
											 sys_memory_container_t
											 mem_container, uint64_t flags,
											 sys_prx_load_module_list_option_t *
											 pOpt, sys_prx_id_t * idlist);

int sys_prx_start_module(sys_prx_id_t id, size_t args, void *argp,
						 int *modres, sys_prx_flags_t flags,
						 sys_prx_start_module_option_t * pOpt);
int sys_prx_stop_module(sys_prx_id_t id, size_t args, void *argp,
						int *modres, sys_prx_flags_t flags,
						sys_prx_stop_module_option_t * pOpt);
int sys_prx_unload_module(sys_prx_id_t id, sys_prx_flags_t flags,
						  const sys_prx_unload_module_option_t * pOpt);

int sys_prx_register_module(const sys_prx_register_module_option_t * pOpt);

int sys_prx_get_module_list(sys_prx_flags_t flags,
							sys_prx_get_module_list_t * pInfo);
int sys_prx_get_module_info(sys_prx_id_t id, sys_prx_flags_t,
							sys_prx_module_info_t * p_info);
sys_prx_id_t sys_prx_get_module_id_by_name(const char *name,
										   sys_prx_flags_t flags,
										   sys_prx_get_module_id_by_name_option_t
										   * pOpt);
sys_prx_id_t sys_prx_get_module_id_by_address(void *addr);
sys_prx_id_t sys_prx_get_my_module_id(	);
										 sys_addr_t
										 sys_prx_get_ppu_guid(sys_prx_id_t
															  modid);
										 int sys_prx_register_library(void
																	  *pLibEnt);
										 int sys_prx_unregister_library(void
																		*pLibEnt);
}
# 15 "C:\\Users\\USER\\Documents\\Visual Studio 2013\\Projects\\mp3_plugin_PS3\\mp3_plugin_PS3\\main.cpp"
# 1 "C:/usr/local/cell\\target\\ppu\\include/cell/fs/cell_fs_errno.h" 3
/*   SCE CONFIDENTIAL                                       */
/*   PlayStation(R)3 Programmer Tool Runtime Library 475.001 */
/*   Copyright (C) 2006 Sony Computer Entertainment Inc.    */
/*   All Rights Reserved.                                   */




/*
 * errnos for file system are moved to include/sys/fs.h
 */
# 1 "C:/usr/local/cell\\target\\ppu\\include/sys/fs.h" 3
/*   SCE CONFIDENTIAL                                       */
/*   PlayStation(R)3 Programmer Tool Runtime Library 475.001 */
/*   Copyright (C) 2006 Sony Computer Entertainment Inc.    */
/*   All Rights Reserved.                                   */




# 1 "C:/usr/local/cell\\target\\ppu\\include/stdio.h" 3
/* SCE CONFIDENTIAL
PlayStation(R)3 Programmer Tool Runtime Library 475.001
* Copyright (C) 2007 Sony Computer Entertainment Inc. 
* All Rights Reserved.
*/
/* stdio.h standard header */
# 1 "C:/usr/local/cell\\target\\ppu\\include/yvals.h" 3
/* SCE CONFIDENTIAL
PlayStation(R)3 Programmer Tool Runtime Library 475.001
* Copyright (C) 2006 Sony Computer Entertainment Inc. 
* All Rights Reserved.
*/
/* yvals.h values header for conforming compilers on various systems */




# 24 "C:/usr/local/cell\\target\\ppu\\include/yvals.h" 3

# 1 "C:/usr/local/cell\\target\\ppu\\include/stdarg.h" 3
/* SCE CONFIDENTIAL
PlayStation(R)3 Programmer Tool Runtime Library 475.001
* Copyright (C) 2011 Sony Computer Entertainment Inc.
* All Rights Reserved.
*/





typedef char *   va_list;


  extern  "C"
  {

    extern char  *__va_funcx(int, va_list, ...) ; /* expanded by compiler */

  }


# 28 "C:/usr/local/cell\\target\\ppu\\include/stdarg.h" 3

# 39 "C:/usr/local/cell\\target\\ppu\\include/stdarg.h" 3

# 26 "C:/usr/local/cell\\target\\ppu\\include/yvals.h" 3




/* You can predefine (on the compile command line, for example):

_ALT_NS=1 -- to use namespace _Dinkum_std for C++
_ALT_NS=2 -- to use namespace _Dinkum_std for C++ and C
_C_AS_CPP -- to compile C library as C++
_C_IN_NS -- to define C names in std/_Dinkum_std instead of global namespace
_C99 -- to turn ON C99 library support
_NO_EX -- to turn OFF use of try/throw
_NO_MT -- to turn OFF thread synchronization
_NO_NS -- to turn OFF use of namespace declarations
_STL_DB (or _STLP_DEBUG) -- to turn ON iterator/range debugging
__NO_LONG_LONG -- to define _Longlong as long, not long long

You can change (in this header):

_COMPILER_TLS -- from 0 to 1 if _TLS_QUAL is not nil
_EXFAIL -- from 1 to any nonzero value for EXIT_FAILURE
_FILE_OP_LOCKS -- from 0 to 1 for file atomic locks
_GLOBAL_LOCALE -- from 0 to 1 for shared locales instead of per-thread
_HAS_IMMUTABLE_SETS -- from 1 to 0 to permit alterable set elements
_HAS_STRICT_CONFORMANCE -- from 0 to 1 to disable nonconforming extensions
_HAS_TRADITIONAL_IOSTREAMS -- from 1 to 0 to omit old iostreams functions
_HAS_TRADITIONAL_ITERATORS -- from 0 to 1 for vector/string pointer iterators
_HAS_TRADITIONAL_POS_TYPE -- from 0 to 1 for streampos same as streamoff
_HAS_TRADITIONAL_STL -- from 1 to 0 to omit old STL functions
_IOSTREAM_OP_LOCKS -- from 0 to 1 for iostream atomic locks
_TLS_QUAL -- from nil to compiler TLS qualifier, such as __declspec(thread)
_USE_EXISTING_SYSTEM_NAMES -- from 1 to 0 to disable mappings (_Open to open)

Include directories needed to compile with Dinkum C:

C -- include/c
C99 -- include/c (define _C99)
Standard C++ -- include/c include

Include directories needed to compile with native C:

C -- none
C99 -- N/A
Standard C++ -- include
 */

 /* Dinkumware configuration defines for ppu-lv2.  These are dinkumware
    implementation details, so we set them here, rather than having the
    compiler set them. */



 /* We set _C_IN_NS so it compliant with C++ standard.  An end user
    can prevent it from being set by setting _C_IN_GLOBAL. */




















		/* DETERMINE MACHINE TYPE */

# 109 "C:/usr/local/cell\\target\\ppu\\include/yvals.h" 3

# 119 "C:/usr/local/cell\\target\\ppu\\include/yvals.h" 3

# 127 "C:/usr/local/cell\\target\\ppu\\include/yvals.h" 3

		/* DETERMINE _Ptrdifft AND _Sizet FROM MACHINE TYPE */


typedef int _Int32t;
typedef unsigned int _Uint32t;







typedef int _Ptrdifft;






typedef unsigned int _Sizet;









		/* EXCEPTION CONTROL */
# 165 "C:/usr/local/cell\\target\\ppu\\include/yvals.h" 3



		/* NAMING PROPERTIES */
/* #define _STD_LINKAGE	defines C names as extern "C++" */
/* #define _STD_USING	defines C names in namespace std or _Dinkum_std */



















		/* THREAD AND LOCALE CONTROL */












/* LV2-MODIFIED */


/* LV2-MODIFIED END */

		/* THREAD-LOCAL STORAGE */
# 216 "C:/usr/local/cell\\target\\ppu\\include/yvals.h" 3

# 223 "C:/usr/local/cell\\target\\ppu\\include/yvals.h" 3







# 236 "C:/usr/local/cell\\target\\ppu\\include/yvals.h" 3

		/* NAMESPACE CONTROL */




namespace std {}





# 278 "C:/usr/local/cell\\target\\ppu\\include/yvals.h" 3

# 287 "C:/usr/local/cell\\target\\ppu\\include/yvals.h" 3






# 309 "C:/usr/local/cell\\target\\ppu\\include/yvals.h" 3












# 327 "C:/usr/local/cell\\target\\ppu\\include/yvals.h" 3





# 350 "C:/usr/local/cell\\target\\ppu\\include/yvals.h" 3

# 369 "C:/usr/local/cell\\target\\ppu\\include/yvals.h" 3

/* Inline definitions are only supported in C99 or C++. */




     /* GCC doesn't handle C99 inline definitions correctly, but will
      * give the same behaviour if we explicitly say 'extern'. */
# 387 "C:/usr/local/cell\\target\\ppu\\include/yvals.h" 3

# 410 "C:/usr/local/cell\\target\\ppu\\include/yvals.h" 3


namespace std {
typedef bool _Bool;
}


		/* VC++ COMPILER PARAMETERS */



# 427 "C:/usr/local/cell\\target\\ppu\\include/yvals.h" 3

namespace std {
		/* FLOATING-POINT PROPERTIES */






		/* INTEGER PROPERTIES */
















typedef long long _Longlong;
typedef unsigned long long _ULonglong;

# 462 "C:/usr/local/cell\\target\\ppu\\include/yvals.h" 3

		/* wchar_t AND wint_t PROPERTIES */



typedef wchar_t _Wchart;


# 482 "C:/usr/local/cell\\target\\ppu\\include/yvals.h" 3
 /* Values for the SN Systems SNC for PS3 compiler. */




  




typedef int _Wintt;

# 506 "C:/usr/local/cell\\target\\ppu\\include/yvals.h" 3

		/* POINTER PROPERTIES */


		/* signal PROPERTIES */




		/* stdarg PROPERTIES */
typedef va_list _Va_list;



# 526 "C:/usr/local/cell\\target\\ppu\\include/yvals.h" 3



		/* stdlib PROPERTIES */


extern "C" {
void _Atexit(void (*)(void));
}

		/* stdio PROPERTIES */









typedef char _Sysch_t;

		/* STORAGE ALIGNMENT PROPERTIES */


		/* time PROPERTIES */
/** LV2_MODIFIED **/


}

extern "C" {
# 566 "C:/usr/local/cell\\target\\ppu\\include/yvals.h" 3
typedef void *_Rmtx;

}

		/* MULTITHREAD PROPERTIES */


extern "C" {
void _Locksyslock(int);
void _Unlocksyslock(int);
}






		/* LOCK MACROS */
# 594 "C:/usr/local/cell\\target\\ppu\\include/yvals.h" 3










namespace std {
extern "C++" {	// in case of _C_AS_CPP
		// CLASS _Lockit
class _Lockit
	{	// lock while object in existence -- MUST NEST
public:

# 628 "C:/usr/local/cell\\target\\ppu\\include/yvals.h" 3

	explicit _Lockit()
		: _Locktype(1)
		{	// set default lock
		
			_Locksyslock(_Locktype);
		}

	explicit _Lockit(int _Type)
		: _Locktype(_Type)
		{	// set the lock
		
			_Locksyslock(_Locktype);
		}

	~_Lockit()
		{	// clear the lock
		
			_Unlocksyslock(_Locktype);
		}

private:
	int _Locktype;
public:
	_Lockit(const _Lockit&);			// not defined
	_Lockit& operator=(const _Lockit&);	// not defined


	};

class _Mutex
	{	// lock under program control
public:

# 672 "C:/usr/local/cell\\target\\ppu\\include/yvals.h" 3
	_Mutex();
	~_Mutex();
	void _Lock();
	void _Unlock();

private:
	_Mutex(const _Mutex&);				// not defined
	_Mutex& operator=(const _Mutex&);	// not defined
	_Rmtx *_Mtx;


	};
}	// extern "C++"
}


		/* MISCELLANEOUS MACROS */


















namespace std {
using ::va_list;
}





# 723 "C:/usr/local/cell\\target\\ppu\\include/yvals.h" 3



/*
 * Copyright (c) 1992-2003 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
V4.02:0216 */
# 11 "C:/usr/local/cell\\target\\ppu\\include/stdio.h" 3




namespace std {





/** #if defined(_WIN32_C_LIB)      \ **/










		/* MACROS */








# 49 "C:/usr/local/cell\\target\\ppu\\include/stdio.h" 3


















		/* TYPE DEFINITIONS */


typedef struct _Mbstatet
	{	/* state of a multibyte translation */
	unsigned long _Wchar;
	unsigned short _Byte, _State;
	} _Mbstatet;
/* This macro is refered to by iosfwd, stdexcept, xlocale */




typedef struct fpos_t
	{	/* file position */
	long _Off;	/* can be system dependent */
	_Mbstatet _Wstate;
	} fpos_t;



typedef struct _Filet
	{	/* file control information */
	unsigned short _Mode;
	unsigned char _Idx;
	signed short _Handle;

	unsigned char *_Buf, *_Bend, *_Next;
	unsigned char *_Rend, *_Wend, *_Rback;

	_Wchart *_WRback, _WBack[2];
	unsigned char *_Rsave, *_WRend, *_WWend;

	_Mbstatet _Wstate;
	struct _Filet *_Next_elem;
	unsigned char _Back[3], _Cbuf;

	_Rmtx *_stream_mtx;

	uint64_t fpos;
	uint64_t _Rsize;
	uint64_t _offset;
	unsigned char *_BRend;
	unsigned short _Bflag;
	} _Filet;
typedef _Filet FILE;

		/* declarations */
extern "C" {
extern FILE _Stdin, _Stdout, _Stderr;

void clearerr(FILE *);
int fclose(FILE *);
int feof(FILE *);
int ferror(FILE *);
int fflush(FILE *);
int fgetc(FILE *);
int fgetpos(FILE *, fpos_t *);
char *fgets(char *, int, FILE *);
FILE *fopen(const char *, const char *);
FILE *fdopen(int, const char *);
int fileno(FILE *);
int fprintf(FILE *, const char *, ...);
int fputc(int, FILE *);
int fputs(const char *, FILE *);
size_t fread(void *, size_t, size_t, FILE *);
FILE *freopen(const char *, const char *,
	FILE *);
int fscanf(FILE * , const char *, ...);
int fseek(FILE *, long, int);
int fsetpos(FILE *, const fpos_t *);
long ftell(FILE *);
size_t fwrite(const void *, size_t, size_t,
	FILE *);
char *gets(char *);
void perror(const char *);
int printf(const char *, ...);
int puts(const char *);
int remove(const char *);
int rename(const char *, const char *);
void rewind(FILE *);
int scanf(const char *, ...);
void setbuf(FILE * , char *);
int setvbuf(FILE * , char *, int, size_t);
int sprintf(char *, const char *, ...);
int sscanf(const char *, const char *, ...);
int ungetc(int, FILE *);
int vfprintf(FILE *, const char *, _Va_list);
int vprintf(const char *, _Va_list);
int vsprintf(char *, const char *, _Va_list);

long _Fgpos(FILE *, fpos_t *);
int _Flocale(FILE *, const char *, int);
void _Fsetlocale(FILE *, int);
int _Fspos(FILE *, const fpos_t *, long, int);


void _Lockfilelock(_Filet *);
void _Unlockfilelock(_Filet *);



int snprintf(char *, size_t,
	const char *, ...);
int vsnprintf(char *, size_t,
	const char *, _Va_list);
int vfscanf(FILE *,
	const char *, _Va_list);
int vscanf(const char *, _Va_list);
int vsscanf(const char *,
	const char *, _Va_list);

# 187 "C:/usr/local/cell\\target\\ppu\\include/stdio.h" 3
}


		/* declarations only */
extern "C" {
int getc(FILE *);
int getchar(void);
int putc(int, FILE *);
int putchar(int);
}

# 258 "C:/usr/local/cell\\target\\ppu\\include/stdio.h" 3
}





using ::std:: fpos_t; using ::std:: FILE;
using ::std:: clearerr; using ::std:: fclose; using ::std:: feof;
using ::std:: ferror; using ::std:: fflush; using ::std:: fgetc;
using ::std:: fgetpos; using ::std:: fgets; using ::std:: fopen;
using ::std:: fileno; using ::std:: fdopen;
using ::std:: fprintf; using ::std:: fputc; using ::std:: fputs;
using ::std:: fread; using ::std:: freopen; using ::std:: fscanf;
using ::std:: fseek; using ::std:: fsetpos; using ::std:: ftell;
using ::std:: fwrite; using ::std:: getc; using ::std:: getchar;
using ::std:: gets; using ::std:: perror;
using ::std:: putc; using ::std:: putchar;
using ::std:: printf; using ::std:: puts; using ::std:: remove;
using ::std:: rename; using ::std:: rewind; using ::std:: scanf;
using ::std:: setbuf; using ::std:: setvbuf; using ::std:: sprintf;
using ::std:: sscanf;
using ::std:: ungetc; using ::std:: vfprintf; using ::std:: vprintf;
using ::std:: vsprintf;


using ::std:: snprintf; using ::std:: vsnprintf;
using ::std:: vfscanf; using ::std:: vscanf; using ::std:: vsscanf;









/*
 * Copyright (c) 1992-2003 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
V4.02:0216 */
# 10 "C:/usr/local/cell\\target\\ppu\\include/sys/fs.h" 3
# 1 "C:/usr/local/cell\\target\\ppu\\include/errno.h" 3
/* SCE CONFIDENTIAL
PlayStation(R)3 Programmer Tool Runtime Library 475.001
* Copyright (C) 2006 Sony Computer Entertainment Inc.
* All Rights Reserved.
*/
/* errno.h standard header */







/* The Lv-2 error codes. */



namespace std {

# 55 "C:/usr/local/cell\\target\\ppu\\include/errno.h" 3

# 107 "C:/usr/local/cell\\target\\ppu\\include/errno.h" 3

		/* DECLARATIONS */
extern "C" {

extern __declspec(thread) int _Errno;




int *_Geterrno(void); // for special vsh



}
}


/*
 * Copyright (c) 1992-2003 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
V4.02:0216 */
# 11 "C:/usr/local/cell\\target\\ppu\\include/sys/fs.h" 3
# 1 "C:/usr/local/cell\\target\\ppu\\include/time.h" 3
/* SCE CONFIDENTIAL
PlayStation(R)3 Programmer Tool Runtime Library 475.001
* Copyright (C) 2007 Sony Computer Entertainment Inc. 
* All Rights Reserved.
*/
/* time.h standard header */








namespace std {

		/* macros */






		/* type definitions */

# 32 "C:/usr/local/cell\\target\\ppu\\include/time.h" 3

// LV2_MODIFIED
typedef int64_t clock_t;



# 49 "C:/usr/local/cell\\target\\ppu\\include/time.h" 3



struct tm
	{	/* date and time components */
	int tm_sec;
	int tm_min;
	int tm_hour;
	int tm_mday;
	int tm_mon;
	int tm_year;
	int tm_wday;
	int tm_yday;
	int tm_isdst;
	};








typedef int clockid_t;




extern "C" {	/* low-level functions */
time_t time(time_t *);
}

extern "C" {	/* declarations */
char * asctime(const struct tm *);
clock_t clock(void);
char * ctime(const time_t *);
double difftime(time_t, time_t);
struct tm * gmtime(const time_t *);
struct tm * localtime(const time_t *);
time_t mktime(struct tm *);
size_t strftime(char *, size_t,
	const char *, const struct tm *);
}
}






using ::std:: clock_t;







using ::std:: clockid_t;


using ::std:: tm;
using ::std:: asctime; using ::std:: clock; using ::std:: ctime;
using ::std:: difftime; using ::std:: gmtime; using ::std:: localtime;
using ::std:: mktime; using ::std:: strftime; using ::std:: time;


/*
 * Copyright (c) 1992-2003 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
V4.02:0216 */
# 12 "C:/usr/local/cell\\target\\ppu\\include/sys/fs.h" 3
# 1 "C:/usr/local/cell\\target\\ppu\\include/sys/fs_external.h" 3
/*   SCE CONFIDENTIAL                                       */
/*   PlayStation(R)3 Programmer Tool Runtime Library 475.001 */
/*   Copyright (C) 2007 Sony Computer Entertainment Inc.    */
/*   All Rights Reserved.                                   */




extern "C" {
#pragma pack(4)

/*
 * max path length except for mount point length
 */

/*
 * max file name length
 */

/*
 * max mount point length
 */


/*
 * CellFsMode
 */
typedef int CellFsMode;
# 46 "C:/usr/local/cell\\target\\ppu\\include/sys/fs_external.h" 3

/* 006 */

/* 005 */

/* 700 */

/* 600 */

/* 500 */

/* 400 */

/* 707 */

/* 606 */

/* 505 */

/* 404 */


/* CellFsDirent.d_type */





/*
 * CellFsDirent
 */
typedef struct CellFsDirent {
	uint8_t d_type;				/* file type                  */
	uint8_t d_namlen;			/* length of string in d_name */
	char d_name[(255) + 1];
} CellFsDirent;

/* CellFsStat.st_uid */



/* CellFsStat.st_gid */


/*
 * CellFsStat
 */
typedef struct CellFsStat {
	CellFsMode st_mode;			/* mode                     */
	int st_uid;					/* user  id -> not used now */
	int st_gid;					/* group id -> not used now */
	time_t st_atime;			/* last access time         */
	time_t st_mtime;			/* last modified time       */
	time_t st_ctime;			/* create time              */
	uint64_t st_size;			/* file size                */
	uint64_t st_blksize;		/* block size               */
} CellFsStat;

/*
 * CellFsUtimbuf
 */
typedef struct CellFsUtimbuf {
	time_t actime;
	time_t modtime;
} CellFsUtimbuf;

/*
 * flags for cellFsOpen
 */
# 124 "C:/usr/local/cell\\target\\ppu\\include/sys/fs_external.h" 3

# 134 "C:/usr/local/cell\\target\\ppu\\include/sys/fs_external.h" 3
/*
 * whence for cellFsLseek(original definition are in stdio.h)
 */




/*
 * error code
 */
typedef int CellFsErrno;

# 198 "C:/usr/local/cell\\target\\ppu\\include/sys/fs_external.h" 3

# 251 "C:/usr/local/cell\\target\\ppu\\include/sys/fs_external.h" 3

#pragma pack()
}

# 13 "C:/usr/local/cell\\target\\ppu\\include/sys/fs.h" 3

# 13 "C:/usr/local/cell\\target\\ppu\\include/cell/fs/cell_fs_errno.h" 3



# 16 "C:\\Users\\USER\\Documents\\Visual Studio 2013\\Projects\\mp3_plugin_PS3\\mp3_plugin_PS3\\main.cpp"
# 1 "C:/usr/local/cell\\target\\ppu\\include/cell/fs/cell_fs_file_api.h" 3
/*   SCE CONFIDENTIAL                                       */
/*   PlayStation(R)3 Programmer Tool Runtime Library 475.001 */
/*   Copyright (C) 2008 Sony Computer Entertainment Inc.    */
/*   All Rights Reserved.                                   */






typedef struct CellFsDirectoryEntry
{
    CellFsStat attribute;
    CellFsDirent entry_name;
} CellFsDirectoryEntry;


extern "C" {


typedef enum CellFsDiscReadRetryType {
    CELL_FS_DISC_READ_RETRY_NONE,
    CELL_FS_DISC_READ_RETRY_DEFAULT
} CellFsDiscReadRetryType;

CellFsErrno cellFsOpen(const char *path, int flags, int *fd, const void *arg, uint64_t size);
CellFsErrno cellFsRead(int fd, void *buf, uint64_t nbytes, uint64_t *nread);
CellFsErrno cellFsWrite(int fd, const void *buf, uint64_t nbytes, uint64_t *nwrite);
CellFsErrno cellFsClose(int fd);
CellFsErrno cellFsOpendir(const char *path, int *fd);
CellFsErrno cellFsReaddir(int fd, CellFsDirent *dir, uint64_t *nread);
CellFsErrno cellFsClosedir(int fd);
CellFsErrno cellFsStat(const char *path, CellFsStat *sb);
CellFsErrno cellFsFstat(int fd, CellFsStat *sb);
CellFsErrno cellFsMkdir(const char *path, CellFsMode mode);
CellFsErrno cellFsRename(const char *from, const char *to);
CellFsErrno cellFsRmdir(const char *path);
CellFsErrno cellFsUnlink(const char *path);
CellFsErrno cellFsLseek(int fd, int64_t offset, int whence, uint64_t *pos);
CellFsErrno cellFsFsync(int fd);

CellFsErrno cellFsFGetBlockSize(int fd, uint64_t *sector_size,
                uint64_t *block_size);
CellFsErrno cellFsGetBlockSize(const char *path, uint64_t *sector_size,
                uint64_t *block_size);
CellFsErrno cellFsGetFreeSize(
        const char *directory_path,
        uint32_t *fs_block_size,
        uint64_t *free_block_count);

CellFsErrno cellFsTruncate(const char *path, uint64_t size);
CellFsErrno cellFsFtruncate(int fd, uint64_t size);

CellFsErrno cellFsUtime(const char *path, const CellFsUtimbuf *timep);
CellFsErrno cellFsChmod(const char *path, CellFsMode mode);

CellFsErrno cellFsGetDirectoryEntries(
        int fd,
        CellFsDirectoryEntry *entries,
        uint32_t entries_size,
        uint32_t *data_count);
/* from SDK200 */
CellFsErrno cellFsAllocateFileAreaWithoutZeroFill(
        const char *path,
        const uint64_t size);
/* from SDK220 */
CellFsErrno cellFsSetIoBuffer(
        int fd,
        size_t buffer_size_limit,
        int page_type,
        sys_memory_container_t container);
CellFsErrno cellFsSetDefaultContainer(
        sys_memory_container_t container,
        size_t total_limit);
CellFsErrno cellFsSetIoBufferFromDefaultContainer(
        int fd,
        size_t buffer_size_limit,
        int page_type);
/* from SDK240 */
CellFsErrno cellFsReadWithOffset(
        int fd,
        uint64_t offset,
        void *buffer,
        uint64_t buffer_size,
        uint64_t *read_bytes);
CellFsErrno cellFsWriteWithOffset(
        int fd,
        uint64_t offset,
        const void *data,
        uint64_t data_size,
        uint64_t *written_bytes);
CellFsErrno cellFsSdataOpen(
        const char *path,
        int flags, /* must be CELL_FS_O_RDONLY now */
        int *fd,
        const void *arg,
        uint64_t size);
CellFsErrno cellFsSdataOpenByFd(
        int mself_fd,
        int flags, /* must be CELL_FS_O_RDONLY now */
        int *sdata_fd,
        uint64_t offset, 
        const void *arg,
        uint64_t size);

CellFsErrno cellFsSetDiscReadRetrySetting(const CellFsDiscReadRetryType retry_type);

}





/* CellFsRingBuffer.copy */



/* CellFsRingBuffer */
typedef struct CellFsRingBuffer
{
  uint64_t ringbuf_size;
  uint64_t block_size;
  uint64_t transfer_rate;
  int copy;
} CellFsRingBuffer;

/* return value of status cellFsSt{Read,Write}GetStatus */






extern "C" {


CellFsErrno cellFsStReadInit(int fd, const CellFsRingBuffer *ringbuf);
CellFsErrno cellFsStReadFinish(int fd);
CellFsErrno cellFsStReadGetRingBuf(int fd, CellFsRingBuffer *ringbuf);
CellFsErrno cellFsStReadGetStatus(int fd, uint64_t *status);
CellFsErrno cellFsStReadGetRegid(int fd, uint64_t *regid);
CellFsErrno cellFsStReadStart(int fd, uint64_t offset, uint64_t size);
CellFsErrno cellFsStReadStop(int fd);
CellFsErrno cellFsStRead(int fd, char *buf, uint64_t size, uint64_t *rsize);
CellFsErrno cellFsStReadGetCurrentAddr(int fd, char **addr, uint64_t *size);
CellFsErrno cellFsStReadPutCurrentAddr(int fd, char *addr, uint64_t size);
CellFsErrno cellFsStReadWait(int fd, uint64_t size);
CellFsErrno cellFsStReadWaitCallback(int fd, uint64_t size, void (*func)(int xfd, uint64_t xsize));


}


/* max count for cellFsAioInit */

/* max count for cellFsAioRead par mount_point */

/* CellFsAio */
typedef struct CellFsAio {
  int fd;
  uint64_t offset;
  void *buf;
  uint64_t size;
  uint64_t user_data;
} CellFsAio;


extern "C" {

CellFsErrno cellFsAioInit(const char *mount_point);
CellFsErrno cellFsAioFinish(const char *mount_point);
CellFsErrno cellFsAioRead(CellFsAio *aio, int *id,
                          void (*func)(CellFsAio *aio, CellFsErrno err,
                                       int id, uint64_t size));
CellFsErrno cellFsAioCancel(int id);
CellFsErrno cellFsAioWrite(CellFsAio *aio, int *id,
                           void (*func)(CellFsAio *aio, CellFsErrno err,
                                        int id, uint64_t size));

}




# 17 "C:\\Users\\USER\\Documents\\Visual Studio 2013\\Projects\\mp3_plugin_PS3\\mp3_plugin_PS3\\main.cpp"
# 1 "C:/usr/local/cell\\target\\ppu\\include/sysutil/sysutil_userinfo.h" 3
/* SCE CONFIDENTIAL
PlayStation(R)3 Programmer Tool Runtime Library 475.001
* Copyright (C) 2007 Sony Computer Entertainment Inc.
* All Rights Reserved.
*/





# 1 "C:/usr/local/cell\\target\\ppu\\include/sysutil/sysutil_common.h" 3
/* SCE CONFIDENTIAL
PlayStation(R)3 Programmer Tool Runtime Library 475.001
* Copyright (C) 2012 Sony Computer Entertainment Inc.
* All Rights Reserved.
*/







extern "C" {



# 55 "C:/usr/local/cell\\target\\ppu\\include/sysutil/sysutil_common.h" 3

# 64 "C:/usr/local/cell\\target\\ppu\\include/sysutil/sysutil_common.h" 3

/*J 共通イベントコールバックの識別子 */
# 73 "C:/usr/local/cell\\target\\ppu\\include/sysutil/sysutil_common.h" 3









/*J 表示メッセージのロケール */
# 103 "C:/usr/local/cell\\target\\ppu\\include/sysutil/sysutil_common.h" 3

/*J 決定ボタンアサイン */



/*J 日付フォーマット */




/*J 時刻フォーマット */



/*J ゲーム視聴年齢制限 */
# 130 "C:/usr/local/cell\\target\\ppu\\include/sysutil/sysutil_common.h" 3

/*J ゲーム視聴年齢制限レベル0の起動制限 */



/*J インターネットブラウザ起動制限 */



/*J ライセンス地域 */
# 147 "C:/usr/local/cell\\target\\ppu\\include/sysutil/sysutil_common.h" 3

/*J カメラちらつき防止設定 */





/*J 振動設定 */



/*J キーボードの入力方式(日本語キーボード) */


/*J キーボードの入力方式(中国語キーボード) */



/*J コントローラ自動電源OFF機能 */


/*J 地磁気センサー機能 */





typedef unsigned int CellSysutilUserId;

typedef void (*CellSysutilCallback)( uint64_t status, uint64_t param, void * userdata );

int cellSysutilCheckCallback(void);
int cellSysutilRegisterCallback( int slot, CellSysutilCallback func, void * userdata );
int cellSysutilUnregisterCallback( int slot );



}


# 12 "C:/usr/local/cell\\target\\ppu\\include/sysutil/sysutil_userinfo.h" 3



extern "C" {


/*J 正常終了コード */








typedef enum {								/*J 各種サイズ */
	CELL_USERINFO_USER_MAX		= 16,		/*J ユーザ数最大値 */
	CELL_USERINFO_TITLE_SIZE	= 256,		/*J ユーザ選択ダイアログに表示されるタイトル最大サイズ */
	CELL_USERINFO_USERNAME_SIZE	= 64		/*J ユーザネーム最大サイズ終端のNULL含む */
} CellUserInfoParamSize;

typedef enum {								/*J 画面に表示するユーザリストのタイプ */
	CELL_USERINFO_LISTTYPE_ALL	= 0,		/*J カレントユーザを含めた全てのユーザを表示 */
	CELL_USERINFO_LISTTYPE_NOCURRENT		/*J カレントユーザを除いたユーザを表示 */
} CellUserInfoListType;

typedef enum {									/*J ユーザ選択リストの初期フォーカス位置 */
	CELL_USERINFO_FOCUS_LISTHEAD = 0xffffffff	/*J リスト先頭のアイコン */
} CellUserInfoFocus;

/*J 構造体：引数向け -------------------------------------------------------------------------------- */

typedef struct {							/*J ユーザ情報構造体 */
	CellSysutilUserId id;					/*J ユーザID */
	char name[CELL_USERINFO_USERNAME_SIZE];	/*J ユーザ名 */
} CellUserInfoUserStat;

typedef struct {							/* ユーザIDリスト */
	CellSysutilUserId userId[CELL_USERINFO_USER_MAX];
} CellUserInfoUserList;

typedef struct {						/*J ユーザ選択リスト指定構造体 */
	char *title;						/*J 画面上に表示するタイトル名 */
	CellSysutilUserId focus;			/*J フォーカス位置指定 */
	unsigned int fixedListNum;			/*J 固定リストサイズ */
	CellUserInfoUserList *fixedList;	/*J 固定リスト */
	void *reserved;
} CellUserInfoListSet;

typedef struct {						/*J リストタイプ指定構造体 */
	char *title;						/*J 画面上に表示するタイトル名 */
	CellSysutilUserId focus;			/*J フォーカス位置指定 */
	CellUserInfoListType type;			/*J リストタイプ */
	void *reserved;
} CellUserInfoTypeSet;

/*J コールバック関数 -------------------------------------------------------------------------------- */
/*J ユーザ選択リスト終了コールバック関数 */
typedef void (*CellUserInfoFinishCallback)( int result,
											CellUserInfoUserStat *selectedUser,
											void *userdata );

/*J ユーティリティ関数 ------------------------------------------------------------------------------ */

/*J ユーザ情報取得（同期関数）*/
int cellUserInfoGetStat( CellSysutilUserId id, CellUserInfoUserStat *stat );

/*J ユーザリスト取得（同期関数）*/
int cellUserInfoGetList(
		unsigned int *listNum,					/*J ユーザリストの項目数を受け取るポインタ */
		CellUserInfoUserList *listBuf,			/*J CellUserInfoListSetに合わせた ユーザリストを受け取るバッファ */
		CellSysutilUserId *currentUserId		/*J カレントユーザのユーザIDを受け取るポインタ */
		);

/*J リスト指定型ユーザ選択（非同期関数）*/
int cellUserInfoSelectUser_SetList(
		CellUserInfoListSet *setList,			/*J ユーザ選択リストのユーザリスト指定 */
		CellUserInfoFinishCallback funcSelect,	/*J ユーザ選択終了時に呼ばれるコールバック関数 */
		sys_memory_container_t container,		/*J メモリコンテナ */
		void *userdata							/*J コールバック関数に渡されるデータ */
		);
 
/*J リストタイプ型ユーザ選択（非同期関数）*/
int cellUserInfoSelectUser_ListType(
		CellUserInfoTypeSet *listType,			/*J ユーザ選択リストのリストタイプ指定 */
		CellUserInfoFinishCallback funcSelect,	/*J ユーザ選択終了時に呼ばれるコールバック関数 */
		sys_memory_container_t container,		/*J メモリコンテナ */
		void *userdata							/*J コールバック関数に渡されるデータ */
		);

/*J オーバーレイ表示設定 */
void cellUserInfoEnableOverlay( int enable );


}


# 18 "C:\\Users\\USER\\Documents\\Visual Studio 2013\\Projects\\mp3_plugin_PS3\\mp3_plugin_PS3\\main.cpp"
# 1 "C:/usr/local/cell\\target\\ppu\\include/sysutil/sysutil_oskdialog.h" 3
/* SCE CONFIDENTIAL
PlayStation(R)3 Programmer Tool Runtime Library 475.001
* Copyright (C) 2007 Sony Computer Entertainment Inc.
* All Rights Reserved.
*/







extern "C" {


/*J OSK の状態 */
# 24 "C:/usr/local/cell\\target\\ppu\\include/sysutil/sysutil_oskdialog.h" 3

/* constant definitions------------------------------------------------------ */
/*J OSK のエラー */





/*J OSK ユーティリティの状態 */
typedef enum {
	CELL_OSKDIALOG_LOCAL_STATUS_NONE						= (0),		/*J 未初期化 */
	CELL_OSKDIALOG_LOCAL_STATUS_INITIALIZING				= (1),		/*J 初期化中 */
	CELL_OSKDIALOG_LOCAL_STATUS_INITIALIZED					= (2),		/*J 初期化済み */
	CELL_OSKDIALOG_LOCAL_STATUS_OPENED						= (3),		/*J サービス開始 */
	CELL_OSKDIALOG_LOCAL_STATUS_CLOSING						= (4),		/*J サービスを終了中 */
	CELL_OSKDIALOG_LOCAL_STATUS_CLOSED						= (5),		/*J サービスを終了 */
	CELL_OSKDIALOG_LOCAL_STATUS_CONTINUE					= (6),		/*J ユーザー選択通知、サービスを続行中 */
	CELL_OSKDIALOG_LOCAL_STATUS_CHANGED_TO_KEYBOARD_INPUT	= (7),		/*J 対象入力デバイスをキーボードに変更 */
	CELL_OSKDIALOG_LOCAL_STATUS_CHANGED_TO_PAD_INPUT		= (8),		/*J 対象入力デバイスをパッドに変更 */
	CELL_OSKDIALOG_LOCAL_STATUS_HIDE_OSK					= (9),		/*J 確定続行により非表示化完了 */
	CELL_OSKDIALOG_LOCAL_STATUS_SHOW_OSK					= (10), 	/*J 入力検知により、表示開始 */
} CellOskDialogLocalStatus;

/*J 入力モード */



# 68 "C:/usr/local/cell\\target\\ppu\\include/sysutil/sysutil_oskdialog.h" 3





# 82 "C:/usr/local/cell\\target\\ppu\\include/sysutil/sysutil_oskdialog.h" 3

/*J 座標指定のオプション */
# 90 "C:/usr/local/cell\\target\\ppu\\include/sysutil/sysutil_oskdialog.h" 3

/*J 禁止動作設定フラグ */





/*J 有効パネル設定フラグ */



/*J OSKダイアログストリングのサイズ */


/*J イベント取得権設定フラグ */


/*J OSKダイアログの初期起動設定 */
typedef enum {
	CELL_OSKDIALOG_INITIAL_PANEL_LAYOUT_SYSTEM	= (0),		/*J ユーザーがシステムソフトウェアで使用していたキーレイアウトで起動 */
	CELL_OSKDIALOG_INITIAL_PANEL_LAYOUT_10KEY	= (1),		/*J テンキーパネルで起動 */
	CELL_OSKDIALOG_INITIAL_PANEL_LAYOUT_FULLKEY	= (2),		/*J フルキーボードパネルで起動 */
}CellOskDialogInitialKeyLayout;

/*J 各入力フィールド個別の戻り値 */
typedef enum {
	CELL_OSKDIALOG_INPUT_FIELD_RESULT_OK			= (0),	/*J 正常に終了した */
	CELL_OSKDIALOG_INPUT_FIELD_RESULT_CANCELED		= (1),	/*J ユーザがキャンセル操作をした */
	CELL_OSKDIALOG_INPUT_FIELD_RESULT_ABORT			= (2),	/*J 強制終了 */
	CELL_OSKDIALOG_INPUT_FIELD_RESULT_NO_INPUT_TEXT	= (3),	/*J 入力文字列がない */
} CellOskDialogInputFieldResult;

/*J OSK 入力デバイス */
typedef enum {
	CELL_OSKDIALOG_INPUT_DEVICE_PAD			= (0),		/*J コントローラ */
	CELL_OSKDIALOG_INPUT_DEVICE_KEYBOARD	= (1),		/*J キーボード */
} CellOskDialogInputDevice;

/*J ウィンドウ分離型で入力確定・キャンセル時の動作設定 */
typedef enum {
	CELL_OSKDIALOG_CONTINUOUS_MODE_NONE			= (0),		/*J 確定続行オプションを使用しない */
	CELL_OSKDIALOG_CONTINUOUS_MODE_REMAIN_OPEN	= (1),		/*J 確定続行オプションを使用(オンスクリーンキーボードダイアログは常に表示) */
	CELL_OSKDIALOG_CONTINUOUS_MODE_HIDE			= (2),		/*J 確定続行オプションを使用(初期状態=非表示) */
	CELL_OSKDIALOG_CONTINUOUS_MODE_SHOW			= (3),		/*J 確定続行オプションを使用(初期状態=表示) */
} CellOskDialogContinuousMode;

/*J 表示/非表示の通知パラメータ */
typedef enum {
	CELL_OSKDIALOG_DISPLAY_STATUS_HIDE		 	= (0),		/*J ダイアログ非表示化完了 */
	CELL_OSKDIALOG_DISPLAY_STATUS_SHOW		 	= (1),		/*J ダイアログ表示開始 */
} CellOskDialogDisplayStatus;

/* simple variable type definitions------------------------------------------ */
/* nothing */
/* structure definitions----------------------------------------------------- */

/*J 入力フィールド情報の構造体 */
typedef struct {
	uint16_t* message;		/*J OSKアプリの左上にガイドとして表示される文字列 */
	uint16_t* init_text;	/*J 初期入力文字列 */
	int limit_length;		/*J 入力文字の制限値 (単位は「文字」(バイトではありません))*/
} CellOskDialogInputFieldInfo;

/*J コールバック用構造体 */
typedef struct {
	CellOskDialogInputFieldResult result;
	int numCharsResultString;
	uint16_t *pResultString;
} CellOskDialogCallbackReturnParam;

/*J 入力コントロールの位置、サイズ情報構造体 */
typedef struct{
	float x;
	float y;
} CellOskDialogPoint;

/*J ウィンドウのレイアウト情報 */
typedef struct {
	int layoutMode;						/*J 表示領域の基準点に対するオプション */
	CellOskDialogPoint position;		/*J 表示位置をスクリーン座標系で指定 */
} CellOskDialogLayoutInfo;

/*J OSKの種類 */
typedef enum {
	CELL_OSKDIALOG_TYPE_SINGLELINE_OSK	= (0),						/*J 単一行入力ダイアログ */
	CELL_OSKDIALOG_TYPE_MULTILINE_OSK	= (1),						/*J 複数行入力ダイアログ */
	CELL_OSKDIALOG_TYPE_FULL_KEYBOARD_SINGLELINE_OSK,				/*J 単一行フルキーボード入力ダイアログ */
	CELL_OSKDIALOG_TYPE_FULL_KEYBOARD_MULTILINE_OSK,				/*J 複数行フルキーボード入力ダイアログ */
	CELL_OSKDIALOG_TYPE_SEPARATE_SINGLELINE_FIELD_WINDOW,			/*J 分離型の単一行入力フィールドウィンドウ */
	CELL_OSKDIALOG_TYPE_SEPARATE_MULTILINE_FIELD_WINDOW,			/*J 分離型の複数行入力フィールドウィンドウ */
	CELL_OSKDIALOG_TYPE_SEPARATE_INPUT_PANEL_WINDOW,				/*J 分離型テンキーパネルのコントローラ操作部ウィンドウ */
	CELL_OSKDIALOG_TYPE_SEPARATE_FULL_KEYBOARD_INPUT_PANEL_WINDOW,	/*J 分離型フルキーボードパネルのコントローラ操作部ウィンドウ */
	CELL_OSKDIALOG_TYPE_SEPARATE_CANDIDATE_WINDOW,					/*J 分離型のキーボード入力時の候補表示ウィンドウ */
} CellOskDialogType;

/*J OSK ユーティリティ起動パラメータ */
typedef struct {
	/*J OSKの基本定義 */
	unsigned int allowOskPanelFlg;		/*J 使用するパネルをフラグで選択 (英数入力、ひらがな入力など) */ 
	unsigned int firstViewPanel;		/*J 最初に表示するパネルを選択 */ 
	CellOskDialogPoint controlPoint;	/*J OSKの初期表示位置 */
	int prohibitFlgs;					/*J 禁止条項フラグ */
} CellOskDialogParam;

/*J OSK分離ウィンドウ設定構造体 */
typedef struct {
	CellOskDialogContinuousMode continuousMode;			/*J 続行モード */
	int deviceMask;										/*J ダイアログでイベントを取得しないデバイス */
	int inputFieldWindowWidth;							/*J 入力フィールドウィンドウの幅 */
	float inputFieldBackgroundTrans;					/*J 入力フィールドウィンドウの背景の透過率 */
	CellOskDialogLayoutInfo *inputFieldLayoutInfo;		/*J 入力フィールドウィンドウのレイアウト情報（NULL不可） */
	CellOskDialogLayoutInfo *inputPanelLayoutInfo;		/*J パネルウィンドウのレイアウト情報（NULL可） */
	void *reserved;										/*J 予約領域（NULL） */
} CellOskDialogSeparateWindowOption;

int cellOskDialogLoadAsync( sys_memory_container_t mem_container, const CellOskDialogParam* dialogParam, const CellOskDialogInputFieldInfo* inputFieldInfo );
int cellOskDialogUnloadAsync(CellOskDialogCallbackReturnParam* OutputInfo);
int cellOskDialogAbort(void);
int cellOskDialogGetSize( uint16_t *width, uint16_t *height, CellOskDialogType dialogType);
int cellOskDialogSetLayoutMode( int32_t layoutMode);
int cellOskDialogAddSupportLanguage( uint32_t supportLanguage);
int cellOskDialogSetKeyLayoutOption( uint32_t option);
int cellOskDialogDisableDimmer(void);
int cellOskDialogSetInitialKeyLayout( CellOskDialogInitialKeyLayout initialKeyLayout);
int cellOskDialogSetInitialInputDevice( CellOskDialogInputDevice inputDevice );
int cellOskDialogSetSeparateWindowOption( CellOskDialogSeparateWindowOption* windowOption );
int cellOskDialogSetDeviceMask( uint32_t deviceMask );
int cellOskDialogGetInputText( CellOskDialogCallbackReturnParam* OutputInfo );


}


# 19 "C:\\Users\\USER\\Documents\\Visual Studio 2013\\Projects\\mp3_plugin_PS3\\mp3_plugin_PS3\\main.cpp"
# 1 "C:/usr/local/cell\\target\\ppu\\include/sysutil/sysutil_msgdialog.h" 3
/* SCE CONFIDENTIAL
PlayStation(R)3 Programmer Tool Runtime Library 475.001
* Copyright (C) 2007 Sony Computer Entertainment Inc.
* All Rights Reserved.
*/







extern "C" {




															/*E Maximum size of specified messages(byte) */

															/*E Size of the string to display in the progress bar(byte) */
/*J
 * ダイアログの機能
 *
 *  31                   16 15   14 13     12 11   10 9    8    7 6       4       3    2    1    0
 * +-----------------------+-------+---------+-------+------+----+---------+-------+----+----+----+
 * |    R e s e r v e d    | Rsrvd | PrgType | Rsrvd | DCId | DC | BtnType | Rsrvd | BG | SM | ST |
 * +-----------------------+-------+---------+-------+------+----+---------+-------+----+----+----+
 *
 *  bit 31-16: Reserved
 *      0x0000= 常にゼロ固定
 *
 *  bit 15,14: Reserved
 *      00= 常にゼロ固定
 *
 *  bit 13,12: プログレスバーの種別(Progress bar Type)
 *      0= プログレスバーなし
 *      1= プログレスバー1本
 *      2= プログレスバー2本
 *
 *  bit 11,10: Reserved
 *      00= 常にゼロ固定
 *
 *  bit 9,8: デフォルトカーソル位置(Default Cursor Index)
 *      もっとも左に位置するボタンからのインデックス値
 *      ボタンなしの場合、0
 *      Yes/No ボタンの場合、0= Yes ボタン 1= No ボタン
 *      OK ボタンの場合、0= OK ボタン
 *         :
 *
 *  bit 7: 戻るボタンの無効化(Disable Cancel button)
 *      0= 戻るボタンを無効化しない
 *      1= 戻るボタンを無効化する
 *
 *  bit 6-4: ボタンの種別(Button Type)
 *      0= ボタンなし
 *      1= Yes/No ボタン
 *      2= OK ボタン
 *
 *  bit 3: Reserved
 *      0= 常にゼロ固定
 *
 *  bit 2: 背景の表示(BG Visible)
 *      0= 背景を表示する
 *      1= 背景を表示しない(透明)
 *
 *  bit 1: 起動音のミュート(SE Mute)
 *      0= ミュートしない
 *      1= ミュートする
 *         "bit 0: 起動音の種別(SE Type)" の指定によらず起動音は鳴らなくなります。
 *
 *  bit 0: 起動音の種別(SE Type)
 *      0= エラー音
 *      1= 通常起動音
 */
/*E
 * Dialog feature
 *
 *  31                   16 15   14 13     12 11   10 9    8    7 6       4       3    2    1    0
 * +-----------------------+-------+---------+-------+------+----+---------+-------+----+----+----+
 * |    R e s e r v e d    | Rsrvd | PrgType | Rsrvd | DCId | DC | BtnType | Rsrvd | BG | SM | ST |
 * +-----------------------+-------+---------+-------+------+----+---------+-------+----+----+----+
 *
 *  bit 31-16: Reserved
 *      0x00= Always fixed to 0
 *
 *  bit 15,14: Reserved
 *      00= Always fixed to 0
 *
 *  bit 13,12: Progress bar Type
 *      0= No progress bar
 *      1= 1 progress bar
 *      2= 2 progress bars
 *
 *  bit 11,10: Reserved
 *      00= Always fixed to 0
 *
 *  bit 9,8: Default cursor position (Default Cursor Index)
 *      Index value from the leftmost button
 *      0 when no button is provided
 *      0= Yes button and 1= No button when Yes/No buttons are provided
 *      0= OK button when OK button is provided
 *         :
 *
 *  bit 7: Disable the cancel button(Disable Cancel button)
 *      0= Do not disable the cancel button
 *      1= Disable the cancel button
 *
 *  bit 6-4: Button type(Button Type)
 *      0= No button is provided
 *      1= Yes/No buttons
 *      2= OK button
 *
 *  bit 3: Reserved
 *      0= Always fixed to 0
 *
 *  bit 2: Background display(BG Visible)
 *      0= Display the background
 *      1= Do not display the background(transparence)
 *
 *  bit 1: Mute the startup sound (SE Mute)
 *      0= Do not mute
 *      1= Mute
 *         The startup sound will be muted regardless of whether "bit 0: Startup sound type(SE Type)" is specified
 *
 *  bit 0: Startup sound type(SE Type)
 *      0= Error sound
 *      1= Normal startup sound
 */
/*J bit 0: 起動音の種別(SE Type) */
/*E bit 0: Startup sound type(SE Type) */

																/*E Error sound */

																/*E Normal startup sound */

/*J bit 1: 起動音のミュート(SE Mute) */
/*E bit 1: Mute the startup sound (SE Mute) */

																/*E Do not mute */

																/*E Mute */

/*J bit 2: 背景の表示(BG Visible) */
/*E bit 2: Background display(BG Visible) */

																/*E Display the background */

																/*E Do not display the background(transparence) */

/*J bit 6-4: ボタンの種別(Button Type) */
/*E bit 6-4: Button type (Button Type) */

																/*E No button is provided */

																/*E Yes/No buttons */

																/*E OK button */

/*J bit 7: 戻るボタンの無効化(Disable Cancel button) */
/*E bit 7: Disable the cancel button (Disable Cancel button) */

																/*E Do not disable the cancel button */

																/*E Disable the cancel button */

/*J bit 9,8: デフォルトカーソル位置(Default Cursor Index) */
/*E bit 9,8: Default cursor position (Default Cursor Index) */

																/*E No button is provided */

																/*E Yes button */

																/*E No button */

																/*E OK button */

/*J bit 13,12: プログレスバーの種別(Progress bar Type) */
/*E bit 13,12: Progress bar Type */

																/*E No progress bar */

																/*E 1 progress bar */

																/*E 2 progress bars */

/*J ボタン付きダイアログの押されたボタンの結果 */
/*E Pressed button result type */
typedef enum
{
	CELL_MSGDIALOG_BUTTON_NONE    = -1,		/*J ボタンは押されていない(cellMsgDialogCloseによる終了の場合) */
											/*E No button is pressed(when ended by cellMsgDialogClose) */
	CELL_MSGDIALOG_BUTTON_INVALID = 0,		/*J 無効なボタンが押された */
											/*E An invalid button is pressed */
	CELL_MSGDIALOG_BUTTON_OK      = 1,		/*J [OK]を決定ボタンで選択した */
											/*E [OK] was selected for the decision button */
	CELL_MSGDIALOG_BUTTON_YES     = 1,		/*J [Yes]を決定ボタンで選択した */
											/*E [Yes] was selected for the decision button */
	CELL_MSGDIALOG_BUTTON_NO      = 2,		/*J [No]を決定ボタンで選択した */
											/*E [No] was selected for the decision button */
	CELL_MSGDIALOG_BUTTON_ESCAPE  = 3		/*J 戻るボタンが押された */
											/*E The back button was pressed */
} CellMsgDialogButtonType;

/*J 対象とするプログレスバー */
/*E Target progress bar */
typedef enum
{
	CELL_MSGDIALOG_PROGRESSBAR_INDEX_SINGLE       = 0,	/*J プログレスバー1本の時のプログレスバー */
														/*E Single progress bar */
	CELL_MSGDIALOG_PROGRESSBAR_INDEX_DOUBLE_UPPER = 0,	/*J プログレスバー2本の時の上側プログレスバー */
														/*E The upper progress bar when there are 2 */
	CELL_MSGDIALOG_PROGRESSBAR_INDEX_DOUBLE_LOWER = 1	/*J プログレスバー2本の時の下側プログレスバー */
														/*E The lower progress bar when there are 2 */
} CellMsgDialogProgressBarIndex;

/*J エラーコード */
/*E Error code */

																	/*E Parameter is invalid */

																	/*E The dialogue is not opened */

/*J メッセージダイアログ結果通知コールバック関数 */
/*E A callback function that notifies the result from the message dialogue */
typedef void (*CellMsgDialogCallback)( int buttonType, void *userData );

/*J メッセージダイアログを文字列指定で開く */
/*E Specify a string to open the message dialogue */
int cellMsgDialogOpen2( unsigned int type,			/*J ダイアログの機能をビットOR演算子で組み合わせて設定します。 */
													/*E The dialogue features are set using the bit OR operators */
						const char *msgString,		/*J 表示する文字列 (UTF-8で指定。NULL終端文字を含む) */
													/*E A string to display(Specify in UTF-8, including the NULL termination character) */
						CellMsgDialogCallback func,	/*J メッセージダイアログ結果通知コールバック関数指定 */
													/*E Specify the call back function that notifies the result from the message dialogue */
						void *userData,				/*J コールバック関数で受け取るユーザデータ */
													/*E User data received by the call back function */
						void *extParam				/*J 拡張用パラメータ */
													/*E Extension parameter */
);

/*J メッセージダイアログをエラー番号指定で開く */
int cellMsgDialogOpenErrorCode( unsigned int errorNum,			/*J エラー番号 */
																/*E Error number */
								CellMsgDialogCallback func,		/*J メッセージダイアログ結果通知コールバック関数指定 */
																/*E Specify the call back function that notifies the result from the message dialogue */
								void *userData,					/*J コールバック関数で受け取るユーザデータ */
																/*E User data received by the call back function */
								void *extParam					/*J 拡張用パラメータ */
																/*E Extension parameter */
);

/*J SimulView メッセージダイアログを開く */
int cellMsgDialogOpenSimulViewWarning( 
								CellMsgDialogCallback func,		/*J メッセージダイアログ結果通知コールバック関数指定 */
																/*E Specify the call back function that notifies the result from the message dialogue */
								void *userData,					/*J コールバック関数で受け取るユーザデータ */
																/*E User data received by the call back function */
								void *extParam					/*J 拡張用パラメータ */
																/*E Extension parameter */
);

/*J メッセージダイアログ内のプログレスバーに付加表示される文字列を設定する */
/*E Set a string to display in the progress bar within the message dialogue */
int cellMsgDialogProgressBarSetMsg( unsigned int progressbarIndex,	/*J 対象とするプログレスバー(CellMsgDialogProgressBarIndex) */
																	/*E Target progress bar(CellMsgDialogProgressBarIndex) */
									const char *msgString			/*J プログレスバーに付加表示する文字列 (UTF-8で指定。NULL終端文字を含む) */
																	/*E A string to display in the progress bar(Specify in UTF-8, including the NULL termination character) */
);

/*J メッセージダイアログ内のプログレスバーの進捗率をリセット(0%)する */
/*E Reset the progress bar in the message dialogue to 0% */
int cellMsgDialogProgressBarReset( unsigned int progressbarIndex	/*J 対象とするプログレスバー(CellMsgDialogProgressBarIndex) */
																	/*E Target progress bar(CellMsgDialogProgressBarIndex) */
);

/*J メッセージダイアログ内のプログレスバーの進捗率を加算する */
/*E Increase the progress rate of the progress bar in the message dialogue */
int cellMsgDialogProgressBarInc( unsigned int progressbarIndex,		/*J 対象とするプログレスバー(CellMsgDialogProgressBarIndex) */
																	/*E Target progress bar(CellMsgDialogProgressBarIndex) */
								 unsigned int delta					/*J 加算する進捗率(%) */
								 									/*E Progress rate to increase(%) */
);

/*J メッセージダイアログを強制的に閉じる */
/*E Forcibly close the message dialogue */
int cellMsgDialogAbort( void );

/*J メッセージダイアログを閉じる */
/*E Close the message dialogue */
int cellMsgDialogClose( float delayTime								/*J ダイアログを閉じはじめるまでの遅延時間(msec) */
																	/*E Delay time to close the dialogue(msec) */
);




/*J 以下は互換性のため残してありますが、使用しないでください。 */
/*E The following have been retained for compatibility. Do not use.  */
typedef enum
{
	CELL_MSGDIALOG_DIALOG_TYPE_ERROR	= 0x00000000,	/*J エラーダイアログ */
														/*E Error dialog */
	CELL_MSGDIALOG_DIALOG_TYPE_NORMAL	= 0x00000001,	/*J 通常ダイアログ */
														/*E Normal dialog */

	CELL_MSGDIALOG_BUTTON_TYPE_NONE		= 0x00000000,	/*J [Yes/No]ボタン無し */
														/*E No [Yes/No] buttons */
	CELL_MSGDIALOG_BUTTON_TYPE_YESNO	= 0x00000010,	/*J [Yes/No]ボタン有 */
														/*E With [Yes/No] buttons */

	CELL_MSGDIALOG_DEFAULT_CURSOR_YES	= 0x00000000,	/*J デフォルトカーソル[Yes] */
														/*E Default cursor [Yes] */
	CELL_MSGDIALOG_DEFAULT_CURSOR_NO	= 0x00000100	/*J デフォルトカーソル[No] */
														/*E Default cursor [No] */
} CellMsgDialogType;

int cellMsgDialogOpen( unsigned int type,			/*J 起動タイプ CellMsgDialogTypeの値をビットOR演算子で組み合わせて設定します。 */
													/*E The dialogue features are set using the bit OR operators */
					   const char *msgString,		/*J 表示する文字列 (UTF-8で指定。NULL終端文字を含む) */
													/*E A string to display(Specify in UTF-8, including the NULL termination character) */
					   CellMsgDialogCallback func,	/*J メッセージダイアログ結果通知コールバック関数指定 */
													/*E Specify the call back function that notifies the result from the message dialogue */
					   void *userData,				/*J コールバック関数で受け取るユーザデータ */
													/*E User data received by the call back function */
					   void *extparam				/*J 拡張用パラメータ */
													/*E Extension parameter */
);



}


# 20 "C:\\Users\\USER\\Documents\\Visual Studio 2013\\Projects\\mp3_plugin_PS3\\mp3_plugin_PS3\\main.cpp"
# 1 "C:/usr/local/cell\\target\\ppu\\include/sys/paths.h" 3
/*   SCE CONFIDENTIAL                                       */
/*   PlayStation(R)3 Programmer Tool Runtime Library 475.001 */
/*   Copyright (C) 2008 Sony Computer Entertainment Inc.    */
/*   All Rights Reserved.                                   */




/* The default mount point */


/* The mount point for a file system on a remote host PC */


/* The mount point for a file system on builtin HDD */



/* The mount point for a file system on builtin memory stick */


/* The mount point for a file system on builtin BDVD drive */


/* mount point used for debugging purpose such as core dump target */


# 21 "C:\\Users\\USER\\Documents\\Visual Studio 2013\\Projects\\mp3_plugin_PS3\\mp3_plugin_PS3\\main.cpp"
# 1 "C:/usr/local/cell\\target\\ppu\\include/sys/socket.h" 3
/*   SCE CONFIDENTIAL                                       */
/*   PlayStation(R)3 Programmer Tool Runtime Library 475.001 */
/*   Copyright (C) 2009 Sony Computer Entertainment Inc.    */
/*   All Rights Reserved.                                   */




# 1 "C:/usr/local/cell\\target\\ppu\\include/sys/ansi.h" 3
/*   SCE CONFIDENTIAL                                       */
/*   PlayStation(R)3 Programmer Tool Runtime Library 475.001 */
/*   Copyright (C) 2005 Sony Computer Entertainment Inc.    */
/*   All Rights Reserved.                                   */





extern "C" {


	typedef unsigned int in_addr_t;
	typedef unsigned short in_port_t;
	typedef unsigned char sa_family_t;
	typedef unsigned int socklen_t;


}
# 10 "C:/usr/local/cell\\target\\ppu\\include/sys/socket.h" 3


extern "C" {


/* socket types */






/* option flags */
# 32 "C:/usr/local/cell\\target\\ppu\\include/sys/socket.h" 3

/* additional options */
# 42 "C:/usr/local/cell\\target\\ppu\\include/sys/socket.h" 3




	struct linger {
		int l_onoff;			/* on/off */
		int l_linger;			/* linger time [sec] */
	};



/* address families */
# 89 "C:/usr/local/cell\\target\\ppu\\include/sys/socket.h" 3

	struct sockaddr {
		unsigned char sa_len;
		sa_family_t sa_family;
		char sa_data[14];
	};

	struct iovec {
		int zero1;				/* system use, big endian */
		void *iov_base;
		int zero2;				/* system use, big endian */
		size_t iov_len;
	};

	struct msghdr {
		int zero1;				/* system use, big endian */
		void *msg_name;
		socklen_t msg_namelen;
		int padding1;			/* system use, 32bit */
		int zero2;				/* system use, big endian */
		struct iovec *msg_iov;
		int msg_iovlen;
		int padding2;			/* system use, 32bit */
		int zero3;				/* system use, big endian */
		void *msg_control;
		socklen_t msg_controllen;
		int msg_flags;
	};

# 130 "C:/usr/local/cell\\target\\ppu\\include/sys/socket.h" 3





	int accept(int s, struct sockaddr *addr, socklen_t * addrlen);
	int bind(int s, const struct sockaddr *addr, socklen_t addrlen);
	int connect(int s, const struct sockaddr *name, socklen_t namelen);
	int getpeername(int s, struct sockaddr *name, socklen_t * namelen);
	int getsockname(int s, struct sockaddr *name, socklen_t * namelen);
	int getsockopt(int s, int level, int optname, void *optval,
				   socklen_t * optlen);
	int listen(int s, int backlog);
	ssize_t recv(int s, void *buf, size_t len, int flags);
	ssize_t recvfrom(int s, void *buf, size_t len,
					 int flags, struct sockaddr *from, socklen_t * fromlen);
	ssize_t recvmsg(int s, struct msghdr *msg, int flags);
	ssize_t send(int s, const void *msg, size_t len, int flags);
	ssize_t sendto(int s, const void *msg, size_t len,
				   int flags, const struct sockaddr *to, socklen_t tolen);
	ssize_t sendmsg(int s, const struct msghdr *msg, int flags);
	int setsockopt(int s, int level, int optname, const void *optval,
				   socklen_t optlen);
	int shutdown(int s, int how);
	int socket(int domain, int type, int protocol);
	int socketclose(int s);


}
# 22 "C:\\Users\\USER\\Documents\\Visual Studio 2013\\Projects\\mp3_plugin_PS3\\mp3_plugin_PS3\\main.cpp"
# 1 "C:/usr/local/cell\\target\\ppu\\include/sys/random_number.h" 3
/*
 *   SCE CONFIDENTIAL                                      
 *   PlayStation(R)3 Programmer Tool Runtime Library 475.001
 *   Copyright (C) 2010 Sony Computer Entertainment Inc.   
 *   All Rights Reserved.                                  
 */







extern "C" {


int sys_get_random_number(void *addr, uint64_t size);

}

# 23 "C:\\Users\\USER\\Documents\\Visual Studio 2013\\Projects\\mp3_plugin_PS3\\mp3_plugin_PS3\\main.cpp"
# 1 "C:/usr/local/cell\\target\\ppu\\include/sysutil/sysutil_sysparam.h" 3
/* SCE CONFIDENTIAL
PlayStation(R)3 Programmer Tool Runtime Library 475.001
 * Copyright (C) 2009 Sony Computer Entertainment Inc.
 * All Rights Reserved.
 */






extern "C" {


# 34 "C:/usr/local/cell\\target\\ppu\\include/sysutil/sysutil_sysparam.h" 3





/* --------------------------- Error Code ----------------------------- */
enum {
	/* #define CELL_SYSUTIL_ERROR_BASE_SYSTEMPARAM		(0x8002b200) */
	/* video */
	CELL_VIDEO_OUT_SUCCEEDED						= 0,
	CELL_VIDEO_OUT_ERROR_NOT_IMPLEMENTED			= (0x8002b220),
	CELL_VIDEO_OUT_ERROR_ILLEGAL_CONFIGURATION		= (0x8002b221),
	CELL_VIDEO_OUT_ERROR_ILLEGAL_PARAMETER			= (0x8002b222),
	CELL_VIDEO_OUT_ERROR_PARAMETER_OUT_OF_RANGE		= (0x8002b223),
	CELL_VIDEO_OUT_ERROR_DEVICE_NOT_FOUND			= (0x8002b224),
	CELL_VIDEO_OUT_ERROR_UNSUPPORTED_VIDEO_OUT		= (0x8002b225),
	CELL_VIDEO_OUT_ERROR_UNSUPPORTED_DISPLAY_MODE	= (0x8002b226),
	CELL_VIDEO_OUT_ERROR_CONDITION_BUSY				= (0x8002b227),
	CELL_VIDEO_OUT_ERROR_VALUE_IS_NOT_SET			= (0x8002b228),

	/* audio */
	CELL_AUDIO_OUT_SUCCEEDED						= 0,
	CELL_AUDIO_OUT_ERROR_NOT_IMPLEMENTED			= (0x8002b240),
	CELL_AUDIO_OUT_ERROR_ILLEGAL_CONFIGURATION		= (0x8002b241),
	CELL_AUDIO_OUT_ERROR_ILLEGAL_PARAMETER			= (0x8002b242),
	CELL_AUDIO_OUT_ERROR_PARAMETER_OUT_OF_RANGE		= (0x8002b243),
	CELL_AUDIO_OUT_ERROR_DEVICE_NOT_FOUND			= (0x8002b244),
	CELL_AUDIO_OUT_ERROR_UNSUPPORTED_AUDIO_OUT		= (0x8002b245),
	CELL_AUDIO_OUT_ERROR_UNSUPPORTED_SOUND_MODE		= (0x8002b246),
	CELL_AUDIO_OUT_ERROR_CONDITION_BUSY             = (0x8002b247),

	CELL_AUDIO_IN_SUCCEEDED							= 0,
	CELL_AUDIO_IN_ERROR_NOT_IMPLEMENTED				= (0x8002b260),
	CELL_AUDIO_IN_ERROR_ILLEGAL_CONFIGURATION		= (0x8002b261),
	CELL_AUDIO_IN_ERROR_ILLEGAL_PARAMETER			= (0x8002b262),
	CELL_AUDIO_IN_ERROR_PARAMETER_OUT_OF_RANGE		= (0x8002b263),
	CELL_AUDIO_IN_ERROR_DEVICE_NOT_FOUND			= (0x8002b264),
	CELL_AUDIO_IN_ERROR_UNSUPPORTED_AUDIO_IN		= (0x8002b265),
	CELL_AUDIO_IN_ERROR_UNSUPPORTED_SOUND_MODE		= (0x8002b266),
	CELL_AUDIO_IN_ERROR_CONDITION_BUSY				= (0x8002b267)

};

/* ----------------------------- Video -------------------------------- */

typedef enum CellVideoOut {
	CELL_VIDEO_OUT_PRIMARY,
	CELL_VIDEO_OUT_SECONDARY
} CellVideoOut;

typedef enum CellVideoOutResolutionId {
	CELL_VIDEO_OUT_RESOLUTION_UNDEFINED  = 0,
	CELL_VIDEO_OUT_RESOLUTION_1080       = 1,
	CELL_VIDEO_OUT_RESOLUTION_720        = 2,
	CELL_VIDEO_OUT_RESOLUTION_480        = 4,
	CELL_VIDEO_OUT_RESOLUTION_576        = 5,
	CELL_VIDEO_OUT_RESOLUTION_1600x1080  = 10,
	CELL_VIDEO_OUT_RESOLUTION_1440x1080  = 11,
	CELL_VIDEO_OUT_RESOLUTION_1280x1080  = 12,
	CELL_VIDEO_OUT_RESOLUTION_960x1080   = 13
	,
	CELL_VIDEO_OUT_RESOLUTION_720_3D_FRAME_PACKING        = 0x81,
	CELL_VIDEO_OUT_RESOLUTION_1024x720_3D_FRAME_PACKING   = 0x88,
	CELL_VIDEO_OUT_RESOLUTION_960x720_3D_FRAME_PACKING    = 0x89,
	CELL_VIDEO_OUT_RESOLUTION_800x720_3D_FRAME_PACKING    = 0x8a,
	CELL_VIDEO_OUT_RESOLUTION_640x720_3D_FRAME_PACKING    = 0x8b,
	CELL_VIDEO_OUT_RESOLUTION_720_DUALVIEW_FRAME_PACKING  = 0x91,
	CELL_VIDEO_OUT_RESOLUTION_720_SIMULVIEW_FRAME_PACKING = 0x91,
	CELL_VIDEO_OUT_RESOLUTION_1024x720_DUALVIEW_FRAME_PACKING   = 0x98,
	CELL_VIDEO_OUT_RESOLUTION_1024x720_SIMULVIEW_FRAME_PACKING  = 0x98,
	CELL_VIDEO_OUT_RESOLUTION_960x720_DUALVIEW_FRAME_PACKING    = 0x99,
	CELL_VIDEO_OUT_RESOLUTION_960x720_SIMULVIEW_FRAME_PACKING   = 0x99,
	CELL_VIDEO_OUT_RESOLUTION_800x720_DUALVIEW_FRAME_PACKING    = 0x9a,
	CELL_VIDEO_OUT_RESOLUTION_800x720_SIMULVIEW_FRAME_PACKING   = 0x9a,
	CELL_VIDEO_OUT_RESOLUTION_640x720_DUALVIEW_FRAME_PACKING    = 0x9b,
	CELL_VIDEO_OUT_RESOLUTION_640x720_SIMULVIEW_FRAME_PACKING   = 0x9b
} CellVideoOutResolutionId;

typedef enum CellVideoOutScanMode {
	CELL_VIDEO_OUT_SCAN_MODE_INTERLACE,
	CELL_VIDEO_OUT_SCAN_MODE_PROGRESSIVE
} CellVideoOutScanMode;

typedef enum CellVideoOutRefreshRate {
	CELL_VIDEO_OUT_REFRESH_RATE_AUTO    = 0x0000,
	CELL_VIDEO_OUT_REFRESH_RATE_59_94HZ = 0x0001,
	CELL_VIDEO_OUT_REFRESH_RATE_50HZ    = 0x0002,
	CELL_VIDEO_OUT_REFRESH_RATE_60HZ    = 0x0004,
	CELL_VIDEO_OUT_REFRESH_RATE_30HZ    = 0x0008
} CellVideoOutRefreshRate;

typedef enum CellVideoOutPortType {
	CELL_VIDEO_OUT_PORT_NONE          = 0x00,
	CELL_VIDEO_OUT_PORT_HDMI          = 0x01,
	CELL_VIDEO_OUT_PORT_NETWORK       = 0x41,
	CELL_VIDEO_OUT_PORT_COMPOSITE_S   = 0x81,
	CELL_VIDEO_OUT_PORT_D             = 0x82,
	CELL_VIDEO_OUT_PORT_COMPONENT     = 0x83,
	CELL_VIDEO_OUT_PORT_RGB           = 0x84,
	CELL_VIDEO_OUT_PORT_AVMULTI_SCART = 0x85,
	CELL_VIDEO_OUT_PORT_DSUB          = 0x86
} CellVideoOutPortType;

typedef enum CellVideoOutDisplayAspect {
    CELL_VIDEO_OUT_ASPECT_AUTO,
	CELL_VIDEO_OUT_ASPECT_4_3,
	CELL_VIDEO_OUT_ASPECT_16_9
} CellVideoOutDisplayAspect;

typedef enum CellVideoOutBufferColorFormat {
	CELL_VIDEO_OUT_BUFFER_COLOR_FORMAT_X8R8G8B8,
	CELL_VIDEO_OUT_BUFFER_COLOR_FORMAT_X8B8G8R8,
	CELL_VIDEO_OUT_BUFFER_COLOR_FORMAT_R16G16B16X16_FLOAT
} CellVideoOutBufferColorFormat;

typedef enum CellVideoOutOutputState {
	CELL_VIDEO_OUT_OUTPUT_STATE_ENABLED,
	CELL_VIDEO_OUT_OUTPUT_STATE_DISABLED,
	CELL_VIDEO_OUT_OUTPUT_STATE_PREPARING
} CellVideoOutOutputState;

typedef enum CellVideoOutDeviceState {
	CELL_VIDEO_OUT_DEVICE_STATE_UNAVAILABLE,
	CELL_VIDEO_OUT_DEVICE_STATE_AVAILABLE,
} CellVideoOutDeviceState;

typedef enum CellVideoOutColorSpace {
	CELL_VIDEO_OUT_COLOR_SPACE_RGB   = 0x01,
	CELL_VIDEO_OUT_COLOR_SPACE_YUV   = 0x02,
	CELL_VIDEO_OUT_COLOR_SPACE_XVYCC = 0x04
} CellVideoOutColorSpace;

typedef enum CellVideoOutDebugMonitorType {
	CELL_VIDEO_OUT_DEBUG_MONITOR_TYPE_UNDEFINED     = 0,
	CELL_VIDEO_OUT_DEBUG_MONITOR_TYPE_480I_59_94HZ  = 1,
	CELL_VIDEO_OUT_DEBUG_MONITOR_TYPE_576I_50HZ     = 2,
	CELL_VIDEO_OUT_DEBUG_MONITOR_TYPE_480P_59_94HZ  = 3,
	CELL_VIDEO_OUT_DEBUG_MONITOR_TYPE_576P_50HZ     = 4,
	CELL_VIDEO_OUT_DEBUG_MONITOR_TYPE_1080I_59_94HZ = 5,
	CELL_VIDEO_OUT_DEBUG_MONITOR_TYPE_720P_59_94HZ  = 7,
	CELL_VIDEO_OUT_DEBUG_MONITOR_TYPE_1080P_59_94HZ = 9,
	CELL_VIDEO_OUT_DEBUG_MONITOR_TYPE_WXGA_60HZ     = 11,
	CELL_VIDEO_OUT_DEBUG_MONITOR_TYPE_SXGA_60HZ     = 12,
	CELL_VIDEO_OUT_DEBUG_MONITOR_TYPE_WUXGA_60HZ    = 13
} CellVideoOutDebugMonitorType;

typedef struct CellVideoOutColorInfo {
	uint16_t                      redX;
	uint16_t                      redY;
	uint16_t                      greenX;
	uint16_t                      greenY;
	uint16_t                      blueX;
	uint16_t                      blueY;
	uint16_t                      whiteX;
	uint16_t                      whiteY;
	uint32_t                      gamma;
} CellVideoOutColorInfo;

typedef struct CellVideoOutKSVList {
	uint8_t                       ksv[32*5];
	uint8_t                       reserved[4];
	uint32_t                      count;
} CellVideoOutKSVList;

typedef enum CellVideoOutDisplayConversion {
	CELL_VIDEO_OUT_DISPLAY_CONVERSION_NONE			= 0x00,
	CELL_VIDEO_OUT_DISPLAY_CONVERSION_TO_WXGA	    = 0x01,
	CELL_VIDEO_OUT_DISPLAY_CONVERSION_TO_SXGA       = 0x02,
	CELL_VIDEO_OUT_DISPLAY_CONVERSION_TO_WUXGA	    = 0x03,
	CELL_VIDEO_OUT_DISPLAY_CONVERSION_TO_1080	    = 0x05,
	CELL_VIDEO_OUT_DISPLAY_CONVERSION_TO_REMOTEPLAY = 0x10,
	CELL_VIDEO_OUT_DISPLAY_CONVERSION_TO_720_3D_FRAME_PACKING = 0x80,
	CELL_VIDEO_OUT_DISPLAY_CONVERSION_TO_720_DUALVIEW_FRAME_PACKING  = 0x81,
	CELL_VIDEO_OUT_DISPLAY_CONVERSION_TO_720_SIMULVIEW_FRAME_PACKING = 0x81
} CellVideoOutDisplayConversion;

typedef struct CellVideoOutDisplayMode {
	uint8_t                       resolutionId;
	uint8_t                       scanMode;
	uint8_t                       conversion;
	uint8_t                       aspect;
	uint8_t                       reserved[2];
	uint16_t                      refreshRates;
} CellVideoOutDisplayMode;

typedef struct CellVideoOutResolution {
	uint16_t                      width;
	uint16_t                      height;
} CellVideoOutResolution;

typedef struct CellVideoOutDeviceInfo {
	uint8_t                       portType;
	uint8_t                       colorSpace;
	uint16_t                      latency;
	uint8_t                       availableModeCount;
	uint8_t                       state;
	uint8_t                       rgbOutputRange;
	uint8_t                       reserved[5];
	CellVideoOutColorInfo         colorInfo;
	CellVideoOutDisplayMode       availableModes[32];
	CellVideoOutKSVList           ksvList;
} CellVideoOutDeviceInfo;

typedef struct CellVideoOutState {
	uint8_t                       state;
	uint8_t                       colorSpace;
	uint8_t                       reserved[6];
	CellVideoOutDisplayMode       displayMode;
} CellVideoOutState;

typedef struct CellVideoOutConfiguration {
	uint8_t                       resolutionId;
	uint8_t                       format;
	uint8_t                       aspect;
	uint8_t                       reserved[9];
	uint32_t                      pitch;
} CellVideoOutConfiguration;

typedef enum CellVideoOutEvent {
	CELL_VIDEO_OUT_EVENT_DEVICE_CHANGED,
	CELL_VIDEO_OUT_EVENT_OUTPUT_DISABLED,
	CELL_VIDEO_OUT_EVENT_DEVICE_AUTHENTICATED,
	CELL_VIDEO_OUT_EVENT_OUTPUT_ENABLED
} CellVideoOutEvent;

typedef enum CellVideoOutCopyControl {
	CELL_VIDEO_OUT_COPY_CONTROL_COPY_FREE,
	CELL_VIDEO_OUT_COPY_CONTROL_COPY_ONCE,
	CELL_VIDEO_OUT_COPY_CONTROL_COPY_NEVER
} CellVideoOutCopyControl;

typedef struct CellVideoOutOption {
	uint32_t                      reserved;
} CellVideoOutOption;

typedef int (*CellVideoOutCallback)(
	uint32_t slot, uint32_t videoOut, uint32_t deviceIndex,
	uint32_t event, CellVideoOutDeviceInfo* info, void* userData
);

typedef enum CellVideoOutRGBOutputRange {
	CELL_VIDEO_OUT_RGB_OUTPUT_RANGE_LIMITED,
	CELL_VIDEO_OUT_RGB_OUTPUT_RANGE_FULL
} CellVideoOutRGBOutputRange;


int cellVideoOutRegisterCallback(
	uint32_t slot, CellVideoOutCallback function, void* userData
);

int cellVideoOutUnregisterCallback(uint32_t slot);

int cellVideoOutGetNumberOfDevice(uint32_t videoOut);

int cellVideoOutGetState(
	uint32_t videoOut, uint32_t deviceIndex, CellVideoOutState* state
);

int cellVideoOutGetDeviceInfo(
	uint32_t videoOut, uint32_t deviceIndex, CellVideoOutDeviceInfo* info
);

int cellVideoOutConfigure(
	uint32_t videoOut, CellVideoOutConfiguration* config,
	CellVideoOutOption* option, uint32_t waitForEvent
);

int cellVideoOutGetConfiguration(
	uint32_t videoOut, CellVideoOutConfiguration* config,
	CellVideoOutOption* option
);

int cellVideoOutGetResolution(
	uint32_t resolutionId, CellVideoOutResolution* resolution
);

int cellVideoOutGetResolutionAvailability(
	uint32_t videoOut, uint32_t resolutionId, uint32_t aspect, uint32_t option
);

int cellVideoOutSetCopyControl(
	uint32_t videoOut, uint32_t control
);
    
int cellVideoOutDebugSetMonitorType(
	uint32_t videoOut, uint32_t monitorType
);

int cellVideoOutSetGamma(
	uint32_t videoOut, float gamma
);

int cellVideoOutGetGamma(
	uint32_t videoOut, float* gamma
);

int cellVideoOutGetScreenSize(
	uint32_t videoOut, float* screenSize
);

int cellVideoOutConvertCursorColor(
	uint32_t videoOut, int displaybuffer_format, float gamma, int source_buffer_format, void *src_addr, uint32_t *dest_addr, int num
);

int cellVideoOutGetConvertCursorColorInfo(
	uint8_t		*rgbOutputRange
);
// add by nemoto

/* ----------------------------- Audio -------------------------------- */

typedef enum CellAudioOut {
	CELL_AUDIO_OUT_PRIMARY,
	CELL_AUDIO_OUT_SECONDARY
} CellAudioOut;

typedef enum CellAudioOutPortType {
	CELL_AUDIO_OUT_PORT_HDMI,
	CELL_AUDIO_OUT_PORT_SPDIF,
	CELL_AUDIO_OUT_PORT_ANALOG,
	CELL_AUDIO_OUT_PORT_USB,
	CELL_AUDIO_OUT_PORT_BLUETOOTH,
	CELL_AUDIO_OUT_PORT_NETWORK
} CellAudioOutPortType;

typedef enum CellAudioOutputState {
	CELL_AUDIO_OUT_OUTPUT_STATE_ENABLED,
	CELL_AUDIO_OUT_OUTPUT_STATE_DISABLED,
	CELL_AUDIO_OUT_OUTPUT_STATE_PREPARING
} CellAudioOutOutputState;

typedef enum CellAudioOutDeviceState {
	CELL_AUDIO_OUT_DEVICE_STATE_UNAVAILABLE,
	CELL_AUDIO_OUT_DEVICE_STATE_AVAILABLE,
} CellAudioOutDeviceState;

typedef enum CellAudioOutCodingType {
	CELL_AUDIO_OUT_CODING_TYPE_LPCM = 0,
	CELL_AUDIO_OUT_CODING_TYPE_AC3,
	CELL_AUDIO_OUT_CODING_TYPE_MPEG1,
	CELL_AUDIO_OUT_CODING_TYPE_MP3,
	CELL_AUDIO_OUT_CODING_TYPE_MPEG2,
	CELL_AUDIO_OUT_CODING_TYPE_AAC,
	CELL_AUDIO_OUT_CODING_TYPE_DTS,
	CELL_AUDIO_OUT_CODING_TYPE_ATRAC,
	CELL_AUDIO_OUT_CODING_TYPE_DOLBY_DIGITAL_PLUS = 9,
	CELL_AUDIO_OUT_CODING_TYPE_BITSTREAM = 0xff
} CellAudioOutCodingType;

typedef enum CellAudioOutFs {
	CELL_AUDIO_OUT_FS_32KHZ                     = 0x01,
	CELL_AUDIO_OUT_FS_44KHZ                     = 0x02,
	CELL_AUDIO_OUT_FS_48KHZ                     = 0x04,
	CELL_AUDIO_OUT_FS_88KHZ                     = 0x08,
	CELL_AUDIO_OUT_FS_96KHZ                     = 0x10,
	CELL_AUDIO_OUT_FS_176KHZ                    = 0x20,
	CELL_AUDIO_OUT_FS_192KHZ                    = 0x40
} CellAudioOutFs;

typedef enum CellAudioOutChnum {
	CELL_AUDIO_OUT_CHNUM_2                      = 2,
	CELL_AUDIO_OUT_CHNUM_4                      = 4,
	CELL_AUDIO_OUT_CHNUM_6                      = 6,
	CELL_AUDIO_OUT_CHNUM_8                      = 8
} CellAudioOutChnum;

typedef enum CellAudioOutSbitOrBitrate {
	CELL_AUDIO_OUT_SBIT_NONE                    = 0x00,
	CELL_AUDIO_OUT_SBIT_16BIT                   = 0x01,
	CELL_AUDIO_OUT_SBIT_20BIT                   = 0x02,
	CELL_AUDIO_OUT_SBIT_24BIT                   = 0x04
} CellAudioOutSbitOrBitrate;

typedef enum CellAudioOutSpeakerLayout {
	CELL_AUDIO_OUT_SPEAKER_LAYOUT_DEFAULT       = 0x00000000,
	CELL_AUDIO_OUT_SPEAKER_LAYOUT_2CH           = 0x00000001,
	CELL_AUDIO_OUT_SPEAKER_LAYOUT_6CH_LREClr    = 0x00010000,
	CELL_AUDIO_OUT_SPEAKER_LAYOUT_8CH_LREClrxy  = 0x40000000
} CellAudioOutSpeakerLayout;

typedef struct CellAudioOutSoundMode {
	uint8_t                       type;
	uint8_t                       channel;
	uint8_t                       fs;
	uint8_t                       reserved;
	uint32_t                      layout;
} CellAudioOutSoundMode;

typedef struct CellAudioOutState {
	uint8_t                       state;
    uint8_t                       encoder;
	uint8_t                       reserved[6];
	uint32_t                      downMixer;
	CellAudioOutSoundMode         soundMode;
} CellAudioOutState;

typedef struct CellAudioOutDeviceInfo {
	uint8_t                       portType;
	uint8_t                       availableModeCount;
	uint8_t                       state;
	uint8_t                       reserved[3];
	uint16_t                      latency;
	CellAudioOutSoundMode         availableModes[16];
} CellAudioOutDeviceInfo;

typedef enum CellAudioOutDownMixer {
	CELL_AUDIO_OUT_DOWNMIXER_NONE,
	CELL_AUDIO_OUT_DOWNMIXER_TYPE_A,
	CELL_AUDIO_OUT_DOWNMIXER_TYPE_B
} CellAudioOutDownMixer;

typedef struct CellAudioOutConfiguration {
	uint8_t                       channel;
	uint8_t                       encoder;
	uint8_t                       reserved[10];
	uint32_t                      downMixer;
} CellAudioOutConfiguration;

typedef struct CellAudioOutOption {
	uint32_t                      reserved;
} CellAudioOutOption;

typedef enum CellAudioOutEvent {
	CELL_AUDIO_OUT_EVENT_DEVICE_CHANGED,
	CELL_AUDIO_OUT_EVENT_OUTPUT_DISABLED,
	CELL_AUDIO_OUT_EVENT_DEVICE_AUTHENTICATED,
	CELL_AUDIO_OUT_EVENT_OUTPUT_ENABLED
} CellAudioOutEvent;

typedef int (*CellAudioOutCallback)(
	uint32_t slot, uint32_t audioOut, uint32_t deviceIndex,
	uint32_t event, CellAudioOutDeviceInfo* info, void* userData
);

typedef uint32_t CellAudioOutLatency;

typedef enum CellAudioOutCopyControl {
	CELL_AUDIO_OUT_COPY_CONTROL_COPY_FREE,
	CELL_AUDIO_OUT_COPY_CONTROL_COPY_ONCE,
	CELL_AUDIO_OUT_COPY_CONTROL_COPY_NEVER
} CellAudioOutCopyControl;
//#define _ENABLE_MULTI_HEADPHONE
//#if defined(_ENABLE_MULTI_HEADPHONE)
typedef enum CellAudioOutDeviceMode {
	CELL_AUDIO_OUT_SINGLE_DEVICE_MODE            = 0,
	CELL_AUDIO_OUT_MULTI_DEVICE_MODE             = 1,
	CELL_AUDIO_OUT_MULTI_DEVICE_MODE_2           = 2,
} CellAudioOutDeviceMode;

typedef struct CellAudioOutSoundMode2 {
	uint8_t type;
	uint8_t channel;
	uint16_t fs;
	uint8_t reserved[4];
} CellAudioOutSoundMode2;

typedef struct CellAudioOutDeviceInfo2 {
	uint8_t portType;
	uint8_t availableModeCount;
	uint8_t state;
	uint8_t deviceNumber;
	uint8_t reserved[12];
	uint64_t deviceId;
	uint64_t type;
	char name[64];
	CellAudioOutSoundMode2 availableModes[16];
} CellAudioOutDeviceInfo2;

typedef struct CellAudioOutRegistrationOption {
	uint32_t                      reserved;
} CellAudioOutRegistrationOption;

typedef struct CellAudioOutDeviceConfiguration {
	uint8_t volume;
	uint8_t reserved[31];
} CellAudioOutDeviceConfiguration;

//#endif //defined(_ENABLE_MULTI_HEADPHONE)


int cellAudioOutRegisterCallback(
	uint32_t slot, CellAudioOutCallback function, void* userData
);

int cellAudioOutUnregisterCallback(uint32_t slot);

int cellAudioOutGetNumberOfDevice(uint32_t audioOut);

int cellAudioOutGetDeviceInfo(
	uint32_t audioOut, uint32_t deviceIndex, CellAudioOutDeviceInfo* info
);

int cellAudioOutGetState(
	uint32_t audioOut, uint32_t deviceIndex, CellAudioOutState* state
);

int cellAudioOutConfigure(
	uint32_t audioOut, CellAudioOutConfiguration* config,
	CellAudioOutOption* option, uint32_t waitForEvent
);

int cellAudioOutGetConfiguration(
	uint32_t audioOut, CellAudioOutConfiguration* config,
	CellAudioOutOption* option
);

int cellAudioOutSetCopyControl(
	uint32_t audioOut, uint32_t control
);

//#if defined(_ENABLE_MULTI_HEADPHONE)
int cellAudioOutSetDeviceMode(
	uint32_t deviceMode
);

int cellAudioOutGetAvailableDeviceInfo(
	uint32_t count,
	CellAudioOutDeviceInfo2 info[]
);

int cellAudioOutRegisterDevice(
	uint64_t deviceType,
	const char * name,
	CellAudioOutRegistrationOption* option,
	CellAudioOutDeviceConfiguration* config
);

int cellAudioOutUnregisterDevice(
	uint32_t deviceNumber
);

int cellAudioOutGetDeviceInfo2(
	uint32_t deviceNumber,
	uint32_t deviceIndex,
	CellAudioOutDeviceInfo2* info
);
//#endif //defined(_ENABLE_MULTI_HEADPHONE)

/* ----------------------------- Audio In -------------------------------- */

typedef enum CellAudioInDeviceMode {
	CELL_AUDIO_IN_SINGLE_DEVICE_MODE            = 0,
	CELL_AUDIO_IN_MULTI_DEVICE_MODE             = 1,
	CELL_AUDIO_IN_MULTI_DEVICE_MODE_2           = 2,
	//-->> [bug:97339]
	CELL_AUDIO_IN_MULTI_DEVICE_MODE_10          = 10,
	//<<-- [bug:97339]
} CellAudioInDeviceMode;

typedef enum CellAudioInPortType {
	CELL_AUDIO_IN_PORT_USB                      = 3,
	CELL_AUDIO_IN_PORT_BLUETOOTH                = 4
} CellAudioInPortType;

typedef enum CellAudioInDeviceState {
	CELL_AUDIO_IN_DEVICE_STATE_UNAVAILABLE      = 0,
	CELL_AUDIO_IN_DEVICE_STATE_AVAILABLE        = 1
} CellAudioInDeviceState;

typedef enum CellAudioInCodingType {
	CELL_AUDIO_IN_CODING_TYPE_LPCM              = 0
} CellAudioInCodingType;

typedef enum CellAudioInChnum {
	CELL_AUDIO_IN_CHNUM_NONE                    = 0,
	CELL_AUDIO_IN_CHNUM_1                       = 1,
	CELL_AUDIO_IN_CHNUM_2                       = 2
} CellAudioInChnum;

typedef enum CellAudioInFs {
	CELL_AUDIO_IN_FS_UNDEFINED                  = 0x00,
	CELL_AUDIO_IN_FS_8KHZ                       = 0x01,
	CELL_AUDIO_IN_FS_12KHZ                      = 0x02,
	CELL_AUDIO_IN_FS_16KHZ                      = 0x04,
	CELL_AUDIO_IN_FS_24KHZ                      = 0x08,
	CELL_AUDIO_IN_FS_32KHZ                      = 0x10,
	CELL_AUDIO_IN_FS_48KHZ                      = 0x20,
} CellAudioInFs;

typedef struct CellAudioInSoundMode {
	uint8_t type;
	uint8_t channel;
	uint16_t fs;
	uint8_t reserved[4];
} CellAudioInSoundMode;

typedef struct CellAudioInDeviceInfo {
	uint8_t portType;
	uint8_t availableModeCount;
	uint8_t state;
	uint8_t deviceNumber;
	uint8_t reserved[12];
	uint64_t deviceId;
	uint64_t type;
	char name[64];
	CellAudioInSoundMode availableModes[16];
} CellAudioInDeviceInfo;

typedef struct CellAudioInDeviceConfiguration {
	uint8_t volume;
	uint8_t reserved[31];
} CellAudioInDeviceConfiguration;

typedef struct CellAudioInRegistrationOption {
	uint32_t                      reserved;
} CellAudioInRegistrationOption;

int cellAudioInSetDeviceMode(
	uint32_t deviceMode
);

int cellAudioInRegisterDevice(
	uint64_t deviceType,
	const char* name,
	CellAudioInRegistrationOption* option,
	CellAudioInDeviceConfiguration* config
);

int cellAudioInUnregisterDevice(
	uint32_t deviceNumber
);

int cellAudioInGetDeviceInfo(
	uint32_t deviceNumber,
	uint32_t deviceIndex,
	CellAudioInDeviceInfo* info
);

int cellAudioInGetAvailableDeviceInfo(
	uint32_t count,
	CellAudioInDeviceInfo info[]
);

int cellAudioOutGetSoundAvailability(        
	uint32_t audioOut, uint32_t type, uint32_t fs, uint32_t option
);

int cellAudioOutGetSoundAvailability2(        
	uint32_t audioOut, uint32_t type, uint32_t fs, uint32_t ch, uint32_t option
);

int cellSysutilGetSystemParamInt( int id, int *value );
int cellSysutilGetSystemParamString( int id, char *buf, unsigned int bufsize );


}


# 24 "C:\\Users\\USER\\Documents\\Visual Studio 2013\\Projects\\mp3_plugin_PS3\\mp3_plugin_PS3\\main.cpp"
# 1 "C:/usr/local/cell\\target\\ppu\\include/sys\\dbg.h" 3
/*   SCE CONFIDENTIAL                                       */
/*   PlayStation(R)3 Programmer Tool Runtime Library 475.001 */
/*   Copyright (C) 2009 Sony Computer Entertainment Inc.    */
/*   All Rights Reserved.                                   */




# 1 "C:/usr/local/cell\\target\\ppu\\include/sys/system_types.h" 3
/*   SCE CONFIDENTIAL                                       */
/*   PlayStation(R)3 Programmer Tool Runtime Library 475.001 */
/*   Copyright (C) 2005 Sony Computer Entertainment Inc.    */
/*   All Rights Reserved.                                   */








# 10 "C:/usr/local/cell\\target\\ppu\\include/sys\\dbg.h" 3
# 1 "C:/usr/local/cell\\target\\ppu\\include/sys/spu_thread_group.h" 3
/*   SCE CONFIDENTIAL                                       */
/*   PlayStation(R)3 Programmer Tool Runtime Library 475.001 */
/*   Copyright (C) 2010 Sony Computer Entertainment Inc.    */
/*   All Rights Reserved.                                   */

/** \ingroup all_syscall
 * \defgroup spu_thread_group SPU Thread Groups
 * \brief system calls defined in sys/spu_thread_group.h
 *
 * Interfaces defined in sys/spu_thread_group.h.
 *
 * Refer to <i>Cell OS Lv-2 User's Manual</i> for the detailed description.
 */


/*@{*/











extern "C" {






# 42 "C:/usr/local/cell\\target\\ppu\\include/sys/spu_thread_group.h" 3






# 54 "C:/usr/local/cell\\target\\ppu\\include/sys/spu_thread_group.h" 3

/* exception causes */
# 69 "C:/usr/local/cell\\target\\ppu\\include/sys/spu_thread_group.h" 3

/* log */





/** \brief SPU thread group attribute structure
 *
 * The sys_spu_thread_group_attribute_t structure type is used to set
 * attributes to an SPU thread group by sys_spu_thread_group_create().
 *
 * \a type must be one of the following values.
 *  - SYS_SPU_THREAD_GROUP_TYPE_NORMAL \n
 *    Normal SPU thread group.
 *  - SYS_SPU_THREAD_GROUP_TYPE_SEQUENTIAL \n
 *    An SPU thread group whose execution is triggered by termination of 
 *    other SPU thread groups.
 *
 * \see sys_spu_thread_group_create
 */
struct sys_spu_thread_group_attribute {
	/** The length of \a name including the null terminator */
	::std:: size_t nsize;
	/** A string of the name for this SPU thread group */
	const char *name;
	/** SPU thread group type */
	int type;
	/** A memory container.  It is used only if
		SYS_SPU_THREAD_GROUP_TYPE_MEMORY_FROM_CONTAINER is specified */
	union {
		sys_memory_container_t ct;
	} option;
};
typedef struct sys_spu_thread_group_attribute sys_spu_thread_group_attribute_t;


/**
 * \brief Initialize an SPU thread group attribute structure
 *
 * The sys_spu_thread_group_attribute_initialize() function initializes an SPU
 * thread group attribute structure \a attr with the default value.
 *
 * \param attr  an SPU thread group attribute structure
 *
 */
# 121 "C:/usr/local/cell\\target\\ppu\\include/sys/spu_thread_group.h" 3


/**
 * \brief Set name and nsize member in an SPU thread group attribute structure
 *
 * The sys_spu_thread_group_attribute_name() function sets a name and a nsize
 * member in an SPU thread group attribute structure \a attr with \a name to
 * name an SPU thread group.
 *
 * \param attr an SPU thread group attribute structure
 * \param name a pointer to a string to name
 *
 */
# 146 "C:/usr/local/cell\\target\\ppu\\include/sys/spu_thread_group.h" 3


/**
 * \brief Set type member in an SPU thread group attribute structure
 *
 * The sys_spu_thread_group_attribute_type() function sets a type member in
 * an SPU thread group attribute structure \a attr with \a type.
 *
 * \param attr    an SPU thread attribute structure
 * \param type    type to be specified
 *
 */






/**
 * \brief Set memory container member in an SPU thread group attribute structure
 *
 * The sys_spu_thread_group_attribute_memory_container() function sets a type
 * member in an SPU thread group attribute structure \a attr with \a type.
 *
 * \param attr       an SPU thread attribute structure
 * \param container  memory container to be specified
 *
 */









extern inline int sys_spu_thread_group_create(sys_spu_thread_group_t * id,
											  unsigned int num, int prio,
											  sys_spu_thread_group_attribute_t *
											  attr);

extern inline int sys_spu_thread_group_create(sys_spu_thread_group_t * id,
											  unsigned int num, int prio,
											  sys_spu_thread_group_attribute_t *
											  attr)
{
	extern uint64_t __system_call_170(uint64_t, uint64_t, uint64_t, uint64_t); uint64_t p1 = __system_call_170((uint32_t) id, num, prio, (uint32_t) attr);;





	return (int)(p1);
}

extern inline int sys_spu_thread_group_destroy(sys_spu_thread_group_t id);

extern inline int sys_spu_thread_group_destroy(sys_spu_thread_group_t id)
{
	extern uint64_t __system_call_171(uint64_t); uint64_t p1 = __system_call_171(id);;




	return (int)(p1);
}


extern inline int sys_spu_thread_group_start(sys_spu_thread_group_t id);

extern inline int sys_spu_thread_group_start(sys_spu_thread_group_t id)
{
	extern uint64_t __system_call_173(uint64_t); uint64_t p1 = __system_call_173(id);;




	return (int)(p1);
}

extern inline int sys_spu_thread_group_start_on_exit(sys_spu_thread_group_t gid,
													 int ngroups,
													 sys_spu_thread_group_t *
													 groups);

extern inline int sys_spu_thread_group_start_on_exit(sys_spu_thread_group_t gid,
													 int ngroups,
													 sys_spu_thread_group_t *
													 groups)
{
	extern uint64_t __system_call_167(uint64_t, uint64_t, uint64_t); uint64_t p1 = __system_call_167(gid, ngroups, (uint32_t) groups);;





	return (int)(p1);
}


extern inline int sys_spu_thread_group_terminate(sys_spu_thread_group_t id,
												 int value);

extern inline int sys_spu_thread_group_terminate(sys_spu_thread_group_t id,
												 int value)
{
	extern uint64_t __system_call_177(uint64_t, uint64_t); uint64_t p1 = __system_call_177(id, value);;




	return (int)(p1);
}


extern inline int sys_spu_thread_group_suspend(sys_spu_thread_group_t id);

extern inline int sys_spu_thread_group_suspend(sys_spu_thread_group_t id)
{
	extern uint64_t __system_call_174(uint64_t); uint64_t p1 = __system_call_174(id);;




	return (int)(p1);
}

extern inline int sys_spu_thread_group_resume(sys_spu_thread_group_t id);

extern inline int sys_spu_thread_group_resume(sys_spu_thread_group_t id)
{
	extern uint64_t __system_call_175(uint64_t); uint64_t p1 = __system_call_175(id);;




	return (int)(p1);
}


extern inline int sys_spu_thread_group_yield(sys_spu_thread_group_t id);

extern inline int sys_spu_thread_group_yield(sys_spu_thread_group_t id)
{
	extern uint64_t __system_call_176(uint64_t); uint64_t p1 = __system_call_176(id);;




	return (int)(p1);
}


extern inline int sys_spu_thread_group_set_priority(sys_spu_thread_group_t id,
													int priority);

extern inline int sys_spu_thread_group_set_priority(sys_spu_thread_group_t id,
													int priority)
{
	extern uint64_t __system_call_179(uint64_t, uint64_t); uint64_t p1 = __system_call_179(id, priority);;




	return (int)(p1);
}

extern inline int sys_spu_thread_group_get_priority(sys_spu_thread_group_t id,
													int *priority);

extern inline int sys_spu_thread_group_get_priority(sys_spu_thread_group_t id,
													int *priority)
{
	extern uint64_t __system_call_180(uint64_t, uint64_t); uint64_t p1 = __system_call_180(id, (uint32_t) priority);;




	return (int)(p1);
}


extern inline int sys_spu_thread_group_join(sys_spu_thread_group_t gid,
											int *cause, int *status);

extern inline int sys_spu_thread_group_join(sys_spu_thread_group_t gid,
											int *cause, int *status)
{
	extern uint64_t __system_call_178(uint64_t, uint64_t, uint64_t); uint64_t p1 = __system_call_178(gid, (uint32_t) cause, (uint32_t) status);;





	return (int)(p1);
}


extern inline int sys_spu_thread_group_connect_event(sys_spu_thread_group_t id,
													 sys_event_queue_t eq,
													 sys_event_type_t et);

extern inline int sys_spu_thread_group_connect_event(sys_spu_thread_group_t id,
													 sys_event_queue_t eq,
													 sys_event_type_t et)
{
	extern uint64_t __system_call_185(uint64_t, uint64_t, uint64_t); uint64_t p1 = __system_call_185(id, eq, et);;




	return (int)(p1);
}

extern inline int sys_spu_thread_group_disconnect_event(sys_spu_thread_group_t
														id,
														sys_event_type_t et);

extern inline int sys_spu_thread_group_disconnect_event(sys_spu_thread_group_t
														id, sys_event_type_t et)
{
	extern uint64_t __system_call_186(uint64_t, uint64_t); uint64_t p1 = __system_call_186(id, et);;




	return (int)(p1);
}



extern inline int
sys_spu_thread_group_connect_event_all_threads(sys_spu_thread_group_t id,
											   sys_event_queue_t eq,
											   uint64_t req, uint8_t * spup);

extern inline int
sys_spu_thread_group_connect_event_all_threads(sys_spu_thread_group_t id,
											   sys_event_queue_t eq,
											   uint64_t req, uint8_t * spup)
{
	extern uint64_t __system_call_251(uint64_t, uint64_t, uint64_t, uint64_t); uint64_t p1 = __system_call_251(id, eq, req, (uint32_t) spup);;





	return (int)(p1);
}

extern inline int
sys_spu_thread_group_disconnect_event_all_threads(sys_spu_thread_group_t id,
												  uint8_t spup);

extern inline int
sys_spu_thread_group_disconnect_event_all_threads(sys_spu_thread_group_t id,
												  uint8_t spup)
{
	extern uint64_t __system_call_252(uint64_t, uint64_t); uint64_t p1 = __system_call_252(id, spup);;




	return (int)(p1);
}




extern inline int
sys_spu_thread_group_set_cooperative_victims(sys_spu_thread_group_t id,
											 uint32_t victims);

extern inline int
sys_spu_thread_group_set_cooperative_victims(sys_spu_thread_group_t id,
											 uint32_t victims)
{
	extern uint64_t __system_call_250(uint64_t, uint64_t); uint64_t p1 = __system_call_250(id, victims);;




	return (int)(p1);
}


extern inline int sys_spu_thread_group_log(int command, int *stat);

extern inline int sys_spu_thread_group_log(int command, int *stat)
{
	extern uint64_t __system_call_254(uint64_t, uint64_t); uint64_t p1 = __system_call_254(command, (uint32_t) stat);;




	return (int)(p1);
}



}


/*@}*/
# 13 "C:/usr/local/cell\\target\\ppu\\include/sys\\dbg.h" 3
# 1 "C:/usr/local/cell\\target\\ppu\\include/sys/spu_thread.h" 3
/*   SCE CONFIDENTIAL                                       */
/*   PlayStation(R)3 Programmer Tool Runtime Library 475.001 */
/*   Copyright (C) 2008 Sony Computer Entertainment Inc.    */
/*   All Rights Reserved.                                   */

/** \ingroup all_syscall
 * \defgroup spu_thread SPU Threads
 * \brief system calls defined in sys/spu_thread.h
 *
 * Interfaces defined in sys/spu_thread.h.
 *
 * Refer to <i>Cell OS Lv-2 User's Manual</i> for the detailed description.
 */
/*@{*/










# 1 "C:/usr/local/cell\\target\\ppu\\include/sys/spu_image.h" 3
/*   SCE CONFIDENTIAL                                       */
/*   PlayStation(R)3 Programmer Tool Runtime Library 475.001 */
/*   Copyright (C) 2006 Sony Computer Entertainment Inc.    */
/*   All Rights Reserved.                                   */

/**
 * \ingroup all_syscall
 * \defgroup spu SPU image
 * \brief system calls for SPU program images
 * 
 * Interfaces defined in sys/spu_image.h
 *
 * Refer to <i>Cell OS Lv-2 User's Manual</i> for the detailed description. 
 */

/*@{*/











extern "C" {






/** \brief SPU segment structure
 *
 * The sys_spu_segment_t structure type describes an SPU segment.
 * The initial image to be loaded to an SPU is represented by an array 
 * of this structure type.
 *
 * \a type must be one of the following values.
 * - SYS_SPU_SEGMENT_TYPE_COPY \n
 *   The segment type is COPY.  A segment of this type copies a specified 
 *   area in the process address space to the local storage.
 * - SYS_SPU_SEGMENT_TYPE_FILL \n
 *   The segment type is FILL.  A segment of this type fills a specified 
 *   area in the local storage with an arbitrary 32-bit values.
 * - SYS_SPU_SEGMENT_TYPE_INFO \n
 *   The segment type is INFO.  The detail specification is TBD.
 *
 * \a size represents the size of this SPU segment, and its valid range is 
 * from 128 byte to 16 KB.
 *
 * \a src is a union type, and its meaning differs with the SPU segment type.
 * \a pa_start is used if \a type is SYS_SPU_SEGMENT_TYPE_COPY, and 
 * represents the top effective address of an area in the process address 
 * space that is copied to the SPU segment.  \a pa_start must be aligned to
 * 128 bytes.
 * \a value is used if \a type is 
 * SYS_SEGMENT_TYPE_FILL, and represents the 32-bit value to be filled in 
 * the SPU segment.
 * 
 */
struct sys_spu_segment {
	/** SPU segment type (COPY/FILL/INFO) */
	int type;
	/** Top LS address on which this SPU segment will be loaded */
	::std:: uint32_t ls_start;
	/** Size of this SPU segment in bytes */
	int size;
	union {
		/** Top effective address which an SPU segment of COPY type will copy from */
		sys_addr_t pa_start;
		/** The value to be filled in an SPU segment of FILL type */
		::std:: uint32_t value;
		uint64_t pad;
	} src;
};
typedef struct sys_spu_segment sys_spu_segment_t;






struct sys_spu_image {
	uint32_t type;
	uint32_t entry_point;
	sys_spu_segment_t *segs;
	int nsegs;
};
typedef struct sys_spu_image sys_spu_image_t;





extern int sys_spu_image_import(sys_spu_image_t * img, const void *src,
								uint32_t type);
extern int sys_spu_image_close(sys_spu_image_t * img);

extern inline int sys_spu_image_open(sys_spu_image_t * img, const char *path);

extern inline int sys_spu_image_open(sys_spu_image_t * img, const char *path)
{
	extern uint64_t __system_call_156(uint64_t, uint64_t); uint64_t p1 = __system_call_156((uint32_t) img, (uint32_t) path);;




	return (int)(p1);
}



extern inline int sys_spu_image_open_by_fd(sys_spu_image_t * img, int fd,
										   off64_t offset);

extern inline int sys_spu_image_open_by_fd(sys_spu_image_t * img, int fd,
										   off64_t offset)
{
	extern uint64_t __system_call_260(uint64_t, uint64_t, uint64_t); uint64_t p1 = __system_call_260((uint32_t) img, fd, offset);;




	return (int)(p1);
}



/*@}*/

}

# 26 "C:/usr/local/cell\\target\\ppu\\include/sys/spu_thread.h" 3


extern "C" {


























/** \brief SPU thread argument structure
 * 
 * The sys_spu_thread_argument_t structure type is used to pass arguments 
 * to an SPU thread by sys_spu_thread_initialize().
 *
 * \see sys_spu_thread_initialize
 */
typedef struct sys_spu_thread_argument {
	::std:: uint64_t arg1;
						/**< arg1 (loaded to SPU GPR3) */
	::std:: uint64_t arg2;
						/**< arg2 (loaded to SPU GPR4) */
	::std:: uint64_t arg3;
						/**< arg3 (loaded to SPU GPR5) */
	::std:: uint64_t arg4;
						/**< arg4 (loaded to SPU GPR6) */
} sys_spu_thread_argument_t;






/** \brief SPU thread attribute sturcture
 *
 * The sys_spu_thread_attribute_t structure type is used to set 
 * attributes to an SPU thread by sys_spu_thread_initialize().
 *
 * \see sys_spu_thread_initialize, sys_spu_thread_segment_t
 */
struct sys_spu_thread_attribute {
  /** A string of the name for this SPU thread */
	const char *name;
  /** The length of \a name including the null terminator */
	::std:: size_t nsize;
  /** SPU thread options (NONE/SYNC_INTR_ENABLE/DEC_SYNC_TB_ENABLE) */
	::std:: uint32_t option;
};
typedef struct sys_spu_thread_attribute sys_spu_thread_attribute_t;


/**
 * \brief Initialize an SPU thread attribute structure
 *
 * The sys_spu_thread_attribute_initialize() function initializes an SPU thread
 * attribute structure \a attr with the default value.
 *
 * \param attr  an SPU thread attribute structure
 *
 */
# 111 "C:/usr/local/cell\\target\\ppu\\include/sys/spu_thread.h" 3


/**
 * \brief Set name and nsize member in an SPU thread attribute structure
 *
 * The sys_spu_thread_attribute_name() function sets a name and a nsize member
 * in an SPU thread attribute structure \a attr with \a name to name
 * an SPU thread.
 *
 * \param attr  an SPU thread attribute structure
 * \param name  a pointer to a string to name
 *
 */
# 136 "C:/usr/local/cell\\target\\ppu\\include/sys/spu_thread.h" 3


/**
 * \brief Set option member in an SPU thread attribute structure
 *
 * The sys_spu_thread_attribute_option() function sets an option member in
 * an SPU thread attribute structure \a attr with \a option.
 *
 * \param attr    an SPU thread attribute structure
 * \param option  option to be specified
 *
 */






/**
 * \brief Initialize an SPU thread argument structure
 *
 * The sys_spu_thread_argument_initialize() function initialize an SPU thread
 * argument structure \arg with zeros.
 *
 * \param arg  an SPU thread argument structure
 *
 */






/* Basic operations */
extern inline int sys_spu_thread_initialize(sys_spu_thread_t * thread,
											sys_spu_thread_group_t group,
											unsigned int spu_num,
											sys_spu_image_t * img,
											sys_spu_thread_attribute_t * attr,
											sys_spu_thread_argument_t * arg);

extern inline int sys_spu_thread_initialize(sys_spu_thread_t * thread,
											sys_spu_thread_group_t group,
											unsigned int spu_num,
											sys_spu_image_t * img,
											sys_spu_thread_attribute_t * attr,
											sys_spu_thread_argument_t * arg)
{
	extern uint64_t __system_call_172(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t); uint64_t p1 = __system_call_172((uint32_t) thread, group, spu_num, (uint32_t) img, (uint32_t) attr, (uint32_t) arg);;





	return (int)(p1);
}


extern inline int sys_spu_thread_set_argument(sys_spu_thread_t id,
											  sys_spu_thread_argument_t * arg);

extern inline int sys_spu_thread_set_argument(sys_spu_thread_t id,
											  sys_spu_thread_argument_t * arg)
{
	extern uint64_t __system_call_166(uint64_t, uint64_t); uint64_t p1 = __system_call_166(id, (uint32_t) arg);;




	return (int)(p1);
}


extern inline int sys_spu_thread_get_exit_status(sys_spu_thread_t id,
												 int *status);

extern inline int sys_spu_thread_get_exit_status(sys_spu_thread_t id,
												 int *status)
{
	extern uint64_t __system_call_165(uint64_t, uint64_t); uint64_t p1 = __system_call_165(id, (uint32_t) status);;




	return (int)(p1);
}


extern inline int sys_spu_thread_connect_event(sys_spu_thread_t id,
											   sys_event_queue_t eq,
											   sys_event_type_t et,
											   ::std:: uint8_t spup);

extern inline int sys_spu_thread_connect_event(sys_spu_thread_t id,
											   sys_event_queue_t eq,
											   sys_event_type_t et,
											   ::std:: uint8_t spup)
{
	extern uint64_t __system_call_191(uint64_t, uint64_t, uint64_t, uint64_t); uint64_t p1 = __system_call_191(id, eq, et, spup);;




	return (int)(p1);
}


extern inline int sys_spu_thread_disconnect_event(sys_spu_thread_t id,
												  sys_event_type_t et,
												  ::std:: uint8_t spup);

extern inline int sys_spu_thread_disconnect_event(sys_spu_thread_t id,
												  sys_event_type_t et,
												  ::std:: uint8_t spup)
{
	extern uint64_t __system_call_192(uint64_t, uint64_t, uint64_t); uint64_t p1 = __system_call_192(id, et, spup);;




	return (int)(p1);
}


extern inline int sys_spu_thread_bind_queue(sys_spu_thread_t id,
											sys_event_queue_t spuq,
											::std:: uint32_t spuq_num);

extern inline int sys_spu_thread_bind_queue(sys_spu_thread_t id,
											sys_event_queue_t spuq,
											::std:: uint32_t spuq_num)
{
	extern uint64_t __system_call_193(uint64_t, uint64_t, uint64_t); uint64_t p1 = __system_call_193(id, spuq, spuq_num);;




	return (int)(p1);
}


extern inline int sys_spu_thread_unbind_queue(sys_spu_thread_t id,
											  ::std:: uint32_t spuq_num);

extern inline int sys_spu_thread_unbind_queue(sys_spu_thread_t id,
											  ::std:: uint32_t spuq_num)
{
	extern uint64_t __system_call_194(uint64_t, uint64_t); uint64_t p1 = __system_call_194(id, spuq_num);;




	return (int)(p1);
}



/* Context operations */
extern inline int sys_spu_thread_write_ls(sys_spu_thread_t id,
										  ::std:: uint32_t address,
										  ::std:: uint64_t value,
										  ::std:: size_t type);

extern inline int sys_spu_thread_write_ls(sys_spu_thread_t id,
										  ::std:: uint32_t address,
										  ::std:: uint64_t value,
										  ::std:: size_t type)
{
	extern uint64_t __system_call_181(uint64_t, uint64_t, uint64_t, uint64_t); uint64_t p1 = __system_call_181(id, address, value, type);;




	return (int)(p1);
}

extern inline int sys_spu_thread_read_ls(sys_spu_thread_t id,
										 ::std:: uint32_t address,
										 ::std:: uint64_t * value,
										 ::std:: size_t type);

extern inline int sys_spu_thread_read_ls(sys_spu_thread_t id,
										 ::std:: uint32_t address,
										 ::std:: uint64_t * value,
										 ::std:: size_t type)
{
	extern uint64_t __system_call_182(uint64_t, uint64_t, uint64_t, uint64_t); uint64_t p1 = __system_call_182(id, address, (uint32_t) value, type);;




	return (int)(p1);
}


extern inline int sys_spu_thread_write_snr(sys_spu_thread_t id, int number,
										   ::std:: uint32_t value);

extern inline int sys_spu_thread_write_snr(sys_spu_thread_t id, int number,
										   ::std:: uint32_t value)
{
	extern uint64_t __system_call_184(uint64_t, uint64_t, uint64_t); uint64_t p1 = __system_call_184(id, number, value);;




	return (int)(p1);
}



extern inline int sys_spu_thread_set_spu_cfg(sys_spu_thread_t id,
											 ::std:: uint64_t value);

extern inline int sys_spu_thread_set_spu_cfg(sys_spu_thread_t id,
											 ::std:: uint64_t value)
{
	extern uint64_t __system_call_187(uint64_t, uint64_t); uint64_t p1 = __system_call_187(id, value);;




	return (int)(p1);
}


extern inline int sys_spu_thread_get_spu_cfg(sys_spu_thread_t id,
											 ::std:: uint64_t * value);

extern inline int sys_spu_thread_get_spu_cfg(sys_spu_thread_t id,
											 ::std:: uint64_t * value)
{
	extern uint64_t __system_call_188(uint64_t, uint64_t); uint64_t p1 = __system_call_188(id, (uint32_t) value);;




	return (int)(p1);
}


extern inline int sys_spu_thread_write_spu_mb(sys_spu_thread_t id,
											  ::std:: uint32_t value);

extern inline int sys_spu_thread_write_spu_mb(sys_spu_thread_t id,
											  ::std:: uint32_t value)
{
	extern uint64_t __system_call_190(uint64_t, uint64_t); uint64_t p1 = __system_call_190(id, value);;




	return (int)(p1);
}


extern inline int sys_spu_thread_recover_page_fault(sys_spu_thread_t id);

extern inline int sys_spu_thread_recover_page_fault(sys_spu_thread_t id)
{
	extern uint64_t __system_call_198(uint64_t); uint64_t p1 = __system_call_198(id);;




	return (int)(p1);
}



/* For compatible with SDK050 */
static int sys_spu_thread_write_to_ls(sys_spu_thread_t id,
									  ::std:: uint32_t address,
									  ::std:: uint64_t value, ::std:: size_t type)
	__attribute__ ((deprecated));

static int sys_spu_thread_read_from_ls(sys_spu_thread_t id,
									   ::std:: uint32_t address,
									   ::std:: uint64_t * value,
									   ::std:: size_t type)
	__attribute__ ((deprecated));

static int sys_spu_thread_write_signal(sys_spu_thread_t id,
									   int number, ::std:: uint32_t value)
	__attribute__ ((deprecated));


extern inline int sys_spu_thread_write_to_ls(sys_spu_thread_t id,
											 ::std:: uint32_t address,
											 ::std:: uint64_t value,
											 ::std:: size_t type)
{
	return sys_spu_thread_write_ls(id, address, value, type);
}


extern inline int sys_spu_thread_read_from_ls(sys_spu_thread_t id,
											  ::std:: uint32_t address,
											  ::std:: uint64_t * value,
											  ::std:: size_t type)
{
	return sys_spu_thread_read_ls(id, address, value, type);
}

extern inline int sys_spu_thread_write_signal(sys_spu_thread_t id,
											  int number, ::std:: uint32_t value)
{
	return sys_spu_thread_write_snr(id, number, value);
}




}


/*@}*/
# 14 "C:/usr/local/cell\\target\\ppu\\include/sys\\dbg.h" 3
# 1 "C:/usr/local/cell\\target\\ppu\\include/sys/synchronization.h" 3
/*   SCE CONFIDENTIAL                                       */
/*   PlayStation(R)3 Programmer Tool Runtime Library 475.001 */
/*   Copyright (C) 2009 Sony Computer Entertainment Inc.    */
/*   All Rights Reserved.                                   */

/**
 * \ingroup all_syscall
 * \defgroup synch Synchronous Primitives
 * \brief 
 */
/*@{*/












extern "C" {


/*
 * Values for attr_protocol
 */





/*
 * Values for attr_recursive.
 */



/*
 * Values for attr_pshared
 */


/*
 * Values for attr_adaptive
 */



/*
 * Values for flags
 */





/*
 * Values for type
 */




/*
 * Values for timeout
 */


/*
 * Values for event flag wait mode and options
 */






/*
 * Invalid values for ID
 */












/**
 * \brief Mutex attribute structure
 *
 * The \a sys_mutex_attribute_t structure type is used by sys_mutex_create() 
 * to specify the mutex attributes.  
 * The meaning of each member variable is as follows.
 * 
 * - \a attr_protocol \n
 *   \a attr_protocol specifies the scheduling policy for waiting PPU threads.
 *   If multiple PPU threads are waiting on the mutex, the kernel chooses a 
 *   PPU thread which acquires a lock of the mutex next based on the scheduling
 *   policy specified by this variable.  This variable must take one of the 
 *   following values.
 *     - SYS_SYNC_FIFO \n
 *       Waiting PPU threads acquire locks of the mutex in FIFO order 
 *       (first-in first-out).
 *     - SYS_SYNC_PRIORITY \n 
 *       Waiting PPU threads acquire locks of the mutex in priority order.
 *       If there are multiple PPU threads which have the highest priority,
 *       they are ordered with FIFO.
 *     - SYS_SYNC_PRIORITY_INHERIT \n
 *       <b>(Not implemented)</b>  
 *       The mutex behaves as BPIP(Basic Priority 
 *       Inheritance Protocol). When a thread tries to acquire the lock, if the
 *       owner thread exists and has lower priority than that thread, then the 
 *       owner temporarily inherits that thread's priority and continues the 
 *       execution. Priority inheritance continues until the lock is released.
 *
 * - \a attr_recursive \n
 *   \a attr_recursive specifies whether recursive locks on the mutex are 
 *   allowed or not.  This variable must take one of the following values.
 *     - SYS_SYNC_RECURSIVE \n
 *       Recursive locks are allowed.
 *     - SYS_SYNC_NOT_RECURSIVE \n
 *       Recursive locks are not allowed.
 *
 * - \a attr_pshared \n
 *   \a attr_pshared specifies whether this mutex is shareable among processes
 *   or not.  This variable must take one of the following values.
 *     - SYS_SYNC_PROCESS_SHARED \n
 *       The mutex is process-shareable.
 *     - SYS_SYNC_NOT_PROCESS_SHARED \n
 *       The mutex is not process-shareable.
 *
 * - \a attr_adaptive \n 
 *    <b>(Not implemented)</b>
 *    The sys_adaptive_t can specify whether the thread wait-spins or 
 *    not, when the thread can not acquire a lock.  
 *    - SYS_SYNC_ADAPTIVE \n
 *      When a thread can not acquire a lock, the thread wait spinning until
 *      the lock becomes released and available for the thread.
 *    - SYS_SYNC_NOT_ADAPTIVE \n
 *      When a thread can not acquire the lock, wait on the synchronization 
 *      primitive. 
 *   \a attr_adaptive is not implemented, and currently has no effect.
 *
 * - \a key \n
 *   \a key is used only when \a attr_pshared is SYS_SYNC_PROCESS_SHARED.  
 *   Its valid range is from 1 to (2^63 - 1).  Specifying an out-of-range value
 *   causes undefined behavior of the synchronous primitive. 
 *   A process-shared mutex has a key value which is unique in the LPAR, and 
 *   sys_mutex_create() uses this value when it obtains an reference of a 
 *   mutex which has already been created in another process.
 *   
 * - \a flags \n
 *   \a flags is used only when \a attr_pshared is SYS_SYNC_PROCESS_SHARED,
 *   and its value affects the behavior of sys_mutex_create() when it creates
 *   or obtains a reference of a process-shared mutex.
 *   This variable must take one of the following values.
 *   - SYS_SYNC_NEWLY_CREATED \n
 *     sys_mutex_create() creates a new process-shared mutex with the given 
 *     key.  If there is already a process-shared mutex with the key, 
 *     sys_mutex_create() fails.
 *   - SYS_SYNC_NOT_CREATE \n
 *     sys_mutex_create() tries to obtain a reference of a process-shared 
 *     mutex which has already been created in another process.  If there is 
 *     no mutex with the given key in the LPAR, sys_mutex_create() fails.
 *     Values in \a attr_protocol, \a attr_recursive and \a attr_adaptive are 
 *     ignored, and attributes of already existing synchronous primitive is 
 *     always prioritized.
 *   - SYS_SYNC_NOT_CARE \n
 *     If there is a process-shared mutex with the given key, obtain a 
 *     reference to it.  Otherwise, create a new process-shared mutex with the 
 *     given key.
 *
 * - \a name \n
 *    \a name of the mutex can be specified in \a name, with up to 7. 
 *    characters (excluding the null-terminator).
 *
 *
 * \see sys_mutex_create, sys_mutex_attribute_initialize()
 */
typedef struct mutex_attr {
	sys_protocol_t attr_protocol;	/**< Policy for waiting threads */
	sys_recursive_t attr_recursive;	/**< Whether recursive locks are effective */
	sys_process_shared_t attr_pshared; /**< Whether the mutex is shared among 
                                          multiple processes */
	sys_adaptive_t attr_adaptive;	/**< Adaptiveness */
	sys_ipc_key_t key;				/**< process-shared key */
	int flags;						/**< flags */
	::std:: uint32_t pad;
	char name[(7 + 1)];	 /**< mutex name for debugging */
} sys_mutex_attribute_t;


/**
 * \brief Condition variable attribute structure
 *
 * The \a sys_cond_attribute_t structure type is used by sys_cond_create() to 
 * specify the condition variable attributes.  
 * The meanings of member variables are similar to those of 
 * sys_mutex_attribute_t.  
 * Refer to the specification of sys_mutex_attribute_t.
 *
 * \see sys_cond_create, sys_cond_attribute_initialize(),
 *      sys_mutex_attribute_t
 */
typedef struct cond_attr {
	sys_process_shared_t attr_pshared; /**< Whether the condition variable is
                                        * shared  among multiple processes */
	int flags;						   /**< flags */
	sys_ipc_key_t key;				   /**< process-shared key */
	char name[(7 + 1)];	   /**< cond name for debugging */
} sys_cond_attribute_t;


/**
 * \brief Reader/writer lock attribute structure
 *
 * The \a sys_rwlock_attribute_t structure type is used by 
 * sys_cond_create() to specify the reader/writer lock attributes.  
 * The meanings of member variables are similar to those of 
 * sys_mutex_attribute_t.
 * Refer to the specification of sys_mutex_attribute_t.
 *
 * \see sys_rwlock_create, sys_rwlock_attribute_initialize()
 *      sys_mutex_attribute_t
 */
typedef struct rwlock_attr {
	sys_protocol_t attr_protocol;		/**< Policy for waiting threads */
	sys_process_shared_t attr_pshared;	/**< Whether the reader/writer lock is 
                                             shared among multiple processes */
	sys_ipc_key_t key;					/**< process-shared key */
	int flags;							/**< flags */
	::std:: uint32_t pad;
	char name[(7 + 1)]; /**< rwlock name for debugging */
} sys_rwlock_attribute_t;



/**
 * \brief Semaphore attribute structure
 *
 * The \a sys_semaphore_attribute_t structure type is used by 
 * sys_semaphore_create() to specify the semaphore attributes.  
 * The meanings of member variables are similar to those of 
 * sys_mutex_attribute_t.
 * Refer to the specification of sys_mutex_attribute_t.
 *
 * \see sys_semaphore_create, sys_semaphore_attribute_initialize()
 *      sys_semaphore_attribute_t
 */
typedef struct {
	sys_protocol_t attr_protocol;
	sys_process_shared_t attr_pshared;
	sys_ipc_key_t key;
	int flags;
	::std:: uint32_t pad;
	char name[(7 + 1)]; /**< semaphore name for debugging */
} sys_semaphore_attribute_t;

typedef ::std:: int32_t sys_semaphore_value_t;



/**
 * \brief Event flag attribute structure
 *
 * The \a sys_event_flag_attribute_t structure type is used by 
 * sys_event_flag_create() to specify the event_flag attributes.  
 * The meanings of member variables are similar to those of 
 * sys_mutex_attribute_t.
 * Refer to the specification of sys_mutex_attribute_t.
 *
 * \see sys_event_flag_create, sys_event_flag_attribute_initialize()
 *      sys_event_flag_attribute_t
 */
typedef struct {
	sys_protocol_t attr_protocol;
	sys_process_shared_t attr_pshared;
	sys_ipc_key_t key;
	int flags;
	int type;
	char name[(7 + 1)]; /**< event_flag name for debugging */
} sys_event_flag_attribute_t;



typedef struct lwmutex_attr {
	sys_protocol_t attr_protocol;	/**< Policy for waiting threads */
	sys_recursive_t attr_recursive;	/**< Whether recursive locks are effective */
	char name[(7 + 1)]; /**< lwmutex name for debugging */
} sys_lwmutex_attribute_t;

typedef struct {
	volatile ::std:: uint32_t owner;
	volatile ::std:: uint32_t waiter;
} sys_lwmutex_lock_info_t;

typedef union {
	sys_lwmutex_lock_info_t info;
	volatile ::std:: uint64_t all_info;
} sys_lwmutex_variable_t;

typedef struct sys_lwmutex {
	sys_lwmutex_variable_t lock_var;
	::std:: uint32_t attribute;
	::std:: uint32_t recursive_count;
	_sys_sleep_queue_t sleep_queue;
	::std:: uint32_t pad;
} sys_lwmutex_t;


typedef struct sys_lwcond {
	sys_lwmutex_t *lwmutex;
	_sys_lwcond_queue_t lwcond_queue;
} sys_lwcond_t;

typedef struct sys_lwcond_attribute {
	char name[(7 + 1)]; /**< lwmutex name for debugging */
} sys_lwcond_attribute_t;


# 338 "C:/usr/local/cell\\target\\ppu\\include/sys/synchronization.h" 3

# 354 "C:/usr/local/cell\\target\\ppu\\include/sys/synchronization.h" 3

/**
 * The sys_mutex_attribute_initialize() macro sets default values to the specified mutex 
 * attribute structure.
 * The default values are  SYS_SYNC_PRIORITY, SYS_SYNC_NOT_RECURSIVE,
 * SYS_SYNC_NOT_PROCESS_SHARED, SYS_SYNC_NOT_ADAPTIVE.
 */
# 371 "C:/usr/local/cell\\target\\ppu\\include/sys/synchronization.h" 3

/**
 * The sys_mutex_attribute_name_set() function sets a specified name to the 
 * specified name area of an attribute structure.
 */
extern inline
	void sys_mutex_attribute_name_set(char attr_name[], const char *name);

extern inline
	void sys_mutex_attribute_name_set(char attr_name[], const char *name)
{
	do{ uint64_t *d = (uint64_t*)(attr_name); uint64_t *s = (uint64_t*)(name); *(d) = *(s); uint8_t *db = (uint8_t*)(attr_name); *(db + 7) = '\0'; }while(0);
	return;
}

extern inline int sys_mutex_create(sys_mutex_t * mutex_id,
								   sys_mutex_attribute_t * attr);

extern inline int sys_mutex_create(sys_mutex_t * mutex_id,
								   sys_mutex_attribute_t * attr)
{
	extern uint64_t __system_call_100(uint64_t, uint64_t); uint64_t p1 = __system_call_100((uint32_t) mutex_id, (uint32_t) attr);;




	return (int)(p1);
}

extern inline int sys_mutex_destroy(sys_mutex_t mutex_id);

extern inline int sys_mutex_destroy(sys_mutex_t mutex_id)
{
	extern uint64_t __system_call_101(uint64_t); uint64_t p1 = __system_call_101(mutex_id);;




	return (int)(p1);
}

extern inline int sys_mutex_lock(sys_mutex_t mutex_id, usecond_t timeout);

extern inline int sys_mutex_lock(sys_mutex_t mutex_id, usecond_t timeout)
{
	extern uint64_t __system_call_102(uint64_t, uint64_t); uint64_t p1 = __system_call_102(mutex_id, timeout);;




	return (int)(p1);
}

extern inline int sys_mutex_trylock(sys_mutex_t mutex_id);

extern inline int sys_mutex_trylock(sys_mutex_t mutex_id)
{
	extern uint64_t __system_call_103(uint64_t); uint64_t p1 = __system_call_103(mutex_id);;




	return (int)(p1);
}

extern inline int sys_mutex_unlock(sys_mutex_t mutex_id);

extern inline int sys_mutex_unlock(sys_mutex_t mutex_id)
{
	extern uint64_t __system_call_104(uint64_t); uint64_t p1 = __system_call_104(mutex_id);;




	return (int)(p1);
}





/**
 * The sys_cond_attribute_initialize() macro sets default values to the 
 * specified condition variable attribute structure.
 * The default values are SYS_SYNC_NOT_PROCESS_SHARED.
 */
# 464 "C:/usr/local/cell\\target\\ppu\\include/sys/synchronization.h" 3

/**
 * The sys_cond_attribute_name_set() function sets a specified name to the 
 * specified name area of an attribute structure.
 */
extern inline
	void sys_cond_attribute_name_set(char attr_name[], const char *name);

extern inline
	void sys_cond_attribute_name_set(char attr_name[], const char *name)
{
	do{ uint64_t *d = (uint64_t*)(attr_name); uint64_t *s = (uint64_t*)(name); *(d) = *(s); uint8_t *db = (uint8_t*)(attr_name); *(db + 7) = '\0'; }while(0);
	return;
}


extern inline int sys_cond_create(sys_cond_t * cond_id, sys_mutex_t mutex_id,
								  sys_cond_attribute_t * attr);

extern inline int sys_cond_create(sys_cond_t * cond_id, sys_mutex_t mutex_id,
								  sys_cond_attribute_t * attr)
{
	extern uint64_t __system_call_105(uint64_t, uint64_t, uint64_t); uint64_t p1 = __system_call_105((uint32_t) cond_id, mutex_id, (uint32_t) attr);;





	return (int)(p1);
}

extern inline int sys_cond_destroy(sys_cond_t cond_id);

extern inline int sys_cond_destroy(sys_cond_t cond_id)
{
	extern uint64_t __system_call_106(uint64_t); uint64_t p1 = __system_call_106(cond_id);;




	return (int)(p1);
}

extern inline int sys_cond_wait(sys_cond_t cond_id, usecond_t timeout);

extern inline int sys_cond_wait(sys_cond_t cond_id, usecond_t timeout)
{
	extern uint64_t __system_call_107(uint64_t, uint64_t); uint64_t p1 = __system_call_107(cond_id, timeout);;




	return (int)(p1);
}

extern inline int sys_cond_signal(sys_cond_t cond_id);

extern inline int sys_cond_signal(sys_cond_t cond_id)
{
	extern uint64_t __system_call_108(uint64_t); uint64_t p1 = __system_call_108(cond_id);;




	return (int)(p1);
}

extern inline int sys_cond_signal_to(sys_cond_t cond_id,
									 sys_ppu_thread_t thread);

extern inline int sys_cond_signal_to(sys_cond_t cond_id,
									 sys_ppu_thread_t thread)
{
	extern uint64_t __system_call_110(uint64_t, uint64_t); uint64_t p1 = __system_call_110(cond_id, thread);;




	return (int)(p1);
}

extern inline int sys_cond_signal_all(sys_cond_t cond_id);

extern inline int sys_cond_signal_all(sys_cond_t cond_id)
{
	extern uint64_t __system_call_109(uint64_t); uint64_t p1 = __system_call_109(cond_id);;




	return (int)(p1);
}





/**
 * sys_rwlock_attribute_initialize macro sets default values to the specified 
 * reader/writer lock attribute structure.
 * The default values are  SYS_SYNC_PRIORITY, SYS_SYNC_NOT_PROCESS_SHARED.
 */
# 574 "C:/usr/local/cell\\target\\ppu\\include/sys/synchronization.h" 3

/**
 * The sys_rwlock_attribute_name_set() function sets a specified name to the 
 * specified name area of an attribute structure.
 */
extern inline
	void sys_rwlock_attribute_name_set(char attr_name[], const char *name);

extern inline
	void sys_rwlock_attribute_name_set(char attr_name[], const char *name)
{
	do{ uint64_t *d = (uint64_t*)(attr_name); uint64_t *s = (uint64_t*)(name); *(d) = *(s); uint8_t *db = (uint8_t*)(attr_name); *(db + 7) = '\0'; }while(0);
	return;
}

extern inline int sys_rwlock_create(sys_rwlock_t * rw_lock_id,
									sys_rwlock_attribute_t * attr);

extern inline int sys_rwlock_create(sys_rwlock_t * rw_lock_id,
									sys_rwlock_attribute_t * attr)
{
	extern uint64_t __system_call_120(uint64_t, uint64_t); uint64_t p1 = __system_call_120((uint32_t) rw_lock_id, (uint32_t) attr);;




	return (int)(p1);
}

extern inline int sys_rwlock_destroy(sys_rwlock_t rw_lock_id);

extern inline int sys_rwlock_destroy(sys_rwlock_t rw_lock_id)
{
	extern uint64_t __system_call_121(uint64_t); uint64_t p1 = __system_call_121(rw_lock_id);;




	return (int)(p1);
}

extern inline int sys_rwlock_rlock(sys_rwlock_t rw_lock_id, usecond_t timeout);

extern inline int sys_rwlock_rlock(sys_rwlock_t rw_lock_id, usecond_t timeout)
{
	extern uint64_t __system_call_122(uint64_t, uint64_t); uint64_t p1 = __system_call_122(rw_lock_id, timeout);;




	return (int)(p1);
}

extern inline int sys_rwlock_tryrlock(sys_rwlock_t rw_lock_id);

extern inline int sys_rwlock_tryrlock(sys_rwlock_t rw_lock_id)
{
	extern uint64_t __system_call_123(uint64_t); uint64_t p1 = __system_call_123(rw_lock_id);;




	return (int)(p1);
}

extern inline int sys_rwlock_runlock(sys_rwlock_t rw_lock_id);

extern inline int sys_rwlock_runlock(sys_rwlock_t rw_lock_id)
{
	extern uint64_t __system_call_124(uint64_t); uint64_t p1 = __system_call_124(rw_lock_id);;




	return (int)(p1);
}

extern inline int sys_rwlock_wlock(sys_rwlock_t rw_lock_id, usecond_t timeout);

extern inline int sys_rwlock_wlock(sys_rwlock_t rw_lock_id, usecond_t timeout)
{
	extern uint64_t __system_call_125(uint64_t, uint64_t); uint64_t p1 = __system_call_125(rw_lock_id, timeout);;




	return (int)(p1);
}

extern inline int sys_rwlock_trywlock(sys_rwlock_t rw_lock_id);

extern inline int sys_rwlock_trywlock(sys_rwlock_t rw_lock_id)
{
	extern uint64_t __system_call_148(uint64_t); uint64_t p1 = __system_call_148(rw_lock_id);;




	return (int)(p1);
}

extern inline int sys_rwlock_wunlock(sys_rwlock_t rw_lock_id);

extern inline int sys_rwlock_wunlock(sys_rwlock_t rw_lock_id)
{
	extern uint64_t __system_call_127(uint64_t); uint64_t p1 = __system_call_127(rw_lock_id);;




	return (int)(p1);
}





/**
 * sys_semaphore_attribute_initialize macro sets default values to 
 * the specified semaphore attribute structure.
 * The default values are  SYS_SYNC_PRIORITY, SYS_SYNC_NOT_PROCESS_SHARED.
 */
# 704 "C:/usr/local/cell\\target\\ppu\\include/sys/synchronization.h" 3

/**
 * The sys_semaphore_attribute_name_set() function sets a specified name to the 
 * specified name area of an attribute structure.
 */
extern inline
	void sys_semaphore_attribute_name_set(char attr_name[], const char *name);

extern inline
	void sys_semaphore_attribute_name_set(char attr_name[], const char *name)
{
	do{ uint64_t *d = (uint64_t*)(attr_name); uint64_t *s = (uint64_t*)(name); *(d) = *(s); uint8_t *db = (uint8_t*)(attr_name); *(db + 7) = '\0'; }while(0);
	return;
}

extern inline int sys_semaphore_create(sys_semaphore_t * sem,
									   sys_semaphore_attribute_t * attr,
									   sys_semaphore_value_t initial_val,
									   sys_semaphore_value_t max_val);

extern inline int sys_semaphore_create(sys_semaphore_t * sem,
									   sys_semaphore_attribute_t * attr,
									   sys_semaphore_value_t initial_val,
									   sys_semaphore_value_t max_val)
{
	extern uint64_t __system_call_90(uint64_t, uint64_t, uint64_t, uint64_t); uint64_t p1 = __system_call_90((uint32_t) sem, (uint32_t) attr, initial_val, max_val);;





	return (int)(p1);
}

extern inline int sys_semaphore_destroy(sys_semaphore_t sem);

extern inline int sys_semaphore_destroy(sys_semaphore_t sem)
{
	extern uint64_t __system_call_91(uint64_t); uint64_t p1 = __system_call_91(sem);;




	return (int)(p1);
}

extern inline int sys_semaphore_wait(sys_semaphore_t sem, usecond_t timeout);

extern inline int sys_semaphore_wait(sys_semaphore_t sem, usecond_t timeout)
{
	extern uint64_t __system_call_92(uint64_t, uint64_t); uint64_t p1 = __system_call_92(sem, timeout);;




	return (int)(p1);
}

extern inline int sys_semaphore_trywait(sys_semaphore_t sem);

extern inline int sys_semaphore_trywait(sys_semaphore_t sem)
{
	extern uint64_t __system_call_93(uint64_t); uint64_t p1 = __system_call_93(sem);;




	return (int)(p1);
}

extern inline int sys_semaphore_post(sys_semaphore_t sem,
									 sys_semaphore_value_t val);

extern inline int sys_semaphore_post(sys_semaphore_t sem,
									 sys_semaphore_value_t val)
{
	extern uint64_t __system_call_94(uint64_t, uint64_t); uint64_t p1 = __system_call_94(sem, val);;




	return (int)(p1);
}

extern inline int sys_semaphore_get_value(sys_semaphore_t sem,
										  sys_semaphore_value_t * val);

extern inline int sys_semaphore_get_value(sys_semaphore_t sem,
										  sys_semaphore_value_t * val)
{
	extern uint64_t __system_call_114(uint64_t, uint64_t); uint64_t p1 = __system_call_114(sem, (uint32_t) val);;




	return (int)(p1);
}





/**
 * sys_event_flag_attribute_initialize macro sets default values to 
 * the specified event_flag attribute structure.
 * The default values are  SYS_SYNC_PRIORITY, SYS_SYNC_NOT_PROCESS_SHARED.
 */
# 820 "C:/usr/local/cell\\target\\ppu\\include/sys/synchronization.h" 3

/**
 * The sys_event_flag_attribute_name_set() function sets a specified name to the 
 * specified name area of an attribute structure.
 */
extern inline
	void sys_event_flag_attribute_name_set(char attr_name[], const char *name);

extern inline
	void sys_event_flag_attribute_name_set(char attr_name[], const char *name)
{
	do{ uint64_t *d = (uint64_t*)(attr_name); uint64_t *s = (uint64_t*)(name); *(d) = *(s); uint8_t *db = (uint8_t*)(attr_name); *(db + 7) = '\0'; }while(0);
	return;
}

extern inline int sys_event_flag_create(sys_event_flag_t * id,
										sys_event_flag_attribute_t * attr,
										uint64_t init);

extern inline int sys_event_flag_create(sys_event_flag_t * id,
										sys_event_flag_attribute_t * attr,
										uint64_t init)
{
	extern uint64_t __system_call_82(uint64_t, uint64_t, uint64_t); uint64_t p1 = __system_call_82((uint32_t) id, (uint32_t) attr, init);;




	return (int)(p1);
}

extern inline int sys_event_flag_destroy(sys_event_flag_t id);

extern inline int sys_event_flag_destroy(sys_event_flag_t id)
{
	extern uint64_t __system_call_83(uint64_t); uint64_t p1 = __system_call_83(id);;




	return (int)(p1);
}

extern inline int sys_event_flag_wait(sys_event_flag_t id, uint64_t bitptn,
									  uint32_t mode, uint64_t * result,
									  usecond_t timeout);

extern inline int sys_event_flag_wait(sys_event_flag_t id, uint64_t bitptn,
									  uint32_t mode, uint64_t * result,
									  usecond_t timeout)
{
	extern uint64_t __system_call_85(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t); uint64_t p1 = __system_call_85(id, bitptn, mode, (uint32_t) result, timeout);;





	return (int)(p1);
}

extern inline int sys_event_flag_trywait(sys_event_flag_t id, uint64_t bitptn,
										 uint32_t mode, uint64_t * result);

extern inline int sys_event_flag_trywait(sys_event_flag_t id, uint64_t bitptn,
										 uint32_t mode, uint64_t * result)
{
	extern uint64_t __system_call_86(uint64_t, uint64_t, uint64_t, uint64_t); uint64_t p1 = __system_call_86(id, bitptn, mode, (uint32_t) result);;




	return (int)(p1);
}

extern inline int sys_event_flag_set(sys_event_flag_t id, uint64_t bitptn);

extern inline int sys_event_flag_set(sys_event_flag_t id, uint64_t bitptn)
{
	extern uint64_t __system_call_87(uint64_t, uint64_t); uint64_t p1 = __system_call_87(id, bitptn);;




	return (int)(p1);
}

extern inline int sys_event_flag_clear(sys_event_flag_t id, uint64_t bitptn);

extern inline int sys_event_flag_clear(sys_event_flag_t id, uint64_t bitptn)
{
	extern uint64_t __system_call_118(uint64_t, uint64_t); uint64_t p1 = __system_call_118(id, bitptn);;




	return (int)(p1);
}

extern inline int sys_event_flag_cancel(sys_event_flag_t id, int *num);

extern inline int sys_event_flag_cancel(sys_event_flag_t id, int *num)
{
	extern uint64_t __system_call_132(uint64_t, uint64_t); uint64_t p1 = __system_call_132(id, (uint32_t) num);;




	return (int)(p1);
}

extern inline int sys_event_flag_get(sys_event_flag_t id, uint64_t * bitptn);

extern inline int sys_event_flag_get(sys_event_flag_t id, uint64_t * bitptn)
{
	extern uint64_t __system_call_139(uint64_t, uint64_t); uint64_t p1 = __system_call_139(id, (uint32_t) bitptn);;




	return (int)(p1);
}





/**
 * sys_lwmutex_attribute_initialize macro sets default values to the specified 
 * lwmutex attribute structure.
 * The default values are  SYS_SYNC_PRIORITY, SYS_SYNC_NOT_RECURSIVE.
 */
# 957 "C:/usr/local/cell\\target\\ppu\\include/sys/synchronization.h" 3

/**
 * The sys_lwmutex_attribute_name_set() function sets a specified name to the 
 * specified name area of an attribute structure.
 */
extern inline
	void sys_lwmutex_attribute_name_set(char attr_name[], const char *name);

extern inline
	void sys_lwmutex_attribute_name_set(char attr_name[], const char *name)
{
	do{ uint64_t *d = (uint64_t*)(attr_name); uint64_t *s = (uint64_t*)(name); *(d) = *(s); uint8_t *db = (uint8_t*)(attr_name); *(db + 7) = '\0'; }while(0);
	return;
}

extern int sys_lwmutex_create(sys_lwmutex_t * mutex_id,
							  sys_lwmutex_attribute_t * attr);
extern int sys_lwmutex_destroy(sys_lwmutex_t * lwmutex_id);
extern int sys_lwmutex_lock(sys_lwmutex_t * lwmutex_id, usecond_t timeout);
extern int sys_lwmutex_trylock(sys_lwmutex_t * lwmutex_id);
extern int sys_lwmutex_unlock(sys_lwmutex_t * lwmutex_id);









/**
 * The sys_lwcond_attribute_name_set() function sets a specified name to the 
 * specified name area of an attribute structure.
 */
extern inline
	void sys_lwcond_attribute_name_set(char attr_name[], const char *name);

extern inline
	void sys_lwcond_attribute_name_set(char attr_name[], const char *name)
{
	do{ uint64_t *d = (uint64_t*)(attr_name); uint64_t *s = (uint64_t*)(name); *(d) = *(s); uint8_t *db = (uint8_t*)(attr_name); *(db + 7) = '\0'; }while(0);
	return;
}

extern int sys_lwcond_create(sys_lwcond_t * lwcond, sys_lwmutex_t * lwmutex,
							 sys_lwcond_attribute_t * attr);
extern int sys_lwcond_destroy(sys_lwcond_t * lwcond);
extern int sys_lwcond_wait(sys_lwcond_t * lwcond, usecond_t timeout);
extern int sys_lwcond_signal(sys_lwcond_t * lwcond);
extern int sys_lwcond_signal_all(sys_lwcond_t * lwcond);
extern int sys_lwcond_signal_to(sys_lwcond_t * lwcond, sys_ppu_thread_t thr);






}


/*@}*/
# 15 "C:/usr/local/cell\\target\\ppu\\include/sys\\dbg.h" 3
# 1 "C:/usr/local/cell\\target\\ppu\\include/sys/event.h" 3
/*   SCE CONFIDENTIAL                                       */
/*   PlayStation(R)3 Programmer Tool Runtime Library 475.001 */
/*   Copyright (C) 2008 Sony Computer Entertainment Inc.    */
/*   All Rights Reserved.                                   */

/**
 * \ingroup all_syscall
 * \defgroup event Event
 * \brief system calls defined in sys/event.h
 *
 * Interfaces defined in sys/event.h
 *
 * Refer to <i>Cell OS Lv-2 User's Manual</i> for the detailed description.

 *
 */
/*@{*/















extern "C" {















/**
 * \brief Event queue attribute
 *
 * The sys_event_queue_attr structure type specifies the event queue attributes
 * This structure type can be initialized by the sys_event_queue_init() macro 
 * function.
 *
 * \see sys_event_queue_create, sys_event_queue_init()
 */
typedef struct sys_event_queue_attr {
	sys_protocol_t attr_protocol;	 /**< Policy for waiting threads */
	int type;					 /**< Event Queue type */
	char name[(7 + 1)];	 /**< event_queue name for debugging */
} sys_event_queue_attribute_t;

/**
 * \brief Event type
 *
 * Each event records the key value of the source port that sends the event, 
 * and three additional data.
 *
 * \see sys_event_queue_receive, sys_event_queue_tryreceive
 */
typedef struct sys_event {
	::std:: uint64_t source;	/**< Source port name */
	::std:: uint64_t data1;	/**< First data */
	::std:: uint64_t data2;	/**< Second data */
	::std:: uint64_t data3;	/**< Third data */
} sys_event_t;



/**
 * The sys_event_queue_attribute_initialize() macro sets default values to the 
 * specified event queue attributes.
 * The default values are SYS_SYNC_PRIORITY and SYS_PPU_QUEUE.
 */
# 92 "C:/usr/local/cell\\target\\ppu\\include/sys/event.h" 3

/**
 * The sys_event_queue_attribute_name_set() function sets a specified name 
 * to the specified name area of an attribute structure.
 */
extern inline
	void sys_event_queue_attribute_name_set(char attr_name[], const char *name);

extern inline
	void sys_event_queue_attribute_name_set(char attr_name[], const char *name)
{
	do{ uint64_t *d = (uint64_t*)(attr_name); uint64_t *s = (uint64_t*)(name); *(d) = *(s); uint8_t *db = (uint8_t*)(attr_name); *(db + 7) = '\0'; }while(0);
	return;
}

extern inline int sys_event_queue_create(sys_event_queue_t * equeue_id,
										 sys_event_queue_attribute_t * attr,
										 sys_ipc_key_t event_queue_key,
										 int size);

extern inline int sys_event_queue_create(sys_event_queue_t * equeue_id,
										 sys_event_queue_attribute_t * attr,
										 sys_ipc_key_t event_queue_key,
										 int size)
{
	extern uint64_t __system_call_128(uint64_t, uint64_t, uint64_t, uint64_t); uint64_t p1 = __system_call_128((uint32_t) equeue_id, (uint32_t) attr, event_queue_key, size);;





	return (int)(p1);
}


extern inline int sys_event_queue_destroy(sys_event_queue_t equeue_id,
										  int mode);

extern inline int sys_event_queue_destroy(sys_event_queue_t equeue_id, int mode)
{
	extern uint64_t __system_call_129(uint64_t, uint64_t); uint64_t p1 = __system_call_129(equeue_id, mode);;




	return (int)(p1);
}


extern inline int sys_event_queue_receive(sys_event_queue_t equeue_id,
										  sys_event_t * event,
										  usecond_t timeout);

extern inline int sys_event_queue_receive(sys_event_queue_t equeue_id,
										  sys_event_t * event,
										  usecond_t timeout)
{
	extern uint64_t __system_call_130(uint64_t, uint64_t, uint64_t); uint64_t p1 = __system_call_130(equeue_id, (uint32_t) event, timeout);;



	event->source = (uint64_t)( __reg( 4 ) ); event->data1 = (uint64_t)( __reg( 5 ) ); event->data2 = (uint64_t)( __reg( 6 ) ); event->data3 = (uint64_t)( __reg( 7 ) );

	return (int)(p1);
}


extern inline int sys_event_queue_tryreceive(sys_event_queue_t equeue_id,
											 sys_event_t * event_array,
											 int size, int *number);

extern inline int sys_event_queue_tryreceive(sys_event_queue_t equeue_id,
											 sys_event_t * event_array,
											 int size, int *number)
{
	extern uint64_t __system_call_131(uint64_t, uint64_t, uint64_t, uint64_t); uint64_t p1 = __system_call_131(equeue_id, (uint32_t) event_array, size, (uint32_t) number);;





	return (int)(p1);
}



extern inline int sys_event_queue_drain(sys_event_queue_t equeue_id);

extern inline int sys_event_queue_drain(sys_event_queue_t equeue_id)
{
	extern uint64_t __system_call_133(uint64_t); uint64_t p1 = __system_call_133(equeue_id);;




	return (int)(p1);
}


extern inline int sys_event_port_create(sys_event_port_t * eport_id,
										int port_type, uint64_t name);

extern inline int sys_event_port_create(sys_event_port_t * eport_id,
										int port_type, uint64_t name)
{
	extern uint64_t __system_call_134(uint64_t, uint64_t, uint64_t); uint64_t p1 = __system_call_134((uint32_t) eport_id, port_type, name);;




	return (int)(p1);
}


extern inline int sys_event_port_destroy(sys_event_port_t eport_id);

extern inline int sys_event_port_destroy(sys_event_port_t eport_id)
{
	extern uint64_t __system_call_135(uint64_t); uint64_t p1 = __system_call_135(eport_id);;




	return (int)(p1);
}


extern inline int sys_event_port_send(sys_event_port_t eport_id,
									  ::std:: uint64_t data1,
									  ::std:: uint64_t data2,
									  ::std:: uint64_t data3);

extern inline int sys_event_port_send(sys_event_port_t eport_id,
									  ::std:: uint64_t data1,
									  ::std:: uint64_t data2,
									  ::std:: uint64_t data3)
{
	extern uint64_t __system_call_138(uint64_t, uint64_t, uint64_t, uint64_t); uint64_t p1 = __system_call_138(eport_id, data1, data2, data3);;




	return (int)(p1);
}



extern inline int sys_event_port_connect_local(sys_event_port_t event_port_id,
											   sys_event_queue_t
											   event_queue_id);

extern inline int sys_event_port_connect_local(sys_event_port_t event_port_id,
											   sys_event_queue_t event_queue_id)
{
	extern uint64_t __system_call_136(uint64_t, uint64_t); uint64_t p1 = __system_call_136(event_port_id, event_queue_id);;




	return (int)(p1);
}



extern inline int sys_event_port_disconnect(sys_event_port_t event_port_id);

extern inline int sys_event_port_disconnect(sys_event_port_t event_port_id)
{
	extern uint64_t __system_call_137(uint64_t); uint64_t p1 = __system_call_137(event_port_id);;




	return (int)(p1);
}



}


/*@}*/
# 16 "C:/usr/local/cell\\target\\ppu\\include/sys\\dbg.h" 3







/* PPU core*/





/* SPU core */







/*
 * CELL_ERROR_FACILITY_SYSTEM_SERVICE	0x001
 * 	liblv2dbg	: 0x8001_0401- 0x8001_04ff
 *
 */
/* #define CELL_ERROR_FACILITY_SYSTEM_SERVICE	0x001	*/

/* ERR: CELL_LV2DBG_MAKE_ERROR(0x0401) */


/* ERR: CELL_LV2DBG_MAKE_ERROR(0x0402) */


/* ERR: CELL_LV2DBG_MAKE_ERROR(0x0403) */


/* ERR: CELL_LV2DBG_MAKE_ERROR(0x0404) */


/* ERR: CELL_LV2DBG_MAKE_ERROR(0x0405) */


/* ERR: CELL_LV2DBG_MAKE_ERROR(0x0406) */


/* ERR: CELL_LV2DBG_MAKE_ERROR(0x0407) */


/* ERR: CELL_LV2DBG_MAKE_ERROR(0x0408) */


/* ERR: CELL_LV2DBG_MAKE_ERROR(0x0409) */


/* ERR: CELL_LV2DBG_MAKE_ERROR(0x040a) */


/* ERR: CELL_LV2DBG_MAKE_ERROR(0x040b) */


/* ERR: CELL_LV2DBG_MAKE_ERROR(0x040c) */


/* ERR: CELL_LV2DBG_MAKE_ERROR(0x040d) */


/* ERR: CELL_LV2DBG_MAKE_ERROR(0x040e) */


/* ERR: CELL_LV2DBG_MAKE_ERROR(0x040f) */


/* ERR: CELL_LV2DBG_MAKE_ERROR(0x0410) */


/* ERR: CELL_LV2DBG_MAKE_ERROR(0x0411) */


/* ERR: CELL_LV2DBG_MAKE_ERROR(0x0412) */


/* ERR: CELL_LV2DBG_MAKE_ERROR(0x0413) */


/* ERR: CELL_LV2DBG_MAKE_ERROR(0x0414) */


/* ERR: CELL_LV2DBG_MAKE_ERROR(0x0415) */


/* ERR: CELL_LV2DBG_MAKE_ERROR(0x0416) */


/* ERR: CELL_LV2DBG_MAKE_ERROR(0x0417) */


/* ERR: CELL_LV2DBG_MAKE_ERROR(0x0418) */


/* ERR: CELL_LV2DBG_MAKE_ERROR(0x0419) */


/* ERR: CELL_LV2DBG_MAKE_ERROR(0x041a) */


/* ERR: CELL_LV2DBG_MAKE_ERROR(0x041b) */


/* ERR: CELL_LV2DBG_MAKE_ERROR(0x041c) */


/* ERR: CELL_LV2DBG_MAKE_ERROR(0x041d) */


/* ERR: CELL_LV2DBG_MAKE_ERROR(0x041e) */


/* ERR: CELL_LV2DBG_MAKE_ERROR(0x041f) */


/* ERR: CELL_LV2DBG_MAKE_ERROR(0x0420) */


/* ERR: CELL_LV2DBG_MAKE_ERROR(0x0421) */


/* ERR: CELL_LV2DBG_MAKE_ERROR(0x0422) */


/* ERR: CELL_LV2DBG_MAKE_ERROR(0x0423) */


/* ERR: CELL_LV2DBG_MAKE_ERROR(0x0424) */


/* ERR: CELL_LV2DBG_MAKE_ERROR(0x0425) */


/* ERR: CELL_LV2DBG_MAKE_ERROR(0x0426) */


/* ERR: CELL_LV2DBG_MAKE_ERROR(0x0427) */


/* ERR: CELL_LV2DBG_MAKE_ERROR(0x0428) */


/* ERR: CELL_LV2DBG_MAKE_ERROR(0x0429) */


/* ERR: CELL_LV2DBG_MAKE_ERROR(0x042a) */


/* ERR: CELL_LV2DBG_MAKE_ERROR(0x042b) */


/* ERR: CELL_LV2DBG_MAKE_ERROR(0x042c) */


/* ERR: CELL_LV2DBG_MAKE_ERROR(0x042d) */


/* ERR: CELL_LV2DBG_MAKE_ERROR(0x042e) */


/* ERR: CELL_LV2DBG_MAKE_ERROR(0x042f) */



/* Control Flags */







/*
 * Event type
 *
 */ 
/* PPU Excpetion Type */
# 210 "C:/usr/local/cell\\target\\ppu\\include/sys\\dbg.h" 3

/* Others */



/* Type for Vector registers of PPU */
typedef union {
  uint8_t	byte[16];
  uint16_t	halfword[16/sizeof(uint16_t)];
  uint32_t	word[16/sizeof(uint32_t)];
  uint64_t	dw[16/sizeof(uint64_t)];
} sys_dbg_vr_t;

/* Data structure for PPU thread context */
typedef struct {
  uint64_t	gpr[32];	/* General Purpose Register GPR[0-31] */
  uint32_t	cr;			/* Condition Register */
  uint64_t	xer;			/* Fixed Point Exception Register  */
  uint64_t	lr;			/* Link Register */
  uint64_t	ctr;			/* Control Register */
  uint64_t	pc;			/* Program Counter */
  uint64_t	fpr[32];	/* Floating Point Register FPR[0-31] */
  uint32_t	fpscr;			/* Floating Point Status and Control Register */
  sys_dbg_vr_t	vr[32];		/* Vector Register VR[0-31]*/
  sys_dbg_vr_t	vscr;			/* Vector Status and Control Register */
} sys_dbg_ppu_thread_context_t;


/* Type for SPU GPR registers */
typedef union {
  uint8_t	byte[16];
  uint16_t	halfword[16/sizeof(uint16_t)];
  uint32_t	word[16/sizeof(uint32_t)];
  uint64_t	dw[16/sizeof(uint64_t)];
} sys_dbg_spu_gpr_t;

/* Type for SPU FPSCR register */
typedef union {
  uint8_t	byte[16];
  uint16_t	halfword[16/sizeof(uint16_t)];
  uint32_t	word[16/sizeof(uint32_t)];
  uint64_t	dw[16/sizeof(uint64_t)];
} sys_dbg_spu_fpscr_t;

/* Data structure for SPU thread context (obsolete) */
typedef struct {
  sys_dbg_spu_gpr_t	gpr[128];		/* GPR[0-127]*/
  uint32_t		npc;				/* Next Program Counter */
  uint32_t		fpscr;				/* FPSCR */
  uint32_t		srr0;				/* SRR0 */
  uint32_t		spu_status;			/* SPU STATUS */
  uint64_t		spu_cfg;			/* SPU CFG */
  uint32_t		mb_stat;			/* MB_stat */
  uint32_t		ppu_mb;				/* PPU Mail Box */
  uint32_t		spu_mb[4];		/* SPU Mail Box */
  uint32_t		decrementer;			/* Decrementer */
  uint64_t		mfc_cq_sr[96];	/* MFC Command Queue Save/Restore Register */
} sys_dbg_spu_thread_context_t;

/* Data structure for SPU thread context */
typedef struct {
  sys_dbg_spu_gpr_t	gpr[128];		/* GPR[0-127]*/
  uint32_t		npc;				/* Next Program Counter */
  sys_dbg_spu_fpscr_t	fpscr;				/* FPSCR */
  uint32_t		srr0;				/* SRR0 */
  uint32_t		spu_status;			/* SPU STATUS */
  uint64_t		spu_cfg;			/* SPU CFG */
  uint32_t		mb_stat;			/* MB_stat */
  uint32_t		ppu_mb;				/* PPU Mail Box */
  uint32_t		spu_mb[4];		/* SPU Mail Box */
  uint32_t		decrementer;			/* Decrementer */
  uint64_t		mfc_cq_sr[96];	/* MFC Command Queue Save/Restore Register */
} sys_dbg_spu_thread_context2_t;

/* Mutex information */
typedef struct {
  sys_mutex_attribute_t	attr;
  sys_ppu_thread_t	owner;
  int			lock_counter;
  int			cond_ref_counter;
  sys_cond_t		cond_id;		// Always Zero (0) in this field
  sys_ppu_thread_t*	wait_id_list;
  uint32_t		wait_threads_num;
  uint32_t		wait_all_threads_num;
} sys_dbg_mutex_information_t;

/* Condition Variable information */
typedef struct {
  sys_cond_attribute_t	attr;
  sys_mutex_t		mutex_id;
  sys_ppu_thread_t*	wait_id_list;
  uint32_t		wait_threads_num;
  uint32_t		wait_all_threads_num;
} sys_dbg_cond_information_t;

/* RWLock information */
typedef struct {
  sys_rwlock_attribute_t	attr;
  sys_ppu_thread_t		owner;
  sys_ppu_thread_t*		r_wait_id_list;
  uint32_t			r_wait_threads_num;
  uint32_t			r_wait_all_threads_num;
  sys_ppu_thread_t*		w_wait_id_list;
  uint32_t			w_wait_threads_num;
  uint32_t			w_wait_all_threads_num;
} sys_dbg_rwlock_information_t;

/* Event Queue information */
typedef struct {
  sys_event_queue_attribute_t	attr;
  sys_ipc_key_t			event_queue_key;
  int				queue_size;
  sys_ppu_thread_t*		wait_id_list;
  uint32_t			wait_threads_num;
  uint32_t			wait_all_threads_num;
  sys_event_t*			equeue_list;
  uint32_t			readable_equeue_num;
  uint32_t			readable_all_equeue_num;
} sys_dbg_event_queue_information_t;

/* Semaphore information */
typedef struct {
  sys_semaphore_attribute_t	attr;
  sys_semaphore_value_t		max_val;
  sys_semaphore_value_t		cur_val;
  sys_ppu_thread_t*		wait_id_list;
  uint32_t			wait_threads_num;
  uint32_t			wait_all_threads_num;
} sys_dbg_semaphore_information_t;

/* LWMutex information */
typedef struct {
  sys_lwmutex_attribute_t	attr;
  sys_ppu_thread_t		owner;
  int				lock_counter;
  sys_ppu_thread_t*		wait_id_list;
  uint32_t			wait_threads_num;
  uint32_t			wait_all_threads_num;
} sys_dbg_lwmutex_information_t;

/* Lightweight Condition Variable information */
typedef struct {
  sys_lwcond_attribute_t	attr;
  sys_lwmutex_t*		lwmutex;
  sys_ppu_thread_t*		wait_id_list;
  uint32_t			wait_threads_num;
  uint32_t			wait_all_threads_num;
} sys_dbg_lwcond_information_t;

/* Event Flag information */
typedef struct {
  uint64_t	bitptn;
  uint32_t	mode;
} sys_dbg_event_flag_wait_information_t;

typedef struct {
  sys_event_flag_attribute_t			attr;
  uint64_t					cur_bitptn;
  sys_ppu_thread_t*				wait_id_list;
  sys_dbg_event_flag_wait_information_t*	wait_info_list;
  uint32_t					wait_threads_num;
  uint32_t					wait_all_threads_num;
} sys_dbg_event_flag_information_t;


/* Read ppu thread registers from the target PPU thread */
extern "C" int sys_dbg_read_ppu_thread_context(sys_ppu_thread_t id,
                                          sys_dbg_ppu_thread_context_t* ppu_context);

/* Read spu thread registers from the target SPU thread (obsolete) */
extern "C" int sys_dbg_read_spu_thread_context(sys_spu_thread_t id,
                                          sys_dbg_spu_thread_context_t* spu_context);

/* Read spu thread registers from the target SPU thread */
extern "C" int sys_dbg_read_spu_thread_context2(sys_spu_thread_t id,
                                           sys_dbg_spu_thread_context2_t* spu_context);

/* Type of PPU Exception Handler */
typedef void (*dbg_exception_handler_t)(uint64_t, sys_ppu_thread_t, uint64_t);	/* exception type, id, dar */

/* Set stacksize for PPU exception handling thread (NOT thread safe) */
extern "C" int sys_dbg_set_stacksize_ppu_exception_handler(size_t stacksize);


/* Initialize PPU exception handler (NOT thread safe) */
extern "C" int sys_dbg_initialize_ppu_exception_handler(int prio);
          
          
/* Finalize PPU exception handler (NOT thread safe) */
extern "C" int sys_dbg_finalize_ppu_exception_handler(void);
          

/* Register PPU exception handler */
extern "C" int sys_dbg_register_ppu_exception_handler(dbg_exception_handler_t callback,
                                                 uint64_t ctrl_flags);

/* Unregister PPU exception handler */
extern "C" int sys_dbg_unregister_ppu_exception_handler(void);


/* Wakeup the PPU exception handler */
extern "C" int sys_dbg_signal_to_ppu_exception_handler(uint64_t flags);


/*
 * Get information for some synchronization primitives 
 *
 */


typedef _sys_sleep_queue_t sys_lwmutex_pseudo_id_t;
typedef _sys_lwcond_queue_t sys_lwcond_pseudo_id_t;


/* Get mutex information */
extern "C" int sys_dbg_get_mutex_information(sys_mutex_t id,
                                        sys_dbg_mutex_information_t* info);



/* Get condition variable information */
extern "C" int sys_dbg_get_cond_information(sys_cond_t id,
                                       sys_dbg_cond_information_t* info);



/* Get RWLock information */
extern "C" int sys_dbg_get_rwlock_information(sys_rwlock_t id,
                                         sys_dbg_rwlock_information_t* info);



/* Get event queue information */
extern "C" int sys_dbg_get_event_queue_information(sys_event_queue_t id,
                                              sys_dbg_event_queue_information_t* info);



/* Get semaphore information */
extern "C" int sys_dbg_get_semaphore_information(sys_semaphore_t id,
                                            sys_dbg_semaphore_information_t* info);


/* Get lwmutex information */
extern "C" int sys_dbg_get_lwmutex_information(sys_lwmutex_pseudo_id_t id,
                                          sys_dbg_lwmutex_information_t* info);

/* Get lwcond information */
extern "C" int sys_dbg_get_lwcond_information(sys_lwcond_pseudo_id_t id,
                                         sys_dbg_lwcond_information_t* info);

/* Get event flag information */
extern "C" int sys_dbg_get_event_flag_information(sys_event_flag_t id,
                                             sys_dbg_event_flag_information_t* info);

/* Get PPU thread ID list */
extern "C" int sys_dbg_get_ppu_thread_ids(sys_ppu_thread_t* ids,
                                     uint64_t* ids_num,
                                     uint64_t* all_ids_num);


/* Get SPU thread group ID list */
extern "C" int sys_dbg_get_spu_thread_group_ids(sys_spu_thread_group_t* ids,
                                           uint64_t* ids_num,
                                           uint64_t* all_ids_num);


/* Get SPU thread ID list */
extern "C" int sys_dbg_get_spu_thread_ids(sys_spu_thread_group_t spu_thread_group_id,
                                     sys_spu_thread_t* ids,
                                     uint64_t* ids_num,
                                     uint64_t* all_ids_num);

/* Get PPU thread name */
extern "C" int sys_dbg_get_ppu_thread_name(sys_ppu_thread_t id, char* name);

/* Get SPU thread name */
extern "C" int sys_dbg_get_spu_thread_name(sys_spu_thread_t id, char* name);

/* Get SPU thread group name */
extern "C" int sys_dbg_get_spu_thread_group_name(sys_spu_thread_group_t id, char* name);


/**
 * The status of PPU thread
 */
typedef enum {
  PPU_THREAD_STATUS_IDLE,		/* IDLE */
  PPU_THREAD_STATUS_RUNNABLE,		/* RUNNABLE */
  PPU_THREAD_STATUS_ONPROC,		/* ONPROC*/
  PPU_THREAD_STATUS_SLEEP,		/* SLEEP */
  PPU_THREAD_STATUS_STOP,		/* STOP */
  PPU_THREAD_STATUS_ZOMBIE,		/* ZOMBIE */
  PPU_THREAD_STATUS_DELETED,		/* DELETED */
  PPU_THREAD_STATUS_UNKNOWN		/* unknown */
} sys_dbg_ppu_thread_status_t;


/**
 * The status of SPU thread group
 */
typedef enum {
  SPU_THREAD_GROUP_STATUS_NOT_INITIALIZED,		/* NOT INITIALIZED */
  SPU_THREAD_GROUP_STATUS_INITIALIZED,			/* INITIALIZED */
  SPU_THREAD_GROUP_STATUS_READY,			/* READY */
  SPU_THREAD_GROUP_STATUS_WAITING,			/* WAITING */
  SPU_THREAD_GROUP_STATUS_SUSPENDED,			/* SUSPENDED */
  SPU_THREAD_GROUP_STATUS_WAITING_AND_SUSPENDED,	/* WAINTNG AND SUSPENDED */
  SPU_THREAD_GROUP_STATUS_RUNNING,			/* RUNNING */
  SPU_THREAD_GROUP_STATUS_STOPPED,			/* STOPPED */
  SPU_THREAD_GROUP_STATUS_UNKNOWN			/* unknown */
} sys_dbg_spu_thread_group_status_t;



/* Get a status of the target PPU thread */
extern "C" int sys_dbg_get_ppu_thread_status(sys_ppu_thread_t id,
                                        sys_dbg_ppu_thread_status_t* status);

/* Get a status of the target SPU thread group  */
extern "C" int sys_dbg_get_spu_thread_group_status(sys_spu_thread_group_t id,
                                              sys_dbg_spu_thread_group_status_t* status);



/* Enable precise mode (MSR[FE0]==1 and MSR[FE1]==1) to the target PPU thread in order to handle floating point enabled exception */
extern "C" int sys_dbg_enable_floating_point_enabled_exception(sys_ppu_thread_t id, uint64_t flags, uint64_t opt1, uint64_t opt2);

/* Disable precise mode to the target PPU thread in order to set to default mode: Ignore Exception (MSR[FE0]==0 and MSR[FE1]==0) */
extern "C" int sys_dbg_disable_floating_point_enabled_exception(sys_ppu_thread_t id, uint64_t flags, uint64_t opt1, uint64_t opt2);


/* Get information of the pages in a VM */


struct sys_vm_page_information {
    uint64_t state;
};
typedef struct sys_vm_page_information sys_vm_page_information_t;
extern "C" int sys_dbg_vm_get_page_information(sys_addr_t addr, unsigned int num,
                                          sys_vm_page_information_t *pageinfo);


/* DABR Control Flags */




/* Set DABR */
extern "C" int sys_dbg_set_address_to_dabr(uint64_t addr, uint64_t ctrl_flag);

/* Get DABR */
extern "C" int sys_dbg_get_address_from_dabr(uint64_t* addr, uint64_t* ctrl_flag);


/* Wakeup the coredump handler  */
extern "C" int sys_dbg_signal_to_coredump_handler(uint64_t data1, uint64_t data2, uint64_t data3);

/* MAT condition flags */




 /* MAT granularity.  THe address must be aligned on the value */


extern "C" int sys_dbg_mat_set_condition(sys_addr_t addr, uint64_t cond);
extern "C" int sys_dbg_mat_get_condition(sys_addr_t addr, uint64_t *condp);


/**
 * The status of coredump function
 */
typedef enum {
  SYS_DBG_COREDUMP_OFF,
  SYS_DBG_COREDUMP_ON_SAVE_TO_APP_HOME,
  SYS_DBG_COREDUMP_ON_SAVE_TO_DEV_MS,
  SYS_DBG_COREDUMP_ON_SAVE_TO_DEV_USB,
  SYS_DBG_COREDUMP_ON_SAVE_TO_DEV_HDD0
} sys_dbg_coredump_parameter_t;

/* Get some parameters of coredump handler */
extern "C" int sys_dbg_get_coredump_params(sys_dbg_coredump_parameter_t* param);

/* Set PPU exception mask to the exception handler */
extern "C" int sys_dbg_set_mask_to_ppu_exception_handler(uint64_t mask, uint64_t flags);


/*@}*/
# 27 "C:\\Users\\USER\\Documents\\Visual Studio 2013\\Projects\\mp3_plugin_PS3\\mp3_plugin_PS3\\main.cpp"
# 1 "C:/usr/local/cell\\target\\ppu\\include/ppu_asm_intrinsics.h" 3
/*  SCE CONFIDENTIAL                          */
/*  PlayStation(R)3 Programmer Tool Runtime Library */
/*  Copyright (C) 2007-2008 Sony Computer Entertainment Inc.   */
/*  All Rights Reserved.                        */




/*
 * asm compatibility header to aid translation of GCC inline assembler to portable C/C++
 *
 * This header file maps many ppu instructions to the equivalent portable C code.
 * It is intended as a porting aid and guide.
 *
 * With optimisation, non-microcoded instructions should map 1:1 with each function.
 * for example, an __addic / __subfe pair should produce something similar
 * in the output. The __rlwinm function should map to a single rlwinm instruction and the
 * optimiser will reduce it further if possible.
 *
 * But above all, this header is intended to act as a guide to generating portable C.
 *
 */


  /* non GNU C versions */




  /*
   * xer-based instructions
   */

# 51 "C:/usr/local/cell\\target\\ppu\\include/ppu_asm_intrinsics.h" 3

  /*
   * arithmetic instructions
   */

  static inline __attribute__( ( always_inline ) ) long long __add( long long a, long long b ) { unsigned long long result = a + b; return result; }
  static inline __attribute__( ( always_inline ) ) long long __addi( long long a, short b ) { unsigned long long result = a + b; return result; }
  static inline __attribute__( ( always_inline ) ) long long __addis( long long a, short b ) { unsigned long long result = a + ( b << 16 ); return result; }
  static inline __attribute__( ( always_inline ) ) long long __subf( long long a, long long b ) { unsigned long long result = b - a; return result; }
  static inline __attribute__( ( always_inline ) ) long long __neg( long long a ) { unsigned long long result = -a; return result; }
  static inline __attribute__( ( always_inline ) ) long long __divd( long long a, long long b ) { unsigned long long result = a / b; return result; }
  static inline __attribute__( ( always_inline ) ) long long __divdu( unsigned long long a, unsigned long long b ) { unsigned long long result = a / b; return result; }
  static inline __attribute__( ( always_inline ) ) long long __divw( long long a, long long b ) { unsigned long long result = (unsigned)( (signed)a / (signed)b ); return result; }
  static inline __attribute__( ( always_inline ) ) long long __divwu( long long a, long long b ) { unsigned long long result = (unsigned)a / (unsigned)b; return result; }
  static inline __attribute__( ( always_inline ) ) long long __mulhd( long long a, long long b ) { unsigned long long result = __builtin_mulhd( a, b ); return result; }
  static inline __attribute__( ( always_inline ) ) long long __mulhdu( long long a, long long b ) { unsigned long long result = __builtin_mulhdu( a, b ); return result; }
  static inline __attribute__( ( always_inline ) ) long long __mulhw( long long a, long long b ) { unsigned long long result = __builtin_mulhw( a, b ); return result; }
  static inline __attribute__( ( always_inline ) ) long long __mulhwu( long long a, long long b ) { unsigned long long result = __builtin_mulhwu( a, b ); return result; }
  static inline __attribute__( ( always_inline ) ) long long __mulld( long long a, long long b ) { unsigned long long result = a * b; return result; }
  static inline __attribute__( ( always_inline ) ) long long __mulli( long long a, short b ) { unsigned long long result = a * b; return result; }
  static inline __attribute__( ( always_inline ) ) long long __mullw( long long a, long long b ) { unsigned long long result = (long long )(int)a * (int)b; return result; }
  static inline __attribute__( ( always_inline ) ) long long __extsb( long long a ) { unsigned long long result = (signed char)a; return result; }
  static inline __attribute__( ( always_inline ) ) long long __extsh( long long a ) { unsigned long long result = (signed short)a; return result; }
  static inline __attribute__( ( always_inline ) ) long long __extsw( long long a ) { unsigned long long result = (signed int)a; return result; }

  /*
   * logical instructions
   */

  static inline __attribute__( ( always_inline ) ) long long __and( long long a, long long b ) { unsigned long long result = a & b; return result; }
  static inline __attribute__( ( always_inline ) ) long long __andc( long long a, long long b ) { unsigned long long result = a & ~b; return result; }
  static inline __attribute__( ( always_inline ) ) long long __eqv( long long a, long long b ) { unsigned long long result = ~( a ^ b ); return result; }
  static inline __attribute__( ( always_inline ) ) long long __nand( long long a, long long b ) { unsigned long long result = ~( a & b ); return result; }
  static inline __attribute__( ( always_inline ) ) long long __nor( long long a, long long b ) { unsigned long long result = ~( a | b ); return result; }
  static inline __attribute__( ( always_inline ) ) long long __or( long long a, long long b ) { unsigned long long result = a | b; return result; }
  static inline __attribute__( ( always_inline ) ) long long __orc( long long a, long long b ) { unsigned long long result = a | ~b; return result; }
  static inline __attribute__( ( always_inline ) ) long long __ori( long long a, unsigned short b ) { unsigned long long result = a | (unsigned long long)b; return result; }
  static inline __attribute__( ( always_inline ) ) long long __oris( long long a, unsigned short b ) { unsigned long long result = a | ( (unsigned long long)b << 16 ); return result; }
  static inline __attribute__( ( always_inline ) ) long long __xor( long long a, long long b ) { unsigned long long result = a ^ b; return result; }
  static inline __attribute__( ( always_inline ) ) long long __xori( long long a, const unsigned short b ) { unsigned long long result = a ^ (unsigned long long)b; return result; }
  static inline __attribute__( ( always_inline ) ) long long __xoris( long long a, const unsigned short b ) { unsigned long long result = a ^ ( (unsigned long long)b << 16 ); return result; }

  /*
   * floating point instructions
   */

  static inline __attribute__( ( always_inline ) ) double __fadd( double a, double b ) { double result = a + b; return result; }
  static inline __attribute__( ( always_inline ) ) double __fadds( double a, double b ) { float result = a + b; return result; }
  static inline __attribute__( ( always_inline ) ) double __fdiv( double a, double b ) { double result = a / b; return result; }
  static inline __attribute__( ( always_inline ) ) double __fdivs( double a, double b ) { float result = a / b; return result; }
  static inline __attribute__( ( always_inline ) ) double __fmadd( double a, double b, double c ) { double result = a * b + c; return result; }
  static inline __attribute__( ( always_inline ) ) double __fmadds( double a, double b, double c ) { float result = a * b + c; return result; }
  static inline __attribute__( ( always_inline ) ) double __fmr( double b ) { return b; }
  static inline __attribute__( ( always_inline ) ) double __fmsubs( double a, double b, double c ) { float result = a * b - c; return result; }
  static inline __attribute__( ( always_inline ) ) double __fmsub( double a, double b, double c ) { double result = a * b - c; return result; }

  /* Note: This intrinsic is being moved from the compiler to this header file, always include ppu_asm_intrinsics.h when using it for future compatibility. */
  /*__ALWAYS_INLINE double __fabs( double a ) { double result = __builtin_fabs( a ); return result; } */

  /* Note: This intrinsic is being moved from the compiler to this header file, always include ppu_asm_intrinsics.h when using it for future compatibility. */
  /*__ALWAYS_INLINE float __fabsf( float a ) { double result = __builtin_fabsf( a ); return result; } */

  static inline __attribute__( ( always_inline ) ) double __fnabs( double a ) { double result = __builtin_fnabs( a ); return result; }
  static inline __attribute__( ( always_inline ) ) double __fnabsf( double a ) { double result = __builtin_fnabsf( a ); return result; }
  static inline __attribute__( ( always_inline ) ) double __fneg( double a ) { double result = -a; return result; }
  static inline __attribute__( ( always_inline ) ) double __fnmadd( double a, double b, double c ) { double result = -( c + a * b ); return result; }
  static inline __attribute__( ( always_inline ) ) double __fnmadds( double a, double b, double c ) { float result = -( c + a * b ); return result; }
  static inline __attribute__( ( always_inline ) ) double __fnmsub( double a, double b, double c ) { double result = c - a * b; return result; }
  static inline __attribute__( ( always_inline ) ) double __fnmsubs( double a, double b, double c ) { float result = c - a * b; return result; }
  static inline __attribute__( ( always_inline ) ) float __fres( float a ) { double result = __builtin_fre( a ); return result; }
  static inline __attribute__( ( always_inline ) ) double __fsqrt( double a ) { double result = __builtin_fsqrt( a ); return result; }

  /* Note: This intrinsic is being moved from the compiler to this header file, always include ppu_asm_intrinsics.h when using it for future compatibility. */
  /*__ALWAYS_INLINE float __fsqrts( float a ) { double result = __builtin_fsqrt( a ); return result; } */

  static inline __attribute__( ( always_inline ) ) double __frsp( double a ) { return (float)a; }

  /* Note: This intrinsic is being moved from the compiler to this header file, always include ppu_asm_intrinsics.h when using it for future compatibility. */
  /*__ALWAYS_INLINE double __fsel( double a, double b, double c ) { return __builtin_fsel( a, b, c ); } */

  static inline __attribute__( ( always_inline ) ) double __fsub( double a, double b ) { double result = a - b; return result; }
  static inline __attribute__( ( always_inline ) ) double __fsubs( double a, double b ) { float result = a - b; return result; }
  static inline __attribute__( ( always_inline ) ) long long __lbz( const short offset, void *p ) { unsigned char *addr = (unsigned char *)( (unsigned char *)p + offset ); return *addr; }
  static inline __attribute__( ( always_inline ) ) long long __lbzx( void *p, long long offset ) { unsigned char *addr = (unsigned char *)( (unsigned char *)p + offset ); return *addr; }
  static inline __attribute__( ( always_inline ) ) long long __ld( const short offset, void *p ) { unsigned long long *addr = (unsigned long long *)( (unsigned char *)p + offset ); return *addr; }
  static inline __attribute__( ( always_inline ) ) long long __ldx( void *p, long long offset ) { unsigned long long *addr = (unsigned long long *)( (unsigned char *)p + offset ); return *addr; }
  static inline __attribute__( ( always_inline ) ) double __lfd( const short offset, void *p ) { double *addr = (double *)( (unsigned char *)p + offset ); return *addr; }
  static inline __attribute__( ( always_inline ) ) double __lfdx( void *p, long long offset ) { double *addr = (double *)( (unsigned char *)p + offset ); return *addr; }
  static inline __attribute__( ( always_inline ) ) double __lfs( const short offset, void *p ) { float *addr = (float *)( (unsigned char *)p + offset ); return *addr; }
  static inline __attribute__( ( always_inline ) ) double __lfsx( void *p, long long offset ) { float *addr = (float *)( (unsigned char *)p + offset ); return *addr; }
  static inline __attribute__( ( always_inline ) ) long long __lha( const short offset, void *p ) { short *addr = (short *)( (unsigned char *)p + offset ); return *addr; }
  static inline __attribute__( ( always_inline ) ) long long __lhax( void *p, long long offset ) { short *addr = (short *)( (unsigned char *)p + offset ); return *addr; }
  static inline __attribute__( ( always_inline ) ) long long __lhz( const short offset, void *p ) { unsigned short *addr = (unsigned short *)( (unsigned char *)p + offset ); return *addr; }
  static inline __attribute__( ( always_inline ) ) long long __lhzx( void *p, long long offset ) { unsigned short *addr = (unsigned short *)( (unsigned char *)p + offset ); return *addr; }
  static inline __attribute__( ( always_inline ) ) long long __lwa( const short offset, void *p ) { int *addr = (int *)( (unsigned char *)p + offset ); return *addr; }
  static inline __attribute__( ( always_inline ) ) long long __lwax( void *p, long long offset ) { int *addr = (int *)( (unsigned char *)p + offset ); return *addr; }
  static inline __attribute__( ( always_inline ) ) long long __lwz( const short offset, void *p ) { unsigned *addr = (unsigned *)( (unsigned char *)p + offset ); return *addr; }
  static inline __attribute__( ( always_inline ) ) long long __lwzx( void *p, long long offset ) { unsigned *addr = (unsigned *)( (unsigned char *)p + offset ); return *addr; }


  /*
   * shifts:
   */

  static inline __attribute__( ( always_inline ) ) long long __sld( long long a, long long b ) { unsigned long long result = a << b; return result; }
  static inline __attribute__( ( always_inline ) ) long long __sldi( long long a, unsigned char b ) { unsigned long long result = a << b; return result; }
  static inline __attribute__( ( always_inline ) ) long long __slw( long long a, long long b ) { unsigned result = (unsigned)a << (unsigned)b; return result; }
  static inline __attribute__( ( always_inline ) ) long long __slwi( long long a, unsigned char b ) { unsigned result = (unsigned)a << (unsigned)b; return result; }
  static inline __attribute__( ( always_inline ) ) long long __srd( long long a, long long b ) { unsigned long long result = (unsigned long long)a >> b; return result; }
  static inline __attribute__( ( always_inline ) ) long long __srdi( long long a, long long b ) { unsigned long long result = (unsigned long long)a >> b; return result; }
  static inline __attribute__( ( always_inline ) ) long long __srw( long long a, long long b ) { unsigned result = (unsigned)a >> b; return result; }
  static inline __attribute__( ( always_inline ) ) long long __srwi( long long a, unsigned char b ) { unsigned result = (unsigned)a >> b; return result; }

  /*
   * stores:
   */

  /*
   * stores are converted to offset, indexed or update forms depending on context.
   *
   * store -> load -> store tripples of different types are re-interpreted
   *   eg. stfiwx or float to int conversion via stack-based unions
   */

  static inline __attribute__( ( always_inline ) ) void __stb( long long a, const short offset, void *p ) { unsigned char *addr = (unsigned char *)( (unsigned char *)p + offset ); *addr = a; }
  static inline __attribute__( ( always_inline ) ) void __stbx( long long a, void *p, long long offset ) { unsigned char *addr = (unsigned char *)( (unsigned char *)p + offset ); *addr = a; }
  static inline __attribute__( ( always_inline ) ) void __std( long long a, const short offset, void *p ) { unsigned long long *addr = (unsigned long long *)( (unsigned char *)p + offset ); *addr = a; }
  static inline __attribute__( ( always_inline ) ) void __stdx( long long a, void *p, long long offset ) { unsigned long long *addr = (unsigned long long *)( (unsigned char *)p + offset ); *addr = a; }
  static inline __attribute__( ( always_inline ) ) void __stfd( double a, const short offset, void *p ) { double *addr = (double *)( (unsigned char *)p + offset ); *addr = a; }
  static inline __attribute__( ( always_inline ) ) void __stfdx( double a, void *p, long long offset ) { double *addr = (double *)( (unsigned char *)p + offset ); *addr = a; }
  static inline __attribute__( ( always_inline ) ) void __stfs( double a, const short offset, void *p ) { float *addr = (float *)( (unsigned char *)p + offset ); *addr = (float)a; }
  static inline __attribute__( ( always_inline ) ) void __stfsx( double a, void *p, long long offset ) { float *addr = (float *)( (unsigned char *)p + offset ); *addr = (float)a; }
  static inline __attribute__( ( always_inline ) ) void __sth( long long a, const short offset, void *p ) { short *addr = (short *)( (unsigned char *)p + offset ); *addr = a; }
  static inline __attribute__( ( always_inline ) ) void __sthx( long long a, void *p, long long offset ) { short *addr = (short *)( (unsigned char *)p + offset ); *addr = a; }
  static inline __attribute__( ( always_inline ) ) void __stw( long long a, const short offset, void *p ) { unsigned int *addr = (unsigned int *)( (unsigned char *)p + offset ); *addr = a; }
  static inline __attribute__( ( always_inline ) ) void __stwx( long long a, void *p, long long offset ) { unsigned int *addr = (unsigned int *)( (unsigned char *)p + offset ); *addr = a; }

  /* store the bottom 32 bits of a fpu register after fctiw/fctiwz */
  static inline __attribute__( ( always_inline ) ) void __stfiwx( double a, void *p, long long offset ) { __builtin_stfiwx( a, p, offset ); }


  /* load/store update instruction functional equivalents */
# 207 "C:/usr/local/cell\\target\\ppu\\include/ppu_asm_intrinsics.h" 3

# 222 "C:/usr/local/cell\\target\\ppu\\include/ppu_asm_intrinsics.h" 3

# 385 "C:/usr/local/cell\\target\\ppu\\include/ppu_asm_intrinsics.h" 3



# 28 "C:\\Users\\USER\\Documents\\Visual Studio 2013\\Projects\\mp3_plugin_PS3\\mp3_plugin_PS3\\main.cpp"
# 1 "C:/usr/local/cell\\host-win32\\sn\\ppu\\include/ppu_intrinsics.h" 3
/*  SCE CONFIDENTIAL                          */
/*  PlayStation(R)3 Programmer Tool Runtime Library */
/*  Copyright (C) 2009 Sony Computer Entertainment Inc.   */
/*  All Rights Reserved.                        */



# 1 "C:/usr/local/cell\\target\\ppu\\include/stdbool.h" 3
/* SCE CONFIDENTIAL
PlayStation(R)3 Programmer Tool Runtime Library 475.001
* Copyright (C) 2005 Sony Computer Entertainment Inc. 
* All Rights Reserved.
*/
/* stdbool.h standard header */






namespace std {



# 31 "C:/usr/local/cell\\target\\ppu\\include/stdbool.h" 3

}


/*
 * Copyright (c) 1992-2003 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
V4.02:0216 */
# 9 "C:/usr/local/cell\\host-win32\\sn\\ppu\\include/ppu_intrinsics.h" 3









/*
 * __INTRINSICS_CHECKING can be used to enable run-time parameter bounds checking for 
 * some of the intrinsics below. 
 */
# 30 "C:/usr/local/cell\\host-win32\\sn\\ppu\\include/ppu_intrinsics.h" 3

/*
 * Some intrinsics currently implemented in the compiler will be moved to this file in future.
 * Please always include ppu_intrinsics.h when using intrinsics.  This will guarantee compatibility
 * with future releases.
 *
 * For upwards compatibility please avoid using the internal __builtin_* intrinsics directly.
 */

/*
 * JSRE form intrinsics. Beware... parameter order may be unexpected!
 */

/* specify the address and direction of a read data stream. Will continue to load cache blocks starting at address */
static inline __attribute__((always_inline)) void __dcbt_TH1000 (void * __address, bool __direction, bool __unlimited, int __id)
{
    __builtin_dcbt3 ((unsigned int) __address & -128u, 
                     ((unsigned int) __direction & 1) * 64 + ((unsigned int) __unlimited & 1) * 32 + ((unsigned int) __id & 15), 
                     8);
}


/* control a stream started by __dcbt_TH1000. start and stop the stream, specify count and other flags. */
static inline __attribute__((always_inline)) void __dcbt_TH1010 ( bool __g0,
                                  int __stop, 
                                  int __unit_count, 
                                  bool __transient, 
                                  bool __unlimited, 
                                  int __id
                                )
{
    __builtin_dcbt3 ((unsigned int) __g0 << 31 | ( (unsigned int) __stop & 3) << 29 | ( (unsigned int) __unit_count & 1023) << 7, 
                     ((unsigned int) __transient & 1) * 64 + ((unsigned int) __unlimited & 1) * 32 + ((unsigned int) __id & 15), 
                     8);
}

/* read the time base. Skip values with zero lower 32 bits. */
/* Note: This intrinsic is being moved from the compiler to this header file, always include ppu_intrinsics.h when using it for future compatibility. */
/* __SNC_INLINE long long __mftb () { return __builtin_mftb (); } */

/* Invalidate a L2 instruction cache block */
static inline __attribute__((always_inline)) void __icbi (void * __ptr) { __builtin_icbi (__ptr, 0); }

/* Invalidate a L2 data cache block */
static inline __attribute__((always_inline)) void __dcbi (void * __ptr) { __builtin_dcbi (__ptr, 0); }

/* Flush a L2 data cache block */
static inline __attribute__((always_inline)) void __dcbf (const void * __ptr) { __builtin_dcbf (__ptr, 0); }

/* Zero a L2 data cache block. */
static inline __attribute__((always_inline)) void __dcbz (void * __ptr) { __builtin_dcbz (__ptr, 0); }

/* Write out a L2 data cache block */
static inline __attribute__((always_inline)) void __dcbst (void * __ptr) { __builtin_dcbst (__ptr, 0); }

/* Read a L2 data cache block ready for a store. */
static inline __attribute__((always_inline)) void __dcbtst (void * __ptr) { __builtin_dcbtst (__ptr, 0); }

/* Read a L2 data cache block, non-streamed form. */
/* Note: This intrinsic is being moved from the compiler to this header file, always include ppu_intrinsics.h when using it for future compatibility. */
/*__SNC_INLINE void __dcbt (void * __ptr) { __builtin_dcbt (__ptr, 0); } */


/* JSRE form memory operations. Beware... parameter order may be unexpected! */
static inline __attribute__((always_inline)) unsigned int       __lwarx (volatile void * __base) { return __builtin_lwarx (__base, 0); }
static inline __attribute__((always_inline)) unsigned long long __ldarx (volatile void * __base) { return __builtin_ldarx (__base, 0); }
static inline __attribute__((always_inline)) bool __stwcx (volatile void * __base, unsigned int       __value) { return __builtin_stwcx (__value, __base, 0); }
static inline __attribute__((always_inline)) bool __stdcx (volatile void * __base, unsigned long long __value) { return __builtin_stdcx (__value, __base, 0); }

static inline __attribute__((always_inline)) unsigned short     __lhbrx (void * __base) { return __builtin_lhbrx (__base, 0); }
static inline __attribute__((always_inline)) unsigned int       __lwbrx (void * __base) { return __builtin_lwbrx (__base, 0); }
static inline __attribute__((always_inline)) unsigned long long __ldbrx (void * __base) { return __builtin_ldbrx (__base, 0); }

static inline __attribute__((always_inline)) void __sthbrx (void * __base, unsigned short     __value) { __builtin_sthbrx (__value, __base, 0); }
static inline __attribute__((always_inline)) void __stwbrx (void * __base, unsigned int       __value) { __builtin_stwbrx (__value, __base, 0); }
static inline __attribute__((always_inline)) void __stdbrx (void * __base, unsigned long long __value) { __builtin_stdbrx (__value, __base, 0); }

/* Note: This intrinsic is being moved from the compiler to this header file, always include ppu_intrinsics.h when using it for future compatibility. */
/*__SNC_INLINE unsigned long long __cntlzd (long long __a) { long long result = __builtin_clzll (__a); return result; } */

/* Note: This intrinsic is being moved from the compiler to this header file, always include ppu_intrinsics.h when using it for future compatibility. */
/*__SNC_INLINE long long __cntlzw (long long __a) { long long result = __builtin_clz (__a); return result; } */

static inline __attribute__((always_inline)) void __sync ()   { __builtin_sync ();   }
static inline __attribute__((always_inline)) void __isync ()  { __builtin_isync ();  }
static inline __attribute__((always_inline)) void __lwsync () { __builtin_lwsync (); }
static inline __attribute__((always_inline)) void __eieio ()  { __builtin_eieio ();  }

/**
 * \brief Convert double to double-word
 *
 * Converts a double value to a double-word integer. This function takes the 
 * current rounding mode into account.
 *
 * \param __a  The value to be converted to a double-word integer.
 * \result  The result of converting 'a' to a double-word integer.
 */
static inline __attribute__((always_inline)) long long __fctid (double __a)
{
    union { long long __out; double __in; } __convert; 
    __convert.__in = __builtin_fctid (__a);
    return __convert.__out;
}

/**
 * \brief Convert double to word with round towards zero
 *
 * Converts a double value to a word. This function always rounds towards zero.
 *
 * \param __a  The value to be converted to a word
 * \result  The result of converting 'a' to a word
 */
static inline __attribute__((always_inline)) int __fctiw (double __a)
{
    union { long long __out; double __in; } __convert;
    __convert.__in = __builtin_fctiw (__a);
    return __convert.__out;
}

/**
 * \brief Convert double to double-word with round towards zero
 * 
 * Converts a double value to a word. This function always rounds towards zero.
 * 
 * \param __a  The value to be converted to a double-word integer
 * \result  The result of converting 'a' to a double-word integer
 */
static inline __attribute__((always_inline)) long long __fctidz (double __a)
{
    union { long long __out; double __in; } __convert;
    __convert.__in = __builtin_fctidz (__a); 
    return __convert.__out;
}

/**
 * \brief Convert double to word with round towards zero
 * 
 * Converts a double to word. This function always rounds towards zero.
 *
 * \param __a  The value to be converted to a word
 * \result  The result of converting 'a' to a word
 */
static inline __attribute__((always_inline)) int __fctiwz (double __a)
{
    union { long long __out; double __in; } __convert;
    __convert.__in = __builtin_fctiwz (__a);
    return __convert.__out;
}

/**
 * \brief Convert double-word to double
 *
 * Converts a double-word value to double-precision floating point.
 *
 * \param __a The value to be converted to floating point
 * \result  The result of converting 'a' to floating point
 */
static inline __attribute__((always_inline)) double __fcfid (long long __a)
{
    union { long long __in; double __out; } __convert; 
    __convert.__in = __a; 
    return __builtin_fcfid (__convert.__out);
}

static inline __attribute__((always_inline)) double __mffs () { return __builtin_mffs (); }
static inline __attribute__((always_inline)) void __mtfsf  (int __mask, double __value) { __builtin_mtfsf  (__mask, __value); }
static inline __attribute__((always_inline)) void __mtfsfi (int __bits, int    __field) { __builtin_mtfsfi (__bits, __field); }

static inline __attribute__((always_inline)) void __mtfsb0 (int __bit) { __builtin_mtfsb0 (__bit); }
static inline __attribute__((always_inline)) void __mtfsb1 (int __bit) { __builtin_mtfsb1 (__bit); }

static inline __attribute__((always_inline)) double __setflm (double __a)
{
    double __tmp = __builtin_mffs ();
    __builtin_mtfsf (255, __a); 
    return __tmp;
}

/*
 * Utility functions. These are support functions for the following intrinsics and are not designed
 * to be used directly.
 */
static inline __attribute__((always_inline)) unsigned long long __mask64 (unsigned int __mb, unsigned int __me) { ; return (unsigned long long) -1 << 63U - (__me - __mb) >> __mb; }
static inline __attribute__((always_inline)) unsigned int       __mask32 (unsigned int __mb, unsigned int __me) { ; return (unsigned int)       -1 << 31U - (__me - __mb) >> __mb; }

static inline __attribute__((always_inline)) unsigned long long __rotate64 (unsigned long long __a, unsigned int __sh) { ; return (__a << __sh) | (__a >> (64U - __sh)); }
static inline __attribute__((always_inline)) unsigned int       __rotate32 (unsigned int       __a, unsigned int __sh) { ; return (__a << __sh) | (__a >> (32U - __sh)); }


/******/

/**
 * \brief Rotate left double-word then clear left
 *
 * The value in the argument 'a' is rotated leftwards by the number of bits specified by the 
 * argument 'b'. A mask  is generated having 1-bits from bit 'mb' through bit 63, and 0-bits 
 * elsewhere. The rotated data is ANDed with the generated mask and returned.
 *
 * \param __a   A value that is to be shifted and masked
 * \param __sh  The number of bits by which the value 'a' is shifted
 * \param __me  The mask is generated with 1-bits from bit 0 to the bit given by this parameter
 * \result      The result of shifting and masking the value 'a'
 */
static inline __attribute__((always_inline)) unsigned long long __rldcl (unsigned long long __a, unsigned long long __sh, unsigned int __mb)
{
    unsigned long long __mask = __mask64 (__mb, 63);
    return __rotate64 (__a, (unsigned int) __sh) & __mask;
}

/**
 * \brief Rotate left double-word then clear right
 *
 * The value in the argument 'a' is rotated leftwards by the number of bits specified by the 
 * argument 'sh'. A mask is generated having 1-bits from bit 0 though bit 'me' and 0-bits 
 * elsewhere. The rotated data ANDed with the generated mask is then returned.
 *
 * \param __a   A value that is to be shifted and masked
 * \param __sh  The number of bits by which the value 'a' is shifted
 * \param __me  The mask is generated with 1-bits from bit 0 to the bit given by this parameter
 * \result      The result of shifting and masking the value 'a'
 */
static inline __attribute__((always_inline)) unsigned long long __rldcr (unsigned long long __a, unsigned long long __sh, unsigned int __me)
{
    unsigned long long __mask = __mask64 (0, __me);
    return __rotate64 (__a, (unsigned int) __sh) & __mask;
}

/**
 * \brief Rotate left double-word immediate then clear
 *
 * The value in the argument 'a' is rotated leftwards by the number of bits specified by the 
 * argument 'sh'. A mask is generated having 1-bits from bit 'mb' through bit '63 - sh' and
 * 0-bits elsewhere. The rotated data is ANDed with the generated mask and returned.
 *
 * \param __a
 * \param __sh
 * \param __mb  
 * \result
 */
/* Table 178 */
static inline __attribute__((always_inline)) unsigned long long __rldic (unsigned long long __a, unsigned int __sh, unsigned int __mb) 
{ 
    unsigned long long __mask = __mask64 (__mb, 63 - __sh);
    return __rotate64 (__a, __sh) & __mask;
}

/**
 * \brief Rotate left double-word immediate then clear left
 *
 * The value in the argument 'a' is rotated leftwards by the number of bits specified by the 
 * argument 'sh'. A mask is generated having 1-bits from bit 'mb' through bit 63 and 0-bits 
 * elsewhere. The rotated data is ANDed with the generated mask and returned.
 *
 * \param __a
 * \param __sh
 * \param __mb
 * \result
 */
/* Table 179 */
static inline __attribute__((always_inline)) unsigned long long __rldicl (unsigned long long __a, unsigned int __sh, unsigned int __mb)
{
    unsigned long long __mask = __mask64 (__mb, 63);
    return __rotate64 (__a, __sh) & __mask;
}

/**
 * \brief Rotate Left double-word immediate then clear right
 *
 * The value in the argument 'a' is rotated leftwards by the number of bits specified by the 
 * argument 'sh'. A mask is generated having 1-bits from bit 0 though bit 'me' and 0-bits 
 * elsewhere. The rotated data is ANDed with the generated mask and returned.
 *
 * \param a
 * \param sh
 * \param me
 * \result
 */
/* Table 180 */
static inline __attribute__((always_inline)) unsigned long long __rldicr (unsigned long long __a, unsigned int __sh, unsigned int __me)
{
    unsigned long long __mask = __mask64 (0, __me);
    return __rotate64 (__a, __sh) & __mask;
}

/**
 * \brief Rotate left double-word immediate then mask insert
 * 
 * A mask is generated with 1-bits from bit 'mb' through bit '63 - sh', and 0-bits elsewhere. 
 * The value in 'a' is ANDed with the complement of this mask, zeroing out just the bits 
 * inside the range 'mb' through '63 - sh'. The argument 'b' is rotated left by 'sh' bits and 
 * ANDs the result with the mask, zeroing out all bits outside the range 'mb' through '63 - sh'. 
 * The two masked values are combined together with inclusive OR and returned.
 * 
 * \param __a
 * \param __b
 * \param __sh
 * \param __mb
 * \result
 */
/* Table 181 */
static inline __attribute__((always_inline)) unsigned long long __rldimi (unsigned long long __a, unsigned long long __b, unsigned int __sh, unsigned int __mb)
{
    unsigned long long __mask = __mask64 (__mb, 63 - __sh);
    return (__rotate64 (__b, __sh) & __mask) | (__a & ~__mask);
}

/**
 * \brief Rotate left word immediate then mask insert
 *
 * A mask is generated with 1-bits from bit 'mb' through bit 'me', and 0-bits elsewhere. The 
 * value in 'a' is ANDed with the complement of this mask, zeroing out just the bits inside 
 * the range 'mb' through 'me'. The argument 'b' is rotated left by 'sh' bits and ANDs the 
 * result with the mask, zeroing out all bits outside the range 'mb' through 'me'. The two 
 * masked values are combined together with inclusive OR and returned.
 *
 * \param __a
 * \param __b   
 * \param __sh  The number of bits by which 'b' is rotated
 * \param __mb  Used, along with 'me', to generate the mask value: this is the starting point of
 *              the sequence of 1-bits
 * \param __me  Used, along with 'mb', to generate the mask value: this is the ending point of 
 *              the sequence of 1-bits
 * \result 
 */
/* Table 182 */
static inline __attribute__((always_inline)) unsigned int __rlwimi (unsigned int __a, unsigned int __b, unsigned int __sh, unsigned int __mb, unsigned int __me)
{
    unsigned int __mask = __mask32 (__mb, __me);
    return (__rotate32 (__b, __sh) & __mask) | (__a & ~__mask); 
}

/**
 * \brief Rotate left word then AND with mask
 * 
 * A mask is generated with 1-bits from 'mb' through bit 'me', and 0-bits elsewhere. The value
 * in a is rotated left by sh bits, then ANDed with this mask and returned.
 * 
 * \param __a
 * \param __sh
 * \param __mb  Used, along with 'me', to generate the mask value: this is the starting point of
 *              the sequence of 1-bits
 * \param __me  Used, along with 'mb', to generate the mask value: this is the ending point of 
 *              the sequence of 1-bits
 * \result
 */
/* Table 183 */
static inline __attribute__((always_inline)) unsigned int __rlwinm (unsigned int __a, unsigned int __sh, unsigned int __mb, unsigned int __me)
{
    unsigned int __mask = __mask32 (__mb, __me);
    return __rotate32 (__a, __sh) & __mask;
}

/**
 * \brief Rotate left word then AND with mask
 * 
 * The argument 'a' is rotated left by the argument 'b'. A mask is generated having 1-bits 
 * from bit 'mb' through bit 'me', and 0-bits elsewhere. The rotated data ANDed with the 
 * generated mask is returned.
 * 
 * \param __a
 * \param __sh
 * \param __mb  Used, along with 'me', to generate the mask value: this is the starting point of
 *              the sequence of 1-bits
 * \param __me  Used, along with 'mb', to generate the mask value: this is the ending point of 
 *              the sequence of 1-bits
 * \result
 */
/* Table 184 */
static inline __attribute__((always_inline)) unsigned int __rlwnm (unsigned int __a, unsigned int __sh, unsigned int __mb, unsigned int __me)
{
    unsigned int __mask = __mask32 (__mb, __me);
    return __rotate32 (__a, __sh) & __mask;
}

/* note: to test for infinity, compare with 3.40282347e38f instead */
static inline __attribute__((always_inline)) double __fmul  (double __a, double __b) { double __result = __a * __b; return __result; }
static inline __attribute__((always_inline)) double __fmuls (double __a, double __b) { float  __result = __a * __b; return __result; }

/* it would be more efficient to use the ternary operator a <= 0 ? b : c */
static inline __attribute__((always_inline)) float __fsels (float __a, float __b, float __c) { return __builtin_fsels (__a, __b, __c); }

/* Floating Reciprocal Square Root Estimate Single */
static inline __attribute__((always_inline)) float __frsqrtes (float __a) { return __builtin_frsqrtes(__a); }

/* Floating Reciprocal Square Root Estimate */
static inline __attribute__((always_inline)) double __frsqrte (double __a) { return __builtin_frsqrte (__a); }



/* eof ppu_intrinsics.h */
# 29 "C:\\Users\\USER\\Documents\\Visual Studio 2013\\Projects\\mp3_plugin_PS3\\mp3_plugin_PS3\\main.cpp"
# 1 "C:/usr/local/cell\\target\\ppu\\include/cell/cell_fs.h" 3
/*   SCE CONFIDENTIAL                                       */
/*   PlayStation(R)3 Programmer Tool Runtime Library 475.001 */
/*   Copyright (C) 2006 Sony Computer Entertainment Inc.    */
/*   All Rights Reserved.                                   */








# 31 "C:\\Users\\USER\\Documents\\Visual Studio 2013\\Projects\\mp3_plugin_PS3\\mp3_plugin_PS3\\main.cpp"
# 1 "C:/usr/local/cell\\target\\ppu\\include/cell/sysmodule.h" 3
/* SCE CONFIDENTIAL
PlayStation(R)3 Programmer Tool Runtime Library 475.001
* Copyright (C) 2010 Sony Computer Entertainment Inc.
* All Rights Reserved.
*/




# 1 "C:/usr/local/cell\\target\\ppu\\include/stdint.h" 3
/* SCE CONFIDENTIAL
PlayStation(R)3 Programmer Tool Runtime Library 475.001
* Copyright (C) 2006 Sony Computer Entertainment Inc. 
* All Rights Reserved.
*/
/* stdint.h standard header */










/* NB: also assumes
	long is 32 bits
	pointer can convert to and from long long
	long long is longest type
 */

/* Get the int types from Lv-2's sys/integertypes.h */


namespace std {

		/* TYPE DEFINITIONS */



typedef signed char int_least8_t;
typedef short int_least16_t;
typedef _Int32t int_least32_t;
typedef _Longlong int_least64_t;
typedef unsigned char uint_least8_t;
typedef unsigned short uint_least16_t;
typedef _Uint32t uint_least32_t;
typedef _ULonglong uint_least64_t;


typedef int32_t int_fast8_t;
typedef int32_t int_fast16_t;
typedef int32_t int_fast32_t;
typedef uint32_t uint_fast8_t;
typedef uint32_t uint_fast16_t;
typedef uint32_t uint_fast32_t;










typedef int64_t int_fast64_t;
typedef uint64_t uint_fast64_t;



typedef _Longlong intmax_t;
typedef _ULonglong uintmax_t;


		/* LIMIT MACROS */
# 123 "C:/usr/local/cell\\target\\ppu\\include/stdint.h" 3

# 141 "C:/usr/local/cell\\target\\ppu\\include/stdint.h" 3

# 191 "C:/usr/local/cell\\target\\ppu\\include/stdint.h" 3

# 198 "C:/usr/local/cell\\target\\ppu\\include/stdint.h" 3
}








using ::std:: int_least8_t; using ::std:: int_least16_t;
using ::std:: int_least32_t;  using ::std:: int_least64_t;
using ::std:: uint_least8_t; using ::std:: uint_least16_t;
using ::std:: uint_least32_t; using ::std:: uint_least64_t;

using ::std:: intmax_t; using ::std:: uintmax_t;


using ::std:: int_fast8_t; using ::std:: int_fast16_t;
using ::std:: int_fast32_t; using ::std:: int_fast64_t;
using ::std:: uint_fast8_t; using ::std:: uint_fast16_t;
using ::std:: uint_fast32_t; using ::std:: uint_fast64_t;


/*
 * Copyright (c) 1992-2003 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
V4.02:0216 */
# 11 "C:/usr/local/cell\\target\\ppu\\include/cell/sysmodule.h" 3




extern "C" {


/* module ID definitions */
# 124 "C:/usr/local/cell\\target\\ppu\\include/cell/sysmodule.h" 3

/* module */

typedef struct {
	int32_t prx_id;
	int32_t prx_depend_id;
} CellSysmoduleInfo;

/* return value (error codes) */








/* function prototypes */
int cellSysmoduleLoadModule(uint16_t id);
int cellSysmoduleUnloadModule(uint16_t id);

int cellSysmoduleInitialize(void);
int cellSysmoduleFinalize(void);

int cellSysmoduleIsLoaded(uint16_t id);

int cellSysmoduleSetMemcontainer(sys_memory_container_t ct);


}


# 32 "C:\\Users\\USER\\Documents\\Visual Studio 2013\\Projects\\mp3_plugin_PS3\\mp3_plugin_PS3\\main.cpp"
# 1 "C:/usr/local/cell\\target\\common\\include/cellstatus.h" 3
/*   SCE CONFIDENTIAL
PlayStation(R)3 Programmer Tool Runtime Library 475.001
*   Copyright (C) 2005 Sony Computer Entertainment Inc.
*   All Rights Reserved.
*/





extern "C" {









}




# 33 "C:\\Users\\USER\\Documents\\Visual Studio 2013\\Projects\\mp3_plugin_PS3\\mp3_plugin_PS3\\main.cpp"
# 1 "C:/usr/local/cell\\target\\ppu\\include/string.h" 3
/* SCE CONFIDENTIAL
* PlayStation(R)3 Programmer Tool Runtime Library 475.001
* Copyright (C) 2008 Sony Computer Entertainment Inc. 
* All Rights Reserved.
*/
/* string.h standard header */









namespace std {

		/* macros */




		/* type definitions */

		/* declarations */
extern "C" {
int memcmp(const void *, const void *, size_t);
void *memcpy(void *, const void *, size_t);
void *memcpy16(void *, const void *, size_t);
void *memset(void *, int, size_t);
void *memset_cs(void *, int, size_t);
char *strcat(char *, const char *);
int strcmp(const char *, const char *);
char *strcpy(char *, const char *);
size_t strlen(const char *);

void *memmove(void *, const void *, size_t);
int strcoll(const char *, const char *);
size_t strcspn(const char *, const char *);
char *strerror(int);
char *strncat(char *, const char *, size_t);
int strncmp(const char *, const char *, size_t);
char *strncpy(char *, const char *, size_t);
char *strncpy_cs(char *, const char *, size_t);
size_t strspn(const char *, const char *);
char *strtok(char *, const char *);
size_t strxfrm(char *, const char *, size_t);
char *strdup(const char *);
int strcasecmp(const char *, const char *);


int strncasecmp(const char *, const char *, size_t);

char *strtok_r(char *, const char *,char **);

}


		// INLINES AND OVERLOADS, for C++


extern "C" {
const char *strchr(const char *, int);
const char *strpbrk(const char *, const char *);
const char *strrchr(const char *, int);
const char *strstr(const char *, const char *);
}

inline char *strchr(char *_Str, int _Ch) {
  // call with const first argument
  return (const_cast<char *>(::std:: strchr((const char *)_Str, _Ch)));
}

inline char *strpbrk(char *_Str1, const char *_Str2) {
  // call with const first argument
  return (const_cast<char *>(::std:: strpbrk((const char *)_Str1, _Str2)));
}

inline char *strrchr(char *_Str, int _Ch) {
  // call with const first argument
  return (const_cast<char *>(::std:: strrchr((const char *)_Str, _Ch)));
}

inline char *strstr(char *_Str1, const char *_Str2) {
  // call with const first argument
  return (const_cast<char *>(::std:: strstr((const char *)_Str1, _Str2)));
}

# 99 "C:/usr/local/cell\\target\\ppu\\include/string.h" 3





extern "C" {
const void *memchr(const void *, int, size_t);
}

inline void *memchr(void *_Str, int _Ch, size_t _Num) {
  // call with const first argument
  return (const_cast<void *>(::std:: memchr((const void *)_Str, _Ch, _Num)));
}








}





using ::std:: memchr; using ::std:: memcmp;
using ::std:: memcpy; using ::std:: memcpy16; using ::std:: memmove;
using ::std:: memset; using ::std:: memset_cs;
using ::std:: strcat; using ::std:: strchr; using ::std:: strcmp;
using ::std:: strcoll; using ::std:: strcpy; using ::std:: strcspn;
using ::std:: strerror; using ::std:: strlen; using ::std:: strncat;
using ::std:: strncmp; using ::std:: strpbrk;
using ::std:: strncpy; using ::std:: strncpy_cs;
using ::std:: strrchr; using ::std:: strspn; using ::std:: strstr;
using ::std:: strtok; using ::std:: strxfrm; using ::std:: strdup;
using ::std:: strcasecmp; using ::std:: strncasecmp; using ::std:: strtok_r;


/*
 * Copyright (c) 1992-2003 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
V4.02:0216 */
# 34 "C:\\Users\\USER\\Documents\\Visual Studio 2013\\Projects\\mp3_plugin_PS3\\mp3_plugin_PS3\\main.cpp"
# 1 "C:/usr/local/cell\\target\\ppu\\include/assert.h" 3
/* SCE CONFIDENTIAL
PlayStation(R)3 Programmer Tool Runtime Library 475.001
* Copyright (C) 2009 Sony Computer Entertainment Inc. 
* All Rights Reserved.
*/
/* assert.h standard header */




namespace std {



# 21 "C:/usr/local/cell\\target\\ppu\\include/assert.h" 3

# 34 "C:/usr/local/cell\\target\\ppu\\include/assert.h" 3

# 44 "C:/usr/local/cell\\target\\ppu\\include/assert.h" 3

# 52 "C:/usr/local/cell\\target\\ppu\\include/assert.h" 3





extern "C" {
void _Assert(const char *, const char *);
void _SCE_Assert(const char *, const char *);
}



}

/*
 * Copyright (c) 1992-2003 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
V4.02:0216 */
# 36 "C:\\Users\\USER\\Documents\\Visual Studio 2013\\Projects\\mp3_plugin_PS3\\mp3_plugin_PS3\\main.cpp"
# 1 "C:/usr/local/cell\\target\\ppu\\include/stddef.h" 3
/* SCE CONFIDENTIAL
PlayStation(R)3 Programmer Tool Runtime Library 475.001
* Copyright (C) 2005 Sony Computer Entertainment Inc. 
* All Rights Reserved.
*/
/* stddef.h standard header */








namespace std {

		/* macros */








# 35 "C:/usr/local/cell\\target\\ppu\\include/stddef.h" 3



		/* type definitions */





typedef _Ptrdifft ptrdiff_t;







}





using ::std:: ptrdiff_t;




/*
 * Copyright (c) 1992-2003 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
V4.02:0216 */
# 37 "C:\\Users\\USER\\Documents\\Visual Studio 2013\\Projects\\mp3_plugin_PS3\\mp3_plugin_PS3\\main.cpp"
# 1 "C:/usr/local/cell\\target\\ppu\\include/stdio.h" 3
/* SCE CONFIDENTIAL
PlayStation(R)3 Programmer Tool Runtime Library 475.001
* Copyright (C) 2007 Sony Computer Entertainment Inc. 
* All Rights Reserved.
*/
/* stdio.h standard header */
# 260 "C:/usr/local/cell\\target\\ppu\\include/stdio.h" 3

# 293 "C:/usr/local/cell\\target\\ppu\\include/stdio.h" 3

/*
 * Copyright (c) 1992-2003 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
V4.02:0216 */
# 38 "C:\\Users\\USER\\Documents\\Visual Studio 2013\\Projects\\mp3_plugin_PS3\\mp3_plugin_PS3\\main.cpp"
# 1 "C:/usr/local/cell\\target\\ppu\\include/stdlib.h" 3
/* SCE CONFIDENTIAL
PlayStation(R)3 Programmer Tool Runtime Library 475.001
* Copyright (C) 2010 Sony Computer Entertainment Inc.
* All Rights Reserved.
*/
/* stdlib.h standard header */









namespace std {

		/* MACROS */








extern "C" {
extern char _Mbcurmax;
}

















		/* TYPE DEFINITIONS */






typedef struct
	{	/* result of int divide */
	int quot;
	int rem;
	} div_t;

typedef struct
	{	/* result of long divide */
	long quot;
	long rem;
	} ldiv_t;


typedef struct
	{	/* result of long long divide */
	_Longlong quot;
	_Longlong rem;
	} _Lldiv_t;



typedef _Lldiv_t lldiv_t;


		/* DECLARATIONS */
extern "C" { /* low-level functions */
void exit(int) __attribute__((__noreturn__));
void _Exit(int) __attribute__((__noreturn__));	/* added with C99 */
void exitspawn(const char *, char *const [], char *const [], sys_addr_t, size_t, int, uint64_t) __attribute__((__noreturn__)); /* only PS3 */
void _Exitspawn(const char *, char *const [], char *const [], sys_addr_t, size_t, int, uint64_t) __attribute__((__noreturn__)); /* only PS3 */
}

extern "C" {
int abs(int);
long labs(long);
void abort(void) __attribute__((__noreturn__));
void *calloc(size_t, size_t);
div_t div(int, int);
void free(void *);
ldiv_t ldiv(long, long);
void *malloc(size_t);
void *(memalign)(size_t boundary, size_t size_arg);  /* !!!GAC added nonstandard memalign*/
int mblen(const char *, size_t);
size_t mbstowcs(wchar_t *,
	const char *, size_t);
int mbtowc(wchar_t *, const char *, size_t);
int rand(void);
void srand(unsigned int);
void *realloc(void *, size_t);


void *reallocalign(void *, size_t size_arg, size_t boundary);
size_t malloc_usable_size(void*);

struct malloc_managed_size {
  size_t max_system_size;
  size_t current_system_size;
  size_t current_inuse_size;
};

int malloc_stats(struct malloc_managed_size *);
int malloc_stats_fast(struct malloc_managed_size *);


long strtol(const char *, char **, int);
size_t wcstombs(char *,
	const wchar_t *, size_t);
int wctomb(char *, wchar_t);

unsigned long _Stoul(const char *, char **, int);
float _Stof(const char *, char **, long);
double _Stod(const char *, char **, long);
long double _Stold(const char *, char **, long);
_Longlong _Stoll(const char *, char **, int);
_ULonglong _Stoull(const char *, char **, int);

size_t _Getmbcurmax(void);


_Longlong llabs(_Longlong);
lldiv_t lldiv(_Longlong, _Longlong);


}


extern "C" {
typedef void _Atexfun(void);
typedef int _Cmpfun(const void *, const void *);

int atexit(void (*)(void));
void *bsearch(const void *, const void *,
	size_t, size_t, _Cmpfun *);
void qsort(void *, size_t, size_t, _Cmpfun *);
}

# 170 "C:/usr/local/cell\\target\\ppu\\include/stdlib.h" 3

		// INLINES, FOR C++
extern "C" {
inline double atof(const char *_Str)
	{	// convert string to double
	return (_Stod(_Str, 0, 0));
	}

inline float atoff(const char *_Str)
	{	// convert string to float
	return (_Stof(_Str, 0, 0));
	}

inline int atoi(const char *_Str)
	{	// convert string to int
	return ((int)_Stoul(_Str, 0, 10));
	}

inline long atol(const char *_Str)
	{	// convert string to long
	return ((long)_Stoul(_Str, 0, 10));
	}

# 200 "C:/usr/local/cell\\target\\ppu\\include/stdlib.h" 3
inline double strtod(const char * _Str,
	char ** _Endptr)
	{	// convert string to double, with checking
	return (_Stod(_Str, _Endptr, 0));
	}

inline unsigned long strtoul(const char * _Str,
	char ** _Endptr, int _Base)
	{	// convert string to unsigned long, with checking
	return (_Stoul(_Str, _Endptr, _Base));
	}



inline _Longlong atoll(const char *_Str)
	{	// convert string to long long
	return ((_Longlong)_Stoull(_Str, 0, 10));
	}

inline float strtof(const char * _Str,
	char ** _Endptr)
	{	// convert string to float, with checking
	return (_Stof(_Str, _Endptr, 0));
	}

inline long double strtold(const char * _Str,
	char ** _Endptr)
	{	// convert string to long double, with checking
	return (_Stold(_Str, _Endptr, 0));
	}

inline _Longlong strtoll(const char * _Str,
	char ** _Endptr, int _Base)
	{	// convert string to long long, with checking
	return (_Stoll(_Str, _Endptr, _Base));
	}

inline _ULonglong strtoull(const char * _Str,
	char ** _Endptr, int _Base)
	{	// convert string to unsigned long long, with checking
	return (_Stoull(_Str, _Endptr, _Base));
	}


}

		// OVERLOADS, FOR C++


inline long abs(long _Left)
	{	// compute abs
	return (labs(_Left));
	}

inline ldiv_t div(long _Left, long _Right)
	{	// compute quotient and remainder
	return (ldiv(_Left, _Right));
	}





inline _Longlong abs(_Longlong _Left)
	{	// compute abs
	return (llabs(_Left));
	}

inline _Lldiv_t div(_Longlong _Left, _Longlong _Right)
	{	// compute quotient and remainder
	return (lldiv(_Left, _Right));
	}




# 321 "C:/usr/local/cell\\target\\ppu\\include/stdlib.h" 3





extern "C" {
extern inline int get_state_TT800(void **state);
extern inline void init_TT800(unsigned int s);
extern inline void init_by_array_TT800(unsigned int init_key[], int key_length);
extern inline unsigned int rand_int32_TT800(void);
extern inline unsigned int rand_int31_TT800(void);
extern inline float rand_real1_TT800(void);
extern inline float rand_real2_TT800(void);
extern inline float rand_real3_TT800(void);
# 1 "C:/usr/local/cell\\target\\ppu\\include/bits/spec.h" 3
/* SCE CONFIDENTIAL
PlayStation(R)3 Programmer Tool Runtime Library 475.001
* Copyright (C) 2011 Sony Computer Entertainment Inc. 
* All Rights Reserved.
*/








# 337 "C:/usr/local/cell\\target\\ppu\\include/stdlib.h" 3
# 1 "C:/usr/local/cell\\target\\ppu\\include/bits/tt800.h" 3
/* SCE CONFIDENTIAL
PlayStation(R)3 Programmer Tool Runtime Library 475.001
* Copyright (C) 2007 Sony Computer Entertainment Inc. 
* All Rights Reserved.
*/



/* The algorithm is taken from the following: */
/* C version of TT800 random number generator developed */
/* by M. Matsumoto, email: matumoto@math.keio.ac.jp */
/* See: ACM Transactions on Modelling and Computer Simulation, */
/* Vol. 4, No. 3, 1994, pages 254-266. */
// This version supports getting and saving of the state vector
// which is encapsulated in a global structure.  Also added functions to
// seed the generator from an integer or array. And to produce output numbers
// scaled into various ranges.

# 1 "C:/usr/local/cell\\target\\ppu\\include/bits/tt800_globals.h" 3
/* SCE CONFIDENTIAL
PlayStation(R)3 Programmer Tool Runtime Library 475.001
* Copyright (C) 2007 Sony Computer Entertainment Inc. 
* All Rights Reserved.
*/





// These are global values and typedefs needed in the tt800 random number generator
// implementation and in the definitions of it's global state vector





typedef struct 
{
  // Current batch of TT800 generated numbers
  unsigned int State[25]; 
  // Next number in the state vector to be returned to the caller
  int Next_Number;
} __TT800_State_t;

extern "C" {
extern __TT800_State_t __TT800;
}

# 20 "C:/usr/local/cell\\target\\ppu\\include/bits/tt800.h" 3

// Returns the address and size (in bytes) of the TT800 state vector.
// This lets you to save and restore the state of the random number generator
// when code is swapped on or off of the SPU.  This allows you to unload an SPU applet,
// load it back up later and have it continue from where it left off in the
// random number sequence, rather than having it start from the beginning.
// This is a better, faster and more statistically correct than reseeding the random
// number generator each time the SPU applet is reloaded.
// 
// To save the state, call this function to get the address and size of the state
// vector then memcopy or DMA that data to some safe location.  To restore it, do 
// do the same thing but copy the data into the address provided.
//
// DO NOT use this to seed the generator as you could put in values would cause the
// generator output to be non-random or degenerate to zero.  Always use the init_
// functions to seed the generator, they protect against bad seed values.
//
// The internal format of this data may change so avoid putting it in long-term
// storage or making assumptions about it's size/format till the library is finalized.
//

extern inline int get_state_TT800 (void * *state)
{
  *state = (void *)&__TT800;
  return(sizeof(__TT800));
}

/* initializes TT800 a seed (Needs to be checked) */
// !!!GAC THIS INITIALIZER MAY NOT BE STATISTICALLY SOUND, it didn't come with the generator
extern inline void init_TT800 (unsigned int s)
{
  int i;
  unsigned int *p = (unsigned int *)__TT800.State;
  for(i=0; i < 25; i++)
  {
    *(p++) ^= s;
  }
  __TT800.Next_Number = 0;
}

/* initializes TT800 an array (Needs to be checked) */
// !!!GAC THIS INITIALIZER MAY NOT BE STATISTICALLY SOUND, it didn't come with the generator
extern inline void init_by_array_TT800 (unsigned int init_key[], int key_length)
{
  int i,j;
  unsigned int *p = (unsigned int *)__TT800.State;
  for(i=0,j=0; i < 25; i++, j++)
  {
    if(j > key_length) j=0;
    *(p++) ^= init_key[j];
  }
  __TT800.Next_Number = 0;
}

// Core random number generator, generates numbers in batches and returns them one at a time.
extern inline unsigned int rand_int32_TT800 (void)
{
  unsigned int y;
  static const unsigned int mag01[2]={0x0, 0x8ebfd028 } ; // This is a magic number, do not change

  // Do we need to generate a new batch of numbers?
  if (__TT800.Next_Number==25)
  { 
    // generate _N_TT800 words at one time 
    int kk;
    for (kk=0;kk<25-7;kk++)
    {
      __TT800.State[kk] = __TT800.State[kk+7] ^ (__TT800.State[kk] >> 1) ^ mag01[__TT800.State[kk] % 2];
    }
    for (; kk<25;kk++)
    {
      __TT800.State[kk] = __TT800.State[kk+(7-25)] ^ (__TT800.State[kk] >> 1) ^ mag01[__TT800.State[kk] % 2];
    }
    __TT800.Next_Number=0;
  }
  // Get the next available number from the array
  y = __TT800.State[__TT800.Next_Number];
  // Temper the number using some more magic numbers from Matsumoto's algorithm
  y ^= (y << 7) & 0x2b5b2500; 
  y ^= (y << 15) & 0xdb8b0000;
  y &= 0xffffffff; // Only required if word size != 32 
  y ^= (y >> 16); 
  __TT800.Next_Number++;
  return( y );
}
/* generates a random number on [0,0x7fffffff]-interval */
extern inline unsigned int rand_int31_TT800 (void)
{
    return (long)(rand_int32_TT800()>>1);
}

/* generates a random number on [0,1]-real-interval */
extern inline float rand_real1_TT800 (void)
{
    return rand_int32_TT800()*(1.0f/4294967295.0f); 
    /* divided by 2^32-1 */ 
}

/* generates a random number on [0,1)-real-interval */
extern inline float rand_real2_TT800 (void)
{
    return rand_int32_TT800()*(1.0f/4294967296.0f); 
    /* divided by 2^32 */
}

/* generates a random number on (0,1)-real-interval */
extern inline float rand_real3_TT800 (void)
{
  unsigned int dr = rand_int32_TT800();
    return (((float)dr) + 0.5f)*(1.0f/4294967296.0f); 
    /* divided by 2^32 */
}

# 338 "C:/usr/local/cell\\target\\ppu\\include/stdlib.h" 3

}

}


# 1 "C:/usr/local/cell\\target\\ppu\\include/bits/sce_stdlib.h" 3
/* SCE CONFIDENTIAL
PlayStation(R)3 Programmer Tool Runtime Library 475.001
* Copyright (C) 2004 Sony Computer Entertainment Inc. 
* All Rights Reserved.
*/



/** COMMON INCLUDES **/
# 1 "C:/usr/local/cell\\host-win32\\sn\\ppu\\include/altivec.h" 3
/* PowerPC AltiVec include file.

   Copyright (c) 2008 SN Systems Ltd.
   support@snsys.com

   This file is provided for compatibility with GCC.  
   */












# 61 "C:/usr/local/cell\\host-win32\\sn\\ppu\\include/altivec.h" 3

# 12 "C:/usr/local/cell\\target\\ppu\\include/bits/sce_stdlib.h" 3
# 1 "C:/usr/local/cell\\target\\ppu\\include/vec_types.h" 3
/*
 * SCE CONFIDENTIAL
 * PlayStation(R)3 Programmer Tool Runtime Library 475.001
 * Copyright (C) 2008 Sony Computer Entertainment Inc. 
 * All Rights Reserved.
 */



/* SNC defined both __SNC__ and __GCC__. Need to detect __SNC__ first */
# 1 "C:/usr/local/cell\\target\\ppu\\include/vec_types_snc.h" 3
/*  SCE CONFIDENTIAL                          */
/*  PlayStation(R)3 Programmer Tool Runtime Library */
/*  Copyright (C) 2008 Sony Computer Entertainment Inc.   */
/*  All Rights Reserved.                        */




typedef vector unsigned char  qword;

typedef vector float          vec_float4;

typedef vector pixel          vec_pixel8;

typedef vector bool char      vec_bchar16;
typedef vector bool short     vec_bshort8;
typedef vector bool int       vec_bint4;
typedef vector bool int       vec_double2;

typedef vector signed char    vec_char16;
typedef vector signed short   vec_short8;
typedef vector signed int     vec_int4;
typedef vector bool short     vec_llong2;

typedef vector unsigned char  vec_uchar16;
typedef vector unsigned short vec_ushort8;
typedef vector unsigned int   vec_uint4;
typedef vector bool char      vec_ullong2;

# 13 "C:/usr/local/cell\\target\\ppu\\include/vec_types.h" 3






# 13 "C:/usr/local/cell\\target\\ppu\\include/bits/sce_stdlib.h" 3
                       
typedef struct
{
   vec_int4 quot; // quotient
   vec_int4 rem;  // remainder
} divi4_t;
                     
/** COMMON CONSTANTS AND MACROS **/


namespace std {


/** NORMAL PROTOTYPES **/
extern "C" {
vec_int4 absi4(vec_int4 x);
divi4_t divi4(vec_int4 numer, vec_int4 denom);
}



/** INLINE DEFINITIONS **/


// Simd
# 1 "C:/usr/local/cell\\target\\ppu\\include/bits/absi4.h" 3
/* SCE CONFIDENTIAL
PlayStation(R)3 Programmer Tool Runtime Library 475.001
* Copyright (C) 2011 Sony Computer Entertainment Inc. 
* All Rights Reserved.
*/
// absi4 - for each of four integer slots, compute absolute value.






extern inline vec_int4 absi4 ( vec_int4 x )
{
   return vec_abs( x );
}


# 39 "C:/usr/local/cell\\target\\ppu\\include/bits/sce_stdlib.h" 3
# 1 "C:/usr/local/cell\\target\\ppu\\include/bits/divi4.h" 3
/* SCE CONFIDENTIAL
PlayStation(R)3 Programmer Tool Runtime Library 475.001
* Copyright (C) 2011 Sony Computer Entertainment Inc. 
* All Rights Reserved.
*/

// divi4 - for each of four integer slots, compute quotient and remainder of numer/denom
// and store in divi4_t struct.  Divide by zero produces quotient = 0, remainder = numerator.







extern inline divi4_t divi4 ( vec_int4 numer, vec_int4 denom )
{
   vec_int4 minusone = (vec_int4)(-1);
   vec_uint4 zero = (vec_uint4)(0);
   vec_uint4 one = (vec_uint4)(1);
   vec_uint4 k158 = (vec_uint4)(158);
   vec_uint4 k23 = (vec_uint4)(23);
   
   divi4_t res;
   vec_uint4 numerPos, denomPos, quotNeg;
   vec_uint4 numerAbs, denomAbs;
   vec_uint4 denomZeros, numerZeros, shift, denomShifted, oneShifted;
   vec_uint4 quot, newQuot, skip, newNum, cont;
   int       anyCont;
       
   // determine whether result needs sign change
 
   numerPos = (vec_uint4)vec_cmpgt( numer, minusone );
   denomPos = (vec_uint4)vec_cmpgt( denom, minusone );
   quotNeg = vec_xor( numerPos, denomPos );
   
   // use absolute values of numerator, denominator
 
   numerAbs = (vec_uint4)vec_sel( vec_sub( (vec_int4)zero, numer ), numer, numerPos );
   denomAbs = (vec_uint4)vec_sel( vec_sub( (vec_int4)zero, denom ), denom, denomPos );
 
   // get difference of leading zeros to align denom with numer

   denomZeros = vec_sub( k158, vec_sr( (vec_uint4)vec_ctf( denomAbs, 0 ), k23 ) );
   numerZeros = vec_sub( k158, vec_sr( (vec_uint4)vec_ctf( numerAbs, 0 ), k23 ) );
      
   shift = vec_sub( denomZeros, numerZeros );
   denomShifted = vec_sl( denomAbs, shift );
   oneShifted = vec_sl( one, shift );
   oneShifted = vec_sel( oneShifted, zero, vec_or( vec_cmpeq( denomAbs, zero ), 
                                                   vec_cmpgt( denomAbs, numerAbs ) ) );
   
   // long division

   quot = zero;
   
   do
   {
      cont = (vec_uint4)vec_cmpgt( oneShifted, zero );
      anyCont = vec_any_gt( oneShifted, zero );
      skip = (vec_uint4)vec_cmpgt( denomShifted, numerAbs );
      
      newQuot = vec_or( quot, oneShifted );
      newNum = vec_sub( numerAbs, denomShifted );
      
      oneShifted = vec_sr( oneShifted, one );
      denomShifted = vec_sr( denomShifted, one );
      
      quot = vec_sel( newQuot, quot, skip );
      numerAbs = vec_sel( numerAbs, newNum, vec_andc( cont, skip ) );
   }
   while ( anyCont );

   res.quot = (vec_int4)vec_sel( quot, vec_sub( zero, quot ), quotNeg );
   res.rem = (vec_int4)vec_sel( (vec_uint4)vec_sub( (vec_int4)zero, (vec_int4)numerAbs ), numerAbs, numerPos );
   return res;
}

# 40 "C:/usr/local/cell\\target\\ppu\\include/bits/sce_stdlib.h" 3


}






using ::std:: absi4;
using ::std:: divi4;
# 346 "C:/usr/local/cell\\target\\ppu\\include/stdlib.h" 3





using ::std:: div_t; using ::std:: ldiv_t;

using ::std:: abort; using ::std:: abs; using ::std:: atexit;
using ::std:: atof; using ::std:: atoi; using ::std:: atol;
using ::std:: bsearch; using ::std:: calloc; using ::std:: div;
using ::std:: exit; using ::std:: free; 
using ::std:: labs; using ::std:: ldiv; using ::std:: malloc;
using ::std:: mblen; using ::std:: mbstowcs; using ::std:: mbtowc;
using ::std:: qsort; using ::std:: rand; 
using ::std:: realloc;
using ::std:: srand; using ::std:: strtod; using ::std:: strtol;
using ::std:: strtoul; 
using ::std:: wcstombs; using ::std:: wctomb;
using ::std:: memalign;  /* !!!GAC added nonstandard memalign*/
using ::std:: atoff;


using  ::std:: reallocalign;
using  ::std:: malloc_usable_size;
using  ::std:: malloc_stats;
using  ::std:: malloc_stats_fast;
using  ::std:: malloc_managed_size;



using ::std:: lldiv_t;

using ::std:: atoll; using ::std:: llabs; using ::std:: lldiv;
using ::std:: strtof; using ::std:: strtold;
using ::std:: strtoll; using ::std:: strtoull;
using ::std:: _Exit;


using ::std:: exitspawn; using ::std:: _Exitspawn;

using ::std:: get_state_TT800; using ::std:: init_TT800; using ::std:: init_by_array_TT800;
using ::std:: rand_int32_TT800; using ::std:: rand_int31_TT800;
using ::std:: rand_real1_TT800; using ::std:: rand_real2_TT800; using ::std:: rand_real3_TT800;



/*
 * Copyright (c) 1992-2003 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
V4.02:0216 */
# 39 "C:\\Users\\USER\\Documents\\Visual Studio 2013\\Projects\\mp3_plugin_PS3\\mp3_plugin_PS3\\main.cpp"
# 1 "C:/usr/local/cell\\target\\ppu\\include/stdint.h" 3
/* SCE CONFIDENTIAL
PlayStation(R)3 Programmer Tool Runtime Library 475.001
* Copyright (C) 2006 Sony Computer Entertainment Inc. 
* All Rights Reserved.
*/
/* stdint.h standard header */
# 201 "C:/usr/local/cell\\target\\ppu\\include/stdint.h" 3

# 220 "C:/usr/local/cell\\target\\ppu\\include/stdint.h" 3

/*
 * Copyright (c) 1992-2003 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
V4.02:0216 */
# 40 "C:\\Users\\USER\\Documents\\Visual Studio 2013\\Projects\\mp3_plugin_PS3\\mp3_plugin_PS3\\main.cpp"
# 1 "C:/usr/local/cell\\target\\ppu\\include/fastmath.h" 3
/* SCE CONFIDENTIAL
 * PlayStation(R)3 Programmer Tool Runtime Library 475.001
 * Copyright (C) 2005 Sony Computer Entertainment Inc.
 * All Rights Reserved.
 */




# 1 "C:/usr/local/cell\\target\\ppu\\include/math.h" 3
/* SCE CONFIDENTIAL
PlayStation(R)3 Programmer Tool Runtime Library 475.001
* Copyright (C) 2004 Sony Computer Entertainment Inc. 
* All Rights Reserved.
*/
/* math.h standard header */
# 1 "C:/usr/local/cell\\target\\ppu\\include/ymath.h" 3
/* SCE CONFIDENTIAL
 PlayStation(R)3 Programmer Tool Runtime Library 475.001
 * Copyright (C) 2006 Sony Computer Entertainment Inc.
 * All Rights Reserved.
 */
/* ymath.h internal header */



namespace std {
extern "C" {

		/* MACROS FOR _FPP_TYPE */
# 27 "C:/usr/local/cell\\target\\ppu\\include/ymath.h" 3

		/* MACROS FOR _Dtest RETURN (0 => ZERO) */





		/* MACROS FOR _Feraise ARGUMENT */







		/* TYPE DEFINITIONS */
typedef union
	{	/* pun float types as integer array */
	unsigned short _Word[8];
	float _Float;
	double _Double;
	long double _Long_double;
	} _Dconst;

		/* ERROR REPORTING */
void _Feraise(int);

		/* double DECLARATIONS */
double _Cosh(double, double);
short _Dtest(double *);
short _Exp(double *, double, short);
double _Log(double, int);
double _Sin(double, unsigned int);
double _Sinh(double, double);
extern /* const */ _Dconst _Denorm, _Hugeval, _Inf,
	_Nan, _Snan;

		/* float DECLARATIONS */
float _FCosh(float, float);
short _FDtest(float *);
short _FExp(float *, float, short);
float _FLog(float, int);
float _FSin(float, unsigned int);
float _FSinh(float, float);
extern /* const */ _Dconst _FDenorm, _FInf, _FNan, _FSnan;

		/* long double DECLARATIONS */
long double _LCosh(long double, long double);
short _LDtest(long double *);
short _LExp(long double *, long double, short);
long double _LLog(long double, int);
long double _LSin(long double, unsigned int);
long double _LSinh(long double, long double);
extern /* const */ _Dconst _LDenorm, _LInf, _LNan, _LSnan;

}
}


/*
 * Copyright (c) 1992-2003 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
V4.02:0216 */
# 11 "C:/usr/local/cell\\target\\ppu\\include/math.h" 3


namespace std {

		/* CODES FOR is* FUNCTIONS */




		/* CODES FOR ilogb FUNCTIONS */











		/* TYPES */

# 43 "C:/usr/local/cell\\target\\ppu\\include/math.h" 3
typedef float float_t;
typedef double double_t;


		/* MACROS */

/* #if defined(__EDG__) && 245 < __EDG_VERSION__ && !defined(__cplusplus) */
# 68 "C:/usr/local/cell\\target\\ppu\\include/math.h" 3

# 75 "C:/usr/local/cell\\target\\ppu\\include/math.h" 3




















extern "C" {
int _FFpcomp(float, float);
int _Fpcomp(double, double);
int _LFpcomp(long double, long double);

int _FDclass(float);
int _Dclass(double);
int _LDclass(long double);

int _FDsign(float);
int _Dsign(double);
int _LDsign(long double);
}









		// TEMPLATE CLASS _Rc_type
template<class _Ty>
	struct _Rc_type
	{	// determine if type is real or complex
	typedef float _Type;	// default is real
	};

		// TEMPLATE CLASS _Rc_widened
template<class _Ty, class _T2>
	struct _Rc_widened
	{	// determine real/complex type
	typedef float _Type;	// (real, real) is real
	};

		// TEMPLATE CLASS _Real_type

# 163 "C:/usr/local/cell\\target\\ppu\\include/math.h" 3
template<class _Ty>
	struct _Real_type
	{	// determine equivalent real type
	typedef double _Type;	// default is double
	};


template<> struct _Real_type<float>
	{	// determine equivalent real type
	typedef float _Type;
	};

template<> struct _Real_type<long double>
	{	// determine equivalent real type
	typedef long double _Type;
	};

		// TEMPLATE CLASS _Real_widened
template<class _Ty, class _T2>
	struct _Real_widened
	{	// determine widened real type
	typedef long double _Type;	// default is long double
	};

template<> struct _Real_widened<float, float>
	{	// determine widened real type
	typedef float _Type;
	};

template<> struct _Real_widened<float, double>
	{	// determine widened real type
	typedef double _Type;
	};

template<> struct _Real_widened<double, float>
	{	// determine widened real type
	typedef double _Type;
	};

template<> struct _Real_widened<double, double>
	{	// determine widened real type
	typedef double _Type;
	};

		// TEMPLATE CLASS _Combined_type
template<class _Trc, class _Tre>
	struct _Combined_type
	{	// determine combined type
	typedef float _Type;	// (real, float) is float
	};

template<> struct _Combined_type<float, double>
	{	// determine combined type
	typedef double _Type;
	};

template<> struct _Combined_type<float, long double>
	{	// determine combined type
	typedef long double _Type;
	};

		// TEMPLATE FUNCTION _FPCOMP
inline int _FPCOMP(float _Left, float _Right)
	{	// compare _Left and _Right
	return (_FFpcomp(_Left, _Right));
	}

inline int _FPCOMP(double _Left, double _Right)
	{	// compare _Left and _Right
	return (_Fpcomp(_Left, _Right));
	}

inline int _FPCOMP(long double _Left, long double _Right)
	{	// compare _Left and _Right
	return (_LFpcomp(_Left, _Right));
	}

template<class _T1, class _T2> inline
	int _FPCOMP(_T1 _Left, _T2 _Right)
	{	// compare _Left and _Right
	typedef typename _Combined_type<float,
		typename _Real_widened<
			typename _Real_type<_T1>::_Type,
			typename _Real_type<_T2>::_Type>::_Type>::_Type _Tw;
	return (_FPCOMP((_Tw)_Left, (_Tw)_Right));
	}

		// FUNCTION fpclassify
inline int fpclassify(float _Left)
	{	// classify argument
	return (_FDtest(&_Left));
	}

inline int fpclassify(double _Left)
	{	// classify argument
	return (_Dtest(&_Left));
	}

inline int fpclassify(long double _Left)
	{	// classify argument
	return (_LDtest(&_Left));
	}

		// FUNCTION signbit
inline bool signbit(float _Left)
	{	// test sign bit
	return (_FDsign(_Left) != 0);
	}

inline bool signbit(double _Left)
	{	// test sign bit
	return (_Dsign(_Left) != 0);
	}

inline bool signbit(long double _Left)
	{	// test sign bit
	return (_LDsign(_Left) != 0);
	}

template<class _Ty> inline
	bool isfinite(_Ty _Left)
	{	// test for finite
	return (fpclassify(_Left) <= 0);
	}

template<class _Ty> inline
	bool isinf(_Ty _Left)
	{	// test for infinite
	return (fpclassify(_Left) == 1);
	}

template<class _Ty> inline
	bool isnan(_Ty _Left)
	{	// test for NaN
	return (fpclassify(_Left) == 2);
	}

template<class _Ty> inline
	bool isnormal(_Ty _Left)
	{	// test for normal
	return (fpclassify(_Left) == (-1));
	}

template<class _Ty1, class _Ty2> inline
	bool isgreater(_Ty1 _Left, _Ty2 _Right)
	{	// test for _Left > _Right
	return ((_FPCOMP(_Left, _Right) & 4) != 0);
	}

template<class _Ty1, class _Ty2> inline
	bool isgreaterequal(_Ty1 _Left, _Ty2 _Right)
	{	// test for _Left >= _Right
	return ((_FPCOMP(_Left, _Right) & (2 | 4)) != 0);
	}

template<class _Ty1, class _Ty2> inline
	bool isless(_Ty1 _Left, _Ty2 _Right)
	{	// test for _Left < _Right
	return ((_FPCOMP(_Left, _Right) & 1) != 0);
	}

template<class _Ty1, class _Ty2> inline
	bool islessequal(_Ty1 _Left, _Ty2 _Right)
	{	// test for _Left <= _Right
	return ((_FPCOMP(_Left, _Right) & (1 | 2)) != 0);
	}

template<class _Ty1, class _Ty2> inline
	bool islessgreater(_Ty1 _Left, _Ty2 _Right)
	{	// test for _Left != _Right
	return ((_FPCOMP(_Left, _Right) & (1 | 4)) != 0);
	}

template<class _Ty1, class _Ty2> inline
	bool isunordered(_Ty1 _Left, _Ty2 _Right)
	{	// test for _Left unorderd w.r.t. _Right
	return (_FPCOMP(_Left, _Right) == 0);
	}

# 354 "C:/usr/local/cell\\target\\ppu\\include/math.h" 3

# 427 "C:/usr/local/cell\\target\\ppu\\include/math.h" 3






extern "C" {
		/* double declarations */
double acos(double);
double asin(double);
double atan(double);
double atan2(double, double);
double ceil(double);
double exp(double);
double fabs(double);
double floor(double);
double fmod(double, double);
double frexp(double, int *);
double ldexp(double, int);
double modf(double, double *);
double pow(double, double);
double sqrt(double);
double tan(double);
double tanh(double);


double acosh(double);
double asinh(double);
double atanh(double);
double cbrt(double);
double copysign(double, double);
double erf(double);
double erfc(double);
double exp2(double);
double expm1(double);
double fdim(double, double);
double fma(double, double, double);
double fmax(double, double);
double fmin(double, double);
double hypot(double, double);
int ilogb(double);
double lgamma(double);
_Longlong llrint(double);
_Longlong llround(double);
double log1p(double);
double logb(double);
long lrint(double);
long lround(double);
double nan(const char *);
double nearbyint(double);
double nextafter(double, double);
double nexttoward(double, long double);
double remainder(double, double);
double remquo(double, double, int *);
double rint(double);
double round(double);
double scalbn(double, int);
double scalbln(double, long);
double tgamma(double);
double trunc(double);


		/* float declarations */
float acosf(float);
float asinf(float);
float atanf(float);
float atan2f(float, float);
float ceilf(float);
float expf(float);
float fabsf(float);
float floorf(float);
float fmodf(float, float);
float frexpf(float, int *);
float ldexpf(float, int);
float modff(float, float *);
float powf(float, float);
float sqrtf(float);
float tanf(float);
float tanhf(float);


float acoshf(float);
float asinhf(float);
float atanhf(float);
float cbrtf(float);
float copysignf(float, float);
float erff(float);
float erfcf(float);
float expm1f(float);
float exp2f(float);
float fdimf(float, float);
float fmaf(float, float, float);
float fmaxf(float, float);
float fminf(float, float);
float hypotf(float, float);
int ilogbf(float);
float lgammaf(float);
_Longlong llrintf(float);
_Longlong llroundf(float);
float log1pf(float);
float logbf(float);
long lrintf(float);
long lroundf(float);
float nanf(const char *);
float nearbyintf(float);
float nextafterf(float, float);
float nexttowardf(float, long double);
float remainderf(float, float);
float remquof(float, float, int *);
float rintf(float);
float roundf(float);
float scalbnf(float, int);
float scalblnf(float, long);
float tgammaf(float);
float truncf(float);


		/* long double declarations */
long double acosl(long double);
long double asinl(long double);
long double atanl(long double);
long double atan2l(long double, long double);
long double ceill(long double);
long double expl(long double);
long double fabsl(long double);
long double floorl(long double);
long double fmodl(long double, long double);
long double frexpl(long double, int *);
long double ldexpl(long double, int);
long double modfl(long double, long double *);
long double powl(long double, long double);
long double sqrtl(long double);
long double tanl(long double);
long double tanhl(long double);


long double acoshl(long double);
long double asinhl(long double);
long double atanhl(long double);
long double cbrtl(long double);
long double copysignl(long double, long double);
long double erfl(long double);
long double erfcl(long double);
long double exp2l(long double);
long double expm1l(long double);
long double fdiml(long double, long double);
long double fmal(long double, long double, long double);
long double fmaxl(long double, long double);
long double fminl(long double, long double);
long double hypotl(long double, long double);
int ilogbl(long double);
long double lgammal(long double);
_Longlong llrintl(long double);
_Longlong llroundl(long double);
long double log1pl(long double);
long double logbl(long double);
long lrintl(long double);
long lroundl(long double);
long double nanl(const char *);
long double nearbyintl(long double);
long double nextafterl(long double, long double);
long double nexttowardl(long double, long double);
long double remainderl(long double, long double);
long double remquol(long double, long double, int *);
long double rintl(long double);
long double roundl(long double);
long double scalbnl(long double, int);
long double scalblnl(long double, long);
long double tgammal(long double);
long double truncl(long double);


}






		// TEMPLATE FUNCTION _Pow_int
template<class _Ty> inline
	_Ty _Pow_int(_Ty _Left, int _Right)
	{	// raise to integer power
	unsigned int _Num = _Right;
	if (_Right < 0)
		_Num = 0 - _Num;

	for (_Ty _Ans = 1; ; _Left *= _Left)
		{	// scale and fold in factors
		if ((_Num & 1) != 0)
			_Ans *= _Left;
		if ((_Num >>= 1) == 0)
			return (0 <= _Right ? _Ans
				: _Ans == _Ty(0) ? ((double)((float)(1e+30F * 1e+30F))) : _Ty(1) / _Ans);
		}
	}


		// double INLINES, FOR C++
extern "C" {
inline double cos(double _Left)
	{	// return cosine
	return (_Sin(_Left, 1));
	}

inline double cosh(double _Left)
	{	// return hyperbolic cosine
	return (_Cosh(_Left, 1));
	}

inline double log(double _Left)
	{	// return natural logarithm
	return (_Log(_Left, 0));
	}

inline double log10(double _Left)
	{	// return base-10 logarithm
	return (_Log(_Left, 1));
	}

inline double sin(double _Left)
	{	// return sine
	return (_Sin(_Left, 0));
	}

inline double sinh(double _Left)
	{	// return hyperbolic sine
	return (_Sinh(_Left, 1));
	}


inline double log2(double _Left)
	{	// return base-2 logarithm
	return (_Log(_Left, -1));
	}


}

inline double abs(double _Left)	// OVERLOADS
	{	// return absolute value
	return (__builtin_fabs(_Left));
	}

# 687 "C:/usr/local/cell\\target\\ppu\\include/math.h" 3
inline double pow(double _Left, int _Right)
	{	// raise to integer power
	return (_Pow_int(_Left, _Right));
	}


		// float INLINES, FOR C++
extern "C" {
inline float cosf(float _Left)
	{	// return cosine
	return (_FSin(_Left, 1));
	}

inline float coshf(float _Left)
	{	// return hyperbolic cosine
	return (_FCosh(_Left, 1));
	}

inline float logf(float _Left)
	{	// return natural logarithm
	return (_FLog(_Left, 0));
	}

inline float log10f(float _Left)
	{	// return base-10 logarithm
	return (_FLog(_Left, 1));
	}

inline float sinf(float _Left)
	{	// return sine
	return (_FSin(_Left, 0));
	}

inline float sinhf(float _Left)
	{	// return hyperbolic sine
	return (_FSinh(_Left, 1));
	}


inline float log2f(float _Left)
	{	// return base-2 logarithm
	return (_FLog(_Left, -1));
	}


}

inline float abs(float _Left)	// OVERLOADS
	{	// return absolute value
	return (__builtin_fabsf(_Left));
	}

inline float acos(float _Left)
	{	// return arccosine
	return (acosf(_Left));
	}

inline float asin(float _Left)
	{	// return arcsine
	return (asinf(_Left));
	}

inline float atan(float _Left)
	{	// return arctangent
	return (atanf(_Left));
	}

inline float atan2(float _Left, float _Right)
	{	// return arctangent
	return (atan2f(_Left, _Right));
	}

inline float ceil(float _Left)
	{	// return ceiling
	return (ceilf(_Left));
	}

inline float cos(float _Left)
	{	// return cosine
	return (_FSin(_Left, 1));
	}

inline float cosh(float _Left)
	{	// return hyperbolic cosine
	return (_FCosh(_Left, 1));
	}

inline float exp(float _Left)
	{	// return exponential
	return (expf(_Left));
	}

inline float fabs(float _Left)
	{	// return absolute value
	return (__builtin_fabsf(_Left));
	}

inline float floor(float _Left)
	{	// return floor
	return (floorf(_Left));
	}

inline float fmod(float _Left, float _Right)
	{	// return modulus
	return (fmodf(_Left, _Right));
	}

inline float frexp(float _Left, int *_Right)
	{	// unpack exponent
	return (frexpf(_Left, _Right));
	}

inline float ldexp(float _Left, int _Right)
	{	// pack exponent
	return (ldexpf(_Left, _Right));
	}

inline float log(float _Left)
	{	// return natural logarithm
	return (_FLog(_Left, 0));
	}

inline float log10(float _Left)
	{	// return base-10 logarithm
	return (_FLog(_Left, 1));
	}

inline float modf(float _Left, float *_Right)
	{	// unpack fraction
	return (modff(_Left, _Right));
	}

inline float pow(float _Left, float _Right)
	{	// raise to power
	return (powf(_Left, _Right));
	}

# 840 "C:/usr/local/cell\\target\\ppu\\include/math.h" 3
inline float pow(float _Left, int _Right)
	{	// raise to integer power
	return (_Pow_int(_Left, _Right));
	}


inline float sin(float _Left)
	{	// return sine
	return (_FSin(_Left, 0));
	}

inline float sinh(float _Left)
	{	// return hyperbolic sine
	return (_FSinh(_Left, 1));
	}

inline float sqrt(float _Left)
	{	// return square root

	return (sqrtf(_Left));



	}

inline float tan(float _Left)
	{	// return tangent
	return (tanf(_Left));
	}

inline float tanh(float _Left)
	{	// return hyperbolic tangent
	return (tanhf(_Left));
	}


inline float acosh(float _Left)
	{	// return hyperbolic arccosine
	return (acoshf(_Left));
	}

inline float asinh(float _Left)
	{	// return hyperbolic arcsine
	return (asinhf(_Left));
	}

inline float atanh(float _Left)
	{	// return hyperbolic arctangent
	return (atanhf(_Left));
	}

inline float cbrt(float _Left)
	{	// return cube root
	return (cbrtf(_Left));
	}

inline float copysign(float _Left, float _Right)
	{	// return copysign
	return (copysignf(_Left, _Right));
	}

inline float erf(float _Left)
	{	// return erf
 	return (erff(_Left)); }

inline float erfc(float _Left)
	{	// return erfc
	return (erfcf(_Left));
	}

inline float exp2(float _Left)
	{	// return exp2
	return (exp2f(_Left));
	}

inline float expm1(float _Left)
	{	// return expml
	return (expm1f(_Left));
	}

inline float fdim(float _Left, float _Right)
	{	// return fdim
	return (fdimf(_Left, _Right));
	}

inline float fma(float _Left, float _Right, float _Addend)
	{	// return fma
	return (fmaf(_Left, _Right, _Addend));
	}

inline float fmax(float _Left, float _Right)
	{	// return fmax
	return (fmaxf(_Left, _Right));
	}

inline float fmin(float _Left, float _Right)
	{	// return fmin
	return (fminf(_Left, _Right));
	}

inline float hypot(float _Left, float _Right)
	{	// return hypot
	return (hypotf(_Left, _Right));
	}

inline int ilogb(float _Left)
	{	// return ilogb
	return (ilogbf(_Left));
	}

inline float lgamma(float _Left)
	{	// return lgamma
	return (lgammaf(_Left));
	}

inline _Longlong llrint(float _Left)
	{	// return llrint
	return (llrintf(_Left));
	}

inline _Longlong llround(float _Left)
	{	// return llround
	return (llroundf(_Left));
	}

inline float log1p(float _Left)
	{	// return loglp
	return (log1pf(_Left));
	}

inline float log2(float _Left)
	{	// return log2
	return (_FLog(_Left, -1));
	}

inline float logb(float _Left)
	{	// return logb
	return (logbf(_Left));
	}

inline long lrint(float _Left)
	{	// return lrint
	return (lrintf(_Left));
	}

inline long lround(float _Left)
	{	// return lround
	return (lroundf(_Left));
	}

inline float nearbyint(float _Left)
	{	// return nearbyint
	return (nearbyintf(_Left));
	}

inline float nextafter(float _Left, float _Right)
	{	// return nextafter
	return (nextafterf(_Left, _Right));
	}

inline float nexttoward(float _Left, long double _Right)
	{	// return nexttoward
	return (nexttowardf(_Left, _Right));
	}

inline float remainder(float _Left, float _Right)
	{	// return remainder
	return (remainderf(_Left, _Right));
	}

inline float remquo(float _Left, float _Right, int *_Pval)
	{	// return remquo
	return (remquof(_Left, _Right, _Pval));
	}

inline float rint(float _Left)
	{	// return rint
	return (rintf(_Left));
	}

inline float round(float _Left)
	{	// return round
	return (roundf(_Left));
	}

inline float scalbn(float _Left, int _Right)
	{	// return scalbn
	return (scalbnf(_Left, _Right));
	}

inline float scalbln(float _Left, long _Right)
	{	// return scalbln
	return (scalblnf(_Left, _Right));
	}

inline float tgamma(float _Left)
	{	// return tgamma
	return (tgammaf(_Left));
	}

inline float trunc(float _Left)
	{	// return trunc
	return (truncf(_Left));
	}


		// long double INLINES, FOR C++
extern "C" {
inline long double cosl(long double _Left)
	{	// return cosine
	return (_LSin(_Left, 1));
	}

inline long double coshl(long double _Left)
	{	// return hyperbolic cosine
	return (_LCosh(_Left, 1));
	}

inline long double logl(long double _Left)
	{	// return natural logarithm
	return (_LLog(_Left, 0));
	}

inline long double log10l(long double _Left)
	{	// return base-10 logarithm
	return (_LLog(_Left, 1));
	}

inline long double sinl(long double _Left)
	{	// return sine
	return (_LSin(_Left, 0));
	}

inline long double sinhl(long double _Left)
	{	// return hyperbolic sine
	return (_LSinh(_Left, 1));
	}


inline long double log2l(long double _Left)
	{	// return base-2 logarithm
	return (_LLog(_Left, -1));
	}


}

inline long double abs(long double _Left)	// OVERLOADS
	{	// return absolute value
	return (fabsl(_Left));
	}

inline long double acos(long double _Left)
	{	// return arccosine
	return (acosl(_Left));
	}

inline long double asin(long double _Left)
	{	// return arcsine
	return (asinl(_Left));
	}

inline long double atan(long double _Left)
	{	// return arctangent
	return (atanl(_Left));
	}

inline long double atan2(long double _Left, long double _Right)
	{	// return arctangent
	return (atan2l(_Left, _Right));
	}

inline long double ceil(long double _Left)
	{	// return ceiling
	return (ceill(_Left));
	}

inline long double cos(long double _Left)
	{	// return cosine
	return (_LSin(_Left, 1));
	}

inline long double cosh(long double _Left)
	{	// return hyperbolic cosine
	return (_LCosh(_Left, 1));
	}

inline long double exp(long double _Left)
	{	// return exponential
	return (expl(_Left));
	}

inline long double fabs(long double _Left)
	{	// return absolute value
	return (fabsl(_Left));
	}

inline long double floor(long double _Left)
	{	// return floor
	return (floorl(_Left));
	}

inline long double fmod(long double _Left, long double _Right)
	{	// return modulus
	return (fmodl(_Left, _Right));
	}

inline long double frexp(long double _Left, int *_Right)
	{	// unpack exponent
	return (frexpl(_Left, _Right));
	}

inline long double ldexp(long double _Left, int _Right)
	{	// pack exponent
	return (ldexpl(_Left, _Right));
	}

inline long double log(long double _Left)
	{	// return natural logarithm
	return (_LLog(_Left, 0));
	}

inline long double log10(long double _Left)
	{	// return base-10 logarithm
	return (_LLog(_Left, 1));
	}

inline long double modf(long double _Left, long double *_Right)
	{	// unpack fraction
	return (modfl(_Left, _Right));
	}

inline long double pow(long double _Left, long double _Right)
	{	// raise to power
	return (powl(_Left, _Right));
	}

# 1193 "C:/usr/local/cell\\target\\ppu\\include/math.h" 3
inline long double pow(long double _Left, int _Right)
	{	// raise to integer power
	return (_Pow_int(_Left, _Right));
	}


inline long double sin(long double _Left)
	{	// return sine
	return (_LSin(_Left, 0));
	}

inline long double sinh(long double _Left)
	{	// return hyperbolic sine
	return (_LSinh(_Left, 1));
	}

inline long double sqrt(long double _Left)
	{	// return square root
	return (sqrtl(_Left));
	}

inline long double tan(long double _Left)
	{	// return tangent
	return (tanl(_Left));
	}

inline long double tanh(long double _Left)
	{	// return hyperbolic tangent
	return (tanhl(_Left));
	}


inline long double acosh(long double _Left)
	{	// return acosh
	return (acoshl(_Left));
	}

inline long double asinh(long double _Left)
	{	// return asinh
	return (asinhl(_Left));
	}

inline long double atanh(long double _Left)
	{	// return atanh
	return (atanhl(_Left));
	}

inline long double cbrt(long double _Left)
	{	// return cbrt
	return (cbrtl(_Left));
	}

inline long double copysign(long double _Left, long double _Right)
	{	// return copysign
	return (copysignl(_Left, _Right));
	}

inline long double erf(long double _Left)
	{	// return erf
	return (erfl(_Left));
	}

inline long double erfc(long double _Left)
	{	// return erfc
	return (erfcl(_Left));
	}

inline long double exp2(long double _Left)
	{	// return exp2
	return (exp2l(_Left));
	}

inline long double expm1(long double _Left)
	{	// return expml
	return (expm1l(_Left));
	}

inline long double fdim(long double _Left, long double _Right)
	{	// return fdim
	return (fdiml(_Left, _Right));
	}

inline long double fma(long double _Left, long double _Right,
	long double _Addend)
	{	// return fma
	return (fmal(_Left, _Right, _Addend));
	}

inline long double fmax(long double _Left, long double _Right)
	{	// return fmax
	return (fmaxl(_Left, _Right));
	}

inline long double fmin(long double _Left, long double _Right)
	{	// return fmin
	return (fminl(_Left, _Right));
	}

inline long double hypot(long double _Left, long double _Right)
	{	// return hypot
	return (hypotl(_Left, _Right));
	}

inline int ilogb(long double _Left)
	{	// return ilogb
	return (ilogbl(_Left));
	}

inline long double lgamma(long double _Left)
	{	// return lgamma
	return (lgammal(_Left));
	}

inline _Longlong llrint(long double _Left)
	{	// return llrint
	return (llrintl(_Left));
	}

inline _Longlong llround(long double _Left)
	{	// return llround
	return (llroundl(_Left));
	}

inline long double log1p(long double _Left)
	{	// return loglp
	return (log1pl(_Left));
	}

inline long double log2(long double _Left)
	{	// return log2
	return (_LLog(_Left, -1));
	}

inline long double logb(long double _Left)
	{	// return logb
	return (logbl(_Left));
	}

inline long lrint(long double _Left)
	{	// return lrint
	return (lrintl(_Left));
	}

inline long lround(long double _Left)
	{	// return lround
	return (lroundl(_Left));
	}

inline long double nearbyint(long double _Left)
	{	// return nearbyint
	return (nearbyintl(_Left));
	}

inline long double nextafter(long double _Left, long double _Right)
	{	// return nextafter
	return (nextafterl(_Left, _Right));
	}

inline long double nexttoward(long double _Left, long double _Right)
	{	// return nexttoward
	return (nexttowardl(_Left, _Right));
	}

inline long double remainder(long double _Left, long double _Right)
	{	// return remainder
	return (remainderl(_Left, _Right));
	}

inline long double remquo(long double _Left, long double _Right,
	int *_Pval)
	{	// return remquo
	return (remquol(_Left, _Right, _Pval));
	}

inline long double rint(long double _Left)
	{	// return rint
	return (rintl(_Left));
	}

inline long double round(long double _Left)
	{	// return round
	return (roundl(_Left));
	}

inline long double scalbn(long double _Left, int _Right)
	{	// return scalbn
	return (scalbnl(_Left, _Right));
	}

inline long double scalbln(long double _Left, long _Right)
	{	// return scalbln
	return (scalblnl(_Left, _Right));
	}

inline long double tgamma(long double _Left)
	{	// return tgamma
	return (tgammal(_Left));
	}

inline long double trunc(long double _Left)
	{	// return trunc
	return (truncl(_Left));
	}


# 1465 "C:/usr/local/cell\\target\\ppu\\include/math.h" 3

/** define M_PI **/
/** Notice that this value is defined as a single precision constant. **/






}


/* Only include the SCE extensions when altivec is enabled */
# 1 "C:/usr/local/cell\\target\\ppu\\include/bits/sce_math.h" 3
/* SCE CONFIDENTIAL
PlayStation(R)3 Programmer Tool Runtime Library 475.001
* Copyright (C) 2004 Sony Computer Entertainment Inc. 
* All Rights Reserved.
*/



/** COMMON INCLUDES **/





namespace std {

/** PROTOTYPES **/
extern "C" {

/* SCE vector versions of estimated or non-standard functions. 
   These functions are estimated vector versions of standard C functions
   or functions that do not correspond to any standard C function.  */

extern inline vec_float4 acosf4fast(vec_float4 x);
extern inline vec_float4 asinf4fast(vec_float4 x);
extern inline vec_float4 atan2f4fast(vec_float4 y, vec_float4 x);
extern inline vec_float4 atanf4fast(vec_float4 x);
extern inline vec_float4 cbrtf4fast(vec_float4 x);
extern inline vec_float4 cosf4fast(vec_float4 x);
extern inline vec_float4 divf4(vec_float4 x, vec_float4 y);
extern inline vec_float4 divf4fast(vec_float4 x, vec_float4 y);
extern inline vec_float4 exp2f4fast(vec_float4 x);
extern inline vec_float4 expf4fast(vec_float4 x);
extern inline vec_float4 expm1f4fast(vec_float4 x);
extern inline vec_float4 log10f4fast(vec_float4 x);
extern inline vec_float4 log1pf4fast(vec_float4 x);
extern inline vec_float4 log2f4fast(vec_float4 x);
extern inline vec_float4 logf4fast(vec_float4 x);
extern inline vec_float4 negatef4(vec_float4 x);
extern inline vec_float4 powf4fast(vec_float4 x, vec_float4 y);
extern inline vec_float4 recipf4(vec_float4 x);
extern inline vec_float4 recipf4fast(vec_float4 x);
extern inline vec_float4 rsqrtf4(vec_float4 x);
extern inline vec_float4 rsqrtf4fast(vec_float4 x);
extern inline void       sincosf4fast(vec_float4 x, vec_float4* s, vec_float4* c);
extern inline vec_float4 sinf4fast(vec_float4 x);
extern inline vec_float4 sqrtf4fast(vec_float4 x);
extern inline vec_float4 tanf4fast(vec_float4 x);

/* SCE vector version of standard functions. 
   These functions are vector versions of the standard C functions. */

extern inline vec_float4 acosf4(vec_float4);
extern inline vec_float4 asinf4(vec_float4);
extern inline vec_float4 atanf4(vec_float4);
extern inline vec_float4 atan2f4(vec_float4, vec_float4);
extern inline vec_float4 ceilf4(vec_float4);
extern inline vec_float4 copysignf4(vec_float4, vec_float4);
extern inline vec_float4 cosf4(vec_float4 x);
extern inline vec_float4 expf4(vec_float4);
extern inline vec_float4 fabsf4(vec_float4);
extern inline vec_float4 floorf4(vec_float4);
extern inline vec_float4 fmaxf4(vec_float4, vec_float4);
extern inline vec_float4 fminf4(vec_float4, vec_float4);
extern inline vec_float4 fmodf4(vec_float4, vec_float4);
extern inline vec_float4 frexpf4(vec_float4, vec_int4 *);
extern inline vec_float4 ldexpf4(vec_float4, vec_int4);
extern inline vec_float4 logf4(vec_float4);
extern inline vec_float4 log10f4(vec_float4);
extern inline vec_float4 modff4(vec_float4, vec_float4*);
extern inline vec_float4 remainderf4(vec_float4, vec_float4);
extern inline void       sincosf4(vec_float4 x, vec_float4* s, vec_float4* c);
extern inline vec_float4 powf4(vec_float4, vec_float4);
extern inline vec_float4 sinf4(vec_float4 x);
extern inline vec_float4 sqrtf4(vec_float4 x);
extern inline vec_float4 tanf4(vec_float4 x);
extern inline vec_float4 truncf4(vec_float4);

extern inline vec_float4 cbrtf4(vec_float4);
extern inline vec_float4 expm1f4(vec_float4);
extern inline vec_float4 exp2f4(vec_float4);
extern inline vec_float4 fdimf4(vec_float4, vec_float4);
extern inline vec_float4 fmaf4(vec_float4, vec_float4, vec_float4);
extern inline vec_float4 hypotf4(vec_float4, vec_float4);
extern inline vec_int4 ilogbf4(vec_float4);


extern inline vec_float4 log1pf4(vec_float4);
extern inline vec_float4 log2f4(vec_float4);
extern inline vec_float4 logbf4(vec_float4);

}


/** INLINE DEFINITIONS **/



/* SIMD */
/* Eric */
# 1 "C:/usr/local/cell\\target\\ppu\\include/bits/truncf4.h" 3
/* SCE CONFIDENTIAL
PlayStation(R)3 Programmer Tool Runtime Library 475.001
* Copyright (C) 2011 Sony Computer Entertainment Inc. 
* All Rights Reserved.
*/




// truncf4 - for each of four float slots, round towards zero to integer value.




extern inline vec_float4 truncf4 ( vec_float4 x )
{
   return vec_trunc( x );
}

# 102 "C:/usr/local/cell\\target\\ppu\\include/bits/sce_math.h" 3
# 1 "C:/usr/local/cell\\target\\ppu\\include/bits/ceilf4.h" 3
/* SCE CONFIDENTIAL
PlayStation(R)3 Programmer Tool Runtime Library 475.001
* Copyright (C) 2011 Sony Computer Entertainment Inc. 
* All Rights Reserved.
*/
// ceilf4 - for each of four float slots, round up to smallest integer not less than the value.







extern inline vec_float4 ceilf4 ( vec_float4 x )
{
   return vec_ceil( x );
}

# 103 "C:/usr/local/cell\\target\\ppu\\include/bits/sce_math.h" 3
# 1 "C:/usr/local/cell\\target\\ppu\\include/bits/copysignf4.h" 3
/* SCE CONFIDENTIAL
PlayStation(R)3 Programmer Tool Runtime Library 475.001
* Copyright (C) 2011 Sony Computer Entertainment Inc. 
* All Rights Reserved.
*/
// copysignf4 - for each of four float slots, return value with magnitude from x and sign from y.







extern inline vec_float4 copysignf4 ( vec_float4 x, vec_float4 y )
{
   vec_uint4 smask = (vec_uint4)(vec_int4)(-1);
   smask = vec_vslw(smask, smask);
   return vec_sel(x, y, smask);
}

# 104 "C:/usr/local/cell\\target\\ppu\\include/bits/sce_math.h" 3
# 1 "C:/usr/local/cell\\target\\ppu\\include/bits/divf4.h" 3
/* SCE CONFIDENTIAL
 * PlayStation(R)3 Programmer Tool Runtime Library 475.001
 * Copyright (C) 2011 Sony Computer Entertainment Inc. 
 * All Rights Reserved.
 */
// divf4 - for each of four float slots, divide numer by denom.







extern inline vec_float4 divf4 ( vec_float4 numer, vec_float4 denom )
{  
   // Reciprocal estimate and 1 Newton-Raphson iteration.
   vec_uint4 mask = (vec_uint4)(vec_int4)(-1);
   vec_float4 vnzero = (vec_float4)vec_vslw(mask, mask);
   vec_float4 y0, y0numer;

   y0 = vec_re(denom);
   y0numer = vec_madd(numer, y0, vnzero);
   y0 = vec_madd(vec_nmsub(denom, y0, (vec_float4)(1.0f) ), y0numer, y0numer);

   return vec_sel(y0numer, y0, vec_cmpeq(y0, y0));
}

# 105 "C:/usr/local/cell\\target\\ppu\\include/bits/sce_math.h" 3
# 1 "C:/usr/local/cell\\target\\ppu\\include/bits/divf4fast.h" 3
/* SCE CONFIDENTIAL
 * PlayStation(R)3 Programmer Tool Runtime Library 475.001
 * Copyright (C) 2011 Sony Computer Entertainment Inc. 
 * All Rights Reserved.
 */
// divf4fast - for each of four float slots, compute estimate of numer/denom as
// product of numer and 12-bit-accurate reciprocal estimate of denom.







extern inline vec_float4 divf4fast ( vec_float4 numer, vec_float4 denom )
{
   vec_float4 vzero = (vec_float4)vec_xor((vec_uint4)(0), (vec_uint4)(0));
   return vec_madd( numer, vec_re( denom ), vzero);
}

# 106 "C:/usr/local/cell\\target\\ppu\\include/bits/sce_math.h" 3
# 1 "C:/usr/local/cell\\target\\ppu\\include/bits/fabsf4.h" 3
/* SCE CONFIDENTIAL
PlayStation(R)3 Programmer Tool Runtime Library 475.001
* Copyright (C) 2011 Sony Computer Entertainment Inc. 
* All Rights Reserved.
*/
// fabsf4 - for each of four float slots, compute absolute value.







extern inline vec_float4 fabsf4 ( vec_float4 x )
{
   return vec_abs( x );
}

# 107 "C:/usr/local/cell\\target\\ppu\\include/bits/sce_math.h" 3
# 1 "C:/usr/local/cell\\target\\ppu\\include/bits/floorf4.h" 3
/* SCE CONFIDENTIAL
PlayStation(R)3 Programmer Tool Runtime Library 475.001
* Copyright (C) 2011 Sony Computer Entertainment Inc. 
* All Rights Reserved.
*/
// floorf4 - for each of four float slots, round down to largest integer not greater than the value.







extern inline vec_float4 floorf4 ( vec_float4 x )
{
   return vec_floor( x );
}

# 108 "C:/usr/local/cell\\target\\ppu\\include/bits/sce_math.h" 3
# 1 "C:/usr/local/cell\\target\\ppu\\include/bits/fmaxf4.h" 3
/* SCE CONFIDENTIAL
PlayStation(R)3 Programmer Tool Runtime Library 475.001
* Copyright (C) 2011 Sony Computer Entertainment Inc. 
* All Rights Reserved.
*/
// fmaxf4 - for each of four float slots, compute maximum of x and y
                    


      



extern inline vec_float4 fmaxf4 ( vec_float4 x, vec_float4 y )
{
   return vec_max( x, y );
}

# 109 "C:/usr/local/cell\\target\\ppu\\include/bits/sce_math.h" 3
# 1 "C:/usr/local/cell\\target\\ppu\\include/bits/fminf4.h" 3
/* SCE CONFIDENTIAL
PlayStation(R)3 Programmer Tool Runtime Library 475.001
* Copyright (C) 2011 Sony Computer Entertainment Inc. 
* All Rights Reserved.
*/
// fminf4 - for each of four float slots, compute minimum of x and y
         






extern inline vec_float4 fminf4 ( vec_float4 x, vec_float4 y )
{
   return vec_min( x, y );
}

# 110 "C:/usr/local/cell\\target\\ppu\\include/bits/sce_math.h" 3
# 1 "C:/usr/local/cell\\target\\ppu\\include/bits/fmodf4.h" 3
/* SCE CONFIDENTIAL
 * PlayStation(R)3 Programmer Tool Runtime Library 475.001
 * Copyright (C) 2011 Sony Computer Entertainment Inc. 
 * All Rights Reserved.
 */
// fmodf4 - for each of four float slots, compute remainder of x/y defined as x - truncated_integer(x/y) * y.
//
// This returns an accurate result when |divf4(x,y)| < 2^20 and |x| < 2^128, and otherwise returns zero.
// If x == 0, the result is 0.
// If x != 0 and y == 0, the result is undefined.







extern inline vec_float4 fmodf4 ( vec_float4 x, vec_float4 y )
{
   vec_float4 q, xabs, yabs, qabs;
   vec_int4   qi0, qi1, qi2;
   vec_float4 i0, i1, i2, r1, r2, i;
   vec_uint4  inrange;
   vec_float4 vzero = (vec_float4)vec_xor((vec_uint4)(0), (vec_uint4)(0));
   vec_uint4 iszero = (vec_uint4)vec_cmpeq(x, vzero);
 
   // Find i = truncated_integer(|x/y|)
 
   // If |divf4(x,y)| < 2^20, the quotient is at most off by 1.0.
   // Thus i is either the truncated quotient, one less, or one greater.
                                                                                
   q = divf4( x, y );
   xabs = fabsf4( x );
   yabs = fabsf4( y );
   qabs = fabsf4( q );
                                                                                
   inrange = (vec_uint4)vec_cmpgt( (vec_float4)((vec_uint4)(0x49800000)), qabs );
                                                                                
   qi1 = vec_cts( qabs, 0 );
   qi0 = vec_add( qi1, (vec_int4)(-1) );
   qi2 = vec_add( qi1, (vec_int4)(1) );
                                                                                                                                                          
   i0 = vec_ctf( qi0, 0 );
   i1 = vec_ctf( qi1, 0 );
   i2 = vec_ctf( qi2, 0 );
                                                                                                                                                          
   // Correct i will be the largest one such that |x| - i*|y| >= 0.
                                                                                                                                                          
   r1 = vec_nmsub( i1, yabs, xabs );
   r2 = vec_nmsub( i2, yabs, xabs );
                                                                                                                                                          
   i = i0;
   i = vec_sel( i1, i, (vec_uint4)vec_cmpgt( vzero, r1 ) );
   i = vec_sel( i2, i, (vec_uint4)vec_cmpgt( vzero, r2 ) );
                                                                                                                                                          
   i = copysignf4( i, q );
                                                                                                                                                          
   return vec_sel(vec_sel((vec_float4)vzero, vec_nmsub( i, y, x ), inrange),
		  x, iszero);
}

# 111 "C:/usr/local/cell\\target\\ppu\\include/bits/sce_math.h" 3
# 1 "C:/usr/local/cell\\target\\ppu\\include/bits/modff4.h" 3
/* SCE CONFIDENTIAL
PlayStation(R)3 Programmer Tool Runtime Library 475.001
* Copyright (C) 2011 Sony Computer Entertainment Inc. 
* All Rights Reserved.
*/
// modff4 - for each of four float slots, compute fractional and integral parts.
// Returns fractional part and stores integral part in *iptr.







extern inline vec_float4 modff4 ( vec_float4 x, vec_float4 *iptr )
{
   vec_float4 integral, fraction;
 
   integral = truncf4( x );
   fraction = vec_sub( x, integral );
 
   *iptr = integral;
   return fraction;
}

# 112 "C:/usr/local/cell\\target\\ppu\\include/bits/sce_math.h" 3
# 1 "C:/usr/local/cell\\target\\ppu\\include/bits/negatef4.h" 3
/* SCE CONFIDENTIAL
 * PlayStation(R)3 Programmer Tool Runtime Library 475.001
 * Copyright (C) 2011 Sony Computer Entertainment Inc. 
 * All Rights Reserved.
 */
// negatef4 - for each of four float slots, negate the sign bit.







extern inline vec_float4 negatef4 ( vec_float4 x )
{
   vec_uint4 smask = (vec_uint4)(vec_int4)(-1);
   smask = vec_vslw(smask, smask);
   return (vec_float4)vec_xor( (vec_uint4)x, smask );
}

# 113 "C:/usr/local/cell\\target\\ppu\\include/bits/sce_math.h" 3
# 1 "C:/usr/local/cell\\target\\ppu\\include/bits/recipf4.h" 3
/* SCE CONFIDENTIAL
 * PlayStation(R)3 Programmer Tool Runtime Library 475.001
 * Copyright (C) 2011 Sony Computer Entertainment Inc. 
 * All Rights Reserved.
 */
// recipf4 - for each of four float slots, compute reciprocal.
                     


                                             



extern inline vec_float4 recipf4 ( vec_float4 x )
{ 
   // Reciprocal estimate and 1 Newton-Raphson iteration.
 
   vec_float4 y0 = vec_re( x );
   vec_float4 res = vec_madd( vec_nmsub( x, y0, (vec_float4)(1.0f) ), y0, y0 );
   return vec_sel(y0, res, vec_cmpeq(res, res));
}

# 114 "C:/usr/local/cell\\target\\ppu\\include/bits/sce_math.h" 3
# 1 "C:/usr/local/cell\\target\\ppu\\include/bits/recipf4fast.h" 3
/* SCE CONFIDENTIAL
PlayStation(R)3 Programmer Tool Runtime Library 475.001
* Copyright (C) 2011 Sony Computer Entertainment Inc. 
* All Rights Reserved.
*/




// recipf4fast - for each of four float slots, compute reciprocal estimate 
// accurate to 12 bits of mantissa.




extern inline vec_float4 recipf4fast ( vec_float4 x )
{
   return vec_re( x );
}

# 115 "C:/usr/local/cell\\target\\ppu\\include/bits/sce_math.h" 3
# 1 "C:/usr/local/cell\\target\\ppu\\include/bits/remainderf4.h" 3
/* SCE CONFIDENTIAL
 * PlayStation(R)3 Programmer Tool Runtime Library 475.001
 * Copyright (C) 2011 Sony Computer Entertainment Inc. 
 * All Rights Reserved.
 */




// remainderf4 - for each of four float slots, compute remainder of x/y defined as x - nearest_integer(x/y) * y.
//
// This returns an accurate result when |divf4(x,y)| < 2^20 and |x| < 2^128, and otherwise returns zero.
// If x == 0, the result is 0.
// If x != 0 and y == 0, the result is undefined.




extern inline vec_float4 remainderf4 ( vec_float4 x, vec_float4 y )
{
   vec_float4 q, xabs, yabs, qabs, yabshalf;
   vec_int4   qi0, qi1, qi2;
   vec_float4 i0, i1, i2, i, rem;
   vec_uint4  inrange, odd0, odd1, odd2, cmp1, cmp2, odd;
   vec_float4 vzero = (vec_float4)vec_xor((vec_uint4)(0), (vec_uint4)(0));
   vec_uint4 iszero = (vec_uint4)vec_cmpeq(x, vzero);
 
   // Find i = truncated_integer(|x/y|)
 
   // If |divf4(x,y)| < 2^20, the quotient is at most off by 1.0.
   // Thus i is either the truncated quotient, one less, or one greater.
                                                                                
   q = divf4( x, y );
   xabs = fabsf4( x );
   yabs = fabsf4( y );
   qabs = fabsf4( q );
                                                                                
   inrange = (vec_uint4)vec_cmpgt( (vec_float4)((vec_uint4)(0x49800000)), qabs );
                                                                                
   qi1 = vec_cts( qabs, 0 );
   qi0 = vec_add( qi1, (vec_int4)(-1) );
   qi2 = vec_add( qi1, (vec_int4)(1) );
                                                                                                                                                          
   odd1 = (vec_uint4)vec_cmpeq( vec_and( qi1, (vec_int4)(1) ), (vec_int4)(1) );
   odd0 = odd2 = vec_nor( odd1, odd1 );

   i0 = vec_ctf( qi0, 0 );
   i1 = vec_ctf( qi1, 0 );
   i2 = vec_ctf( qi2, 0 );
                                                                                                                                                          
   // Correct i will be the largest one such that |x| - i*|y| >= 0.
                                                                                                                                                          
   cmp1 = (vec_uint4)vec_cmpgt( (vec_int4)vzero, (vec_int4)vec_nmsub( i1, yabs, xabs ) );
   cmp2 = (vec_uint4)vec_cmpgt( (vec_int4)vzero, (vec_int4)vec_nmsub( i2, yabs, xabs ) );
                                                                                                                    
   i = i0;
   i = vec_sel( i1, i, cmp1 );
   i = vec_sel( i2, i, cmp2 );
                                                                                                                    
   odd = odd0;
   odd = vec_sel( odd1, odd, cmp1 );
   odd = vec_sel( odd2, odd, cmp2 );
                                                                                                                    
   rem = vec_nmsub( i, yabs, xabs );
                                                                                                                    
   // Test whether i or i+1 = nearest_integer(|x/y|)
   //
   // i+1 is correct if:
   //
   // rem > 0.5*|y|
   // or
   // rem = 0.5*|y| and i is odd

   yabshalf = vec_madd( yabs, (vec_float4)(0.5f), (vec_float4)vzero );
   cmp1 = (vec_uint4)vec_cmpgt( rem, yabshalf );
   cmp2 = vec_and( (vec_uint4)vec_cmpeq( rem, yabshalf ), odd );
                                                                                                                    
   i = vec_sel( i, vec_add( i, (vec_float4)(1.0f) ), vec_or( cmp1, cmp2 ) );
   i = copysignf4( i, q );
                                                                                                                                                          
   return vec_sel(vec_sel((vec_float4)vzero, vec_nmsub( i, y, x ), inrange ),
		 x, iszero);
}

# 116 "C:/usr/local/cell\\target\\ppu\\include/bits/sce_math.h" 3
# 1 "C:/usr/local/cell\\target\\ppu\\include/bits/rsqrtf4.h" 3
/* SCE CONFIDENTIAL
 * PlayStation(R)3 Programmer Tool Runtime Library 475.001
 * Copyright (C) 2011 Sony Computer Entertainment Inc. 
 * All Rights Reserved.
 */




// rsqrtf4 - for each of four float slots, compute reciprocal square root.
// Undefined if input < 0.
      



extern inline vec_float4 rsqrtf4 ( vec_float4 x )
{ 
   // Reciprocal square root estimate and 1 Newton-Raphson iteration.
 
   vec_float4 vzero = (vec_float4)vec_xor((vec_uint4)(0), (vec_uint4)(0));
   vec_float4 half = (vec_float4)(0.5f);
   vec_float4 one = (vec_float4)(1.0f);
   vec_float4 y0, y0x, y0half;

   y0 = vec_rsqrte( x );
   y0x = vec_madd( y0, x, vzero );
   y0half = vec_madd( y0, half, vzero );
   y0x = vec_madd( vec_nmsub( y0, y0x, one ), y0half, y0 );
   return vec_sel(y0, y0x, vec_cmpeq(y0x, y0x));
}

# 117 "C:/usr/local/cell\\target\\ppu\\include/bits/sce_math.h" 3
# 1 "C:/usr/local/cell\\target\\ppu\\include/bits/rsqrtf4fast.h" 3
/* SCE CONFIDENTIAL
PlayStation(R)3 Programmer Tool Runtime Library 475.001
* Copyright (C) 2011 Sony Computer Entertainment Inc. 
* All Rights Reserved.
*/




// rsqrtf4fast - for each of four float slots, compute reciprocal square root estimate 
// accurate to 12 bits of mantissa.
      



extern inline vec_float4 rsqrtf4fast ( vec_float4 x )
{
   return vec_rsqrte( x );
}

# 118 "C:/usr/local/cell\\target\\ppu\\include/bits/sce_math.h" 3
# 1 "C:/usr/local/cell\\target\\ppu\\include/bits/sqrtf4.h" 3
/* SCE CONFIDENTIAL
 * PlayStation(R)3 Programmer Tool Runtime Library 475.001
 * Copyright (C) 2011 Sony Computer Entertainment Inc. 
 * All Rights Reserved.
 */




// sqrtf4 - for each of four float slots, compute square root.
// Undefined if input < 0.
      



extern inline vec_float4 sqrtf4 ( vec_float4 x )
{
   // Reciprocal square root estimate and 1 Newton-Raphson iteration.
 
   vec_float4 zero = (vec_float4)(0.0f);
   vec_float4 half = (vec_float4)(0.5f);
   vec_float4 one = (vec_float4)(1.0f);
   vec_float4 y0, y0x, y0xhalf;
   vec_uint4 cmp_zero;

   y0 = vec_rsqrte( x );
   cmp_zero = (vec_uint4)vec_cmpeq( x, zero );
   cmp_zero = vec_or(cmp_zero, (vec_uint4)vec_cmpeq(y0, zero));
   y0x = vec_madd( y0, x, zero );
   y0xhalf = vec_madd( y0x, half, zero );
   return vec_sel(vec_madd(vec_nmsub(y0, y0x, one), y0xhalf, y0x), x, cmp_zero);
}

# 119 "C:/usr/local/cell\\target\\ppu\\include/bits/sce_math.h" 3
# 1 "C:/usr/local/cell\\target\\ppu\\include/bits/sqrtf4fast.h" 3
/* SCE CONFIDENTIAL
PlayStation(R)3 Programmer Tool Runtime Library 475.001
* Copyright (C) 2011 Sony Computer Entertainment Inc. 
* All Rights Reserved.
*/
// sqrtf4fast - for each of four float slots, compute square root estimate 
// accurate to 12 bits of mantissa.
      






extern inline vec_float4 sqrtf4fast ( vec_float4 x )
{
   vec_float4 zero = (vec_float4)(0.0f);
   return vec_sel( vec_madd( x, vec_rsqrte( x ), zero ), zero, vec_cmpeq( x, zero ) );
}

# 120 "C:/usr/local/cell\\target\\ppu\\include/bits/sce_math.h" 3

/* Vangelis */
# 1 "C:/usr/local/cell\\target\\ppu\\include/bits/sinf4.h" 3
/* SCE CONFIDENTIAL
 * PlayStation(R)3 Programmer Tool Runtime Library 475.001
 * Copyright (C) 2011 Sony Computer Entertainment Inc. 
 * All Rights Reserved.
 */




# 1 "C:/usr/local/cell\\target\\ppu\\include/bits/sincos_c.h" 3
/* SCE CONFIDENTIAL
PlayStation(R)3 Programmer Tool Runtime Library 475.001
* Copyright (C) 2007 Sony Computer Entertainment Inc. 
* All Rights Reserved.
*/



//
// Common constants used to evaluate sind2/cosd2/tand2
//
# 18 "C:/usr/local/cell\\target\\ppu\\include/bits/sincos_c.h" 3

# 25 "C:/usr/local/cell\\target\\ppu\\include/bits/sincos_c.h" 3





//
// Common constants used to evaluate sinf4/cosf4/tanf4
//
# 39 "C:/usr/local/cell\\target\\ppu\\include/bits/sincos_c.h" 3




//
// Common constants used to evaluate sinf4est/cosf4est
//









// common constants used to evaluate sinf/cosf















/** _M_PI is internally used **/




# 11 "C:/usr/local/cell\\target\\ppu\\include/bits/sinf4.h" 3

//
//     Computes the sine of each of the four slots
//     by using a polynomial approximation.
//
extern inline vec_float4 sinf4 (vec_float4 x)
{
    vec_float4 xl,xl2,xl3,res;
    vec_int4   q;
    vec_float4 vzero = (vec_float4)vec_xor((vec_uint4)(0), (vec_uint4)(0));
    vec_uint4 smask = (vec_uint4)(vec_int4)(-1);
    smask = vec_vslw(smask, smask);

    // Range reduction using : xl = angle * TwoOverPi;
    //  
    xl = vec_madd(x, (vec_float4)(0.63661977236f),(vec_float4)vzero);

    // Find the quadrant the angle falls in
    // using:  q = (int) (ceil(abs(xl))*sign(xl))
    //
    xl = vec_add(xl,vec_sel((vec_float4)(0.5f),xl,smask));
    q = vec_cts(xl,0);

     
    // Compute an offset based on the quadrant that the angle falls in
    // 
    vec_int4 offset = vec_and(q,(vec_int4)((int)0x3));

    // Remainder in range [-pi/4..pi/4]
    //
    vec_float4 qf = vec_ctf(q,0);
    vec_float4 p1 = vec_nmsub(qf,(vec_float4)(1.57079625129f),x);
    xl  = vec_nmsub(qf,(vec_float4)(7.54978995489e-8f),p1);
    
    // Compute x^2 and x^3
    //
    xl2 = vec_madd(xl,xl,(vec_float4)vzero);
    xl3 = vec_madd(xl2,xl,(vec_float4)vzero);
    

    // Compute both the sin and cos of the angles
    // using a polynomial expression:
    //   cx = 1.0f + xl2 * ((C0 * xl2 + C1) * xl2 + C2), and
    //   sx = xl + xl3 * ((S0 * xl2 + S1) * xl2 + S2)
    //
    vec_float4 ct1 = vec_madd((vec_float4)(-0.0013602249f),xl2,(vec_float4)(0.0416566950f));
    vec_float4 st1 = vec_madd((vec_float4)(-0.0001950727f),xl2,(vec_float4)(0.0083320758f));

    vec_float4 ct2 = vec_madd(ct1,xl2,(vec_float4)(-0.4999990225f));
    vec_float4 st2 = vec_madd(st1,xl2,(vec_float4)(-0.1666665247f));
    
    vec_float4 cx = vec_madd(ct2,xl2,(vec_float4)(1.0f));
    vec_float4 sx = vec_madd(st2,xl3,xl);

    // Use the cosine when the offset is odd and the sin
    // when the offset is even
    //
    vec_uint4 mask1 = (vec_uint4)vec_cmpeq(vec_and(offset,
                                                   (vec_int4)(0x1)),
                                           (vec_int4)vzero);
    res = vec_sel(cx,sx,mask1);

    // Flip the sign of the result when (offset mod 4) = 1 or 2
    //
    vec_uint4 mask2 = (vec_uint4)vec_cmpeq(vec_and(offset,(vec_int4)(0x2)),(vec_int4)vzero);
    res = vec_sel((vec_float4)vec_xor(smask,(vec_uint4)res),res,mask2);

    return res;

}

# 123 "C:/usr/local/cell\\target\\ppu\\include/bits/sce_math.h" 3
# 1 "C:/usr/local/cell\\target\\ppu\\include/bits/cosf4.h" 3
/* SCE CONFIDENTIAL
 * PlayStation(R)3 Programmer Tool Runtime Library 475.001
 * Copyright (C) 2011 Sony Computer Entertainment Inc. 
 * All Rights Reserved.
 */





//
//     Computes the cosine of each of the four slots
//     by using a polynomial approximation.
//
extern inline vec_float4 cosf4 (vec_float4 x)
{
    vec_float4 xl,xl2,xl3,res;
    vec_int4   q;
    vec_float4 vzero = (vec_float4)vec_xor((vec_uint4)(0), (vec_uint4)(0));
    vec_uint4 smask = (vec_uint4)(vec_int4)(-1);
    smask = vec_vslw(smask, smask);

    // Range reduction using : xl = angle * TwoOverPi;
    //  
    xl = vec_madd(x, (vec_float4)(0.63661977236f), vzero);

    // Find the quadrant the angle falls in
    // using:  q = (int) (ceil(abs(xl))*sign(xl))
    //
    xl = vec_add(xl,vec_sel((vec_float4)(0.5f),xl, smask));
    q = vec_cts(xl,0);

     
    // Compute an offset based on the quadrant that the angle falls in
    // 
    vec_int4 offset = vec_add((vec_int4)(1),vec_and(q,(vec_int4)((int)0x3)));

    // Remainder in range [-pi/4..pi/4]
    //
    vec_float4 qf = vec_ctf(q,0);
    vec_float4 p1 = vec_nmsub(qf,(vec_float4)(1.57079625129f),x);
    xl  = vec_nmsub(qf,(vec_float4)(7.54978995489e-8f),p1);
    
    // Compute x^2 and x^3
    //
    xl2 = vec_madd(xl,xl,vzero);
    xl3 = vec_madd(xl2,xl,vzero);
    

    // Compute both the sin and cos of the angles
    // using a polynomial expression:
    //   cx = 1.0f + xl2 * ((C0 * xl2 + C1) * xl2 + C2), and
    //   sx = xl + xl3 * ((S0 * xl2 + S1) * xl2 + S2)
    //
    vec_float4 ct1 = vec_madd((vec_float4)(-0.0013602249f),xl2,(vec_float4)(0.0416566950f));
    vec_float4 st1 = vec_madd((vec_float4)(-0.0001950727f),xl2,(vec_float4)(0.0083320758f));

    vec_float4 ct2 = vec_madd(ct1,xl2,(vec_float4)(-0.4999990225f));
    vec_float4 st2 = vec_madd(st1,xl2,(vec_float4)(-0.1666665247f));
    
    vec_float4 cx = vec_madd(ct2,xl2,(vec_float4)(1.0f));
    vec_float4 sx = vec_madd(st2,xl3,xl);

    // Use the cosine when the offset is odd and the sin
    // when the offset is even
    //
    vec_uint4 mask1 = (vec_uint4)vec_cmpeq(vec_and(offset,
                                                   (vec_int4)(0x1)),
                                           (vec_int4)vzero);
    res = vec_sel(cx,sx,mask1);

    // Flip the sign of the result when (offset mod 4) = 1 or 2
    //
    vec_uint4 mask2 = (vec_uint4)vec_cmpeq(vec_and(offset,(vec_int4)(0x2)),(vec_int4)(vzero));
    res = vec_sel((vec_float4)vec_xor(smask,(vec_uint4)res),res,mask2);

    return res;

}

# 124 "C:/usr/local/cell\\target\\ppu\\include/bits/sce_math.h" 3
# 1 "C:/usr/local/cell\\target\\ppu\\include/bits/sincosf4.h" 3
/* SCE CONFIDENTIAL
 * PlayStation(R)3 Programmer Tool Runtime Library 475.001
 * Copyright (C) 2011 Sony Computer Entertainment Inc. 
 * All Rights Reserved.
 */






//
//     Computes both the sine and cosine of the all four slots of x
//     by using a polynomial approximation.
//
extern inline void sincosf4 (vec_float4 x, vec_float4* s, vec_float4* c)
{
    vec_float4 xl,xl2,xl3;
    vec_int4   q;
    vec_int4   offsetSin, offsetCos;
    vec_float4 vzero = (vec_float4)vec_xor((vec_uint4)(0), (vec_uint4)(0));
    vec_uint4 smask = (vec_uint4)(vec_int4)(-1);
    smask = vec_vslw(smask, smask);

    // Range reduction using : xl = angle * TwoOverPi;
    //  
    xl = vec_madd(x, (vec_float4)(0.63661977236f),(vec_float4)vzero);

    // Find the quadrant the angle falls in
    // using:  q = (int) (ceil(abs(xl))*sign(xl))
    //
    xl = vec_add(xl,vec_sel((vec_float4)(0.5f),xl,smask));
    q = vec_cts(xl,0);

     
    // Compute the offset based on the quadrant that the angle falls in.
    // Add 1 to the offset for the cosine. 
    //
    offsetSin = vec_and(q,(vec_int4)((int)0x3));
    offsetCos = vec_add((vec_int4)(1),offsetSin);

    // Remainder in range [-pi/4..pi/4]
    //
    vec_float4 qf = vec_ctf(q,0);
    vec_float4 p1 = vec_nmsub(qf,(vec_float4)(1.57079625129f),x);
    xl  = vec_nmsub(qf,(vec_float4)(7.54978995489e-8f),p1);
    
    // Compute x^2 and x^3
    //
    xl2 = vec_madd(xl,xl,(vec_float4)vzero);
    xl3 = vec_madd(xl2,xl,(vec_float4)vzero);
    

    // Compute both the sin and cos of the angles
    // using a polynomial expression:
    //   cx = 1.0f + xl2 * ((C0 * xl2 + C1) * xl2 + C2), and
    //   sx = xl + xl3 * ((S0 * xl2 + S1) * xl2 + S2)
    //
    vec_float4 ct1 = vec_madd((vec_float4)(-0.0013602249f),xl2,(vec_float4)(0.0416566950f));
    vec_float4 st1 = vec_madd((vec_float4)(-0.0001950727f),xl2,(vec_float4)(0.0083320758f));

    vec_float4 ct2 = vec_madd(ct1,xl2,(vec_float4)(-0.4999990225f));
    vec_float4 st2 = vec_madd(st1,xl2,(vec_float4)(-0.1666665247f));
    
    vec_float4 cx = vec_madd(ct2,xl2,(vec_float4)(1.0f));
    vec_float4 sx = vec_madd(st2,xl3,xl);

    // Use the cosine when the offset is odd and the sin
    // when the offset is even
    //
    vec_uint4 sinMask = (vec_uint4)vec_cmpeq(vec_and(offsetSin,(vec_int4)(0x1)),(vec_int4)vzero);
    vec_uint4 cosMask = (vec_uint4)vec_cmpeq(vec_and(offsetCos,(vec_int4)(0x1)),(vec_int4)vzero);    
    *s = vec_sel(cx,sx,sinMask);
    *c = vec_sel(cx,sx,cosMask);

    // Flip the sign of the result when (offset mod 4) = 1 or 2
    //
    sinMask = (vec_uint4)vec_cmpeq(vec_and(offsetSin,(vec_int4)(0x2)),(vec_int4)vzero);
    cosMask = (vec_uint4)vec_cmpeq(vec_and(offsetCos,(vec_int4)(0x2)),(vec_int4)vzero);
    
    *s = vec_sel((vec_float4)vec_xor(smask,(vec_uint4)*s),*s,sinMask);
    *c = vec_sel((vec_float4)vec_xor(smask,(vec_uint4)*c),*c,cosMask);
    
}

# 125 "C:/usr/local/cell\\target\\ppu\\include/bits/sce_math.h" 3
# 1 "C:/usr/local/cell\\target\\ppu\\include/bits/tanf4.h" 3
/* SCE CONFIDENTIAL
 * PlayStation(R)3 Programmer Tool Runtime Library 475.001
 * Copyright (C) 2011 Sony Computer Entertainment Inc. 
 * All Rights Reserved.
 */







//
// Computes the tangent of all four slots of x by using a polynomia approximation. 
//
extern inline vec_float4 tanf4 (vec_float4 x)
{
    vec_float4 xl,xl2,xl3,res;
    vec_int4   q;
    vec_float4 vzero = (vec_float4)vec_xor((vec_uint4)(0), (vec_uint4)(0));
    vec_uint4 smask = (vec_uint4)(vec_int4)(-1);
    smask = vec_vslw(smask, smask);

    // Range reduction using : xl = angle * TwoOverPi;
    //  
    xl = vec_madd(x, (vec_float4)(0.63661977236f),(vec_float4)vzero);

    // Find the quadrant the angle falls in
    // using:  q = (int) (ceil(abs(x))*sign(x))
    //
    xl = vec_add(xl,vec_sel((vec_float4)(0.5f),xl,smask));
    q = vec_cts(xl,0);

     
    // Remainder in range [-pi/4..pi/4]
    //
    vec_float4 qf = vec_ctf(q,0);
    vec_float4 p1 = vec_nmsub(qf,(vec_float4)(1.57079625129f),x);
    xl  = vec_nmsub(qf,(vec_float4)(7.54978995489e-8f),p1);
    
    // Compute x^2 and x^3
    //
    xl2 = vec_madd(xl,xl,(vec_float4)vzero);
    xl3 = vec_madd(xl2,xl,(vec_float4)vzero);
 
    // Compute both the sin and cos of the angles
    // using a polynomial expression:
    //   cx = 1.0f + x2 * (C0 * x2 + C1), and
    //   sx = xl + x3 * S0
    //
    vec_float4 ct2 = vec_madd((vec_float4)( 0.0097099364f),xl2,(vec_float4)(-0.4291161787f));
    
    vec_float4 cx = vec_madd(ct2,xl2,(vec_float4)(1.0f));
    vec_float4 sx = vec_madd((vec_float4)(-0.0957822992f),xl3,xl);

    
    // Compute both cx/sx and sx/cx
    //
    vec_float4 cxosx = divf4(cx,sx);
    vec_float4 sxocx = divf4(sx,cx);

    vec_float4 ncxosx = (vec_float4)vec_xor(smask,(vec_uint4)cxosx);

    // For odd numbered quadrants return -cx/sx , otherwise return
    // sx/cx
    //
    vec_uint4 mask = (vec_uint4)vec_cmpeq(vec_and(q,(vec_int4)(0x1)),(vec_int4)vzero);
    res = vec_sel(ncxosx,sxocx,mask);

    return res;
}

# 126 "C:/usr/local/cell\\target\\ppu\\include/bits/sce_math.h" 3
# 1 "C:/usr/local/cell\\target\\ppu\\include/bits/asinf4.h" 3
/* SCE CONFIDENTIAL
 * PlayStation(R)3 Programmer Tool Runtime Library 475.001
 * Copyright (C) 2011 Sony Computer Entertainment Inc. 
 * All Rights Reserved.
 */



//
// Computes the inverse sine of all four slots of x
//
extern inline vec_float4 asinf4 (vec_float4 x)
{
    vec_uint4 smask = (vec_uint4)(vec_int4)(-1);
    smask = vec_vslw(smask, smask);
    vec_float4 vzero = (vec_float4)vec_xor((vec_uint4)(0), (vec_uint4)(0));
    // positive = (x > 0)
    //
    vec_uint4 positive = (vec_uint4)vec_cmpgt(x, vzero);

    // x = absf(x)
    //
    x = vec_abs(x);

    // gtHalf = (|x| > 0.5)
    //
    vec_uint4 gtHalf = (vec_uint4)vec_cmpgt(x,(vec_float4)(0.5f));    


    // if (x > 0.5)
    //    g = 0.5 - 0.5*x
    //    x = -2 * sqrtf(g)
    // else
    //    g = x * x
    //
    vec_float4 g = vec_sel(vec_madd(x,x, vzero),vec_madd((vec_float4)(-0.5f),x,(vec_float4)(0.5f)),gtHalf);
    
    x = vec_sel(x,vec_madd((vec_float4)(-2.0f),sqrtf4(g), vzero),gtHalf);

    // Compute the polynomials and take their ratio
    //  denom = (1.0f*g + -0.554846723e+1f)*g + 5.603603363f
    //  num = x * g * (-0.504400557f * g + 0.933933258f)
    //
    vec_float4 denom = vec_add(g,(vec_float4)(-5.54846723f));
    vec_float4 num = vec_madd((vec_float4)(-0.504400557f),g,(vec_float4)(0.933933258f));
    denom = vec_madd(denom,g,(vec_float4)(5.603603363f));
    num = vec_madd(vec_madd(x,g, vzero),num, vzero);

    
    // x = x + num / denom
    //
    x = vec_add(x,divf4(num,denom));

    // if (x > 0.5)
    //    x = x + M_PI_2
    //
    x = vec_sel(x,vec_add(x,(vec_float4)(1.57079632679489661923f)),gtHalf);

    
    // if (!positive) x = -x
    //
    x = vec_sel((vec_float4)vec_xor((vec_int4)smask, (vec_int4)x),x,positive);

    return x;
}

# 127 "C:/usr/local/cell\\target\\ppu\\include/bits/sce_math.h" 3
# 1 "C:/usr/local/cell\\target\\ppu\\include/bits/acosf4.h" 3
/* SCE CONFIDENTIAL
 * PlayStation(R)3 Programmer Tool Runtime Library 475.001
 * Copyright (C) 2011 Sony Computer Entertainment Inc. 
 * All Rights Reserved.
 */
/* --------------------------------------------------------------  */
/* PLEASE DO NOT MODIFY THIS SECTION                               */
/* This prolog section is automatically generated.                 */
/*                                                                 */
/* (C)Copyright                                                    */
/* Sony Computer Entertainment, Inc.,                              */
/* Toshiba Corporation,                                            */
/* International Business Machines Corporation,                    */
/* 2001,2002,2003. All rights reserved.                            */
/* S/T/I Confidential Information                                  */
/* --------------------------------------------------------------  */



//
// Computes the inverse cosine of all four slots of x. 
//
extern inline vec_float4 acosf4 (vec_float4 x)
{
    vec_float4 result, xabs;
    vec_float4 t1;
    vec_float4 xabs2, xabs4;
    vec_float4 hi, lo;
    vec_float4 neg, pos;
    vec_uint4 select;
    vec_float4 vzero = (vec_float4)vec_xor((vec_uint4)(0), (vec_uint4)(0));
    
    xabs = vec_abs(x);
    select = (vec_uint4)(vec_sra((vec_int4)(x), (vec_uint4)(31)));
    
    t1 = sqrtf4(vec_sub((vec_float4)(1.0), xabs));
    
    /* Instruction counts can be reduced if the polynomial was
     * computed entirely from nested (dependent) fma's. However, 
     * to reduce the number of pipeline stalls, the polygon is evaluated 
     * in two halves (hi amd lo). 
     */
    xabs2 = vec_madd(xabs,  xabs, vzero);
    xabs4 = vec_madd(xabs2, xabs2, vzero);
    hi = vec_madd((vec_float4)(-0.0012624911), xabs, (vec_float4)(0.0066700901));
    hi = vec_madd(hi, xabs, (vec_float4)(-0.0170881256));
    hi = vec_madd(hi, xabs, (vec_float4)( 0.0308918810));
    lo = vec_madd((vec_float4)(-0.0501743046), xabs, (vec_float4)(0.0889789874));
    lo = vec_madd(lo, xabs, (vec_float4)(-0.2145988016));
    lo = vec_madd(lo, xabs, (vec_float4)( 1.5707963050));
    
    result = vec_madd(hi, xabs4, lo);
    
    /* Adjust the result if x is negactive.
     */
    neg = vec_nmsub(t1, result, (vec_float4)(3.1415926535898f));
    pos = vec_madd(t1, result, vzero);
    
    result = vec_sel(pos, neg, select);
    
    return result;
}

# 128 "C:/usr/local/cell\\target\\ppu\\include/bits/sce_math.h" 3
# 1 "C:/usr/local/cell\\target\\ppu\\include/bits/atanf4.h" 3
/* SCE CONFIDENTIAL
 * PlayStation(R)3 Programmer Tool Runtime Library 475.001
 * Copyright (C) 2011 Sony Computer Entertainment Inc. 
 * All Rights Reserved.
 */
/* --------------------------------------------------------------  */
/* PLEASE DO NOT MODIFY THIS SECTION                               */
/* This prolog section is automatically generated.                 */
/*                                                                 */
/* (C)Copyright                                                    */
/* Sony Computer Entertainment, Inc.,                              */
/* Toshiba Corporation,                                            */
/* International Business Machines Corporation,                    */
/* 2001,2002,2003. All rights reserved.                            */
/* S/T/I Confidential Information                                  */
/* --------------------------------------------------------------  */
/* PROLOG END TAG zYx                                              */
 



//
// Computes the inverse tangent of all four slots of x. 
//
extern inline vec_float4 atanf4 (vec_float4 x)
{
    vec_float4 bias;
    vec_float4 x2, x3, x4, x8, x9;
    vec_float4 hi, lo;
    vec_float4 result;
    vec_float4 inv_x;
    vec_uint4 sign;
    vec_uint4 select;
    vec_float4 xabs;
    vec_float4 vzero = (vec_float4)vec_xor((vec_uint4)(0), (vec_uint4)(0));
    vec_uint4 smask = (vec_uint4)(vec_int4)(-1);
    smask = vec_vslw(smask, smask);
    vec_float4 vnzero = vec_or(vzero, (vec_float4)smask);
    
    sign = vec_and((vec_uint4)x, smask);
    xabs = (vec_float4)vec_andc((vec_uint4)x, smask);
    inv_x = recipf4(x);
    inv_x = (vec_float4)vec_xor((vec_uint4)inv_x, smask);
    select = (vec_uint4)vec_cmpgt(xabs, (vec_float4)(1.0f));
    bias = (vec_float4)(1.57079632679489661923f);
    bias = (vec_float4)vec_and((vec_uint4)bias, select);
    bias = (vec_float4)vec_or((vec_uint4)sign, (vec_uint4)bias);
    
    x = vec_sel(x, inv_x, select);
    
    /* Instruction counts can be reduced if the polynomial was
     * computed entirely from nested (dependent) fma's. However, 
     * to reduce the number of pipeline stalls, the polygon is evaluated 
     * in two halves(hi and lo).
     */
    bias = vec_add(bias, x);
    x2 = vec_madd(x,  x,  vzero);
    x3 = vec_madd(x2, x,  vzero);
    x4 = vec_madd(x2, x2, vzero);
    x8 = vec_madd(x4, x4, vzero);
    x9 = vec_madd(x8, x,  vnzero);
    hi = vec_madd((vec_float4)(0.0028662257f), x2, (vec_float4)(-0.0161657367f));
    hi = vec_madd(hi, x2, (vec_float4)(0.0429096138f));
    hi = vec_madd(hi, x2, (vec_float4)(-0.0752896400f));
    hi = vec_madd(hi, x2, (vec_float4)(0.1065626393f));
    lo = vec_madd((vec_float4)(-0.1420889944f), x2, (vec_float4)(0.1999355085f));
    lo = vec_madd(lo, x2, (vec_float4)(-0.3333314528f));
    lo = vec_madd(lo, x3, bias);
    
    result = vec_madd(hi, x9, lo);    
    return result;
}

# 129 "C:/usr/local/cell\\target\\ppu\\include/bits/sce_math.h" 3
# 1 "C:/usr/local/cell\\target\\ppu\\include/bits/atan2f4.h" 3
/* SCE CONFIDENTIAL
 * PlayStation(R)3 Programmer Tool Runtime Library 475.001
 * Copyright (C) 2011 Sony Computer Entertainment Inc. 
 * All Rights Reserved.
 */




//
// Inverse tangent function of two variables
//
extern inline vec_float4 atan2f4 (vec_float4 y, vec_float4 x)
{
    vec_uint4 smask = (vec_uint4)(vec_int4)(-1);
    smask = vec_vslw(smask, smask);
    vec_float4 vzero = (vec_float4)vec_xor((vec_uint4)(0), (vec_uint4)(0));
    vec_float4 xx = vec_sel(x, (vec_float4)(1.0f), vec_cmpeq(x, y));
    vec_float4 yy = vec_sel(y, (vec_float4)(1.0f), vec_cmpeq(x, y));
    vec_float4 res = atanf4(divf4(yy,xx));

    // Use the arguments to determine the quadrant of the result:
    // if (x < 0)
    //   if (y < 0)
    //      res = -PI + res
    //   else
    //      res = PI + res
    //
    vec_uint4 signy = (vec_uint4)vec_and((vec_uint4)y, smask);
    vec_uint4 isnan = vec_sel((vec_uint4)x, signy, vec_cmpeq(x, x));
    isnan = vec_sel((vec_uint4)y, isnan, vec_cmpeq(y, y));
    vec_uint4 yNeg = (vec_uint4)vec_cmpgt(vzero,y);
    vec_uint4 xNeg = (vec_uint4)vec_cmpgt(vzero,x);
    vec_uint4 szero = (vec_uint4)vec_cmpeq((vec_uint4)x, (vec_uint4)smask);

    vec_float4 bias = vec_sel((vec_float4)(3.14159265358979323846f),(vec_float4)(-3.14159265358979323846f),yNeg);

    vec_float4 newRes = vec_add(bias, res);

    res = vec_sel(vec_sel(res,newRes,xNeg),newRes,szero);

    return (vec_float4)vec_or((vec_uint4)res, isnan);
}

# 130 "C:/usr/local/cell\\target\\ppu\\include/bits/sce_math.h" 3
# 1 "C:/usr/local/cell\\target\\ppu\\include/bits/sinf4fast.h" 3
/* SCE CONFIDENTIAL
 * PlayStation(R)3 Programmer Tool Runtime Library 475.001
 * Copyright (C) 2011 Sony Computer Entertainment Inc. 
 * All Rights Reserved.
 */






//
// A faster implementation of sinf4.  Returns accurate (21+ bits of the mantissa) 
// results only for inputs in the range [-pi/2 .. pi/2]. While no error is reported,
// results are unpredictable for inputs outside this range.
//
extern inline vec_float4 sinf4fast (vec_float4 x)
{
    vec_float4 vzero = (vec_float4)vec_xor((vec_uint4)(0), (vec_uint4)(0));
    vec_uint4 smask = (vec_uint4)(vec_int4)(-1);
    smask = vec_vslw(smask, smask);
    vec_float4 g = vec_madd(x,x,(vec_float4)vzero);
    vec_float4 f = (vec_float4)vec_andc((vec_uint4)x,smask);

    vec_float4 t1 = vec_madd(g,g,(vec_float4)vzero);
    vec_float4 t2 = vec_madd((vec_float4)(-0.1980741872e-3f),g,(vec_float4)(0.8333025139e-2f));
    vec_float4 t3 = vec_madd((vec_float4)(-0.1666665668f),g,(vec_float4)vzero);
    vec_float4 t4 = vec_madd(t1,t1,(vec_float4)vzero);
    vec_float4 t5 = vec_madd(t1,t2,t3);
    vec_float4 r  = vec_madd((vec_float4)(0.2601903036e-5f),t4,t5);

    vec_float4 res = vec_madd(f,r,f);

    res = vec_sel(res, x, smask);

    return res;
}

# 131 "C:/usr/local/cell\\target\\ppu\\include/bits/sce_math.h" 3
# 1 "C:/usr/local/cell\\target\\ppu\\include/bits/cosf4fast.h" 3
/* SCE CONFIDENTIAL
 * PlayStation(R)3 Programmer Tool Runtime Library 475.001
 * Copyright (C) 2011 Sony Computer Entertainment Inc. 
 * All Rights Reserved.
 */





//
// A faster implementation of cosf4.  Returns accurate (21+ bits of the mantissa) 
// results only for inputs in the range [0..pi].  While no error is reported, 
// results are unpredictable for inputs outside this range.
//
extern inline vec_float4 cosf4fast (vec_float4 x)
{
    // cos(x) = sin(pi/2 - x)
    //
    vec_float4 vzero = (vec_float4)vec_xor((vec_uint4)(0), (vec_uint4)(0));
    vec_uint4 smask = (vec_uint4)(vec_int4)(-1);
    smask = vec_vslw(smask, smask);
    x = vec_sub((vec_float4)(1.57079625129f),x);
    x = vec_add((vec_float4)(7.54978995489e-8f),x);

    vec_float4 g = vec_madd(x,x,vzero);
    vec_float4 f = (vec_float4)vec_andc((vec_uint4)x,smask);

    vec_float4 t1 = vec_madd(g,g,vzero);
    vec_float4 t2 = vec_madd((vec_float4)(-0.1980741872e-3f),g,(vec_float4)(0.8333025139e-2f));
    vec_float4 t3 = vec_madd((vec_float4)(-0.1666665668f),g,vzero);
    vec_float4 t4 = vec_madd(t1,t1,vzero);
    vec_float4 t5 = vec_madd(t1,t2,t3);
    vec_float4 r  = vec_madd((vec_float4)(0.2601903036e-5f),t4,t5);

    vec_float4 res = vec_madd(f,r,f);

    res = vec_sel(res, x, smask);

    return res;
}

# 132 "C:/usr/local/cell\\target\\ppu\\include/bits/sce_math.h" 3
# 1 "C:/usr/local/cell\\target\\ppu\\include/bits/sincosf4fast.h" 3
/* SCE CONFIDENTIAL
 * PlayStation(R)3 Programmer Tool Runtime Library 475.001
 * Copyright (C) 2011 Sony Computer Entertainment Inc. 
 * All Rights Reserved.
 */






//
//     A faster implementation of sincosf4.  Returns accurate
//     (21+ bits of the mantissa) results only for inputs in the range [-pi/4 to pi/4].  While
//     no error is reported, results are unpredictable for inputs outside this range.
//
extern inline void sincosf4fast (vec_float4 x, vec_float4* s, vec_float4* c)
{
    vec_float4 xl2,xl3;
    vec_float4 vzero = (vec_float4)vec_xor((vec_uint4)(0), (vec_uint4)(0));
 
    // Compute x^2 and x^3
    //
    xl2 = vec_madd(x,x,(vec_float4)vzero);
    xl3 = vec_madd(xl2,x,(vec_float4)vzero);
    

    // Compute both the sin and cos of the angles
    // using a polynomial expression:
    //   cx = 1.0f + xl2 * ((C0 * xl2 + C1) * xl2 + C2), and
    //   sx = x + xl3 * ((S0 * xl2 + S1) * xl2 + S2)
    //
    vec_float4 ct1 = vec_madd((vec_float4)(-0.0013602249f),xl2,(vec_float4)(0.0416566950f));
    vec_float4 st1 = vec_madd((vec_float4)(-0.0001950727f),xl2,(vec_float4)(0.0083320758f));

    vec_float4 ct2 = vec_madd(ct1,xl2,(vec_float4)(-0.4999990225f));
    vec_float4 st2 = vec_madd(st1,xl2,(vec_float4)(-0.1666665247f));
    
    *c = vec_madd(ct2,xl2,(vec_float4)(1.0f));
    *s = vec_madd(st2,xl3,x);

}

# 133 "C:/usr/local/cell\\target\\ppu\\include/bits/sce_math.h" 3
# 1 "C:/usr/local/cell\\target\\ppu\\include/bits/tanf4fast.h" 3
/* SCE CONFIDENTIAL
 * PlayStation(R)3 Programmer Tool Runtime Library 475.001
 * Copyright (C) 2011 Sony Computer Entertainment Inc. 
 * All Rights Reserved.
 */




// A faster implementation of tanf4. Returns accurate (21+bits of the mantissa) results only
// for inputs in the range [-pi/4 .. pi/4].  While no error is reported, results
// are unpredictable for inputs outside this range.  
//
extern inline vec_float4 tanf4fast (vec_float4 x)
{
    vec_float4 x2,x3;
    vec_float4 vzero = (vec_float4)vec_xor((vec_uint4)(0), (vec_uint4)(0));

    // Compute x^2 and x^3
    //
    x2 = vec_madd(x,x,(vec_float4)vzero);
    x3 = vec_madd(x2,x,(vec_float4)vzero);
    

    // Compute both the sin and cos of the angles
    // using a polynomial expression:
    //   cx = 1.0f + x2 * (C0 * x2 + C1), and
    //   sx = xl + x3 * S0
    //
    vec_float4 ct2 = vec_madd((vec_float4)( 0.0097099364f),x2,(vec_float4)(-0.4291161787f));
    
    vec_float4 cx = vec_madd(ct2,x2,(vec_float4)(1.0f));
    vec_float4 sx = vec_madd((vec_float4)(-0.0957822992f),x3,x);

    vec_float4 res = divf4(sx,cx);
    return res;
}

# 134 "C:/usr/local/cell\\target\\ppu\\include/bits/sce_math.h" 3
# 1 "C:/usr/local/cell\\target\\ppu\\include/bits/acosf4fast.h" 3
/* SCE CONFIDENTIAL
 * PlayStation(R)3 Programmer Tool Runtime Library 475.001
 * Copyright (C) 2011 Sony Computer Entertainment Inc. 
 * All Rights Reserved.
 */
/* --------------------------------------------------------------  */
/* PLEASE DO NOT MODIFY THIS SECTION                               */
/* This prolog section is automatically generated.                 */
/*                                                                 */
/* (C)Copyright                                                    */
/* Sony Computer Entertainment, Inc.,                              */
/* Toshiba Corporation,                                            */
/* International Business Machines Corporation,                    */
/* 2001,2002,2003. All rights reserved.                            */
/* S/T/I Confidential Information                                  */
/* --------------------------------------------------------------  */




//
// A faster but less accurate implementation of the inverse cosine function.
// The results are correct to approximately 12 bits of the mantissa
//
extern inline vec_float4 acosf4fast (vec_float4 x)
{
    vec_float4 result, xabs;
    vec_float4 t1;
    vec_float4 xabs2, xabs4;
    vec_float4 hi, lo;
    vec_float4 neg, pos;
    vec_uint4 select;
    vec_float4 vzero = (vec_float4)vec_xor((vec_uint4)(0), (vec_uint4)(0));
    
    xabs = vec_abs(x);
    select = (vec_uint4)(vec_sra((vec_int4)(x), (vec_uint4)(31)));
    
    t1 = sqrtf4fast(vec_sub((vec_float4)(1.0), xabs));
    
    /* Instruction counts can be reduced if the polynomial was
     * computed entirely from nested (dependent) fma's. However, 
     * to reduce the number of pipeline stalls, the polygon is evaluated 
     * in two halves (hi amd lo). 
     */
    xabs2 = vec_madd(xabs,  xabs, vzero);
    xabs4 = vec_madd(xabs2, xabs2, vzero);
    hi = vec_madd((vec_float4)(-0.0012624911), xabs, (vec_float4)(0.0066700901));
    hi = vec_madd(hi, xabs, (vec_float4)(-0.0170881256));
    hi = vec_madd(hi, xabs, (vec_float4)( 0.0308918810));
    lo = vec_madd((vec_float4)(-0.0501743046), xabs, (vec_float4)(0.0889789874));
    lo = vec_madd(lo, xabs, (vec_float4)(-0.2145988016));
    lo = vec_madd(lo, xabs, (vec_float4)( 1.5707963050));
    
    result = vec_madd(hi, xabs4, lo);
    
    /* Adjust the result if x is negative.
     */
    neg = vec_nmsub(t1, result, (vec_float4)(3.1415926535898f));
    pos = vec_madd(t1, result, vzero);
    
    result = vec_sel(pos, neg, select);
    
    return result;
}

# 135 "C:/usr/local/cell\\target\\ppu\\include/bits/sce_math.h" 3
# 1 "C:/usr/local/cell\\target\\ppu\\include/bits/asinf4fast.h" 3
/* SCE CONFIDENTIAL
 * PlayStation(R)3 Programmer Tool Runtime Library 475.001
 * Copyright (C) 2011 Sony Computer Entertainment Inc. 
 * All Rights Reserved.
 */
/* --------------------------------------------------------------  */
/* PLEASE DO NOT MODIFY THIS SECTION                               */
/* This prolog section is automatically generated.                 */
/*                                                                 */
/* (C)Copyright                                                    */
/* Sony Computer Entertainment, Inc.,                              */
/* Toshiba Corporation,                                            */
/* International Business Machines Corporation,                    */
/* 2001,2002,2003. All rights reserved.                                 */
/* S/T/I Confidential Information                                  */
/* --------------------------------------------------------------  */
/* PROLOG END TAG zYx                                              */




//
// A faster but less accurate implementation of the inverse sine function.
// The results are expected to be accurate to at least 8 bits of the mantissa. On the
// average the results have been observed to be accurate to 19 bits. 
//
extern inline vec_float4 asinf4fast (vec_float4 x)
{
    vec_uint4 mask = (vec_uint4)(vec_int4)(-1);
    mask = vec_vslw(mask, mask);
    vec_float4 vzero = (vec_float4)vec_xor((vec_uint4)(0), (vec_uint4)(0));
    vec_uint4 sign;
    vec_float4 result, xabs;
    vec_float4 t1;
    vec_float4 xabs2, xabs4;
    vec_float4 hi, lo;
    
    /* Extract the sign of x and compute the absolute value of x (in)
     */
    sign = vec_and((vec_uint4)(x), mask);
    xabs = vec_abs(x);
    
    t1 = sqrtf4(vec_sub((vec_float4)(1.0f), xabs));
    
    /* Instruction counts can be reduced if the polynomial was
     * computed entirely from nested (dependent) fma's. However, 
     * to reduce the number of pipeline stalls, the polygon is evaluated 
     * in two halves (hi amd lo). 
     */
    xabs2 = vec_madd(xabs,  xabs, vzero);
    xabs4 = vec_madd(xabs2, xabs2, vzero);
    hi = vec_madd((vec_float4)(-0.0012624911), xabs, (vec_float4)(0.0066700901));
    hi = vec_madd(hi, xabs, (vec_float4)(-0.0170881256));
    hi = vec_madd(hi, xabs, (vec_float4)( 0.0308918810));
    lo = vec_madd((vec_float4)(-0.0501743046), xabs, (vec_float4)(0.0889789874));
    lo = vec_madd(lo, xabs, (vec_float4)(-0.2145988016));
    lo = vec_madd(lo, xabs, (vec_float4)( 1.5707963050));
    
    result = vec_madd(hi, xabs4, lo);
    result = vec_nmsub(t1, result, (vec_float4)(1.5707963267949f));
    
    /* Correct resulting sign
     */
    result = (vec_float4)(vec_or((vec_uint4)(result), sign));
    
    return result;
}

# 136 "C:/usr/local/cell\\target\\ppu\\include/bits/sce_math.h" 3
# 1 "C:/usr/local/cell\\target\\ppu\\include/bits/atanf4fast.h" 3
/* SCE CONFIDENTIAL
 * PlayStation(R)3 Programmer Tool Runtime Library 475.001
 * Copyright (C) 2011 Sony Computer Entertainment Inc. 
 * All Rights Reserved.
 */
/* --------------------------------------------------------------  */
/* PLEASE DO NOT MODIFY THIS SECTION                               */
/* This prolog section is automatically generated.                 */
/*                                                                 */
/* (C)Copyright                                                    */
/* Sony Computer Entertainment, Inc.,                              */
/* Toshiba Corporation,                                            */
/* International Business Machines Corporation,                    */
/* 2001,2002,2003. All rights reserved.                            */
/* S/T/I Confidential Information                                  */
/* --------------------------------------------------------------  */
/* PROLOG END TAG zYx                                              */
 



//
// A faster but less accurate implementation of the atanf4 function.
// The results of atanf4fast are correct to approximately 14 bits of
// the mantissa. 
//
extern inline vec_float4 atanf4fast (vec_float4 x)
{
    vec_float4 bias;
    vec_float4 x2, x3, x4, x8, x9;
    vec_float4 hi, lo;
    vec_float4 result;
    vec_float4 inv_x;
    vec_uint4 sign;
    vec_uint4 select;
    vec_float4 xabs;
    vec_float4 vzero = (vec_float4)vec_xor((vec_uint4)(0), (vec_uint4)(0));
    vec_uint4 smask = (vec_uint4)(vec_int4)(-1);
    smask = vec_vslw(smask, smask);
    
    sign = vec_and((vec_uint4)x, smask);
    xabs = (vec_float4)vec_andc((vec_uint4)x, smask);
    inv_x = recipf4fast(x);
    inv_x = (vec_float4)vec_xor((vec_uint4)inv_x, smask);
    select = (vec_uint4)vec_cmpgt(xabs, (vec_float4)(1.0));
    bias = (vec_float4)vec_or(sign, (vec_uint4)((vec_float4)(1.57079632679489661923f)));
    bias = (vec_float4)vec_and((vec_uint4)bias, select);
    
    x = vec_sel(x, inv_x, select);
    
    /* Instruction counts can be reduced if the polynomial was
     * computed entirely from nested (dependent) fma's. However, 
     * to reduce the number of pipeline stalls, the polygon is evaluated 
     * in two halves(hi and lo).
     */
    bias = vec_add(bias, x);
    x2 = vec_madd(x,  x,  vzero);
    x3 = vec_madd(x2, x,  vzero);
    x4 = vec_madd(x2, x2, vzero);
    x8 = vec_madd(x4, x4, vzero);
    x9 = vec_madd(x8, x,  vzero);
    hi = vec_madd((vec_float4)(0.0028662257), x2, (vec_float4)(-0.0161657367));
    hi = vec_madd(hi, x2, (vec_float4)(0.0429096138));
    hi = vec_madd(hi, x2, (vec_float4)(-0.0752896400));
    hi = vec_madd(hi, x2, (vec_float4)(0.1065626393));
    lo = vec_madd((vec_float4)(-0.1420889944), x2, (vec_float4)(0.1999355085));
    lo = vec_madd(lo, x2, (vec_float4)(-0.3333314528));
    lo = vec_madd(lo, x3, bias);
    
    result = vec_madd(hi, x9, lo);
    
    return result;
}

# 137 "C:/usr/local/cell\\target\\ppu\\include/bits/sce_math.h" 3
# 1 "C:/usr/local/cell\\target\\ppu\\include/bits/atan2f4fast.h" 3
/* SCE CONFIDENTIAL
 * PlayStation(R)3 Programmer Tool Runtime Library 475.001
 * Copyright (C) 2011 Sony Computer Entertainment Inc. 
 * All Rights Reserved.
 */




//
// A faster but less accurate implementation of the atan2f4 function.
// The results are correct to approximately 12 bits of the mantissa. 
//
extern inline vec_float4 atan2f4fast (vec_float4 y, vec_float4 x)
{
    vec_float4 vzero = (vec_float4)vec_xor((vec_uint4)(0), (vec_uint4)(0));
    vec_float4 res = atanf4fast(divf4fast(y,x));

    // Use the arguments to determine the quadrant of the result:
    // if (x < 0)
    //   if (y < 0)
    //      res = -PI + res
    //   else
    //      res = PI + res
    //
    vec_uint4 yNeg = (vec_uint4)vec_cmpgt(vzero,y);
    vec_uint4 xNeg = (vec_uint4)vec_cmpgt(vzero,x);

    vec_float4 bias = vec_sel((vec_float4)(3.14159265358979323846f),(vec_float4)(-3.14159265358979323846f),yNeg);

    vec_float4 newRes = vec_add(bias, res);

    res = vec_sel(res,newRes,xNeg);

    return res;
}

# 138 "C:/usr/local/cell\\target\\ppu\\include/bits/sce_math.h" 3

/* Rick */
# 1 "C:/usr/local/cell\\target\\ppu\\include/bits/fmaf4.h" 3
/* SCE CONFIDENTIAL
PlayStation(R)3 Programmer Tool Runtime Library 475.001
* Copyright (C) 2011 Sony Computer Entertainment Inc. 
* All Rights Reserved.
*/






extern inline vec_float4 fmaf4 (vec_float4 x, vec_float4 y, vec_float4 z)
{
  return vec_madd(x,y,z);
}

# 141 "C:/usr/local/cell\\target\\ppu\\include/bits/sce_math.h" 3
# 1 "C:/usr/local/cell\\target\\ppu\\include/bits/fdimf4.h" 3
/* SCE CONFIDENTIAL
 * PlayStation(R)3 Programmer Tool Runtime Library 475.001
 * Copyright (C) 2011 Sony Computer Entertainment Inc. 
 * All Rights Reserved.
 */






extern inline vec_float4 fdimf4 (vec_float4 x, vec_float4 y)
{
  vec_float4 vzero = (vec_float4)vec_xor((vec_uint4)(0), (vec_uint4)(0));
  vec_float4 diff = vec_sub(x,y);
  return vec_sel(vzero, diff, vec_cmpgt(x,y));
}

# 142 "C:/usr/local/cell\\target\\ppu\\include/bits/sce_math.h" 3
# 1 "C:/usr/local/cell\\target\\ppu\\include/bits/hypotf4.h" 3
/* SCE CONFIDENTIAL
 * PlayStation(R)3 Programmer Tool Runtime Library 475.001
 * Copyright (C) 2011 Sony Computer Entertainment Inc. 
 * All Rights Reserved.
 */






extern inline vec_float4 hypotf4 (vec_float4 x, vec_float4 y)
{
  vec_float4 vzero = (vec_float4)vec_xor((vec_uint4)(0), (vec_uint4)(0));
  vec_float4 sum = vec_madd(x,x,vzero);
  sum = vec_madd(y,y,sum);
  return sqrtf4(sum);
}

# 143 "C:/usr/local/cell\\target\\ppu\\include/bits/sce_math.h" 3

/* Rishi */
# 1 "C:/usr/local/cell\\target\\ppu\\include/bits/frexpf4.h" 3
/* SCE CONFIDENTIAL
 * PlayStation(R)3 Programmer Tool Runtime Library 475.001
 * Copyright (C) 2011 Sony Computer Entertainment Inc. 
 * All Rights Reserved.
 */




extern inline vec_float4 frexpf4 (vec_float4 x, vec_int4 *exp)
{
  vec_float4 vzero = (vec_float4)vec_xor((vec_uint4)(0), (vec_uint4)(0));
  vec_uint4 zeromask = (vec_uint4)vec_cmpeq(x, (vec_float4)vzero);
 
  vec_int4 expmask = (vec_int4)(0x7F800000);
  vec_int4 e1 = vec_and ( (vec_int4)x, expmask);
  vec_int4 e2 = vec_sub(vec_sr(e1, (vec_uint4)(23) ), (vec_int4)(126) );
  *exp = vec_sel(e2, (vec_int4)vzero, zeromask);
 
  vec_float4 m2 = vec_sel(x, (vec_float4)((vec_int4)(0x3F000000)), (vec_uint4)expmask);

  return vec_sel(m2, (vec_float4)vzero, zeromask);
}


/*
{
  *exp = ((vec_int4)(0));
  return ((vec_float4)(0.0f));
}
*/

# 146 "C:/usr/local/cell\\target\\ppu\\include/bits/sce_math.h" 3
# 1 "C:/usr/local/cell\\target\\ppu\\include/bits/ldexpf4.h" 3
/* SCE CONFIDENTIAL
 * PlayStation(R)3 Programmer Tool Runtime Library 475.001
 * Copyright (C) 2011 Sony Computer Entertainment Inc. 
 * All Rights Reserved.
 */




extern inline vec_float4 ldexpf4 (vec_float4 x, vec_int4 exp) 
{
  vec_float4 vzero = (vec_float4)vec_xor((vec_uint4)(0), (vec_uint4)(0));
  vec_uint4 smask = (vec_uint4)(vec_int4)(-1);
  smask = vec_vslw(smask, smask);

  vec_int4 expmask = (vec_int4)(0x7F800000);
  vec_int4 e1 = vec_and((vec_int4)x, expmask);
  vec_int4 e2 = vec_sr(e1,(vec_uint4)(23));

  vec_uint4 maxmask = (vec_uint4)vec_cmpgt(exp, (vec_int4)(255));
  vec_uint4 minmask = (vec_uint4)vec_cmpgt((vec_int4)(-255), exp);
  minmask = vec_or (minmask, (vec_uint4)vec_cmpeq(x, (vec_float4)vzero));

  vec_int4 esum = vec_add(e2, exp);

  maxmask = vec_or (maxmask, (vec_uint4)vec_cmpgt(esum, (vec_int4)(255)));
  maxmask = vec_andc(maxmask, smask);
  minmask = vec_or (minmask, (vec_uint4)vec_cmpgt((vec_int4)vzero, esum));

  x = vec_sel(x, (vec_float4)vec_sl(esum,(vec_uint4)(23)), (vec_uint4)expmask);
  x = vec_sel(x, (vec_float4)vzero, minmask);
  x = vec_sel(x, (vec_float4)maxmask, maxmask);
  return x;
}

# 147 "C:/usr/local/cell\\target\\ppu\\include/bits/sce_math.h" 3
# 1 "C:/usr/local/cell\\target\\ppu\\include/bits/log2f4.h" 3
/* SCE CONFIDENTIAL
 * PlayStation(R)3 Programmer Tool Runtime Library 475.001
 * Copyright (C) 2011 Sony Computer Entertainment Inc. 
 * All Rights Reserved.
 */












extern inline vec_float4 log2f4 (vec_float4 x)
{
  vec_float4 vzero = (vec_float4)vec_xor((vec_uint4)(0), (vec_uint4)(0));
  vec_uint4 smask = (vec_uint4)(vec_int4)(-1);
  smask = vec_vslw(smask, smask);
  vec_float4 ones = (vec_float4)(1.0f);
  vec_uint4 iszero = (vec_uint4)vec_cmpeq(x, vzero);
  vec_uint4 isnan = (vec_uint4)vec_cmpeq(x, x);
  vec_int4 expmask = (vec_int4)(0x7F800000);
  vec_uint4 isinf = (vec_uint4)vec_cmpeq((vec_uint4)x, (vec_uint4)expmask);

  vec_int4 xexp = vec_add( vec_sr(vec_and((vec_int4)x, expmask), (vec_uint4)(23)), (vec_int4)(-126) );
  vec_float4 xx = vec_sel(x, (vec_float4)((vec_int4)(0x3F000000)), (vec_uint4)expmask);

  vec_uint4  mask = (vec_uint4)vec_cmpgt( (vec_float4)((float)0.7071067811865f), xx);
  xx    = vec_sel(xx   , vec_add(xx, xx)                , mask);
  xexp = vec_sel(xexp, vec_sub(xexp, (vec_int4)(1) ), mask);
  
  vec_float4 x1 = vec_sub(xx , ones);
  vec_float4 z  = divf4(x1, vec_add(xx, ones));
  vec_float4 w  = vec_madd(z , z, vzero);
  vec_float4 polywneg;
  polywneg = vec_madd((vec_float4)(((float)(-0.2988439998f))), w, (vec_float4)(((float)(-0.3997655209f))));
  polywneg = vec_madd(polywneg                 , w, (vec_float4)(((float)(-0.6666679125f))));
  
  vec_float4 y    = vec_madd(z, vec_madd(polywneg, w, x1), vzero);
  vec_float4 zz1  = vec_madd((vec_float4)(((float) 1.4426950216293f)), x1, vec_ctf(xexp,0));
  vec_float4 zz2  = vec_madd((vec_float4)(((float) 1.9259629911e-8f)), x1,
			     vec_madd((vec_float4)(((float)-1.4426950408890f)), y, vzero)
			     );
  
  vec_float4 res =  vec_sel(vec_add(zz1,zz2), (vec_float4)vec_or((vec_uint4)expmask, smask), iszero);
  res = vec_sel(res, x, isinf);
  return vec_sel(x, res, isnan);
}

# 148 "C:/usr/local/cell\\target\\ppu\\include/bits/sce_math.h" 3
# 1 "C:/usr/local/cell\\target\\ppu\\include/bits/log2f4fast.h" 3
/* SCE CONFIDENTIAL
PlayStation(R)3 Programmer Tool Runtime Library 475.001
* Copyright (C) 2011 Sony Computer Entertainment Inc. 
* All Rights Reserved.
*/




extern inline vec_float4 log2f4fast (vec_float4 x)
{
  return vec_loge(x);
}

# 149 "C:/usr/local/cell\\target\\ppu\\include/bits/sce_math.h" 3
# 1 "C:/usr/local/cell\\target\\ppu\\include/bits/logf4.h" 3
/* SCE CONFIDENTIAL
 * PlayStation(R)3 Programmer Tool Runtime Library 475.001
 * Copyright (C) 2011 Sony Computer Entertainment Inc. 
 * All Rights Reserved.
 */











extern inline vec_float4 logf4 (vec_float4 x) 
{
  vec_float4 vzero = (vec_float4)vec_xor((vec_uint4)(0), (vec_uint4)(0));
  vec_uint4 smask = (vec_uint4)(vec_int4)(-1);
  smask = vec_vslw(smask, smask);
  vec_float4 ones = (vec_float4)(1.0f);
  vec_int4 expmask = (vec_int4)(0x7F800000);
  vec_uint4 iszero = (vec_uint4)vec_cmpeq(x, vzero);
  vec_uint4 isnan = (vec_uint4)vec_cmpeq(x, x);
  vec_uint4 isinf = (vec_uint4)vec_cmpeq((vec_uint4)x, (vec_uint4)expmask);

  vec_int4 xexp = vec_add( vec_sr(vec_and((vec_int4)x, expmask), (vec_uint4)(23)), (vec_int4)(-126) );
  vec_float4 xx = vec_sel(x, (vec_float4)((vec_int4)(0x3F000000)), (vec_uint4)expmask);

  vec_uint4  mask = (vec_uint4)vec_cmpgt((vec_float4)((float)0.7071067811865f), xx);
  xx = vec_sel(xx, vec_add(xx, xx), mask);
  xexp = vec_sel(xexp, vec_sub(xexp,(vec_int4)(1)), mask);

  vec_float4 x1 = vec_sub(xx, ones);
  vec_float4 z  = divf4  (x1, vec_add(xx, ones));
  vec_float4 w  = vec_madd(z, z, vzero);
  vec_float4 polywneg;
  polywneg = vec_madd((vec_float4)(((float)(-0.2988439998f))), w, (vec_float4)(((float)(-0.3997655209f))));
  polywneg = vec_madd(polywneg                , w, (vec_float4)(((float)(-0.6666679125f))));

  vec_float4 y    = vec_madd(z, vec_madd(polywneg, w, x1), vzero);
  vec_float4 wnew = vec_ctf(xexp,0);
  vec_float4 zz1     = vec_madd((vec_float4)(((float)(0.6931470632553f)))   , wnew, x1);
  vec_float4 zz2neg  = vec_madd((vec_float4)(((float)(-1.1730463525e-7f))), wnew, y );

  //return vec_sel(vec_sub(zz1,zz2neg), (vec_float4)zeromask, zeromask);
  vec_float4 res = vec_sel(vec_sub(zz1,zz2neg), (vec_float4)vec_or((vec_uint4)expmask, smask), iszero);
  res = vec_sel(res, x, isinf);
  return vec_sel(x, res, isnan);
}

# 150 "C:/usr/local/cell\\target\\ppu\\include/bits/sce_math.h" 3
# 1 "C:/usr/local/cell\\target\\ppu\\include/bits/logf4fast.h" 3
/* SCE CONFIDENTIAL
PlayStation(R)3 Programmer Tool Runtime Library 475.001
* Copyright (C) 2011 Sony Computer Entertainment Inc. 
* All Rights Reserved.
*/
/* --------------------------------------------------------------  */
/* PLEASE DO NOT MODIFY THIS SECTION                               */
/* This prolog section is automatically generated.                 */
/*                                                                 */
/* (C)Copyright                                                    */
/* Sony Computer Entertainment, Inc.,                              */
/* Toshiba Corporation,                                            */
/* International Business Machines Corporation,                    */
/* 2001,2002,2003. All rights reserved.                            */
/* S/T/I Confidential Information                                  */
/* --------------------------------------------------------------  */
/* PROLOG END TAG zYx                                              */




/*
 * FUNCTION
 *	float _lnf(float x)
 *
 * DESCRIPTION
 *	_lnf computes the natural log (base e) of the input value x. ln
 *	is computed using log2 as follows:
 *	
 *	   lnf(x) = log2f(x) / log2f(e);
 */

extern inline vec_float4 logf4fast (vec_float4 x)
{
  vec_float4 vzero = (vec_float4)vec_xor((vec_uint4)(0), (vec_uint4)(0));
  return vec_madd(log2f4fast(x), (vec_float4)(0.69314718055995f), vzero);
}

# 151 "C:/usr/local/cell\\target\\ppu\\include/bits/sce_math.h" 3
# 1 "C:/usr/local/cell\\target\\ppu\\include/bits/log10f4.h" 3
/* SCE CONFIDENTIAL
 * PlayStation(R)3 Programmer Tool Runtime Library 475.001
 * Copyright (C) 2011 Sony Computer Entertainment Inc. 
 * All Rights Reserved.
 */














extern inline vec_float4 log10f4 (vec_float4 x) 
{
  vec_float4 vzero = (vec_float4)vec_xor((vec_uint4)(0), (vec_uint4)(0));
  vec_uint4 smask = (vec_uint4)(vec_int4)(-1);
  smask = vec_vslw(smask, smask);
  vec_float4 ones = (vec_float4)(1.0f);
  vec_int4 expmask = (vec_int4)(0x7F800000);
  vec_uint4 iszero = (vec_uint4)vec_cmpeq(x, vzero);
  vec_uint4 isnan = (vec_uint4)vec_cmpeq(x, x);
  vec_uint4 isinf = (vec_uint4)vec_cmpeq((vec_uint4)x, (vec_uint4)expmask);

  vec_int4 xexp = vec_add(vec_sr(vec_and((vec_int4)x, expmask), (vec_uint4)(23)), (vec_int4)(-126));
  vec_float4 xx = vec_sel(x, (vec_float4)((vec_int4)(0x3F000000)), (vec_uint4)expmask);

  vec_uint4 mask = (vec_uint4)vec_cmpgt((vec_float4)((float)0.7071067811865f), xx);
  xx = vec_sel(xx, vec_add(xx, xx), mask);
  xexp = vec_sel(xexp, vec_sub(xexp, (vec_int4)(1)), mask);
  
  vec_float4 x1 = vec_sub(xx, ones);
  vec_float4 z = divf4(x1, vec_add(xx, ones));
  vec_float4 w = vec_madd(z, z, vzero);
  vec_float4 polywneg;
  polywneg = vec_madd((vec_float4)(((float)(-0.2988439998f))), w, (vec_float4)(((float)(-0.3997655209f))));
  polywneg = vec_madd(polywneg                  , w, (vec_float4)(((float)(-0.6666679125f))));
  
  vec_float4 y = vec_madd(z, vec_madd(polywneg, w, x1), vzero);
  vec_float4 wnew = vec_ctf(xexp, 0);
  
  vec_float4 zz1 = vec_madd((vec_float4)(((float) 0.4342944622040f)), x1, 
			    vec_madd((vec_float4)(((float) 0.3010299205780f)), wnew, vzero));
  vec_float4 zz2 = vec_madd((vec_float4)(((float) 1.9699272335e-8f)), x1,
			    vec_madd((vec_float4)(((float) 7.5085978266e-8f)), wnew, 
				     vec_madd((vec_float4)(((float)-0.4342944819033f)), y, vzero)));
  
  vec_float4 res = vec_sel(vec_add(zz1, zz2), (vec_float4)vec_or((vec_uint4)expmask, smask), iszero);
  res = vec_sel(res, x, isinf);
  return vec_sel(x, res, isnan);
}

# 152 "C:/usr/local/cell\\target\\ppu\\include/bits/sce_math.h" 3
# 1 "C:/usr/local/cell\\target\\ppu\\include/bits/log10f4fast.h" 3
/* SCE CONFIDENTIAL
 * PlayStation(R)3 Programmer Tool Runtime Library 475.001
 * Copyright (C) 2011 Sony Computer Entertainment Inc. 
 * All Rights Reserved.
 */
/* --------------------------------------------------------------  */
/* PLEASE DO NOT MODIFY THIS SECTION                               */
/* This prolog section is automatically generated.                 */
/*                                                                 */
/* (C)Copyright                                                    */
/* Sony Computer Entertainment, Inc.,                              */
/* Toshiba Corporation,                                            */
/* International Business Machines Corporation,                    */
/* 2001,2002,2003. All rights reserved.                            */
/* S/T/I Confidential Information                                  */
/* --------------------------------------------------------------  */
/* PROLOG END TAG zYx                                              */




/*
 * FUNCTION
 *	float _log10f(float x)
 *
 * DESCRIPTION
 *	_log10f computes log (base 10) of the input value x. log10
 *	is computed using log2 as follows:
 *	
 *	   log10f(x) = log2(x) / log2(10);
 */
extern inline vec_float4 log10f4fast (vec_float4 x) 
{
  vec_float4 vzero = (vec_float4)vec_xor((vec_uint4)(0), (vec_uint4)(0));
  return vec_madd(log2f4fast(x), (vec_float4)(0.30102999566398f), (vec_float4)vzero);
}

# 153 "C:/usr/local/cell\\target\\ppu\\include/bits/sce_math.h" 3
# 1 "C:/usr/local/cell\\target\\ppu\\include/bits/log1pf4.h" 3
/* SCE CONFIDENTIAL
 * PlayStation(R)3 Programmer Tool Runtime Library 475.001
 * Copyright (C) 2011 Sony Computer Entertainment Inc. 
 * All Rights Reserved.
 */




extern inline vec_float4 log1pf4 (vec_float4 x)
{
  vec_float4 vzero = (vec_float4)vec_xor((vec_uint4)(0), (vec_uint4)(0));
  vec_uint4 iszero = (vec_uint4)vec_cmpeq(x, vzero);
  vec_uint4 isnan = (vec_uint4)vec_cmpeq(x, x);
  vec_uint4 nearzeromask = (vec_uint4)vec_and(vec_cmpgt(x, (vec_float4)(-0.5f)),
					      vec_cmpgt((vec_float4)(0.5f), x));
  vec_float4 x2 = vec_madd(x,x,vzero);
  vec_float4 d0, d1, n0, n1;

  d0 = vec_madd(x , (vec_float4)(1.5934420741f), (vec_float4)(0.8952856868f));
  d1 = vec_madd(x , (vec_float4)(0.1198195734f), (vec_float4)(0.8377145063f));
  d1 = vec_madd(x2, d1, d0);
  
  n0 = vec_madd(x , (vec_float4)(1.1457993413f), (vec_float4)(0.8952856678f));
  n1 = vec_madd(x , (vec_float4)(0.0082862580f), (vec_float4)(0.3394238808f));
  n1 = vec_madd(x2, n1, n0);
 
  vec_float4 res = vec_sel(logf4(vec_add(x, (vec_float4)(1.0f))),
                 vec_madd(x, divf4(n1, d1), vzero), nearzeromask);
  res = vec_sel(res, x, iszero);
  res = vec_sel(x, res, isnan);
  return res;
}

# 154 "C:/usr/local/cell\\target\\ppu\\include/bits/sce_math.h" 3
# 1 "C:/usr/local/cell\\target\\ppu\\include/bits/log1pf4fast.h" 3
/* SCE CONFIDENTIAL
 * PlayStation(R)3 Programmer Tool Runtime Library 475.001
 * Copyright (C) 2011 Sony Computer Entertainment Inc. 
 * All Rights Reserved.
 */




extern inline vec_float4 log1pf4fast (vec_float4 x)
{
  vec_float4 vzero = (vec_float4)vec_xor((vec_uint4)(0), (vec_uint4)(0));
  vec_float4 x2 = vec_madd(x,x,vzero);
  vec_float4 d0, d1, n0, n1;

  d0 = vec_madd(x , (vec_float4)(1.5934420741f), (vec_float4)(0.8952856868f));
  d1 = vec_madd(x , (vec_float4)(0.1198195734f), (vec_float4)(0.8377145063f));
  d1 = vec_madd(x2, d1, d0);
  
  n0 = vec_madd(x , (vec_float4)(1.1457993413f), (vec_float4)(0.8952856678f));
  n1 = vec_madd(x , (vec_float4)(0.0082862580f), (vec_float4)(0.3394238808f));
  n1 = vec_madd(x2, n1, n0);

  return vec_madd(x, divf4(n1, d1), vzero);
}

# 155 "C:/usr/local/cell\\target\\ppu\\include/bits/sce_math.h" 3
# 1 "C:/usr/local/cell\\target\\ppu\\include/bits/logbf4.h" 3
/* SCE CONFIDENTIAL
 * PlayStation(R)3 Programmer Tool Runtime Library 475.001
 * Copyright (C) 2011 Sony Computer Entertainment Inc. 
 * All Rights Reserved.
 */




extern inline vec_float4 logbf4 (vec_float4 x)
{
  vec_float4 vzero = (vec_float4)vec_xor((vec_uint4)(0), (vec_uint4)(0));
  vec_int4 expmask = (vec_int4)(0x7F800000);
  vec_uint4 isnan = (vec_uint4)vec_cmpeq(x, x);
  vec_int4 e1 = vec_and((vec_int4)x, expmask);
  vec_uint4 isinf = (vec_uint4)vec_cmpeq(e1, expmask);
  vec_uint4 zeromask = (vec_uint4)vec_cmpeq(e1, (vec_int4)vzero);
  e1 = vec_sub(e1, (vec_int4)(0x3F800000));
  vec_float4 res = vec_sel(vec_ctf(e1,23), __extension__ ((vec_float4){-((float)((float)(1e+30F * 1e+30F))), -((float)((float)(1e+30F * 1e+30F))), -((float)((float)(1e+30F * 1e+30F))), -((float)((float)(1e+30F * 1e+30F)))}), zeromask);
  res = vec_sel(res, (vec_float4)expmask, isinf);
  return vec_sel(x, res, isnan);
}

# 156 "C:/usr/local/cell\\target\\ppu\\include/bits/sce_math.h" 3
# 1 "C:/usr/local/cell\\target\\ppu\\include/bits/ilogbf4.h" 3
/* SCE CONFIDENTIAL
 * PlayStation(R)3 Programmer Tool Runtime Library 475.001
 * Copyright (C) 2011 Sony Computer Entertainment Inc. 
 * All Rights Reserved.
 */




extern inline vec_int4 ilogbf4 (vec_float4 x)
{
  vec_float4 vzero = (vec_float4)vec_xor((vec_uint4)(0), (vec_uint4)(0));
  vec_int4 minus127 = (vec_int4)(-127);

  vec_int4 e1 = vec_and((vec_int4)x, (vec_int4)(0x7F800000));
  vec_uint4 zeromask = (vec_uint4)vec_cmpeq(e1, (vec_int4)vzero);
  vec_int4 e2 = vec_add(vec_sr(e1,(vec_uint4)(23)), minus127);
  
  return vec_sel(e2, (vec_int4)((-0x7fffffff - 1)), zeromask);

}

# 157 "C:/usr/local/cell\\target\\ppu\\include/bits/sce_math.h" 3
# 1 "C:/usr/local/cell\\target\\ppu\\include/bits/exp2f4.h" 3
/* SCE CONFIDENTIAL
 * PlayStation(R)3 Programmer Tool Runtime Library 475.001
 * Copyright (C) 2011 Sony Computer Entertainment Inc. 
 * All Rights Reserved.
 */
/* --------------------------------------------------------------  */
/* PLEASE DO NOT MODIFY THIS SECTION                               */
/* This prolog section is automatically generated.                 */
/*                                                                 */
/* (C)Copyright                                                    */
/* Sony Computer Entertainment, Inc.,                              */
/* Toshiba Corporation,                                            */
/* International Business Machines Corporation,                    */
/* 2001,2002,2003. All rights reserved.                            */
/* S/T/I Confidential Information                                  */
/* --------------------------------------------------------------  */
/* PROLOG END TAG zYx                                              */




/*
 * FUNCTION
 *	vec_float4 _exp2_v(vec_float4 x)
 *
 * DESCRIPTION
 *	_exp2_v computes 2 raised to the input vector x. Computation is 
 *	performed by observing the 2^(a+b) = 2^a * 2^b.
 *	We decompose x into a and b (above) by letting.
 *	a = ceil(x), b = x - a; 
 *
 *	2^a is easilty computed by placing a into the exponent
 *	or a floating point number whose mantissa is all zeros.
 *
 *	2^b is computed using the following polynomial approximation.
 *	(C. Hastings, Jr, 1955).
 *
 *                __7__
 *		   *		    *	2^(-x) =   /     Ci*x^i


 *                /____
 *                 i=1
 *
 *	for x in the range 0.0 to 1.0
 *
 *	C0 =  1.0
 *	C1 = -0.9999999995
 *	C2 =  0.4999999206
 *	C3 = -0.1666653019
 *	C4 =  0.0416573475
 *	C5 = -0.0083013598
 *	C6 =  0.0013298820
 *	C7 = -0.0001413161
 *
 *	This function does not handle out of range conditions. It
 *	assumes that x is in the range (-128.0, 127.0]. Values outside
 *	this range will produce undefined results.
 */


extern inline vec_float4 exp2f4 (vec_float4 x)
{
  vec_int4 ix;
  vec_uint4 overflow;
  vec_uint4 underflow;
  vec_float4 frac, frac2, frac4;
  vec_float4 exp_int, exp_frac;
  vec_float4 result;
  vec_float4 hi, lo;
  vec_float4 vzero = (vec_float4)vec_xor((vec_uint4)(0), (vec_uint4)(0));
  vec_float4 bias;
  /* Break in the input x into two parts ceil(x), x - ceil(x).
   */

  bias = (vec_float4)(vec_sra((vec_int4)(x), (vec_uint4)(31) ));
  bias = (vec_float4)(vec_andc((vec_uint4)(0x3F7FFFFF), (vec_uint4)bias));
  ix = vec_cts(vec_add(x, bias), 0);  




  frac = vec_sub(vec_ctf(ix, 0), x);
  frac = vec_madd(frac, (vec_float4)(0.69314718055995f), vzero);

  // !!! HRD Changing weird un-understandable and incorrect overflow handling code
  //overflow = vec_sel((vec_uint4)(0x7FFFFFFF), (vec_uint4)x, (vec_uint4)(0x80000000) );  
  overflow  = (vec_uint4)vec_cmpgt(x, (vec_float4)((vec_int4)(0x4300FFFF))); // !!! Biggest possible exponent to fit in range.
  underflow = (vec_uint4)vec_cmpgt((vec_float4)(-126.0f), x);

  //exp_int = (vec_float4)(vec_sl(vec_add(ix, (vec_int4)(127)), (vec_uint4)(23))); // !!! HRD <- changing this to correct for
                                                          // !!! overflow (x >= 127.999999f)
  exp_int = (vec_float4)(vec_sl(vec_add(ix, (vec_int4)(126)), (vec_uint4)(23)));   // !!! HRD <- add with saturation

  /* Instruction counts can be reduced if the polynomial was
   * computed entirely from nested (dependent) fma's. However, 
   * to reduce the number of pipeline stalls, the polygon is evaluated 
   * in two halves (hi amd lo). 
   */
  frac2 = vec_madd(frac, frac, vzero);
  frac4 = vec_madd(frac2, frac2, vzero);

  hi = vec_madd(frac, (vec_float4)(-0.0001413161), (vec_float4)(0.0013298820));
  hi = vec_madd(frac, hi, (vec_float4)(-0.0083013598));
  hi = vec_madd(frac, hi, (vec_float4)(0.0416573475));
  lo = vec_madd(frac, (vec_float4)(-0.1666653019), (vec_float4)(0.4999999206));
  lo = vec_madd(frac, lo, (vec_float4)(-0.9999999995));
  lo = vec_madd(frac, lo, (vec_float4)(1.0));

  exp_frac = vec_madd(frac4, hi, lo);
  //ix = vec_add(ix, vec_sr((vec_int4)(exp_frac), (vec_uint4)(23) ));
  result = vec_madd(exp_frac, exp_int, vzero);
  result = vec_madd(exp_frac, exp_int, result); // !!! HRD

  /* Handle overflow */
  result = vec_sel(result, __extension__ ((vec_float4){((float)((float)(1e+30F * 1e+30F))), ((float)((float)(1e+30F * 1e+30F))), ((float)((float)(1e+30F * 1e+30F))), ((float)((float)(1e+30F * 1e+30F)))}), overflow); 
  result = vec_sel(result, vzero, underflow);
  //result = vec_sel(result, (vec_float4)(overflow), vec_cmpgt((vec_uint4)(ix), (vec_uint4)(255)));

  return (result);
}

# 158 "C:/usr/local/cell\\target\\ppu\\include/bits/sce_math.h" 3
# 1 "C:/usr/local/cell\\target\\ppu\\include/bits/exp2f4fast.h" 3
/* SCE CONFIDENTIAL
PlayStation(R)3 Programmer Tool Runtime Library 475.001
* Copyright (C) 2011 Sony Computer Entertainment Inc. 
* All Rights Reserved.
*/




extern inline vec_float4 exp2f4fast (vec_float4 x)
{
  return vec_expte(x);
}


/*
_FUNC_DEF(vec_float4, exp2f4fast, (vec_float4 x))
{
    return ((vec_float4)(0.0f));
}
*/

# 159 "C:/usr/local/cell\\target\\ppu\\include/bits/sce_math.h" 3
# 1 "C:/usr/local/cell\\target\\ppu\\include/bits/expf4.h" 3
/* SCE CONFIDENTIAL
 * PlayStation(R)3 Programmer Tool Runtime Library 475.001
 * Copyright (C) 2011 Sony Computer Entertainment Inc. 
 * All Rights Reserved.
 */








extern inline vec_float4 expf4 (vec_float4 x) 
{
  vec_float4 vzero = (vec_float4)vec_xor((vec_uint4)(0), (vec_uint4)(0));
  vec_uint4 xnegmask = (vec_uint4)vec_cmpgt(vzero, x);
  vec_float4 goffset  = vec_sel((vec_float4)( 0.5f),(vec_float4)(-0.5f),xnegmask);
  vec_float4 g  = vec_madd(x, (vec_float4)(((float)1.4426950408889634f)), vzero);  
  vec_int4 xexp = vec_cts(vec_add(g, goffset),0);
  
  g = vec_ctf(xexp, 0);
  g = vec_madd(g, (vec_float4)(((float)-1.1730463525082e-7f)), vec_madd(g, (vec_float4)(((float)-0.6931470632553101f)), x));
  vec_float4 z  = vec_madd(g, g, vzero);
  vec_float4 a = vec_madd(z, (vec_float4)(0.0999748594f), vzero);
  vec_float4 b = vec_madd(g, 
			  vec_madd(z, 
				   (vec_float4)(0.0083208258f), 
				   (vec_float4)(0.4999999992f)
				   ),
			  vzero);
  
  vec_float4 foo  = divf4(vec_add((vec_float4)(1.0f), vec_add(a, b)),
			  vec_add((vec_float4)(1.0f), vec_sub(a, b)));

  return ldexpf4(foo, xexp);
  
}

# 160 "C:/usr/local/cell\\target\\ppu\\include/bits/sce_math.h" 3
# 1 "C:/usr/local/cell\\target\\ppu\\include/bits/expf4fast.h" 3
/* SCE CONFIDENTIAL
 * PlayStation(R)3 Programmer Tool Runtime Library 475.001
 * Copyright (C) 2011 Sony Computer Entertainment Inc. 
 * All Rights Reserved.
 */
/* --------------------------------------------------------------  */
/* PLEASE DO NOT MODIFY THIS SECTION                               */
/* This prolog section is automatically generated.                 */
/*                                                                 */
/* (C)Copyright                                                    */
/* Sony Computer Entertainment, Inc.,                              */
/* Toshiba Corporation,                                            */
/* International Business Machines Corporation,                    */
/* 2001,2002,2003. All rights reserved.                                 */
/* S/T/I Confidential Information                                  */
/* --------------------------------------------------------------  */
/* PROLOG END TAG zYx                                              */
 




 
/*
 * FUNCTION
 *      vector float _expf_v(vector float x)
 *
 * DESCRIPTION
 *      _expf_v computes e raised to the input vector x. expf_v is
 *      computed using exp2f_v as e^x = 2^(log2(e)*x)
 */
 
extern inline vec_float4 expf4fast (vec_float4 x)
{
  vec_float4 vzero = (vec_float4)vec_xor((vec_uint4)(0), (vec_uint4)(0));
  return exp2f4fast(vec_madd( (vec_float4)(((float)1.442695040889f)), x, vzero));
}

# 161 "C:/usr/local/cell\\target\\ppu\\include/bits/sce_math.h" 3
# 1 "C:/usr/local/cell\\target\\ppu\\include/bits/expm1f4.h" 3
/* SCE CONFIDENTIAL
 * PlayStation(R)3 Programmer Tool Runtime Library 475.001
 * Copyright (C) 2011 Sony Computer Entertainment Inc. 
 * All Rights Reserved.
 */







extern inline vec_float4 expm1f4 (vec_float4 x) 
{
  vec_float4 vzero = (vec_float4)vec_xor((vec_uint4)(0), (vec_uint4)(0));
  vec_uint4 nearzeromask = (vec_uint4)vec_and(vec_cmpgt(x, (vec_float4)(((float)-0.6931471805599f))),
					      vec_cmpgt((vec_float4)(((float) 0.4054651081082f)), x));
  vec_float4 x2 = vec_madd(x,x,vzero);
  vec_float4 d0, d1, n0, n1;

  d0 = vec_madd(x , (vec_float4)(-0.3203561199f), (vec_float4)(0.9483177697f));
  d1 = vec_madd(x2, (vec_float4)( 0.0326527809f), d0);
  
  n0 = vec_madd(x , (vec_float4)(0.1538026623f), (vec_float4)(0.9483177732f));
  n1 = vec_madd(x , (vec_float4)(0.0024490478f), (vec_float4)(0.0305274668f));
  n1 = vec_madd(x2, n1, n0);
 
  return vec_sel(vec_sub(expf4(x), (vec_float4)(1.0f)),
                 vec_madd(x, divf4(n1, d1), vzero),
                 nearzeromask);
}

# 162 "C:/usr/local/cell\\target\\ppu\\include/bits/sce_math.h" 3
# 1 "C:/usr/local/cell\\target\\ppu\\include/bits/expm1f4fast.h" 3
/* SCE CONFIDENTIAL
 * PlayStation(R)3 Programmer Tool Runtime Library 475.001
 * Copyright (C) 2011 Sony Computer Entertainment Inc. 
 * All Rights Reserved.
 */




extern inline vec_float4 expm1f4fast (vec_float4 x)
{
  vec_float4 vzero = (vec_float4)vec_xor((vec_uint4)(0), (vec_uint4)(0));
  vec_float4 x2 = vec_madd(x,x,vzero);
  vec_float4 d0, d1, n0, n1;
  
  d0 = vec_madd(x , (vec_float4)(-0.3203561199f), (vec_float4)(0.9483177697f));
  d1 = vec_madd(x2, (vec_float4)( 0.0326527809f), d0);
  
  n0 = vec_madd(x , (vec_float4)(0.1538026623f), (vec_float4)(0.9483177732f));
  n1 = vec_madd(x , (vec_float4)(0.0024490478f), (vec_float4)(0.0305274668f));
  n1 = vec_madd(x2, n1, n0);
 
  return vec_madd(x, divf4(n1, d1), vzero);

}

# 163 "C:/usr/local/cell\\target\\ppu\\include/bits/sce_math.h" 3
# 1 "C:/usr/local/cell\\target\\ppu\\include/bits/powf4.h" 3
/* SCE CONFIDENTIAL
 * PlayStation(R)3 Programmer Tool Runtime Library 475.001
 * Copyright (C) 2011 Sony Computer Entertainment Inc. 
 * All Rights Reserved.
 */




extern inline vec_float4 powf4 (vec_float4 x, vec_float4 y)
{
  vec_float4 vzero = (vec_float4)vec_xor((vec_uint4)(0),(vec_uint4)(0));
  vec_uint4 yzero = (vec_uint4)vec_cmpeq((vec_float4)vzero, y);
  vec_uint4 negx  = (vec_uint4)vec_cmpgt((vec_int4)vzero, (vec_int4)x);

  vec_uint4 sbit = (vec_uint4)(vec_int4)(-1);
  sbit = vec_vslw(sbit, sbit);
  vec_float4 absx = vec_andc(x, (vec_float4)sbit);
  vec_float4 absy = vec_andc(y, (vec_float4)sbit);
  vec_uint4 oddy = vec_and(vec_ctu(absy, 0), (vec_uint4)(0x00000001));
  negx = vec_and(negx, (vec_uint4)vec_cmpgt(oddy, (vec_uint4)vzero));

  vec_float4 res = log2f4(absx);
  res = vec_sel(res, y, yzero);
  vec_float4 res1 = vec_madd(y, res, (vec_float4)vzero);
  res1 = exp2f4(vec_sel(res1, res, vec_and(vec_cmpeq(res, vzero),
                        (vec_uint4)vec_cmpgt((vec_int4)x,(vec_int4)vzero))));
  res1 = vec_sel(res1, vec_or((vec_float4)sbit, res1), negx);
  res1 = vec_sel(x, res1, vec_cmpeq(res, res));
  return res1;
}

# 164 "C:/usr/local/cell\\target\\ppu\\include/bits/sce_math.h" 3
# 1 "C:/usr/local/cell\\target\\ppu\\include/bits/powf4fast.h" 3
/* SCE CONFIDENTIAL
PlayStation(R)3 Programmer Tool Runtime Library 475.001
* Copyright (C) 2011 Sony Computer Entertainment Inc. 
* All Rights Reserved.
*/




extern inline vec_float4 powf4fast (vec_float4 x, vec_float4 y)
{
  vec_int4 zeros = (vec_int4)(0);
  vec_uint4 zeromask = (vec_uint4)vec_cmpeq((vec_float4)zeros, x);

  vec_uint4 negmask  = (vec_uint4)vec_cmpgt((vec_float4)zeros, x);
  
  vec_float4 sbit = (vec_float4)((vec_int4)(0x80000000));
  vec_float4 absx = vec_andc(x, sbit);
  vec_float4 absy = vec_andc(y, sbit);
  vec_uint4 oddy = vec_and(vec_ctu(absy, 0), (vec_uint4)(0x00000001));
  negmask = vec_and(negmask, (vec_uint4)vec_cmpgt(oddy, (vec_uint4)zeros));

  vec_float4 res = exp2f4fast(vec_madd(y, log2f4(absx), (vec_float4)zeros));
  res = vec_sel(res, vec_or(sbit, res), negmask);


  return vec_sel(res, (vec_float4)zeros, zeromask);
}

# 165 "C:/usr/local/cell\\target\\ppu\\include/bits/sce_math.h" 3
# 1 "C:/usr/local/cell\\target\\ppu\\include/bits/cbrtf4.h" 3
/* SCE CONFIDENTIAL
 * PlayStation(R)3 Programmer Tool Runtime Library 475.001
 * Copyright (C) 2011 Sony Computer Entertainment Inc. 
 * All Rights Reserved.
 */



# 31 "C:/usr/local/cell\\target\\ppu\\include/bits/cbrtf4.h" 3

extern inline vec_float4 cbrtf4 (vec_float4 x) 
{
  vec_float4 vzero = (vec_float4)vec_xor((vec_uint4)(0), (vec_uint4)(0));
  vec_int4 xexp, n;
  vec_uint4 sgnmask = (vec_uint4)(vec_int4)(-1);
  sgnmask = vec_vslw(sgnmask, sgnmask);
  vec_uint4 iszero = (vec_uint4)vec_cmpeq(x, vzero);
  vec_uint4 isnan = (vec_uint4)vec_cmpeq(x, x);
  vec_uint4 negmask = (vec_uint4)vec_cmpgt(vzero, x);
  vec_float4 xx = vec_andc(x, (vec_float4)sgnmask);

  xx = frexpf4(xx, &xexp);
  vec_float4 p = vec_madd(
			  vec_madd(xx, (vec_float4)(-0.191502161678719066f), (vec_float4)(0.697570460207922770f)),
			  xx,
			  (vec_float4)(0.492659620528969547f)
			  );
  vec_float4 p3 = vec_madd(p, vec_madd(p, p, vzero), vzero);

  vec_int4 quot;
  n = xexp; vec_uint4 negxexpmask = (vec_uint4)vec_cmpgt((vec_int4)(vzero), n); n = vec_sel(n, vec_add(n,(vec_int4)(2)), negxexpmask); quot = vec_add(vec_sra(n,(vec_uint4)(2)), vec_sra(n,(vec_uint4)(4))); quot = vec_add(quot, vec_sra(quot, (vec_uint4)(4))); quot = vec_add(quot, vec_sra(quot, (vec_uint4)(8))); quot = vec_add(quot, vec_sra(quot,(vec_uint4)(16))); vec_int4 r = vec_sub(vec_sub(n,quot), vec_sl(quot,(vec_uint4)(1))); quot = vec_add( quot, vec_sra( vec_add( vec_add(r,(vec_int4)(5)), vec_sl (r,(vec_uint4)(2)) ), (vec_uint4)(4) ) );;
  vec_int4 modval = vec_sub(vec_sub(xexp,quot), vec_sl(quot,(vec_uint4)(1))); // mod = xexp - 3*quotient
  vec_float4 factor =  (vec_float4)(1.0/1.5874010519681994748);
  factor = vec_sel(factor, (vec_float4)(1.0/1.2599210498948731648), vec_cmpeq(modval,(vec_int4)(-1)));
  factor = vec_sel(factor, (vec_float4)(               1.0), vec_cmpeq(modval,(vec_int4)(vzero)));
  factor = vec_sel(factor, (vec_float4)(    1.2599210498948731648), vec_cmpeq(modval,(vec_int4)( 1)));
  factor = vec_sel(factor, (vec_float4)(1.5874010519681994748), vec_cmpeq(modval,(vec_int4)( 2)));

  vec_float4 pre  = vec_madd(p, factor, vzero);
  vec_float4 numr = vec_madd(xx , (vec_float4)(2.0f), p3);
  vec_float4 denr = vec_madd(p3, (vec_float4)(2.0f), xx );
  vec_float4 res = vec_madd(pre, divf4(numr, denr), vzero);
  res = ldexpf4(res, quot);

  res = vec_sel(res, vec_or(res,(vec_float4)sgnmask), negmask);
  res = vec_sel(res, x, iszero);
  return vec_sel(x, res, isnan);
}

/*
_FUNC_DEF(vec_float4, cbrtf4, (vec_float4 x))
{
  vec_uint4 neg  = (vec_uint4)vec_cmpgt((vec_float4)(0.0f), x);
  vec_float4  sbit = (vec_float4)(vec_float4)((int)0x80000000);
  vec_float4 absx = vec_andc(x, sbit);
  vec_float4 res = exp2f4(vec_mul((vec_float4)(0.3333333333333f), log2f4(absx)));
  res = vec_sel(res, vec_or(sbit, res), neg);
  return res;
}
*/

# 166 "C:/usr/local/cell\\target\\ppu\\include/bits/sce_math.h" 3
# 1 "C:/usr/local/cell\\target\\ppu\\include/bits/cbrtf4fast.h" 3
/* SCE CONFIDENTIAL
PlayStation(R)3 Programmer Tool Runtime Library 475.001
* Copyright (C) 2011 Sony Computer Entertainment Inc. 
* All Rights Reserved.
*/



extern inline vec_float4 cbrtf4fast (vec_float4 x)
{
  return cbrtf4(x);
}

/*
_FUNC_DEF(vec_float4, cbrtf4fast, (vec_float4 x))
{
  vec_uchar16 neg  = (vec_uchar16)spu_cmpgt(spu_splats(0.0f), x);
  vec_float4 sbit = (vec_float4)spu_splats((int)0x80000000);
  vec_float4 absx = spu_andc(x, sbit);
  vec_float4 res = exp2f4fast(spu_mul(spu_splats((float)0.3333333333333f), log2f4fast(absx)));
  res = spu_sel(res, spu_or(sbit, res), neg);
  return res;
}
*/

# 167 "C:/usr/local/cell\\target\\ppu\\include/bits/sce_math.h" 3
                                                                                                                                                                                  


}






using ::std:: acosf4fast;
using ::std:: asinf4fast;
using ::std:: atan2f4fast;
using ::std:: atanf4fast;
using ::std:: cbrtf4fast;
using ::std:: cosf4fast;
using ::std:: divf4;
using ::std:: divf4fast;
using ::std:: exp2f4fast;
using ::std:: expf4fast;
using ::std:: expm1f4fast;
using ::std:: log10f4fast;
using ::std:: log1pf4fast;
using ::std:: log2f4fast;
using ::std:: logf4fast;
using ::std:: negatef4;
using ::std:: powf4fast;
using ::std:: recipf4;
using ::std:: recipf4fast;
using ::std:: rsqrtf4;
using ::std:: rsqrtf4fast;
using ::std:: sincosf4fast;
using ::std:: sinf4fast;
using ::std:: sqrtf4fast;
using ::std:: tanf4fast;

using ::std:: acosf4;
using ::std:: asinf4;
using ::std:: atanf4;
using ::std:: atan2f4;
using ::std:: ceilf4;
using ::std:: copysignf4;
using ::std:: cosf4;
using ::std:: expf4;
using ::std:: fabsf4;
using ::std:: floorf4;
using ::std:: fmaxf4;
using ::std:: fminf4;
using ::std:: fmodf4;
using ::std:: frexpf4;
using ::std:: ldexpf4;
using ::std:: logf4;
using ::std:: log10f4;
using ::std:: modff4;
using ::std:: remainderf4;
using ::std:: sincosf4;
using ::std:: powf4;
using ::std:: sinf4;
using ::std:: sqrtf4;
using ::std:: tanf4;
using ::std:: truncf4;

using ::std:: cbrtf4;
using ::std:: expm1f4;
using ::std:: exp2f4;
using ::std:: fdimf4;
using ::std:: fmaf4;
using ::std:: hypotf4;
using ::std:: ilogbf4;


using ::std:: log1pf4;
using ::std:: log2f4;
using ::std:: logbf4;
# 1480 "C:/usr/local/cell\\target\\ppu\\include/math.h" 3






using ::std:: abs;


using ::std:: acos; using ::std:: asin;
using ::std:: atan; using ::std:: atan2; using ::std:: ceil;
using ::std:: cos; using ::std:: cosh; using ::std:: exp;
using ::std:: fabs; using ::std:: floor; using ::std:: fmod;
using ::std:: frexp; using ::std:: ldexp; using ::std:: log;
using ::std:: log10; using ::std:: modf; using ::std:: pow;
using ::std:: sin; using ::std:: sinh; using ::std:: sqrt;
using ::std:: tan; using ::std:: tanh;

using ::std:: acosf; using ::std:: asinf;
using ::std:: atanf; using ::std:: atan2f; using ::std:: ceilf;
using ::std:: cosf; using ::std:: coshf; using ::std:: expf;
using ::std:: fabsf; using ::std:: floorf; using ::std:: fmodf;
using ::std:: frexpf; using ::std:: ldexpf; using ::std:: logf;
using ::std:: log10f; using ::std:: modff; using ::std:: powf;
using ::std:: sinf; using ::std:: sinhf; using ::std:: sqrtf;
using ::std:: tanf; using ::std:: tanhf;

using ::std:: acosl; using ::std:: asinl;
using ::std:: atanl; using ::std:: atan2l; using ::std:: ceill;
using ::std:: cosl; using ::std:: coshl; using ::std:: expl;
using ::std:: fabsl; using ::std:: floorl; using ::std:: fmodl;
using ::std:: frexpl; using ::std:: ldexpl; using ::std:: logl;
using ::std:: log10l; using ::std:: modfl; using ::std:: powl;
using ::std:: sinl; using ::std:: sinhl; using ::std:: sqrtl;
using ::std:: tanl; using ::std:: tanhl;




using ::std:: _Rc_type; using ::std:: _Rc_widened;
using ::std:: _Real_type; using ::std:: _Real_widened;
using ::std:: _Combined_type;

using ::std:: _FPCOMP; using ::std:: fpclassify;
using ::std:: signbit; using ::std:: isfinite; using ::std:: isinf;
using ::std:: isnan; using ::std:: isnormal;
using ::std:: isgreater; using ::std:: isgreaterequal;
using ::std:: isless; using ::std:: islessequal; using ::std:: islessgreater;
using ::std:: isunordered;


using ::std:: float_t; using ::std:: double_t;

using ::std:: acosh; using ::std:: asinh; using ::std:: atanh;
using ::std:: cbrt; using ::std:: erf; using ::std:: erfc;
using ::std:: expm1; using ::std:: exp2;
using ::std:: hypot; using ::std:: ilogb; using ::std:: lgamma;
using ::std:: log1p; using ::std:: log2; using ::std:: logb;
using ::std:: llrint; using ::std:: lrint; using ::std:: nearbyint;
using ::std:: rint; using ::std:: llround; using ::std:: lround;
using ::std:: fdim; using ::std:: fma; using ::std:: fmax; using ::std:: fmin;
using ::std:: round; using ::std:: trunc;
using ::std:: remainder; using ::std:: remquo;
using ::std:: copysign; using ::std:: nan; using ::std:: nextafter;
using ::std:: scalbn; using ::std:: scalbln;
using ::std:: nexttoward; using ::std:: tgamma;

using ::std:: acoshf; using ::std:: asinhf; using ::std:: atanhf;
using ::std:: cbrtf; using ::std:: erff; using ::std:: erfcf;
using ::std:: expm1f; using ::std:: exp2f;
using ::std:: hypotf; using ::std:: ilogbf; using ::std:: lgammaf;
using ::std:: log1pf; using ::std:: log2f; using ::std:: logbf;
using ::std:: llrintf; using ::std:: lrintf; using ::std:: nearbyintf;
using ::std:: rintf; using ::std:: llroundf; using ::std:: lroundf;
using ::std:: fdimf; using ::std:: fmaf; using ::std:: fmaxf; using ::std:: fminf;
using ::std:: roundf; using ::std:: truncf;
using ::std:: remainderf; using ::std:: remquof;
using ::std:: copysignf; using ::std:: nanf;
using ::std:: nextafterf; using ::std:: scalbnf; using ::std:: scalblnf;
using ::std:: nexttowardf; using ::std:: tgammaf;

using ::std:: acoshl; using ::std:: asinhl; using ::std:: atanhl;
using ::std:: cbrtl; using ::std:: erfl; using ::std:: erfcl;
using ::std:: expm1l; using ::std:: exp2l;
using ::std:: hypotl; using ::std:: ilogbl; using ::std:: lgammal;
using ::std:: log1pl; using ::std:: log2l; using ::std:: logbl;
using ::std:: llrintl; using ::std:: lrintl; using ::std:: nearbyintl;
using ::std:: rintl; using ::std:: llroundl; using ::std:: lroundl;
using ::std:: fdiml; using ::std:: fmal; using ::std:: fmaxl; using ::std:: fminl;
using ::std:: roundl; using ::std:: truncl;
using ::std:: remainderl; using ::std:: remquol;
using ::std:: copysignl; using ::std:: nanl;
using ::std:: nextafterl; using ::std:: scalbnl; using ::std:: scalblnl;
using ::std:: nexttowardl; using ::std:: tgammal;




/*
 * Copyright (c) 1992-2003 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
V4.02:0216 */
# 14 "C:/usr/local/cell\\target\\ppu\\include/fastmath.h" 3

namespace std {

extern "C" {
# 1 "C:/usr/local/cell\\target\\ppu\\include/bits/fastmath-int.h" 3
/* SCE CONFIDENTIAL
PlayStation(R)3 Programmer Tool Runtime Library 475.001
 * Copyright (C) 2006 Sony Computer Entertainment Inc.
 * All Rights Reserved.
 */







extern inline float f_fmaxf(float, float);
extern inline float f_fminf(float, float);
extern inline float f_copysignf(float, float);
extern inline float f_fdimf(float, float);
extern inline float f_sqrtf(float);
extern inline float f_hypotf(float, float);
extern inline float f_rintf (float x);
extern inline long int f_lrintf (float x);
extern inline long long int f_llrintf (float x);
extern inline float f_nearbyintf (float x);
extern inline float f_fmaf(float, float, float);
extern inline float f_fmodf(float, float);
extern inline float f_log2f(float);
extern inline float f_logf(float);
extern inline float f_log10f(float);
extern inline float f_exp2f(float);
extern inline float f_expf(float);
extern inline float f_ceilf(float);
extern inline float f_floorf(float);
extern inline float f_sinf(float);
extern inline float f_cosf(float);




# 19 "C:/usr/local/cell\\target\\ppu\\include/fastmath.h" 3


























/** INLINE DEFINITIONS **/


# 1 "C:/usr/local/cell\\target\\ppu\\include/bits/f_fmaxf.h" 3
/* SCE CONFIDENTIAL
 * PlayStation(R)3 Programmer Tool Runtime Library 475.001
 *  Copyright (C) 2011 Sony Computer Entertainment Inc.
 * All Rights Reserved.
 */

/* f_fmaxf function */







extern inline float f_fmaxf (float x, float y)
{       /* compute larger of x and y */
	if (x < y)
		return (y);
	else
		return x;
}

# 49 "C:/usr/local/cell\\target\\ppu\\include/fastmath.h" 3
# 1 "C:/usr/local/cell\\target\\ppu\\include/bits/f_fminf.h" 3
/* SCE CONFIDENTIAL
 * PlayStation(R)3 Programmer Tool Runtime Library 475.001
 *  Copyright (C) 2011 Sony Computer Entertainment Inc.
 * All Rights Reserved.
 */

/* f_fminf function */







extern inline float f_fminf (float x, float y)
{       /* compute larger of x and y */
	if (x < y)
		return (x);
	else
		return (y);
}

# 50 "C:/usr/local/cell\\target\\ppu\\include/fastmath.h" 3
# 1 "C:/usr/local/cell\\target\\ppu\\include/bits/f_copysignf.h" 3
/* SCE CONFIDENTIAL
 * PlayStation(R)3 Programmer Tool Runtime Library 475.001
 * Copyright (C) 2011 Sony Computer Entertainment Inc.
 * All Rights Reserved.
 */

/* copysignf function */







extern inline float f_copysignf (float x, float y)
{	/* copy sign from y to x */
	  union U {
	    unsigned int s;
	    float f;
	  } ux, uy;
	  ux.f = x;
	  uy.f = y;

	ux.s = (ux.s & ~0x80000000) | (uy.s & 0x80000000);
	return (ux.f);
}

# 51 "C:/usr/local/cell\\target\\ppu\\include/fastmath.h" 3
# 1 "C:/usr/local/cell\\target\\ppu\\include/bits/f_fdimf.h" 3
/* SCE CONFIDENTIAL
 * PlayStation(R)3 Programmer Tool Runtime Library 475.001
 *  Copyright (C) 2011 Sony Computer Entertainment Inc.
 * All Rights Reserved.
 */

/* f_fdimf function */







extern inline float f_fdimf (float x, float y)
{
	return y < x ? x - y : 0;
}

# 52 "C:/usr/local/cell\\target\\ppu\\include/fastmath.h" 3
# 1 "C:/usr/local/cell\\target\\ppu\\include/bits/f_sqrtf.h" 3
/* SCE CONFIDENTIAL
 * PlayStation(R)3 Programmer Tool Runtime Library 475.001
 * Copyright (C) 2011 Sony Computer Entertainment Inc.
 * All Rights Reserved.
 */

/* f_sqrtf function */







extern inline float f_sqrtf (float x)
{
	float result;

	result = __builtin_fsqrts(x);



	return result;
}

# 53 "C:/usr/local/cell\\target\\ppu\\include/fastmath.h" 3
# 1 "C:/usr/local/cell\\target\\ppu\\include/bits/f_hypotf.h" 3
/* SCE CONFIDENTIAL
 * PlayStation(R)3 Programmer Tool Runtime Library 475.001
 * Copyright (C) 2011 Sony Computer Entertainment Inc.
 * All Rights Reserved.
 */

/* f_hypotf function */







extern inline float f_hypotf (float x, float y)
{
	double result, input;
	double x1 = x;
	double y1 = y;
	input = x1*x1 + y1*y1;

  	result = __builtin_fsqrt(input);



	return (float)result;
}

# 54 "C:/usr/local/cell\\target\\ppu\\include/fastmath.h" 3
# 1 "C:/usr/local/cell\\target\\ppu\\include/bits/f_rintf.h" 3
/* SCE CONFIDENTIAL
 * PlayStation(R)3 Programmer Tool Runtime Library 475.001
 * Copyright (C) 2011 Sony Computer Entertainment Inc.
 * All Rights Reserved.
 */

/* f_rintf function */







extern inline float f_rintf (float x)
{
	float result;

	result = __builtin_fcfid( __builtin_fctid( x ) );




	return result;
}

# 55 "C:/usr/local/cell\\target\\ppu\\include/fastmath.h" 3
# 1 "C:/usr/local/cell\\target\\ppu\\include/bits/f_lrintf.h" 3
/* SCE CONFIDENTIAL
 * PlayStation(R)3 Programmer Tool Runtime Library 475.001
 * Copyright (C) 2011 Sony Computer Entertainment Inc.
 * All Rights Reserved.
 */

/* f_lrintf function */







extern inline long int f_lrintf (float x)
{
        union {
		double d;
	        long int li[2];
	} udl;

	udl.d = __builtin_fctid(x);



        return udl.li[1];
}

# 56 "C:/usr/local/cell\\target\\ppu\\include/fastmath.h" 3
# 1 "C:/usr/local/cell\\target\\ppu\\include/bits/f_llrintf.h" 3
/* SCE CONFIDENTIAL
 * PlayStation(R)3 Programmer Tool Runtime Library 475.001
 * Copyright (C) 2011 Sony Computer Entertainment Inc.
 * All Rights Reserved.
 */

/* f_llrintf function */







extern inline long long int f_llrintf (float x)
{
        union {
		double d;
	        long long int li;
	} udl;

	udl.d = __builtin_fctid(x);



        return udl.li;
}

# 57 "C:/usr/local/cell\\target\\ppu\\include/fastmath.h" 3
# 1 "C:/usr/local/cell\\target\\ppu\\include/bits/f_nearbyintf.h" 3
/* SCE CONFIDENTIAL
 * PlayStation(R)3 Programmer Tool Runtime Library 475.001
 * Copyright (C) 2011 Sony Computer Entertainment Inc.
 * All Rights Reserved.
 */

/* f_nearbyintf function */







extern inline float f_nearbyintf (float x)
{
	float result;

	result = __builtin_fcfid( __builtin_fctid( x ) );




	return result;
}

# 58 "C:/usr/local/cell\\target\\ppu\\include/fastmath.h" 3
# 1 "C:/usr/local/cell\\target\\ppu\\include/bits/f_fmaf.h" 3
/* SCE CONFIDENTIAL
 * PlayStation(R)3 Programmer Tool Runtime Library 475.001
 * Copyright (C) 2011 Sony Computer Entertainment Inc.
 * All Rights Reserved.
 */

/* f_fmaf function */







extern inline float f_fmaf (float x, float y, float z)
{
	return (x*y)+z;
}

# 59 "C:/usr/local/cell\\target\\ppu\\include/fastmath.h" 3
# 1 "C:/usr/local/cell\\target\\ppu\\include/bits/f_fmodf.h" 3
/* SCE CONFIDENTIAL
 * PlayStation(R)3 Programmer Tool Runtime Library 475.001
 * Copyright (C) 2011 Sony Computer Entertainment Inc.
 * All Rights Reserved.
 */

/* --------------------------------------------------------------  */
/* PLEASE DO NOT MODIFY THIS SECTION                               */
/* This prolog section is automatically generated.                 */
/*                                                                 */
/* (C)Copyright                                                    */
/* Sony Computer Entertainment, Inc.,                              */
/* Toshiba Corporation,                                            */
/* International Business Machines Corporation,                    */
/* 2001,2002,2003. All rights reserved.                            */
/* S/T/I Confidential Information                                  */
/* --------------------------------------------------------------  */
/* PROLOG END TAG zYx                                              */

/*
 * FUNCTION
 *	float f_fmodf(float x, float y)
 *
 * DESCRIPTION
 *	The f_fmodf subroutine computes the remainder of
 *	dividing x by y. The return value is x - n*y, where n is
 *	the quotient of x/y, rounded towards zero.
 *
 *	The full range form (default) provides fmod computation on 
 *	all IEEE floating point values (excluding floating overflow
 *	or underflow).
 *
 *	The limited range form (selected by defining FMOD_INTEGER_RANGE)
 *	compute fmod of all floating-point x/y values in the 32-bit
 *	signed integer range. Values outside this range get clamped.
 */







extern inline float f_fmodf (float x, float y)
{
  int exp;
  unsigned int mask, andMask, orMask;
  float abs_y;
  union {
    float f;
    signed int i;
    unsigned int ui;
  } trunc;
  float quotient;


  abs_y = __builtin_fabsf(y);



  quotient = trunc.f = x/abs_y;

  /* Construct a mask to remove the fraction bits. The
   * mask depends on the exponent of the biased floating
   * point quotient.
   */
  exp = (trunc.ui >> 23) & 0xFF;
  exp = 127 - exp;

  orMask  = ~((unsigned int)((signed int)(exp-1) >> 31)); 
  andMask = 0x7FFFFF >> (-exp);

  mask  = (exp > -31) ? andMask : 0;
  mask |= orMask;

  trunc.ui &= ~mask;

  return (abs_y*(quotient - trunc.f));

}

# 60 "C:/usr/local/cell\\target\\ppu\\include/fastmath.h" 3
# 1 "C:/usr/local/cell\\target\\ppu\\include/bits/f_log2f.h" 3
/* SCE CONFIDENTIAL
 * PlayStation(R)3 Programmer Tool Runtime Library 475.001
 * Copyright (C) 2011 Sony Computer Entertainment Inc.
 * All Rights Reserved.
 */

/* --------------------------------------------------------------  */
/* PLEASE DO NOT MODIFY THIS SECTION                               */
/* This prolog section is automatically generated.                 */
/*                                                                 */
/* (C)Copyright                                                    */
/* Sony Computer Entertainment, Inc.,                              */
/* Toshiba Corporation,                                            */
/* International Business Machines Corporation,                    */
/* 2001,2002,2003. All rights reserved.                            */
/* S/T/I Confidential Information                                  */
/* --------------------------------------------------------------  */
/* PROLOG END TAG zYx                                              */




/*
 * FUNCTION
 *	float _log2f(float x)
 *
 * DESCRIPTION
 *	_log2f computes log (base 2) of the input value x. The log2f
 *	function is approximated as a polynomial of order 8
 *	(C. Hastings, Jr, 1955).
 *
 *                   __8__
 *		      *		       *	log2f(1+x) =   /     Ci*x^i


 *                   /____
 *                    i=1
 *
 *	for x in the range 0.0 to 1.0
 *
 *	C1 =  1.4426898816672
 *	C2 = -0.72116591947498
 *	C3 =  0.47868480909345
 *	C4 = -0.34730547155299
 *	C5 =  0.24187369696082
 *	C6 = -0.13753123777116
 *	C7 =  0.052064690894143
 *	C8 = -0.0093104962134977
 *
 *	This function assumes that x is a non-zero positive value.
 */




extern inline float f_log2f (float x)
{
  union {
    unsigned int ui;
    float f;
  } in;
  int exponent;
  float result;
  float x2, x4;
  float hi, lo;

  in.f = x;

  /* Extract the exponent from the input X. 
   */
  exponent = (signed)((in.ui >> 23) & 0xFF) - 127;

  /* Compute the remainder after removing the exponent.
   */
  in.ui -= exponent << 23;
  
  /* Calculate the log2 of the remainder using the polynomial
   * approximation.
   */
  x = in.f - 1.0f;

  /* Instruction counts can be reduced if the polynomial was
   * computed entirely from nested (dependent) fma's. However, 
   * to reduce the number of pipeline stalls, the polygon is evaluated 
   * in two halves (hi amd lo). 
   */
  x2 = x * x;
  x4 = x2 * x2;
  hi = -0.0093104962134977f*x + 0.052064690894143f;
  hi =                   hi*x - 0.13753123777116f;
  hi =                   hi*x + 0.24187369696082f;
  hi =                   hi*x - 0.34730547155299f;
  lo =  0.47868480909345f  *x - 0.72116591947498f;
  lo =                   lo*x + 1.4426898816672f;
  lo =                   lo*x;
  result = hi*x4 + lo;

  /* Add the exponent back into the result.
   */
  result += (float)(exponent);

  return (result);
}

# 61 "C:/usr/local/cell\\target\\ppu\\include/fastmath.h" 3
# 1 "C:/usr/local/cell\\target\\ppu\\include/bits/f_logf.h" 3
/* SCE CONFIDENTIAL
 * PlayStation(R)3 Programmer Tool Runtime Library 475.001
 * Copyright (C) 2011 Sony Computer Entertainment Inc.
 * All Rights Reserved.
 */

/* --------------------------------------------------------------  */
/* PLEASE DO NOT MODIFY THIS SECTION                               */
/* This prolog section is automatically generated.                 */
/*                                                                 */
/* (C)Copyright                                                    */
/* Sony Computer Entertainment, Inc.,                              */
/* Toshiba Corporation,                                            */
/* International Business Machines Corporation,                    */
/* 2001,2002,2003. All rights reserved.                            */
/* S/T/I Confidential Information                                  */
/* --------------------------------------------------------------  */






/*
 * FUNCTION
 *	float f_logf(float x)
 *
 * DESCRIPTION
 *	f_logf computes the natural log (base e) of the input value x. ln
 *	is computed using log2 as follows:
 *	
 *	   lnf(x) = log2f(x) / log2f(e);
 */




extern inline float f_logf (float x)
{
  return (f_log2f(x) * 0.69314718055995f);
}

# 62 "C:/usr/local/cell\\target\\ppu\\include/fastmath.h" 3
# 1 "C:/usr/local/cell\\target\\ppu\\include/bits/f_log10f.h" 3
/* SCE CONFIDENTIAL
 * PlayStation(R)3 Programmer Tool Runtime Library 475.001
 * Copyright (C) 2011 Sony Computer Entertainment Inc.
 * All Rights Reserved.
 */

/* --------------------------------------------------------------  */
/* PLEASE DO NOT MODIFY THIS SECTION                               */
/* This prolog section is automatically generated.                 */
/*                                                                 */
/* (C)Copyright                                                    */
/* Sony Computer Entertainment, Inc.,                              */
/* Toshiba Corporation,                                            */
/* International Business Machines Corporation,                    */
/* 2001,2002,2003. All rights reserved.                            */
/* S/T/I Confidential Information                                  */
/* --------------------------------------------------------------  */






/*
 * FUNCTION
 *	float f_log10f(float x)
 *
 * DESCRIPTION
 *	_log10f computes log (base 10) of the input value x. log10
 *	is computed using log2 as follows:
 *	
 *	   log10f(x) = log2(x) / log2(10);
 */




extern inline float f_log10f (float x)
{
  return (f_log2f(x) * 0.30102999566398f);
}

# 63 "C:/usr/local/cell\\target\\ppu\\include/fastmath.h" 3
# 1 "C:/usr/local/cell\\target\\ppu\\include/bits/f_exp2f.h" 3
/* SCE CONFIDENTIAL
 * PlayStation(R)3 Programmer Tool Runtime Library 475.001
 * * Copyright (C) 2011 Sony Computer Entertainment Inc.
 * * All Rights Reserved.
 * */

/* --------------------------------------------------------------  */
/* PLEASE DO NOT MODIFY THIS SECTION                               */
/* This prolog section is automatically generated.                 */
/*                                                                 */
/* (C)Copyright                                                    */
/* Sony Computer Entertainment, Inc.,                              */
/* Toshiba Corporation,                                            */
/* International Business Machines Corporation,                    */
/* 2001,2002,2003. All rights reserved.                            */
/* S/T/I Confidential Information                                  */
/* --------------------------------------------------------------  */
/* PROLOG END TAG zYx                                              */








/*
 * FUNCTION
 *	float _exp2f(float x)
 *
 * DESCRIPTION
 *	_exp2f computes 2 raised to the input x. Computation is 
 *	performed by observing the 2^(a+b) = 2^a * 2^b.
 *	We decompose x into a and b (above) by letting.
 *	a = ceil(x), b = x - a; 
 *
 *	2^a is easilty computed by placing a into the exponent
 *	or a floating point number whose mantissa is all zeros.
 *
 *	2^b is computed using the following polynomial approximation.
 *	(C. Hastings, Jr, 1955).
 *
 *                __7__
 *		   *		    *	2^(-x) =   /     Ci*x^i


 *                /____
 *                 i=1
 *
 *	for x in the range 0.0 to 1.0
 *
 *	C0 =  1.0
 *	C1 = -0.9999999995
 *	C2 =  0.4999999206
 *	C3 = -0.1666653019
 *	C4 =  0.0416573475
 *	C5 = -0.0083013598
 *	C6 =  0.0013298820
 *	C7 = -0.0001413161
 *
 *	This function does not handle out of range conditions. It
 *	assumes that x is in the range (-128.0, 127.0]. Values outside
 *	this range will produce undefined results.
 */










extern inline float f_exp2f (float x)
{
  union {
    float f;
    unsigned int ui;
  } bias, exp_int, exp_frac;
  int ix;
  float frac, frac2, frac4;
  float hi, lo;

  /* Break in the input x into two parts ceil(x), x - ceil(x).
   */
  bias.f = x;
  bias.ui = ~(unsigned int)((signed)(bias.ui) >> 31) & 0x3F7FFFFF;
  ix = (int)(x + bias.f);
  frac = (float)ix - x;
  frac *= 0.69314718055995f;

  exp_int.ui  = (ix + 127) << 23;

  /* Instruction counts can be reduced if the polynomial was
   * computed entirely from nested (dependent) fma's. However, 
   * to reduce the number of pipeline stalls, the polygon is evaluated 
   * in two halves (hi amd lo). 
   */
  frac2 = frac  * frac;
  frac4 = frac2 * frac2;
  hi = -0.0001413161f * frac + 0.0013298820f;
  hi =             hi * frac - 0.0083013598f;
  hi =             hi * frac + 0.0416573475f;
  lo = -0.1666653019f * frac + 0.4999999206f;
  lo =             lo * frac - 0.9999999995f;
  lo =             lo * frac + 1.0f;
  exp_frac.f =     hi * frac4 + lo;

  ix += exp_frac.ui >> 23;
  exp_frac.f *= exp_int.f;

  /* Handle overflow */
  if ((unsigned int)(ix) > 255) {
    exp_frac.ui = (ix < 0) ? 0x0 : 0x7F800000;
  }

  return (exp_frac.f);
}

# 64 "C:/usr/local/cell\\target\\ppu\\include/fastmath.h" 3
# 1 "C:/usr/local/cell\\target\\ppu\\include/bits/f_expf.h" 3
/* SCE CONFIDENTIAL
 * PlayStation(R)3 Programmer Tool Runtime Library 475.001
 * Copyright (C) 2011 Sony Computer Entertainment Inc.
 * All Rights Reserved.
 */

/* --------------------------------------------------------------  */
/* PLEASE DO NOT MODIFY THIS SECTION                               */
/* This prolog section is automatically generated.                 */
/*                                                                 */
/* (C)Copyright                                                    */
/* Sony Computer Entertainment, Inc.,                              */
/* Toshiba Corporation,                                            */
/* International Business Machines Corporation,                    */
/* 2001,2002,2003. All rights reserved.                            */
/* S/T/I Confidential Information                                  */
/* --------------------------------------------------------------  */
/* PROLOG END TAG zYx                                              */










/*
 * FUNCTION
 *	float f_expf(float x)
 *
 * DESCRIPTION
 *	f_expf computes e raised to the input x. expf is 
 *	computed using exp2f as e^x = 2^(log2(e)*x)
 */




extern inline float f_expf (float x)
{
  return (f_exp2f(1.442695040889f * x));
}

# 65 "C:/usr/local/cell\\target\\ppu\\include/fastmath.h" 3
# 1 "C:/usr/local/cell\\target\\ppu\\include/bits/f_ceilf.h" 3
/* SCE CONFIDENTIAL
 * PlayStation(R)3 Programmer Tool Runtime Library 475.001
 * Copyright (C) 2011 Sony Computer Entertainment Inc.
 * All Rights Reserved.
 */

/* ceilf--  returns smallest integer(as a float) not less than x(round x -> infinity) */ 







extern inline float f_ceilf (float x)
{
	int i=(int)x;

	typedef union trunc {
		float f;
		signed int i;
	} trunc;
        trunc xt, yt;
	xt.f=x;
	yt.f=x-(float)i;
        if(!yt.i || (xt.i&0x7f800000) >= 0x4B800000)
        	return x;
        else if(xt.i&0x80000000)
                return (float)i;
        return (float)++i;
}

# 66 "C:/usr/local/cell\\target\\ppu\\include/fastmath.h" 3
# 1 "C:/usr/local/cell\\target\\ppu\\include/bits/f_floorf.h" 3
/* SCE CONFIDENTIAL
 * PlayStation(R)3 Programmer Tool Runtime Library 475.001
 * Copyright (C) 2011 Sony Computer Entertainment Inc.
 * All Rights Reserved.
 */

/* floorf */ 







extern inline float f_floorf (float x)
{
	int i=(int)x;

	typedef union trunc {
		float f;
		signed int i;
	} trunc;
        trunc xt, yt;
	xt.f=x;
	yt.f=(float)i-x;
        if(!yt.i || (xt.i&0x7f800000) >= 0x4B800000)
        	return x;
        else
	if(xt.i&0x80000000)
                return (float)--i;
        return (float)i;
}

# 67 "C:/usr/local/cell\\target\\ppu\\include/fastmath.h" 3
# 1 "C:/usr/local/cell\\target\\ppu\\include/bits/f_sinf.h" 3
/* SCE CONFIDENTIAL
 * PlayStation(R)3 Programmer Tool Runtime Library 475.001
 * Copyright (C) 2011 Sony Computer Entertainment Inc.
 * All Rights Reserved.
 */

/* f_sinf function */









extern inline float f_sinf (float x)
{
	float y, z;
	int n;
	
	typedef union trunc {
		float f;
		signed int i;
	} trunc;
	trunc xt;
	xt.f=x;
	if (xt.i < 0)
	{
	    return -f_sinf(-x);
	}
	
    	/* range reduction */ 
    
    	y = x * (float)(4.0 / 3.141592653589793f);
	n = (int)y;
	
    	y = y - (float)n;
    
	if (n & 1)
	{
	    y = 1.0f - y;
	}
	if ((n+1)&2)
	{
	    z = (((-0.31872783e-3f * y*y + 0.1584968416e-1f) * y*y + (-0.30842416558f)) * y*y + 0.9999999673f);
	}
	else
	{
		z = (((-0.35950439e-4f * y*y + 0.2490001007e-2f) * y*y + (-0.8074543253e-1f)) * y*y + 0.7853981633f) * y;
	}
	if ((n & 7) > 3)
	{
	    z = -z;
	}
	return z;
	
}

# 68 "C:/usr/local/cell\\target\\ppu\\include/fastmath.h" 3
# 1 "C:/usr/local/cell\\target\\ppu\\include/bits/f_cosf.h" 3
/* SCE CONFIDENTIAL
 * PlayStation(R)3 Programmer Tool Runtime Library 475.001
 * Copyright (C) 2011 Sony Computer Entertainment Inc.
 * All Rights Reserved.
 */

/* f_cosf function */









extern inline float f_cosf (float x)
{
	float y, z;
	int n;
	
	typedef union trunc {
		float f;
	  	signed int i;
	 } trunc;
	 trunc xt;
	 xt.f = x;
	 
	if (xt.i < 0)
	{
	    return f_cosf(-x);
	}

	/* range reduction */
	
    	y = x * (float)(4.0 / 3.141592653589793f);
	n = (int)y;
    	y = y - (float)n;
            
	if (n & 1)
	{
	    	y = 1.0f - y;
	}
	if ((n+1)&2)
	{
	    	z = (((-0.35950439e-4f * y*y + 0.2490001007e-2f) * y*y + (-0.8074543253e-1f)) * y*y + 0.7853981633f) * y;
	}
	else
	{
		z = (((-0.31872783e-3f * y*y + 0.1584968416e-1f) * y*y + (-0.30842416558f)) * y*y + 0.9999999673f);
	}
	if (((n+2) & 7) > 3)
	{
	    	z = -z;
	}

	return z;
}

# 69 "C:/usr/local/cell\\target\\ppu\\include/fastmath.h" 3



float f_acosf(float);
float f_asinf(float);
float f_atanf(float);
float f_atan2f(float, float);
float f_frexpf(float, int*);
float f_ldexpf(float, int);
long long int f_llroundf(float);
float f_log1pf(float);
long int f_lroundf(float);
float f_tanf(float);
float f_powf(float, float);

}
}




































































































using ::std:: f_fmaxf;
using ::std:: f_fminf;
using ::std:: f_copysignf;
using ::std:: f_fdimf;
using ::std:: f_sqrtf;
using ::std:: f_hypotf;
using ::std:: f_rintf; 
using ::std:: f_lrintf;
using ::std:: f_llrintf;
using ::std:: f_nearbyintf;
using ::std:: f_fmaf; 
using ::std:: f_fmodf; 
using ::std:: f_log2f; 
using ::std:: f_logf;
using ::std:: f_log10f;
using ::std:: f_exp2f;
using ::std:: f_expf;
using ::std:: f_ceilf; 
using ::std:: f_floorf;
using ::std:: f_sinf;
using ::std:: f_cosf;
using ::std:: f_acosf;
using ::std:: f_asinf;
using ::std:: f_atanf;
using ::std:: f_atan2f;
using ::std:: f_frexpf;
using ::std:: f_ldexpf;
using ::std:: f_llroundf;
using ::std:: f_log1pf;
using ::std:: f_lroundf;
using ::std:: f_tanf;
using ::std:: f_powf;




# 41 "C:\\Users\\USER\\Documents\\Visual Studio 2013\\Projects\\mp3_plugin_PS3\\mp3_plugin_PS3\\main.cpp"
# 1 "C:/usr/local/cell\\target\\ppu\\include/math.h" 3
/* SCE CONFIDENTIAL
PlayStation(R)3 Programmer Tool Runtime Library 475.001
* Copyright (C) 2004 Sony Computer Entertainment Inc. 
* All Rights Reserved.
*/
/* math.h standard header */
# 1476 "C:/usr/local/cell\\target\\ppu\\include/math.h" 3

/* Only include the SCE extensions when altivec is enabled */
# 1 "C:/usr/local/cell\\target\\ppu\\include/bits/sce_math.h" 3
/* SCE CONFIDENTIAL
PlayStation(R)3 Programmer Tool Runtime Library 475.001
* Copyright (C) 2004 Sony Computer Entertainment Inc. 
* All Rights Reserved.
*/
# 173 "C:/usr/local/cell\\target\\ppu\\include/bits/sce_math.h" 3

# 1480 "C:/usr/local/cell\\target\\ppu\\include/math.h" 3


# 1577 "C:/usr/local/cell\\target\\ppu\\include/math.h" 3

/*
 * Copyright (c) 1992-2003 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
V4.02:0216 */
# 42 "C:\\Users\\USER\\Documents\\Visual Studio 2013\\Projects\\mp3_plugin_PS3\\mp3_plugin_PS3\\main.cpp"
# 1 "C:/usr/local/cell\\target\\ppu\\include/ctype.h" 3
/* SCE CONFIDENTIAL
* PlayStation(R)3 Programmer Tool Runtime Library 475.001
* Copyright (C) 2006 Sony Computer Entertainment Inc.
* All Rights Reserved.
*/
/* ctype.h standard header */






namespace std {

		/* _Ctype code bits */
# 27 "C:/usr/local/cell\\target\\ppu\\include/ctype.h" 3

extern "C" {
typedef const short *_Ctype_t;

extern const short *__ctype_ptr;

_Ctype_t _Getpctype(void);
_Ctype_t _Getptolower(void);
_Ctype_t _Getptoupper(void);


// for special vsh 
//extern _TLS_QUAL _Ctype_t _Ctype;
//extern _TLS_QUAL _Ctype_t _Tolotab;
//extern _TLS_QUAL _Ctype_t _Touptab;

extern _Ctype_t _Ctype;
extern _Ctype_t _Tolotab;
extern _Ctype_t _Touptab;









}


		// INLINES, for C++
extern "C" {
inline int isalnum(int _Ch)
	{	// check alnum bits
	return ((__ctype_ptr)[_Ch] & (0x20|0x10|0x02|0x200));
	}

inline int isalpha(int _Ch)
	{	// check alpha bits
	return ((__ctype_ptr)[_Ch] & (0x10|0x02|0x200));
	}

inline int iscntrl(int _Ch)
	{	// check cntrl bits
	return ((__ctype_ptr)[_Ch] & 0x80);
	}

inline int isdigit(int _Ch)
	{	// check digit bits
	return ((__ctype_ptr)[_Ch] & 0x20);
	}

inline int isgraph(int _Ch)
	{	// check graph bits
	return ((__ctype_ptr)[_Ch] & (0x20|0x10|0x08|0x02|0x200));
	}

inline int islower(int _Ch)
	{	// check alnum bits
	return ((__ctype_ptr)[_Ch] & 0x10);
	}

inline int isprint(int _Ch)
	{	// check print bits
	return ((__ctype_ptr)[_Ch] & (0x20|0x10|0x08|0x04|0x02|0x200));
	}

inline int ispunct(int _Ch)
	{	// check punct bits
	return ((__ctype_ptr)[_Ch] & 0x08);
	}

inline int _Isspace(int _Ch)
	{	// check space bits
	return ((__ctype_ptr)[_Ch] & (0x40|0x04|0x100));
	}

inline int isspace(int _Ch)
	{	// check space bits
	return (_Isspace(_Ch));
	}

inline int isupper(int _Ch)
	{	// check upper bits
	return ((__ctype_ptr)[_Ch] & 0x02);
	}

inline int isxdigit(int _Ch)
	{	// check xdigit bits
	return ((__ctype_ptr)[_Ch] & 0x01);
	}


inline int isblank(int _Ch)
	{	// check blank bits
	return ((__ctype_ptr)[_Ch] & (0x04|0x400));
	}


inline int tolower(int _Ch)
	{	// convert to lower case
	int __x=_Ch; 
	return (isupper(__x) ? (__x - 'A' + 'a') : __x);
	}

inline int toupper(int _Ch)
	{	// convert to upper case
	int __x=_Ch; 
	return (islower(__x) ? (__x - 'a' + 'A') : __x);
	}

inline int isalnum_ascii(int _Ch)
	{	// check alnum bits
	return ((__ctype_ptr)[_Ch] & (0x20|0x10|0x02|0x200));
	}

inline int isalpha_ascii(int _Ch)
	{	// check alpha bits
	return ((__ctype_ptr)[_Ch] & (0x10|0x02|0x200));
	}

inline int iscntrl_ascii(int _Ch)
	{	// check cntrl bits
	return ((__ctype_ptr)[_Ch] & 0x80);
	}

inline int isdigit_ascii(int _Ch)
	{	// check digit bits
	return ((__ctype_ptr)[_Ch] & 0x20);
	}

inline int isgraph_ascii(int _Ch)
	{	// check graph bits
	return ((__ctype_ptr)[_Ch] & (0x20|0x10|0x08|0x02|0x200));
	}

inline int islower_ascii(int _Ch)
	{	// check alnum bits
	return ((__ctype_ptr)[_Ch] & 0x10);
	}

inline int isprint_ascii(int _Ch)
	{	// check print bits
	return ((__ctype_ptr)[_Ch] & (0x20|0x10|0x08|0x04|0x02|0x200));
	}

inline int ispunct_ascii(int _Ch)
	{	// check punct bits
	return ((__ctype_ptr)[_Ch] & 0x08);
	}

inline int _Isspace_ascii(int _Ch)
	{	// check space bits
	return ((__ctype_ptr)[_Ch] & (0x40|0x04|0x100));
	}

inline int isspace_ascii(int _Ch)
	{	// check space bits
	return (_Isspace_ascii(_Ch));
	}

inline int isupper_ascii(int _Ch)
	{	// check upper bits
	return ((__ctype_ptr)[_Ch] & 0x02);
	}

inline int isxdigit_ascii(int _Ch)
	{	// check xdigit bits
	return ((__ctype_ptr)[_Ch] & 0x01);
	}


inline int isblank_ascii(int _Ch)
	{	// check blank bits
	return ((__ctype_ptr)[_Ch] & (0x04|0x400));
	}


inline int tolower_ascii(int _Ch)
	{	// convert to lower case
	int __x=_Ch; 
	return (isupper(__x) ? (__x - 'A' + 'a') : __x);
	}

inline int toupper_ascii(int _Ch)
	{	// convert to upper case
	int __x=_Ch; 
	return (islower(__x) ? (__x - 'a' + 'A') : __x);
	}


}

# 283 "C:/usr/local/cell\\target\\ppu\\include/ctype.h" 3

}





using ::std:: isalnum; using ::std:: isalpha; using ::std:: iscntrl;
using ::std:: isdigit; using ::std:: isgraph; using ::std:: islower;
using ::std:: isprint; using ::std:: ispunct; using ::std:: isspace;
using ::std:: isupper; using ::std:: isxdigit; using ::std:: tolower;
using ::std:: toupper;
using ::std:: isalnum_ascii; using ::std:: isalpha_ascii; using ::std:: iscntrl_ascii;
using ::std:: isdigit_ascii; using ::std:: isgraph_ascii; using ::std:: islower_ascii;
using ::std:: isprint_ascii; using ::std:: ispunct_ascii; using ::std:: isspace_ascii;
using ::std:: isupper_ascii; using ::std:: isxdigit_ascii; using ::std:: tolower_ascii;
using ::std:: toupper_ascii;


using ::std:: isblank;
using ::std:: isblank_ascii;




/*
 * Copyright (c) 1992-2003 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
V4.02:0216 */
# 43 "C:\\Users\\USER\\Documents\\Visual Studio 2013\\Projects\\mp3_plugin_PS3\\mp3_plugin_PS3\\main.cpp"
# 1 "C:/usr/local/cell\\target\\ppu\\include/hash_map" 3
// hash_map standard header
# 1 "C:/usr/local/cell\\target\\ppu\\include/xhash" 3
/* SCE CONFIDENTIAL
 PlayStation(R)3 Programmer Tool Runtime Library 475.001
 * Copyright (C) 2006 Sony Computer Entertainment Inc.
 * All Rights Reserved.
 */
// xhash internal header
# 1 "C:/usr/local/cell\\target\\ppu\\include/cstring" 3
/* SCE CONFIDENTIAL
PlayStation(R)3 Programmer Tool Runtime Library 475.001
* Copyright (C) 2005 Sony Computer Entertainment Inc. 
* All Rights Reserved.
*/
// cstring standard header




# 1 "C:/usr/local/cell\\target\\ppu\\include/string.h" 3
/* SCE CONFIDENTIAL
* PlayStation(R)3 Programmer Tool Runtime Library 475.001
* Copyright (C) 2008 Sony Computer Entertainment Inc. 
* All Rights Reserved.
*/
/* string.h standard header */
# 122 "C:/usr/local/cell\\target\\ppu\\include/string.h" 3

# 138 "C:/usr/local/cell\\target\\ppu\\include/string.h" 3

/*
 * Copyright (c) 1992-2003 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
V4.02:0216 */
# 14 "C:/usr/local/cell\\target\\ppu\\include/cstring" 3


# 61 "C:/usr/local/cell\\target\\ppu\\include/cstring" 3

/*
 * Copyright (c) 1992-2003 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
V4.02:0216 */
# 10 "C:/usr/local/cell\\target\\ppu\\include/xhash" 3
# 1 "C:/usr/local/cell\\target\\ppu\\include/cwchar" 3
/* SCE CONFIDENTIAL
PlayStation(R)3 Programmer Tool Runtime Library 475.001
* Copyright (C) 2005 Sony Computer Entertainment Inc. 
* All Rights Reserved.
*/
// cwchar standard header




# 1 "C:/usr/local/cell\\target\\ppu\\include/wchar.h" 3
/* SCE CONFIDENTIAL
PlayStation(R)3 Programmer Tool Runtime Library 475.001
* Copyright (C) 2005 Sony Computer Entertainment Inc. 
* All Rights Reserved.
*/
/* wchar.h standard header */








namespace std {

		/* MACROS */












		/* TYPE DEFINITIONS */
# 39 "C:/usr/local/cell\\target\\ppu\\include/wchar.h" 3

typedef _Mbstatet mbstate_t;

struct tm;
struct _Filet;








typedef _Wintt wint_t;


extern "C" {
		/* stdio DECLARATIONS */
wint_t fgetwc(struct _Filet *);
wchar_t *fgetws(wchar_t *, int,
	struct _Filet *);
wint_t fputwc(wchar_t, struct _Filet *);
int fputws(const wchar_t *,
	struct _Filet *);
int fwide(struct _Filet *, int);
int fwprintf(struct _Filet *,
	const wchar_t *, ...);
int fwscanf(struct _Filet *,
	const wchar_t *, ...);
wint_t getwc(struct _Filet *);
wint_t getwchar(void);
wint_t putwc(wchar_t, struct _Filet *);
wint_t putwchar(wchar_t);
int swprintf(wchar_t *, size_t,
	const wchar_t *, ...);
int swscanf(const wchar_t *,
	const wchar_t *, ...);
wint_t ungetwc(wint_t, struct _Filet *);
int vfwprintf(struct _Filet *,
	const wchar_t *, _Va_list);
int vswprintf(wchar_t *, size_t,
	const wchar_t *, _Va_list);
int vwprintf(const wchar_t *, _Va_list);
int wprintf(const wchar_t *, ...);
int wscanf(const wchar_t *, ...);


int vfwscanf(struct _Filet *,
	const wchar_t *, _Va_list);
int vswscanf(const wchar_t *,
	const wchar_t *, _Va_list);
int vwscanf(const wchar_t *, _Va_list);


		/* stdlib DECLARATIONS */
size_t mbrlen(const char *,
	size_t, mbstate_t *);
size_t mbrtowc(wchar_t *, const char *,
	size_t, mbstate_t *);
size_t mbsrtowcs(wchar_t *,
	const char **, size_t, mbstate_t *);
int mbsinit(const mbstate_t *);
size_t wcrtomb(char *,
	wchar_t, mbstate_t *);
size_t wcsrtombs(char *,
	const wchar_t **, size_t, mbstate_t *);
long wcstol(const wchar_t *,
	wchar_t **, int);


_Longlong wcstoll(const wchar_t *,
	wchar_t **, int);
_ULonglong wcstoull(const wchar_t *,
	wchar_t **, int);


		/* string DECLARATIONS */
wchar_t *wcscat(wchar_t *, const wchar_t *);
int wcscmp(const wchar_t *, const wchar_t *);
wchar_t *wcscpy(wchar_t *, const wchar_t *);
size_t wcslen(const wchar_t *);
int wcsncmp(const wchar_t *, const wchar_t *, size_t);
wchar_t *wcsncpy(wchar_t *,
	const wchar_t *, size_t);

int wcscoll(const wchar_t *, const wchar_t *);
size_t wcscspn(const wchar_t *, const wchar_t *);
wchar_t *wcsncat(wchar_t *,
	const wchar_t *, size_t);
size_t wcsspn(const wchar_t *, const wchar_t *);
wchar_t *wcstok(wchar_t *, const wchar_t *,
	wchar_t **);
size_t wcsxfrm(wchar_t *,
	const wchar_t *, size_t);
int wmemcmp(const wchar_t *, const wchar_t *, size_t);
wchar_t *wmemcpy(wchar_t *,
	const wchar_t *, size_t);
wchar_t *wmemmove(wchar_t *, const wchar_t *, size_t);
wchar_t *wmemset(wchar_t *, wchar_t, size_t);
 
		/* time DECLARATIONS */
size_t wcsftime(wchar_t *, size_t,
	const wchar_t *, const struct tm *);

wint_t _Btowc(int);
int _Wctob(wint_t);
double _WStod(const wchar_t *, wchar_t **, long);
float _WStof(const wchar_t *, wchar_t **, long);
long double _WStold(const wchar_t *, wchar_t **, long);
unsigned long _WStoul(const wchar_t *, wchar_t **, int);
}


		// INLINES AND OVERLOADS, FOR C++


extern "C" {
const wchar_t *wmemchr(const wchar_t *, wchar_t, size_t);
}

inline wchar_t *wmemchr(wchar_t *_Str, wchar_t _Ch, size_t _Num) {
  // call with const first argument
  return (const_cast<wchar_t *>(wmemchr((const wchar_t *)_Str, _Ch, _Num)));
}

# 171 "C:/usr/local/cell\\target\\ppu\\include/wchar.h" 3

# 1 "C:/usr/local/cell\\target\\ppu\\include/xwcstod.h" 3
/* xwcstod.h internal header */




		/* INLINES, FOR C++ */
extern "C" {
inline double wcstod(const wchar_t * _Str,
	wchar_t ** _Endptr)
	{return (_WStod(_Str, _Endptr, 0));
	}

inline unsigned long wcstoul(const wchar_t * _Str,
	wchar_t ** _Endptr, int _Base)
	{return (_WStoul(_Str, _Endptr, _Base));
	}
}

# 29 "C:/usr/local/cell\\target\\ppu\\include/xwcstod.h" 3



/*
 * Copyright (c) 1992-2003 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
V4.02:0216 */
# 173 "C:/usr/local/cell\\target\\ppu\\include/wchar.h" 3
# 1 "C:/usr/local/cell\\target\\ppu\\include/xwstr.h" 3
/* SCE CONFIDENTIAL
* PlayStation(R)3 Programmer Tool Runtime Library 475.001
* Copyright (C) 2005 Sony Computer Entertainment Inc. 
* All Rights Reserved.
*/
/* xwstr.h internal header */




		/* INLINES AND OVERLOADS, FOR C++ */
extern "C" {
const wchar_t *wcschr(const wchar_t *, wchar_t);
const wchar_t *wcspbrk(const wchar_t *, const wchar_t *);
const wchar_t *wcsrchr(const wchar_t *, wchar_t);
const wchar_t *wcsstr(const wchar_t *, const wchar_t *);
}

inline wchar_t *wcschr(wchar_t *_Str, wchar_t _Ch) {
  return (const_cast<wchar_t *>(wcschr((const wchar_t *)_Str, _Ch)));
}

inline wchar_t *wcspbrk(wchar_t *_Str1, const wchar_t *_Str2) {
  return (const_cast<wchar_t *>(wcspbrk((const wchar_t *)_Str1, _Str2)));
}

inline wchar_t *wcsrchr(wchar_t *_Str, wchar_t _Ch) {
  return (const_cast<wchar_t *>(wcsrchr((const wchar_t *)_Str, _Ch)));
}

inline wchar_t *wcsstr(wchar_t *_Str1, const wchar_t *_Str2) {
  return (const_cast<wchar_t *>(wcsstr((const wchar_t *)_Str1, _Str2)));
}

extern "C" {
inline wint_t btowc(int _By)
	{	// convert single byte to wide character
	return (_Btowc(_By));
	}

inline int wctob(wint_t _Wc)
	{	// convert wide character to single byte
	return (_Wctob(_Wc));
	}


inline float wcstof(const wchar_t * _Str,
	wchar_t ** _Endptr)
	{	// convert wide string to float
	return (_WStof(_Str, _Endptr, 0));
	}

inline long double wcstold(const wchar_t * _Str,
	wchar_t ** _Endptr)
	{	// convert wide string to double
	return (_WStold(_Str, _Endptr, 0));
	}


}

# 87 "C:/usr/local/cell\\target\\ppu\\include/xwstr.h" 3



/*
 * Copyright (c) 1992-2003 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
V4.02:0216 */
# 174 "C:/usr/local/cell\\target\\ppu\\include/wchar.h" 3
}


# 207 "C:/usr/local/cell\\target\\ppu\\include/wchar.h" 3

/*
 * Copyright (c) 1992-2003 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
V4.02:0216 */
# 14 "C:/usr/local/cell\\target\\ppu\\include/cwchar" 3


# 52 "C:/usr/local/cell\\target\\ppu\\include/cwchar" 3

/*
 * Copyright (c) 1992-2003 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
V4.02:0216 */
# 11 "C:/usr/local/cell\\target\\ppu\\include/xhash" 3
# 1 "C:/usr/local/cell\\target\\ppu\\include/functional" 3
// functional standard header
# 1 "C:/usr/local/cell\\target\\ppu\\include/xstddef" 3
// xstddef standard header






# 1 "C:/usr/local/cell\\target\\ppu\\include/cstddef" 3
/* SCE CONFIDENTIAL
PlayStation(R)3 Programmer Tool Runtime Library 475.001
* Copyright (C) 2005 Sony Computer Entertainment Inc. 
* All Rights Reserved.
*/
// cstddef standard header




# 1 "C:/usr/local/cell\\target\\ppu\\include/stddef.h" 3
/* SCE CONFIDENTIAL
PlayStation(R)3 Programmer Tool Runtime Library 475.001
* Copyright (C) 2005 Sony Computer Entertainment Inc. 
* All Rights Reserved.
*/
/* stddef.h standard header */
# 54 "C:/usr/local/cell\\target\\ppu\\include/stddef.h" 3

# 62 "C:/usr/local/cell\\target\\ppu\\include/stddef.h" 3

/*
 * Copyright (c) 1992-2003 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
V4.02:0216 */
# 14 "C:/usr/local/cell\\target\\ppu\\include/cstddef" 3


# 27 "C:/usr/local/cell\\target\\ppu\\include/cstddef" 3

/*
 * Copyright (c) 1992-2003 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
V4.02:0216 */
# 9 "C:/usr/local/cell\\target\\ppu\\include/xstddef" 3
namespace std {

		// EXCEPTION MACROS

# 31 "C:/usr/local/cell\\target\\ppu\\include/xstddef" 3

# 38 "C:/usr/local/cell\\target\\ppu\\include/xstddef" 3








		// typename KEYWORD
/*  #define _TEMPLATE	template<> */






/*   #define _TEMPLATE_MEMBER	template */


		// BITMASK MACROS


# 95 "C:/usr/local/cell\\target\\ppu\\include/xstddef" 3

		// MISCELLANEOUS MACROS















		// TYPE DEFINITIONS
enum _Uninitialized
	{	// tag for suppressing initialization
	_Noinit};
}


/*
 * Copyright (c) 1992-2003 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
V4.02:0216 */
# 5 "C:/usr/local/cell\\target\\ppu\\include/functional" 3
namespace std {

		// TEMPLATE STRUCT unary_function
template<class _Arg,
	class _Result>
	struct unary_function
	{	// base class for unary functions
	typedef _Arg argument_type;
	typedef _Result result_type;
	};

		// TEMPLATE STRUCT binary_function
template<class _Arg1,
	class _Arg2,
	class _Result>
	struct binary_function
	{	// base class for binary functions
	typedef _Arg1 first_argument_type;
	typedef _Arg2 second_argument_type;
	typedef _Result result_type;
	};

		// TEMPLATE STRUCT plus
template<class _Ty>
	struct plus
		: public binary_function<_Ty, _Ty, _Ty>
	{	// functor for operator+
	_Ty operator()(const _Ty& _Left, const _Ty& _Right) const
		{	// apply operator+ to operands
		return (_Left + _Right);
		}
	};

		// TEMPLATE STRUCT minus
template<class _Ty>
	struct minus
		: public binary_function<_Ty, _Ty, _Ty>
	{	// functor for operator-
	_Ty operator()(const _Ty& _Left, const _Ty& _Right) const
		{	// apply operator- to operands
		return (_Left - _Right);
		}
	};

		// TEMPLATE STRUCT multiplies
template<class _Ty>
	struct multiplies
		: public binary_function<_Ty, _Ty, _Ty>
	{	// functor for operator*
	_Ty operator()(const _Ty& _Left, const _Ty& _Right) const
		{	// apply operator* to operands
		return (_Left * _Right);
		}
	};

		// TEMPLATE STRUCT divides
template<class _Ty>
	struct divides
		: public binary_function<_Ty, _Ty, _Ty>
	{	// functor for operator/
	_Ty operator()(const _Ty& _Left, const _Ty& _Right) const
		{	// apply operator/ to operands
		return (_Left / _Right);
		}
	};

		// TEMPLATE STRUCT modulus
template<class _Ty>
	struct modulus
		: public binary_function<_Ty, _Ty, _Ty>
	{	// functor for operator%
	_Ty operator()(const _Ty& _Left, const _Ty& _Right) const
		{	// apply operator% to operands
		return (_Left % _Right);
		}
	};

		// TEMPLATE STRUCT negate
template<class _Ty>
	struct negate
		: public unary_function<_Ty, _Ty>
	{	// functor for unary operator-
	_Ty operator()(const _Ty& _Left) const
		{	// apply operator- to operand
		return (-_Left);
		}
	};

		// TEMPLATE STRUCT equal_to
template<class _Ty>
	struct equal_to
		: public binary_function<_Ty, _Ty, bool>
	{	// functor for operator==
	bool operator()(const _Ty& _Left, const _Ty& _Right) const
		{	// apply operator== to operands
		return (_Left == _Right);
		}
	};

		// TEMPLATE STRUCT not_equal_to
template<class _Ty>
	struct not_equal_to
		: public binary_function<_Ty, _Ty, bool>
	{	// functor for operator!=
	bool operator()(const _Ty& _Left, const _Ty& _Right) const
		{	// apply operator= to operands
		return (_Left != _Right);
		}
	};

		// TEMPLATE STRUCT greater
template<class _Ty>
	struct greater
		: public binary_function<_Ty, _Ty, bool>
	{	// functor for operator>
	bool operator()(const _Ty& _Left, const _Ty& _Right) const
		{	// apply operator> to operands
		return (_Left > _Right);
		}
	};

		// TEMPLATE STRUCT less
template<class _Ty>
	struct less
		: public binary_function<_Ty, _Ty, bool>
	{	// functor for operator<
	bool operator()(const _Ty& _Left, const _Ty& _Right) const
		{	// apply operator< to operands
		return (_Left < _Right);
		}
	};

		// TEMPLATE STRUCT greater_equal
template<class _Ty>
	struct greater_equal
		: public binary_function<_Ty, _Ty, bool>
	{	// functor for operator>=
	bool operator()(const _Ty& _Left, const _Ty& _Right) const
		{	// apply operator>= to operands
		return (_Left >= _Right);
		}
	};

		// TEMPLATE STRUCT less_equal
template<class _Ty>
	struct less_equal
		: public binary_function<_Ty, _Ty, bool>
	{	// functor for operator<=
	bool operator()(const _Ty& _Left, const _Ty& _Right) const
		{	// apply operator<= to operands
		return (_Left <= _Right);
		}
	};

		// TEMPLATE STRUCT logical_and
template<class _Ty>
	struct logical_and
		: public binary_function<_Ty, _Ty, bool>
	{	// functor for operator&&
	bool operator()(const _Ty& _Left, const _Ty& _Right) const
		{	// apply operator&& to operands
		return (_Left && _Right);
		}
	};

		// TEMPLATE STRUCT logical_or
template<class _Ty>
	struct logical_or
		: public binary_function<_Ty, _Ty, bool>
	{	// functor for operator||
	bool operator()(const _Ty& _Left, const _Ty& _Right) const
		{	// apply operator|| to operands
		return (_Left || _Right);
		}
	};

		// TEMPLATE STRUCT logical_not
template<class _Ty>
	struct logical_not
		: public unary_function<_Ty, bool>
	{	// functor for unary operator!
	bool operator()(const _Ty& _Left) const
		{	// apply operator! to operand
		return (!_Left);
		}
	};

		// TEMPLATE CLASS unary_negate
template<class _Fn1>
	class unary_negate
	: public unary_function<typename _Fn1::argument_type, bool>
	{	// functor adapter !_Func(left)
public:
	explicit unary_negate(const _Fn1& _Func)
		: _Functor(_Func)
		{	// construct from functor
		}

	bool operator()(const typename _Fn1::argument_type& _Left) const
		{	// apply functor to operand
		return (!_Functor(_Left));
		}

protected:
	_Fn1 _Functor;	// the functor to apply
	};

		// TEMPLATE FUNCTION not1
template<class _Fn1> inline
	unary_negate<_Fn1> not1(const _Fn1& _Func)
	{	// return a unary_negate functor adapter
	return (::std:: unary_negate<_Fn1>(_Func));
	}

		// TEMPLATE CLASS binary_negate
template<class _Fn2>
	class binary_negate
		: public binary_function<typename _Fn2::first_argument_type,
			typename _Fn2::second_argument_type, bool>
	{	// functor adapter !_Func(left, right)
public:
	explicit binary_negate(const _Fn2& _Func)
		: _Functor(_Func)
		{	// construct from functor
		}

	bool operator()(const typename _Fn2::first_argument_type& _Left,
		const typename _Fn2::second_argument_type& _Right) const
		{	// apply functor to operands
		return (!_Functor(_Left, _Right));
		}

protected:
	_Fn2 _Functor;	// the functor to apply
	};

		// TEMPLATE FUNCTION not2
template<class _Fn2> inline
	binary_negate<_Fn2> not2(const _Fn2& _Func)
	{	// return a binary_negate functor adapter
	return (::std:: binary_negate<_Fn2>(_Func));
	}

		// TEMPLATE CLASS binder1st
template<class _Fn2>
	class binder1st
		: public unary_function<typename _Fn2::second_argument_type,
			typename _Fn2::result_type>
	{	// functor adapter _Func(stored, right)
public:
	typedef unary_function<typename _Fn2::second_argument_type,
		typename _Fn2::result_type> _Base;
	typedef typename _Base::argument_type argument_type;
	typedef typename _Base::result_type result_type;

	binder1st(const _Fn2& _Func,
		const typename _Fn2::first_argument_type& _Left)
		: op(_Func), value(_Left)
		{	// construct from functor and left operand
		}

	result_type operator()(const argument_type& _Right) const
		{	// apply functor to operands
		return (op(value, _Right));
		}

	result_type operator()(argument_type& _Right) const
		{	// apply functor to operands
		return (op(value, _Right));
		}

protected:
	_Fn2 op;	// the functor to apply
	typename _Fn2::first_argument_type value;	// the left operand
	};

		// TEMPLATE FUNCTION bind1st
template<class _Fn2,
	class _Ty> inline
	binder1st<_Fn2> bind1st(const _Fn2& _Func, const _Ty& _Left)
		{	// return a binder1st functor adapter
		typename _Fn2::first_argument_type _Val(_Left);
		return (::std:: binder1st<_Fn2>(_Func, _Val));
		}

		// TEMPLATE CLASS binder2nd
template<class _Fn2>
	class binder2nd
		: public unary_function<typename _Fn2::first_argument_type,
			typename _Fn2::result_type>
	{	// functor adapter _Func(left, stored)
public:
	typedef unary_function<typename _Fn2::first_argument_type,
		typename _Fn2::result_type> _Base;
	typedef typename _Base::argument_type argument_type;
	typedef typename _Base::result_type result_type;

	binder2nd(const _Fn2& _Func,
		const typename _Fn2::second_argument_type& _Right)
		: op(_Func), value(_Right)
		{	// construct from functor and right operand
		}

	result_type operator()(const argument_type& _Left) const
		{	// apply functor to operands
		return (op(_Left, value));
		}

	result_type operator()(argument_type& _Left) const
		{	// apply functor to operands
		return (op(_Left, value));
		}

protected:
	_Fn2 op;	// the functor to apply
	typename _Fn2::second_argument_type value;	// the right operand
	};

		// TEMPLATE FUNCTION bind2nd
template<class _Fn2,
	class _Ty> inline
	binder2nd<_Fn2> bind2nd(const _Fn2& _Func, const _Ty& _Right)
	{	// return a binder2nd functor adapter
	typename _Fn2::second_argument_type _Val(_Right);
	return (::std:: binder2nd<_Fn2>(_Func, _Val));
	}

		// TEMPLATE CLASS pointer_to_unary_function
template<class _Arg,
	class _Result>
	class pointer_to_unary_function
		: public unary_function<_Arg, _Result>
	{	// functor adapter (*pfunc)(left)
public:
	explicit pointer_to_unary_function(_Result (*_Left)(_Arg))
		: _Pfun(_Left)
		{	// construct from pointer
		}

	_Result operator()(_Arg _Left) const
		{	// call function with operand
		return (_Pfun(_Left));
		}

protected:
	_Result (*_Pfun)(_Arg);	// the function pointer
	};

		// TEMPLATE CLASS pointer_to_binary_function
template<class _Arg1,
	class _Arg2,
	class _Result>
	class pointer_to_binary_function
		: public binary_function<_Arg1, _Arg2, _Result>
	{	// functor adapter (*pfunc)(left, right)
public:
	explicit pointer_to_binary_function(
		_Result (*_Left)(_Arg1, _Arg2))
		: _Pfun(_Left)
		{	// construct from pointer
		}

	_Result operator()(_Arg1 _Left, _Arg2 _Right) const
		{	// call function with operands
		return (_Pfun(_Left, _Right));
		}

protected:
	_Result (*_Pfun)(_Arg1, _Arg2);	// the function pointer
	};

		// TEMPLATE FUNCTION ptr_fun
template<class _Arg,
	class _Result> inline
	pointer_to_unary_function<_Arg, _Result>
		ptr_fun(_Result (*_Left)(_Arg))
	{	// return pointer_to_unary_function functor adapter
	return (::std:: pointer_to_unary_function<_Arg, _Result>(_Left));
	}

template<class _Arg1,
	class _Arg2,
	class _Result> inline
	pointer_to_binary_function<_Arg1, _Arg2, _Result>
		ptr_fun(_Result (*_Left)(_Arg1, _Arg2))
	{	// return pointer_to_binary_function functor adapter
	return (::std:: pointer_to_binary_function<_Arg1, _Arg2, _Result>(_Left));
	}

		// TEMPLATE CLASS mem_fun_t
template<class _Result,
	class _Ty>
	class mem_fun_t
		: public unary_function<_Ty *, _Result>
	{	// functor adapter (*p->*pfunc)(), non-const *pfunc
public:
	explicit mem_fun_t(_Result (_Ty::*_Pm)())
		: _Pmemfun(_Pm)
		{	// construct from pointer
		}

	_Result operator()(_Ty *_Pleft) const
		{	// call function
		return ((_Pleft->*_Pmemfun)());
		}

private:
	_Result (_Ty::*_Pmemfun)();	// the member function pointer
	};

		// TEMPLATE CLASS mem_fun1_t
template<class _Result,
	class _Ty,
	class _Arg>
	class mem_fun1_t
		: public binary_function<_Ty *, _Arg, _Result>
	{	// functor adapter (*p->*pfunc)(val), non-const *pfunc
public:
	explicit mem_fun1_t(_Result (_Ty::*_Pm)(_Arg))
		: _Pmemfun(_Pm)
		{	// construct from pointer
		}

	_Result operator()(_Ty *_Pleft, _Arg _Right) const
		{	// call function with operand
		return ((_Pleft->*_Pmemfun)(_Right));
		}

private:
	_Result (_Ty::*_Pmemfun)(_Arg);	// the member function pointer
	};

		// TEMPLATE CLASS const_mem_fun_t
template<class _Result,
	class _Ty>
	class const_mem_fun_t
		: public unary_function<const _Ty *, _Result>
	{	// functor adapter (*p->*pfunc)(), const *pfunc
public:
	explicit const_mem_fun_t(_Result (_Ty::*_Pm)() const)
		: _Pmemfun(_Pm)
		{	// construct from pointer
		}

	_Result operator()(const _Ty *_Pleft) const
		{	// call function
		return ((_Pleft->*_Pmemfun)());
		}

private:
	_Result (_Ty::*_Pmemfun)() const;	// the member function pointer
	};

		// TEMPLATE CLASS const_mem_fun1_t
template<class _Result,
	class _Ty,
	class _Arg>
	class const_mem_fun1_t
		: public binary_function<const _Ty *, _Arg, _Result>
	{	// functor adapter (*p->*pfunc)(val), const *pfunc
public:
	explicit const_mem_fun1_t(_Result (_Ty::*_Pm)(_Arg) const)
		: _Pmemfun(_Pm)
		{	// construct from pointer
		}

	_Result operator()(const _Ty *_Pleft, _Arg _Right) const
		{	// call function with operand
		return ((_Pleft->*_Pmemfun)(_Right));
		}

private:
	_Result (_Ty::*_Pmemfun)(_Arg) const;	// the member function pointer
	};

		// TEMPLATE FUNCTION mem_fun
template<class _Result,
	class _Ty> inline
	mem_fun_t<_Result, _Ty> mem_fun(_Result (_Ty::*_Pm)())
	{	// return a mem_fun_t functor adapter
	return (::std:: mem_fun_t<_Result, _Ty>(_Pm));
	}

template<class _Result,
	class _Ty,
	class _Arg> inline
	mem_fun1_t<_Result, _Ty, _Arg> mem_fun(_Result (_Ty::*_Pm)(_Arg))
	{	// return a mem_fun1_t functor adapter
	return (::std:: mem_fun1_t<_Result, _Ty, _Arg>(_Pm));
	}

template<class _Result,
	class _Ty> inline
	const_mem_fun_t<_Result, _Ty>
		mem_fun(_Result (_Ty::*_Pm)() const)
	{	// return a const_mem_fun_t functor adapter
	return (::std:: const_mem_fun_t<_Result, _Ty>(_Pm));
	}

template<class _Result,
	class _Ty,
	class _Arg> inline
	const_mem_fun1_t<_Result, _Ty, _Arg>
		mem_fun(_Result (_Ty::*_Pm)(_Arg) const)
	{	// return a const_mem_fun1_t functor adapter
	return (::std:: const_mem_fun1_t<_Result, _Ty, _Arg>(_Pm));
	}

		// TEMPLATE FUNCTION mem_fun1 (retained)
template<class _Result,
	class _Ty,
	class _Arg> inline
	mem_fun1_t<_Result, _Ty, _Arg> mem_fun1(_Result (_Ty::*_Pm)(_Arg))
	{	// return a mem_fun1_t functor adapter
	return (::std:: mem_fun1_t<_Result, _Ty, _Arg>(_Pm));
	}

		// TEMPLATE CLASS mem_fun_ref_t
template<class _Result,
	class _Ty>
	class mem_fun_ref_t
		: public unary_function<_Ty, _Result>
	{	// functor adapter (*left.*pfunc)(), non-const *pfunc
public:
	explicit mem_fun_ref_t(_Result (_Ty::*_Pm)())
		: _Pmemfun(_Pm)
		{	// construct from pointer
		}

	_Result operator()(_Ty& _Left) const
		{	// call function
		return ((_Left.*_Pmemfun)());
		}

private:
	_Result (_Ty::*_Pmemfun)();	// the member function pointer
	};

		// TEMPLATE CLASS mem_fun1_ref_t
template<class _Result,
	class _Ty,
	class _Arg>
	class mem_fun1_ref_t
		: public binary_function<_Ty, _Arg, _Result>
	{	// functor adapter (*left.*pfunc)(val), non-const *pfunc
public:
	explicit mem_fun1_ref_t(_Result (_Ty::*_Pm)(_Arg))
		: _Pmemfun(_Pm)
		{	// construct from pointer
		}

	_Result operator()(_Ty& _Left, _Arg _Right) const
		{	// call function with operand
		return ((_Left.*_Pmemfun)(_Right));
		}

private:
	_Result (_Ty::*_Pmemfun)(_Arg);	// the member function pointer
	};

		// TEMPLATE CLASS const_mem_fun_ref_t
template<class _Result,
	class _Ty>
	class const_mem_fun_ref_t
		: public unary_function<_Ty, _Result>
	{	// functor adapter (*left.*pfunc)(), const *pfunc
public:
	explicit const_mem_fun_ref_t(_Result (_Ty::*_Pm)() const)
		: _Pmemfun(_Pm)
		{	// construct from pointer
		}

	_Result operator()(const _Ty& _Left) const
		{	// call function
		return ((_Left.*_Pmemfun)());
		}

private:
	_Result (_Ty::*_Pmemfun)() const;	// the member function pointer
	};

		// TEMPLATE CLASS const_mem_fun1_ref_t
template<class _Result,
	class _Ty,
	class _Arg>
	class const_mem_fun1_ref_t
		: public binary_function<_Ty, _Arg, _Result>
	{	// functor adapter (*left.*pfunc)(val), const *pfunc
public:
	explicit const_mem_fun1_ref_t(_Result (_Ty::*_Pm)(_Arg) const)
		: _Pmemfun(_Pm)
		{	// construct from pointer
		}

	_Result operator()(const _Ty& _Left, _Arg _Right) const
		{	// call function with operand
		return ((_Left.*_Pmemfun)(_Right));
		}

private:
	_Result (_Ty::*_Pmemfun)(_Arg) const;	// the member function pointer
	};

		// TEMPLATE FUNCTION mem_fun_ref
template<class _Result,
	class _Ty> inline
	mem_fun_ref_t<_Result, _Ty> mem_fun_ref(_Result (_Ty::*_Pm)())
	{	// return a mem_fun_ref_t functor adapter
	return (::std:: mem_fun_ref_t<_Result, _Ty>(_Pm));
	}

template<class _Result,
	class _Ty,
	class _Arg> inline
	mem_fun1_ref_t<_Result, _Ty, _Arg>
		mem_fun_ref(_Result (_Ty::*_Pm)(_Arg))
	{	// return a mem_fun1_ref_t functor adapter
	return (::std:: mem_fun1_ref_t<_Result, _Ty, _Arg>(_Pm));
	}

template<class _Result,
	class _Ty> inline
	const_mem_fun_ref_t<_Result, _Ty>
		mem_fun_ref(_Result (_Ty::*_Pm)() const)
	{	// return a const_mem_fun_ref_t functor adapter
	return (::std:: const_mem_fun_ref_t<_Result, _Ty>(_Pm));
	}

template<class _Result,
	class _Ty,
	class _Arg> inline
	const_mem_fun1_ref_t<_Result, _Ty, _Arg>
		mem_fun_ref(_Result (_Ty::*_Pm)(_Arg) const)
	{	// return a const_mem_fun1_ref_t functor adapter
	return (::std:: const_mem_fun1_ref_t<_Result, _Ty, _Arg>(_Pm));
	}

		// TEMPLATE FUNCTION mem_fun1_ref (retained)
template<class _Result,
	class _Ty,
	class _Arg> inline
	mem_fun1_ref_t<_Result, _Ty, _Arg> mem_fun1_ref(_Result (_Ty::*_Pm)(_Arg))
	{	// return a mem_fun1_ref_t functor adapter
	return (::std:: mem_fun1_ref_t<_Result, _Ty, _Arg>(_Pm));
	}

# 721 "C:/usr/local/cell\\target\\ppu\\include/functional" 3

}


/*
 * Copyright (c) 1992-2003 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
 */

/*
 * This file is derived from software bearing the following
 * restrictions:
 *
 * Copyright (c) 1994
 * Hewlett-Packard Company
 *
 * Permission to use, copy, modify, distribute and sell this
 * software and its documentation for any purpose is hereby
 * granted without fee, provided that the above copyright notice
 * appear in all copies and that both that copyright notice and
 * this permission notice appear in supporting documentation.
 * Hewlett-Packard Company makes no representations about the
 * suitability of this software for any purpose. It is provided
 * "as is" without express or implied warranty.
V4.02:0216 */
# 12 "C:/usr/local/cell\\target\\ppu\\include/xhash" 3
# 1 "C:/usr/local/cell\\target\\ppu\\include/list" 3
/* SCE CONFIDENTIAL
 PlayStation(R)3 Programmer Tool Runtime Library 475.001
 * Copyright (C) 2011 Sony Computer Entertainment Inc.
 * All Rights Reserved.
 */
// list standard header
# 1 "C:/usr/local/cell\\target\\ppu\\include/memory" 3
/* SCE CONFIDENTIAL
 PlayStation(R)3 Programmer Tool Runtime Library 475.001
 * Copyright (C) 2006 Sony Computer Entertainment Inc.
 * All Rights Reserved.
 */
// memory standard header
# 1 "C:/usr/local/cell\\target\\ppu\\include/xmemory" 3
// xmemory internal header (from <memory>)
# 1 "C:/usr/local/cell\\target\\ppu\\include/cstdlib" 3
/* SCE CONFIDENTIAL
PlayStation(R)3 Programmer Tool Runtime Library 475.001
* Copyright (C) 2008 Sony Computer Entertainment Inc. 
* All Rights Reserved.
*/
// cstdlib standard header




# 1 "C:/usr/local/cell\\target\\ppu\\include/stdlib.h" 3
/* SCE CONFIDENTIAL
PlayStation(R)3 Programmer Tool Runtime Library 475.001
* Copyright (C) 2010 Sony Computer Entertainment Inc.
* All Rights Reserved.
*/
/* stdlib.h standard header */
# 343 "C:/usr/local/cell\\target\\ppu\\include/stdlib.h" 3

# 1 "C:/usr/local/cell\\target\\ppu\\include/bits/sce_stdlib.h" 3
/* SCE CONFIDENTIAL
PlayStation(R)3 Programmer Tool Runtime Library 475.001
* Copyright (C) 2004 Sony Computer Entertainment Inc. 
* All Rights Reserved.
*/
# 45 "C:/usr/local/cell\\target\\ppu\\include/bits/sce_stdlib.h" 3

# 346 "C:/usr/local/cell\\target\\ppu\\include/stdlib.h" 3


# 391 "C:/usr/local/cell\\target\\ppu\\include/stdlib.h" 3

/*
 * Copyright (c) 1992-2003 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
V4.02:0216 */
# 14 "C:/usr/local/cell\\target\\ppu\\include/cstdlib" 3


# 30 "C:/usr/local/cell\\target\\ppu\\include/cstdlib" 3

# 96 "C:/usr/local/cell\\target\\ppu\\include/cstdlib" 3

/*
 * Copyright (c) 1992-2003 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
V4.02:0216 */
# 5 "C:/usr/local/cell\\target\\ppu\\include/xmemory" 3
# 1 "C:/usr/local/cell\\target\\ppu\\include/new" 3
/* SCE CONFIDENTIAL
PlayStation(R)3 Programmer Tool Runtime Library 475.001
* Copyright (C) 2004 Sony Computer Entertainment Inc. 
* All Rights Reserved.
*/
// new standard header
# 1 "C:/usr/local/cell\\target\\ppu\\include/exception" 3
// exception standard header








namespace std {


		// FORWARD REFERENCES
class exception;
typedef void (*_Prhand)(const exception&);
extern _Prhand _Raise_handler;
void _Throw(const exception&);

# 113 "C:/usr/local/cell\\target\\ppu\\include/exception" 3
		// CLASS exception
class exception
	{	// base of all library exceptions, gcc version
public:
	static _Prhand _Set_raise_handler(_Prhand _Pnew);

	exception()  
		{
		}

	virtual ~exception();





	virtual const char *what() const ;






	void _Raise() const;

protected:
	virtual void _Doraise() const;


	};

		// CLASS bad_exception
class bad_exception
	: public exception
	{	// base of all bad exceptions, gcc version
public:
	bad_exception() 
		{	// construct with no message string
		}

	virtual ~bad_exception() 
		{	// destroy the object
		}





protected:
	virtual void _Doraise() const
		{	// raise this exception
		::std:: _Throw(*this);
		}


	};


		// TYPES
typedef void (*terminate_handler)();
typedef void (*unexpected_handler)();

		// FUNCTION DECLARATIONS
terminate_handler set_terminate(terminate_handler) ;
unexpected_handler set_unexpected(unexpected_handler) ;
bool uncaught_exception();
void terminate() __attribute__((__noreturn__));
void unexpected() __attribute__((__noreturn__));





} /* namespace std */



# 200 "C:/usr/local/cell\\target\\ppu\\include/exception" 3




/*
 * Copyright (c) 1992-2003 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
V4.02:0216 */
# 10 "C:/usr/local/cell\\target\\ppu\\include/new" 3





namespace std {


		// CLASS bad_alloc
class bad_alloc
	: public ::std:: exception
	{	// base of all bad allocation exceptions
public:

# 31 "C:/usr/local/cell\\target\\ppu\\include/new" 3
	bad_alloc() 
		{	// construct with no message string
		}

	virtual const char *what() const 
		{	// report a bad allocation
		return ("bad allocation");
		}


	virtual ~bad_alloc() 
		{}	// destroy the object





protected:
	virtual void _Doraise() const
		{	// perform class-specific exception handling
		::std:: _Throw(*this);
		}


	};





} /* namespace std */









namespace std {
		// SUPPORT TYPES
typedef void (*new_handler)();	// handler for operator new failures

struct nothrow_t
	{	// placement new tag type to suppress exceptions
	};

extern const nothrow_t nothrow;	// constant for placement new tag

		// FUNCTION AND OBJECT DECLARATIONS
new_handler set_new_handler(new_handler)
	;	// establish alternate new handler

extern new_handler _New_hand;	// pointer to current new handler
}

		// new AND delete DECLARATIONS (NB: NOT IN std)


void *operator new(::std:: size_t)
	;	// allocate or throw exception

void *operator new(::std:: size_t, const ::std:: nothrow_t&)
	;	// allocate or return null pointer

inline void *operator new(::std:: size_t, void *_Where) 
	{	// construct with placement at _Where
	return (_Where);
	}


void *operator new[](::std:: size_t)
	;	// allocate array or throw exception

void *operator new[](::std:: size_t, const ::std:: nothrow_t&)
	;	// allocate array or return null pointer

inline void *operator new[](::std:: size_t, void *_Where) 
	{	// construct array with placement at _Where
	return (_Where);
	}



void operator delete  (void *) ;	// delete allocated storage
void operator delete[](void *) ;	// delete allocated array

// The rest of these deletes will be called if the correspond call to
// new throws an exception.
void operator delete  (void *, const ::std:: nothrow_t&) ;	// delete if nothrow new fails -- REPLACEABLE
void operator delete[](void *, const ::std:: nothrow_t&) ;	// delete if nothrow array new fails -- REPLACEABLE
void operator delete  (void *, void *) ;	// delete if placement new fails
void operator delete[](void *, void *) ;	// delete if placement array new fails


// with alignment argument
void *operator new(::std:: size_t, ::std:: size_t)
	;	// allocate or throw exception

void *operator new(::std:: size_t, ::std:: size_t, const ::std:: nothrow_t&)
	;	// allocate or return null pointer

inline void *operator new(::std:: size_t, ::std:: size_t, void *_Where) 
	{	// construct with placement at _Where
	return (_Where);
	}


void *operator new[](::std:: size_t, ::std:: size_t)
	;	// allocate array or throw exception

void *operator new[](::std:: size_t, ::std:: size_t, const ::std:: nothrow_t&)
	;	// allocate array or return null pointer

inline void *operator new[](::std:: size_t, ::std:: size_t, void *_Where) 
	{	// construct array with placement at _Where
	return (_Where);
	}

void operator delete  (void *, ::std:: size_t) ;	// delete allocated storage
void operator delete[](void *, ::std:: size_t) ;	// delete allocated array
void operator delete  (void *, ::std:: size_t, const ::std:: nothrow_t&) ;
void operator delete[](void *, ::std:: size_t, const ::std:: nothrow_t&) ;	
void operator delete  (void *, ::std:: size_t, void *) ;
void operator delete[](void *, ::std:: size_t, void *) ;





/*
 * Copyright (c) 1992-2003 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
V4.02:0216 */
# 6 "C:/usr/local/cell\\target\\ppu\\include/xmemory" 3
# 1 "C:/usr/local/cell\\target\\ppu\\include/xutility" 3
/* SCE CONFIDENTIAL
 PlayStation(R)3 Programmer Tool Runtime Library 475.001
 * Copyright (C) 2006 Sony Computer Entertainment Inc.
 * All Rights Reserved.
 */
// xutility internal header
# 1 "C:/usr/local/cell\\target\\ppu\\include/climits" 3
// climits standard header




# 1 "C:/usr/local/cell\\target\\ppu\\include/limits.h" 3
/* SCE CONFIDENTIAL
PlayStation(R)3 Programmer Tool Runtime Library 475.001
* Copyright (C) 2006 Sony Computer Entertainment Inc. 
* All Rights Reserved.
*/
/* limits.h standard header -- 8-bit version */










# 23 "C:/usr/local/cell\\target\\ppu\\include/limits.h" 3
		/* CHAR PROPERTIES */











		/* INT PROPERTIES */












		/* MULTIBYTE PROPERTIES */


		/* SIGNED CHAR PROPERTIES */



		/* SHORT PROPERTIES */



		/* LONG PROPERTIES */
# 66 "C:/usr/local/cell\\target\\ppu\\include/limits.h" 3

		/* UNSIGNED PROPERTIES */













/*
 * Copyright (c) 1992-2003 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
V4.02:0216 */
# 7 "C:/usr/local/cell\\target\\ppu\\include/climits" 3


/*
 * Copyright (c) 1992-2003 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
V4.02:0216 */
# 10 "C:/usr/local/cell\\target\\ppu\\include/xutility" 3
# 1 "C:/usr/local/cell\\target\\ppu\\include/utility" 3
// utility standard header
# 1 "C:/usr/local/cell\\target\\ppu\\include/iosfwd" 3
// iosfwd standard header
# 1 "C:/usr/local/cell\\target\\ppu\\include/cstdio" 3
/* SCE CONFIDENTIAL
PlayStation(R)3 Programmer Tool Runtime Library 475.001
* Copyright (C) 2005 Sony Computer Entertainment Inc. 
* All Rights Reserved.
*/
// cstdio standard header




# 1 "C:/usr/local/cell\\target\\ppu\\include/stdio.h" 3
/* SCE CONFIDENTIAL
PlayStation(R)3 Programmer Tool Runtime Library 475.001
* Copyright (C) 2007 Sony Computer Entertainment Inc. 
* All Rights Reserved.
*/
/* stdio.h standard header */
# 260 "C:/usr/local/cell\\target\\ppu\\include/stdio.h" 3

# 293 "C:/usr/local/cell\\target\\ppu\\include/stdio.h" 3

/*
 * Copyright (c) 1992-2003 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
V4.02:0216 */
# 14 "C:/usr/local/cell\\target\\ppu\\include/cstdio" 3


# 49 "C:/usr/local/cell\\target\\ppu\\include/cstdio" 3

/*
 * Copyright (c) 1992-2003 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
V4.02:0216 */
# 5 "C:/usr/local/cell\\target\\ppu\\include/iosfwd" 3



namespace std {

		// STREAM POSITIONING TYPES (from <streambuf>)
typedef long streamoff;
typedef int streamsize;

extern fpos_t _Fpz;
extern const streamoff _BADOFF;

		// TEMPLATE CLASS fpos (from <streambuf>)
template<class _Statetype>
	class fpos
	{	// store arbitrary file position
	typedef fpos<_Statetype> _Myt;

public:
	fpos(streamoff _Off = 0)
		: _Myoff(_Off), _Fpos(_Fpz), _Mystate(_Stz)
		{	// construct with stream offset
		}

	fpos(_Statetype _State, fpos_t _Fileposition)
		: _Myoff(0), _Fpos(_Fileposition), _Mystate(_State)
		{	// construct with conversion state and C file position
		}

	_Statetype state() const
		{	// return conversion state
		return (_Mystate);
		}

	void state(_Statetype _State)
		{	// set conversion state
		_Mystate = _State;
		}

	fpos_t seekpos() const
		{	// return C file position
		return (_Fpos);
		}

	operator streamoff() const
		{	// return offset
		return (_Myoff + ((_Fpos). _Off));
		}

	streamoff operator-(const _Myt& _Right) const
		{	// return difference of file positions as an offset
		return ((streamoff)*this - (streamoff)_Right);
		}

	_Myt& operator+=(streamoff _Off)
		{	// add offset
		_Myoff += _Off;
		return (*this);
		}

	_Myt& operator-=(streamoff _Off)
		{	// subtract offset
		_Myoff -= _Off;
		return (*this);
		}

	_Myt operator+(streamoff _Off) const
		{	// return this + offset
		_Myt _Tmp = *this;
		return (_Tmp += _Off);
		}

	_Myt operator-(streamoff _Off) const
		{	// return this - offset
		_Myt _Tmp = *this;
		return (_Tmp -= _Off);
		}

	bool operator==(const _Myt& _Right) const
		{	// test for file position equality
		return ((streamoff)*this == (streamoff)_Right);
		}

	bool operator==(streamoff _Right) const
		{	// test for file position equality with streamoff
		return ((streamoff)*this == _Right);
		}

	bool operator!=(const _Myt& _Right) const
		{	// test for file position inequality
		return (!(*this == _Right));
		}

private:
	static _Statetype _Stz;	// initial conversion state
	streamoff _Myoff;	// stream offset
	fpos_t _Fpos;	// C file position
	_Statetype _Mystate;	// current conversion state
	};

	// STATIC fpos::_Stz OBJECT
template<class _Statetype>
	_Statetype fpos<_Statetype>::_Stz;

# 124 "C:/usr/local/cell\\target\\ppu\\include/iosfwd" 3

typedef fpos<_Mbstatet> streampos;


typedef streampos wstreampos;

		// TEMPLATE STRUCT char_traits (FROM <string>)
template<class _Elem>
	struct char_traits
	{	// properties of a string or stream element
	typedef _Elem char_type;
	typedef long int_type;
	typedef streampos pos_type;
	typedef streamoff off_type;
	typedef _Mbstatet state_type;

	static void assign(_Elem& _Left, const _Elem& _Right)
		{	// assign an element
		_Left = _Right;
		}

	static bool eq(const _Elem& _Left, const _Elem& _Right)
		{	// test for element equality
		return (_Left == _Right);
		}

	static bool lt(const _Elem& _Left, const _Elem& _Right)
		{	// test if _Left precedes _Right
		return (_Left < _Right);
		}

	static int compare(const _Elem *_First1,
		const _Elem *_First2, size_t _Count)
		{	// compare [_First1, _First1 + _Count) with [_First2, ...)
//		_DEBUG_POINTER(_First1);
//		_DEBUG_POINTER(_First2);
		for (; 0 < _Count; --_Count, ++_First1, ++_First2)
			if (!eq(*_First1, *_First2))
				return (lt(*_First1, *_First2) ? -1 : +1);
		return (0);
		}

	static size_t length(const _Elem *_First)
		{	// find length of null-terminated sequence
//		_DEBUG_POINTER(_First);
		size_t _Count;
		for (_Count = 0; !eq(*_First, _Elem()); ++_First)
			++_Count;
		return (_Count);
		}

	static _Elem *copy(_Elem *_First1,
		const _Elem *_First2, size_t _Count)
		{	// copy [_First1, _First1 + _Count) to [_First2, ...)
//		_DEBUG_POINTER(_First1);
//		_DEBUG_POINTER(_First2);
		_Elem *_Next = _First1;
		for (; 0 < _Count; --_Count, ++_Next, ++_First2)
			assign(*_Next, *_First2);
		return (_First1);
		}

	static const _Elem *find(const _Elem *_First,
		size_t _Count, const _Elem& _Ch)
		{	// look for _Ch in [_First, _First + _Count)
//		_DEBUG_POINTER(_First);
		for (; 0 < _Count; --_Count, ++_First)
			if (eq(*_First, _Ch))
				return (_First);
		return (0);
		}

	static _Elem *move(_Elem *_First1,
		const _Elem *_First2, size_t _Count)
		{	// copy [_First1, _First1 + _Count) to [_First2, ...)
//		_DEBUG_POINTER(_First1);
//		_DEBUG_POINTER(_First2);
		_Elem *_Next = _First1;
		if (_First2 < _Next && _Next < _First2 + _Count)
			for (_Next += _Count, _First2 += _Count; 0 < _Count; --_Count)
				assign(*--_Next, *--_First2);
		else
			for (; 0 < _Count; --_Count, ++_Next, ++_First2)
				assign(*_Next, *_First2);
		return (_First1);
		}

	static _Elem *assign(_Elem *_First,
		size_t _Count, _Elem _Ch)
		{	// assign _Count * _Ch to [_First, ...)
//		_DEBUG_POINTER(_First);
		_Elem *_Next = _First;
		for (; 0 < _Count; --_Count, ++_Next)
			assign(*_Next, _Ch);
		return (_First);
		}

	static _Elem to_char_type(const int_type& _Meta)
		{	// convert metacharacter to character
		return ((_Elem)_Meta);
		}

	static int_type to_int_type(const _Elem& _Ch)
		{	// convert character to metacharacter
		return ((int_type)_Ch);
		}

	static bool eq_int_type(const int_type& _Left,
		const int_type& _Right)
		{	// test for metacharacter equality
		return (_Left == _Right);
		}

	static int_type eof()
		{	// return end-of-file metacharacter
		return ((int_type)(-1));
		}

	static int_type not_eof(const int_type& _Meta)
		{	// return anything but EOF
		return (_Meta != eof() ? (int_type)_Meta : (int_type)!eof());
		}
	};

		// STRUCT char_traits<wchar_t>
template<> struct char_traits<wchar_t>
	{	// properties of a string or stream wchar_t element
	typedef wchar_t _Elem;
	typedef _Elem char_type;	// for overloads
	typedef wint_t int_type;
	typedef streampos pos_type;
	typedef streamoff off_type;
	typedef _Mbstatet state_type;

	static void assign(_Elem& _Left, const _Elem& _Right)
		{	// assign an element
		_Left = _Right;
		}

	static bool eq(const _Elem& _Left, const _Elem& _Right)
		{	// test for element equality
		return (_Left == _Right);
		}

	static bool lt(const _Elem& _Left, const _Elem& _Right)
		{	// test if _Left precedes _Right
		return (_Left < _Right);
		}

	static int compare(const _Elem *_First1, const _Elem *_First2,
		size_t _Count)
		{	// compare [_First1, _First1 + _Count) with [_First2, ...)
//		_DEBUG_POINTER(_First1);
//		_DEBUG_POINTER(_First2);
		return (::std:: wmemcmp(_First1, _First2, _Count));
		}

	static size_t length(const _Elem *_First)
		{	// find length of null-terminated sequence
//		_DEBUG_POINTER(_First);
		return (::std:: wcslen(_First));
		}

	static _Elem *copy(_Elem *_First1, const _Elem *_First2,
		size_t _Count)
		{	// copy [_First1, _First1 + _Count) to [_First2, ...)
//		_DEBUG_POINTER(_First1);
//		_DEBUG_POINTER(_First2);
		return ((_Elem *)::std:: wmemcpy(_First1, _First2, _Count));
		}

	static const _Elem *find(const _Elem *_First, size_t _Count,
		const _Elem& _Ch)
		{	// look for _Ch in [_First, _First + _Count)
//		_DEBUG_POINTER(_First);
		return ((const _Elem *)::std:: wmemchr(_First, _Ch, _Count));
		}

	static _Elem *move(_Elem *_First1, const _Elem *_First2,
		size_t _Count)
		{	// copy [_First1, _First1 + _Count) to [_First2, ...)
//		_DEBUG_POINTER(_First1);
//		_DEBUG_POINTER(_First2);
		return ((_Elem *)::std:: wmemmove(_First1, _First2, _Count));
		}

	static _Elem *assign(_Elem *_First, size_t _Count, _Elem _Ch)
		{	// assign _Count * _Ch to [_First, ...)
//		_DEBUG_POINTER(_First);
		return ((_Elem *)::std:: wmemset(_First, _Ch, _Count));
		}

	static _Elem to_char_type(const int_type& _Meta)
		{	// convert metacharacter to character
		return (_Meta);
		}

	static int_type to_int_type(const _Elem& _Ch)
		{	// convert character to metacharacter
		return (_Ch);
		}

	static bool eq_int_type(const int_type& _Left,
		const int_type& _Right)
		{	// test for metacharacter equality
		return (_Left == _Right);
		}

	static int_type eof()
		{	// return end-of-file metacharacter
		return (((wint_t)(-1)));
		}

	static int_type not_eof(const int_type& _Meta)
		{	// return anything but EOF
		return (_Meta != eof() ? _Meta : !eof());
		}
	};

		// STRUCT char_traits<char> (FROM <string>)
template<> struct char_traits<char>
	{	// properties of a string or stream char element
	typedef char _Elem;
	typedef _Elem char_type;
	typedef int int_type;
	typedef streampos pos_type;
	typedef streamoff off_type;
	typedef _Mbstatet state_type;

	static void assign(_Elem& _Left, const _Elem& _Right)
		{	// assign an element
		_Left = _Right;
		}

	static bool eq(const _Elem& _Left, const _Elem& _Right)
		{	// test for element equality
		return (_Left == _Right);
		}

	static bool lt(const _Elem& _Left, const _Elem& _Right)
		{	// test if _Left precedes _Right
		return (_Left < _Right);
		}

	static int compare(const _Elem *_First1, const _Elem *_First2,
		size_t _Count)
		{	// compare [_First1, _First1 + _Count) with [_First2, ...)
//		_DEBUG_POINTER(_First1);
//		_DEBUG_POINTER(_First2);
		return (::std:: memcmp(_First1, _First2, _Count));
		}

	static size_t length(const _Elem *_First)
		{	// find length of null-terminated string
//		_DEBUG_POINTER(_First);
		return (::std:: strlen(_First));
		}

	static _Elem *copy(_Elem *_First1, const _Elem *_First2,
		size_t _Count)
		{	// copy [_First1, _First1 + _Count) to [_First2, ...)
//		_DEBUG_POINTER(_First1);
//		_DEBUG_POINTER(_First2);
		return ((_Elem *)::std:: memcpy(_First1, _First2, _Count));
		}

	static const _Elem *find(const _Elem *_First, size_t _Count,
		const _Elem& _Ch)
		{	// look for _Ch in [_First, _First + _Count)
//		_DEBUG_POINTER(_First);
		return ((const _Elem *)::std:: memchr(_First, _Ch, _Count));
		}

	static _Elem *move(_Elem *_First1, const _Elem *_First2,
		size_t _Count)
		{	// copy [_First1, _First1 + _Count) to [_First2, ...)
//		_DEBUG_POINTER(_First1);
//		_DEBUG_POINTER(_First2);
		return ((_Elem *)::std:: memmove(_First1, _First2, _Count));
		}

	static _Elem *assign(_Elem *_First, size_t _Count, _Elem _Ch)
		{	// assign _Count * _Ch to [_First, ...)
//		_DEBUG_POINTER(_First);
		return ((_Elem *)::std:: memset(_First, _Ch, _Count));
		}

	static _Elem to_char_type(const int_type& _Meta)
		{	// convert metacharacter to character
		return ((_Elem)_Meta);
		}

	static int_type to_int_type(const _Elem& _Ch)
		{	// convert character to metacharacter
		return ((unsigned char)_Ch);
		}

	static bool eq_int_type(const int_type& _Left,
		const int_type& _Right)
		{	// test for metacharacter equality
		return (_Left == _Right);
		}

	static int_type eof()
		{	// return end-of-file metacharacter
		return ((-1));
		}

	static int_type not_eof(const int_type& _Meta)
		{	// return anything but EOF
		return (_Meta != eof() ? _Meta : !eof());
		}
	};

		// FORWARD REFERENCES
template<class _Ty>
	class allocator;
class ios_base;
template<class _Elem,
	class _Traits = char_traits<_Elem> >
	class basic_ios;
template<class _Elem,
	class _Traits = char_traits<_Elem> >
	class istreambuf_iterator;
template<class _Elem,
	class _Traits = char_traits<_Elem> >
	class ostreambuf_iterator;
template<class _Elem,
	class _Traits = char_traits<_Elem> >
	class basic_streambuf;
template<class _Elem,
	class _Traits = char_traits<_Elem> >
	class basic_istream;
template<class _Elem,
	class _Traits = char_traits<_Elem> >
	class basic_ostream;
template<class _Elem,
	class _Traits = char_traits<_Elem> >
	class basic_iostream;
template<class _Elem,
	class _Traits = char_traits<_Elem>,
	class _Alloc = allocator<_Elem> >
	class basic_stringbuf;
template<class _Elem,
	class _Traits = char_traits<_Elem>,
	class _Alloc = allocator<_Elem> >
	class basic_istringstream;
template<class _Elem,
	class _Traits = char_traits<_Elem>,
	class _Alloc = allocator<_Elem> >
	class basic_ostringstream;
template<class _Elem,
	class _Traits = char_traits<_Elem>,
	class _Alloc = allocator<_Elem> >
	class basic_stringstream;
template<class _Elem,
	class _Traits = char_traits<_Elem> >
	class basic_filebuf;
template<class _Elem,
	class _Traits = char_traits<_Elem> >
	class basic_ifstream;
template<class _Elem,
	class _Traits = char_traits<_Elem> >
	class basic_ofstream;
template<class _Elem,
	class _Traits = char_traits<_Elem> >
	class basic_fstream;

# 502 "C:/usr/local/cell\\target\\ppu\\include/iosfwd" 3

		// char TYPEDEFS
typedef basic_ios<char, char_traits<char> > ios;
typedef basic_streambuf<char, char_traits<char> > streambuf;
typedef basic_istream<char, char_traits<char> > istream;
typedef basic_ostream<char, char_traits<char> > ostream;
typedef basic_iostream<char, char_traits<char> > iostream;
typedef basic_stringbuf<char, char_traits<char>,
	allocator<char> > stringbuf;
typedef basic_istringstream<char, char_traits<char>,
	allocator<char> > istringstream;
typedef basic_ostringstream<char, char_traits<char>,
	allocator<char> > ostringstream;
typedef basic_stringstream<char, char_traits<char>,
	allocator<char> > stringstream;
typedef basic_filebuf<char, char_traits<char> > filebuf;
typedef basic_ifstream<char, char_traits<char> > ifstream;
typedef basic_ofstream<char, char_traits<char> > ofstream;
typedef basic_fstream<char, char_traits<char> > fstream;






		// wchat_t TYPEDEFS
typedef basic_ios<wchar_t, char_traits<wchar_t> > wios;
typedef basic_streambuf<wchar_t, char_traits<wchar_t> >
	wstreambuf;
typedef basic_istream<wchar_t, char_traits<wchar_t> > wistream;
typedef basic_ostream<wchar_t, char_traits<wchar_t> > wostream;
typedef basic_iostream<wchar_t, char_traits<wchar_t> > wiostream;
typedef basic_stringbuf<wchar_t, char_traits<wchar_t>,
	allocator<wchar_t> > wstringbuf;
typedef basic_istringstream<wchar_t, char_traits<wchar_t>,
	allocator<wchar_t> > wistringstream;
typedef basic_ostringstream<wchar_t, char_traits<wchar_t>,
	allocator<wchar_t> > wostringstream;
typedef basic_stringstream<wchar_t, char_traits<wchar_t>,
	allocator<wchar_t> > wstringstream;
typedef basic_filebuf<wchar_t, char_traits<wchar_t> > wfilebuf;
typedef basic_ifstream<wchar_t, char_traits<wchar_t> > wifstream;
typedef basic_ofstream<wchar_t, char_traits<wchar_t> > wofstream;
typedef basic_fstream<wchar_t, char_traits<wchar_t> > wfstream;


# 560 "C:/usr/local/cell\\target\\ppu\\include/iosfwd" 3

}

# 583 "C:/usr/local/cell\\target\\ppu\\include/iosfwd" 3

/*
 * Copyright (c) 1992-2003 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
V4.02:0216 */
# 5 "C:/usr/local/cell\\target\\ppu\\include/utility" 3

namespace std {
		// TEMPLATE FUNCTION swap (from <algorithm>)
template<class _Ty> inline
	void swap(_Ty& _Left, _Ty& _Right)
	{	// exchange values stored at _Left and _Right
	_Ty _Tmp = _Left;
	_Left = _Right, _Right = _Tmp;
	}

		// TEMPLATE STRUCT pair
template<class _Ty1,
	class _Ty2> struct pair
	{	// store a pair of values
	typedef pair<_Ty1, _Ty2> _Myt;
	typedef _Ty1 first_type;
	typedef _Ty2 second_type;

	pair()
		: first(_Ty1()), second(_Ty2())
		{	// construct from defaults
		}

	pair(const _Ty1& _Val1, const _Ty2& _Val2)
		: first(_Val1), second(_Val2)
		{	// construct from specified values
		}

	template<class _Other1,
		class _Other2>
		pair(const pair<_Other1, _Other2>& _Right)
		: first(_Right.first), second(_Right.second)
		{	// construct from compatible pair
		}

	void swap(_Myt& _Right)
		{	// exchange contents with _Right
		::std:: swap(first, _Right.first);
		::std:: swap(second, _Right.second);
		}

	_Ty1 first;	// the first stored value
	_Ty2 second;	// the second stored value
	};

		// pair TEMPLATE OPERATORS
template<class _Ty1,
	class _Ty2> inline
	void swap(pair<_Ty1, _Ty2>& _Left, pair<_Ty1, _Ty2>& _Right)
	{	// swap _Left and _Right pairs
	_Left.swap(_Right);
	}

template<class _Ty1,
	class _Ty2> inline
	bool operator==(const pair<_Ty1, _Ty2>& _Left,
		const pair<_Ty1, _Ty2>& _Right)
	{	// test for pair equality
	return (_Left.first == _Right.first && _Left.second == _Right.second);
	}

template<class _Ty1,
	class _Ty2> inline
	bool operator!=(const pair<_Ty1, _Ty2>& _Left,
		const pair<_Ty1, _Ty2>& _Right)
	{	// test for pair inequality
	return (!(_Left == _Right));
	}

template<class _Ty1,
	class _Ty2> inline
	bool operator<(const pair<_Ty1, _Ty2>& _Left,
		const pair<_Ty1, _Ty2>& _Right)
	{	// test if _Left < _Right for pairs
	return (_Left.first < _Right.first ||
		!(_Right.first < _Left.first) && _Left.second < _Right.second);
	}

template<class _Ty1,
	class _Ty2> inline
	bool operator>(const pair<_Ty1, _Ty2>& _Left,
		const pair<_Ty1, _Ty2>& _Right)
	{	// test if _Left > _Right for pairs
	return (_Right < _Left);
	}

template<class _Ty1,
	class _Ty2> inline
	bool operator<=(const pair<_Ty1, _Ty2>& _Left,
		const pair<_Ty1, _Ty2>& _Right)
	{	// test if _Left <= _Right for pairs
	return (!(_Right < _Left));
	}

template<class _Ty1,
	class _Ty2> inline
	bool operator>=(const pair<_Ty1, _Ty2>& _Left,
		const pair<_Ty1, _Ty2>& _Right)
	{	// test if _Left >= _Right for pairs
	return (!(_Left < _Right));
	}

template<class _Ty1,
	class _Ty2> inline
	pair<_Ty1, _Ty2> make_pair(_Ty1 _Val1, _Ty2 _Val2)
	{	// return pair composed from arguments
	return (pair<_Ty1, _Ty2>(_Val1, _Val2));
	}


		// TEMPLATE OPERATORS
	namespace rel_ops
		{	// nested namespace to hide relational operators from std
template<class _Ty> inline
	bool operator!=(const _Ty& _Left, const _Ty& _Right)
	{	// test for inequality, in terms of equality
	return (!(_Left == _Right));
	}

template<class _Ty> inline
	bool operator>(const _Ty& _Left, const _Ty& _Right)
	{	// test if _Left > _Right, in terms of operator<
	return (_Right < _Left);
	}

template<class _Ty> inline
	bool operator<=(const _Ty& _Left, const _Ty& _Right)
	{	// test if _Left <= _Right, in terms of operator<
	return (!(_Right < _Left));
	}

template<class _Ty> inline
	bool operator>=(const _Ty& _Left, const _Ty& _Right)
	{	// test if _Left >= _Right, in terms of operator<
	return (!(_Left < _Right));
	}
		}


}


/*
 * Copyright (c) 1992-2003 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
 */

/*
 * This file is derived from software bearing the following
 * restrictions:
 *
 * Copyright (c) 1994
 * Hewlett-Packard Company
 *
 * Permission to use, copy, modify, distribute and sell this
 * software and its documentation for any purpose is hereby
 * granted without fee, provided that the above copyright notice
 * appear in all copies and that both that copyright notice and
 * this permission notice appear in supporting documentation.
 * Hewlett-Packard Company makes no representations about the
 * suitability of this software for any purpose. It is provided
 * "as is" without express or implied warranty.
V4.02:0216 */
# 11 "C:/usr/local/cell\\target\\ppu\\include/xutility" 3
namespace std {

# 196 "C:/usr/local/cell\\target\\ppu\\include/xutility" 3
		// MACROS



struct _Container_base
	{	// base of all containers
	};

struct _Iterator_base
	{	// base of all iterators
	};


//	ITERATOR STUFF (from <iterator>)

		// ITERATOR TAGS
struct input_iterator_tag
	{	// identifying tag for input iterators
	};

struct output_iterator_tag
	{	// identifying tag for output iterators
	};

struct forward_iterator_tag
	: public input_iterator_tag
	{	// identifying tag for forward iterators
	};

struct bidirectional_iterator_tag
	: public forward_iterator_tag
	{	// identifying tag for bidirectional iterators
	};

struct random_access_iterator_tag
	: public bidirectional_iterator_tag
	{	// identifying tag for random-access iterators
	};

struct _Int_iterator_tag
	{	// identifying tag for integer types, not an iterator
	};

		// POINTER ITERATOR TAGS
struct _Nonscalar_ptr_iterator_tag
	{	// pointer to unknown type
	};
struct _Scalar_ptr_iterator_tag
	{	// pointer to scalar type
	};

		// TEMPLATE CLASS iterator
template<class _Category,
	class _Ty,
	class _Diff = ptrdiff_t,
	class _Pointer = _Ty *,
	class _Reference = _Ty&>
		struct iterator
			: public _Iterator_base
	{	// base type for all iterator classes
	typedef _Category iterator_category;
	typedef _Ty value_type;
	typedef _Diff difference_type;
	typedef _Diff distance_type;	// retained
	typedef _Pointer pointer;
	typedef _Reference reference;
	};

template<class _Ty,
	class _Diff,
	class _Pointer,
	class _Reference>
	struct _Bidit
		: public iterator<bidirectional_iterator_tag, _Ty, _Diff,
			_Pointer, _Reference>
	{	// base for bidirectional iterators
	};

template<class _Ty,
	class _Diff,
	class _Pointer,
	class _Reference>
	struct _Ranit
		: public iterator<random_access_iterator_tag, _Ty, _Diff,
			_Pointer, _Reference>
	{	// base for random-access iterators
	};

struct _Outit
	: public iterator<output_iterator_tag, void, void,
		void, void>
	{	// base for output iterators
	};

		// TEMPLATE CLASS iterator_traits
template<class _Iter>
	struct iterator_traits
	{	// get traits from iterator _Iter
	typedef typename _Iter::iterator_category iterator_category;
	typedef typename _Iter::value_type value_type;
	typedef typename _Iter::difference_type difference_type;
	typedef difference_type distance_type;	// retained
	typedef typename _Iter::pointer pointer;
	typedef typename _Iter::reference reference;
	};

template<class _Ty>
	struct iterator_traits<_Ty *>
	{	// get traits from pointer
	typedef random_access_iterator_tag iterator_category;
	typedef _Ty value_type;
	typedef ptrdiff_t difference_type;
	typedef ptrdiff_t distance_type;	// retained
	typedef _Ty *pointer;
	typedef _Ty& reference;
	};

template<class _Ty>
	struct iterator_traits<const _Ty *>
	{	// get traits from const pointer
	typedef random_access_iterator_tag iterator_category;
	typedef _Ty value_type;
	typedef ptrdiff_t difference_type;
	typedef ptrdiff_t distance_type;	// retained
	typedef const _Ty *pointer;
	typedef const _Ty& reference;
	};

template<> struct iterator_traits<_Bool>
	{	// get traits from integer type
	typedef _Int_iterator_tag iterator_category;
	};

template<> struct iterator_traits<char>
	{	// get traits from integer type
	typedef _Int_iterator_tag iterator_category;
	};

template<> struct iterator_traits<signed char>
	{	// get traits from integer type
	typedef _Int_iterator_tag iterator_category;
	};

template<> struct iterator_traits<unsigned char>
	{	// get traits from integer type
	typedef _Int_iterator_tag iterator_category;
	};

template<> struct iterator_traits<wchar_t>
	{	// get traits from integer type
	typedef _Int_iterator_tag iterator_category;
	};

template<> struct iterator_traits<short>
	{	// get traits from integer type
	typedef _Int_iterator_tag iterator_category;
	};

template<> struct iterator_traits<unsigned short>
	{	// get traits from integer type
	typedef _Int_iterator_tag iterator_category;
	};

template<> struct iterator_traits<int>
	{	// get traits from integer type
	typedef _Int_iterator_tag iterator_category;
	};

template<> struct iterator_traits<unsigned int>
	{	// get traits from integer type
	typedef _Int_iterator_tag iterator_category;
	};

template<> struct iterator_traits<long>
	{	// get traits from integer type
	typedef _Int_iterator_tag iterator_category;
	};

template<> struct iterator_traits<unsigned long>
	{	// get traits from integer type
	typedef _Int_iterator_tag iterator_category;
	};


template<> struct iterator_traits<long long>
	{	// get traits from integer type
	typedef _Int_iterator_tag iterator_category;
	};

template<> struct iterator_traits<unsigned long long>
	{	// get traits from integer type
	typedef _Int_iterator_tag iterator_category;
	};


		// TEMPLATE FUNCTION _Iter_cat
template<class _Iter> inline
	typename iterator_traits<_Iter>::iterator_category
		_Iter_cat(const _Iter&)
	{	// return category from iterator argument
	typename iterator_traits<_Iter>::iterator_category _Cat;
	return (_Cat);
	}

		// TEMPLATE FUNCTION _Ptr_cat
template<class _T1,
	class _T2> inline
	_Nonscalar_ptr_iterator_tag _Ptr_cat(_T1&, _T2&)
	{	// return pointer category from arbitrary arguments
	_Nonscalar_ptr_iterator_tag _Cat;
	return (_Cat);
	}


template<class _Ty> inline
	_Scalar_ptr_iterator_tag _Ptr_cat(_Ty **, _Ty **)
	{	// return pointer category from pointer to pointer arguments
	_Scalar_ptr_iterator_tag _Cat;
	return (_Cat);
	}

template<class _Ty> inline
	_Scalar_ptr_iterator_tag _Ptr_cat(_Ty *const *, _Ty **)
	{	// return pointer category from pointer to pointer arguments
	_Scalar_ptr_iterator_tag _Cat;
	return (_Cat);
	}

template<class _Ty> inline
	_Scalar_ptr_iterator_tag _Ptr_cat(_Ty **, const _Ty **)
	{	// return pointer category from pointer to pointer arguments
	_Scalar_ptr_iterator_tag _Cat;
	return (_Cat);
	}

template<class _Ty> inline
	_Scalar_ptr_iterator_tag _Ptr_cat(_Ty *const *, const _Ty **)
	{	// return pointer category from pointer to pointer arguments
	_Scalar_ptr_iterator_tag _Cat;
	return (_Cat);
	}


		// INTEGER FUNCTION _Ptr_cat
inline _Scalar_ptr_iterator_tag _Ptr_cat(_Bool *, _Bool *)
	{	// return pointer category from pointer to bool arguments
	_Scalar_ptr_iterator_tag _Cat;
	return (_Cat);
	}

inline _Scalar_ptr_iterator_tag _Ptr_cat(const _Bool *, _Bool *)
	{	// return pointer category from pointer to bool arguments
	_Scalar_ptr_iterator_tag _Cat;
	return (_Cat);
	}

inline _Scalar_ptr_iterator_tag _Ptr_cat(char *, char *)
	{	// return pointer category from pointer to char arguments
	_Scalar_ptr_iterator_tag _Cat;
	return (_Cat);
	}

inline _Scalar_ptr_iterator_tag _Ptr_cat(const char *, char *)
	{	// return pointer category from pointer to char arguments
	_Scalar_ptr_iterator_tag _Cat;
	return (_Cat);
	}

inline _Scalar_ptr_iterator_tag _Ptr_cat(signed char *, signed char *)
	{	// return pointer category from pointer to signed char arguments
	_Scalar_ptr_iterator_tag _Cat;
	return (_Cat);
	}

inline _Scalar_ptr_iterator_tag _Ptr_cat(const signed char *, signed char *)
	{	// return pointer category from pointer to signed char arguments
	_Scalar_ptr_iterator_tag _Cat;
	return (_Cat);
	}

inline _Scalar_ptr_iterator_tag _Ptr_cat(unsigned char *,
	unsigned char *)
	{	// return pointer category from pointer to unsigned char arguments
	_Scalar_ptr_iterator_tag _Cat;
	return (_Cat);
	}

inline _Scalar_ptr_iterator_tag _Ptr_cat(const unsigned char *,
	unsigned char *)
	{	// return pointer category from pointer to unsigned char arguments
	_Scalar_ptr_iterator_tag _Cat;
	return (_Cat);
	}

inline _Scalar_ptr_iterator_tag _Ptr_cat(wchar_t *, wchar_t *)
	{	// return pointer category from pointer to wchar_t arguments
	_Scalar_ptr_iterator_tag _Cat;
	return (_Cat);
	}

inline _Scalar_ptr_iterator_tag _Ptr_cat(const wchar_t *, wchar_t *)
	{	// return pointer category from pointer to wchar_t arguments
	_Scalar_ptr_iterator_tag _Cat;
	return (_Cat);
	}

inline _Scalar_ptr_iterator_tag _Ptr_cat(short *, short *)
	{	// return pointer category from pointer to short arguments
	_Scalar_ptr_iterator_tag _Cat;
	return (_Cat);
	}

inline _Scalar_ptr_iterator_tag _Ptr_cat(const short *, short *)
	{	// return pointer category from pointer to short arguments
	_Scalar_ptr_iterator_tag _Cat;
	return (_Cat);
	}

inline _Scalar_ptr_iterator_tag _Ptr_cat(unsigned short *,
	unsigned short *)
	{	// return pointer category from pointer to unsigned short arguments
	_Scalar_ptr_iterator_tag _Cat;
	return (_Cat);
	}

inline _Scalar_ptr_iterator_tag _Ptr_cat(const unsigned short *,
	unsigned short *)
	{	// return pointer category from pointer to unsigned short arguments
	_Scalar_ptr_iterator_tag _Cat;
	return (_Cat);
	}

inline _Scalar_ptr_iterator_tag _Ptr_cat(int *, int *)
	{	// return pointer category from pointer to int arguments
	_Scalar_ptr_iterator_tag _Cat;
	return (_Cat);
	}

inline _Scalar_ptr_iterator_tag _Ptr_cat(const int *, int *)
	{	// return pointer category from pointer to int arguments
	_Scalar_ptr_iterator_tag _Cat;
	return (_Cat);
	}

inline _Scalar_ptr_iterator_tag _Ptr_cat(unsigned int *, unsigned int *)
	{	// return pointer category from pointer to unsigned int arguments
	_Scalar_ptr_iterator_tag _Cat;
	return (_Cat);
	}

inline _Scalar_ptr_iterator_tag _Ptr_cat(const unsigned int *, unsigned int *)
	{	// return pointer category from pointer to unsigned int arguments
	_Scalar_ptr_iterator_tag _Cat;
	return (_Cat);
	}

inline _Scalar_ptr_iterator_tag _Ptr_cat(long *, long *)
	{	// return pointer category from pointer to long arguments
	_Scalar_ptr_iterator_tag _Cat;
	return (_Cat);
	}

inline _Scalar_ptr_iterator_tag _Ptr_cat(const long *, long *)
	{	// return pointer category from pointer to long arguments
	_Scalar_ptr_iterator_tag _Cat;
	return (_Cat);
	}

inline _Scalar_ptr_iterator_tag _Ptr_cat(unsigned long *,
	unsigned long *)
	{	// return pointer category from pointer to unsigned long arguments
	_Scalar_ptr_iterator_tag _Cat;
	return (_Cat);
	}

inline _Scalar_ptr_iterator_tag _Ptr_cat(const unsigned long *,
	unsigned long *)
	{	// return pointer category from pointer to unsigned long arguments
	_Scalar_ptr_iterator_tag _Cat;
	return (_Cat);
	}

inline _Scalar_ptr_iterator_tag _Ptr_cat(float *, float *)
	{	// return pointer category from pointer to float arguments
	_Scalar_ptr_iterator_tag _Cat;
	return (_Cat);
	}

inline _Scalar_ptr_iterator_tag _Ptr_cat(const float *, float *)
	{	// return pointer category from pointer to float arguments
	_Scalar_ptr_iterator_tag _Cat;
	return (_Cat);
	}

inline _Scalar_ptr_iterator_tag _Ptr_cat(double *, double *)
	{	// return pointer category from pointer to double arguments
	_Scalar_ptr_iterator_tag _Cat;
	return (_Cat);
	}

inline _Scalar_ptr_iterator_tag _Ptr_cat(const double *, double *)
	{	// return pointer category from pointer to double arguments
	_Scalar_ptr_iterator_tag _Cat;
	return (_Cat);
	}

inline _Scalar_ptr_iterator_tag _Ptr_cat(long double *, long double *)
	{	// return pointer category from pointer to long double arguments
	_Scalar_ptr_iterator_tag _Cat;
	return (_Cat);
	}

inline _Scalar_ptr_iterator_tag _Ptr_cat(const long double *, long double *)
	{	// return pointer category from pointer to long double arguments
	_Scalar_ptr_iterator_tag _Cat;
	return (_Cat);
	}


inline _Scalar_ptr_iterator_tag _Ptr_cat(long long *, long long *)
	{	// return pointer category from pointer to long long arguments
	_Scalar_ptr_iterator_tag _Cat;
	return (_Cat);
	}

inline _Scalar_ptr_iterator_tag _Ptr_cat(const long long *, long long *)
	{	// return pointer category from pointer to long long arguments
	_Scalar_ptr_iterator_tag _Cat;
	return (_Cat);
	}

inline _Scalar_ptr_iterator_tag _Ptr_cat(unsigned long long *, unsigned long long *)
	{	// return pointer category from pointer to ulong long arguments
	_Scalar_ptr_iterator_tag _Cat;
	return (_Cat);
	}

inline _Scalar_ptr_iterator_tag _Ptr_cat(const unsigned long long *, unsigned long long *)
	{	// return pointer category from pointer to ulong long arguments
	_Scalar_ptr_iterator_tag _Cat;
	return (_Cat);
	}


# 758 "C:/usr/local/cell\\target\\ppu\\include/xutility" 3
		// ITERATOR DEBUGGING MACROS
# 766 "C:/usr/local/cell\\target\\ppu\\include/xutility" 3

		// TEMPLATE FUNCTION _Val_type
template<class _Iter> inline
	typename iterator_traits<_Iter>::value_type *_Val_type(_Iter)
	{	// return value type from arbitrary argument
	return (0);
	}

		// TEMPLATE FUNCTION advance
template<class _InIt,
	class _Diff> inline
	void advance(_InIt& _Where, _Diff _Off)
	{	// increment iterator by offset, arbitrary iterators
	_Advance(_Where, _Off, _Iter_cat(_Where));
	}

template<class _InIt,
	class _Diff> inline
	void _Advance(_InIt& _Where, _Diff _Off, input_iterator_tag)
	{	// increment iterator by offset, input iterators






	for (; 0 < _Off; --_Off)
		++_Where;
	}

template<class _FI,
	class _Diff> inline
	void _Advance(_FI& _Where, _Diff _Off, forward_iterator_tag)
	{	// increment iterator by offset, forward iterators






	for (; 0 < _Off; --_Off)
		++_Where;
	}

template<class _BI,
	class _Diff> inline
	void _Advance(_BI& _Where, _Diff _Off, bidirectional_iterator_tag)
	{	// increment iterator by offset, bidirectional iterators
	for (; 0 < _Off; --_Off)
		++_Where;
	for (; _Off < 0; ++_Off)
		--_Where;
	}

template<class _RI,
	class _Diff> inline
	void _Advance(_RI& _Where, _Diff _Off, random_access_iterator_tag)
	{	// increment iterator by offset, random-access iterators
	_Where += _Off;
	}

		// TEMPLATE FUNCTION _Dist_type
template<class _Iter> inline
	typename iterator_traits<_Iter>::difference_type
		*_Dist_type(_Iter)
	{	// return distance type from arbitrary argument
	return (0);
	}

		// TEMPLATE FUNCTIONS distance and _Distance
template<class _InIt,
	class _Diff> inline
		void _Distance2(_InIt _First, _InIt _Last, _Diff& _Off,
			input_iterator_tag)
	{	// add to _Off distance between input iterators
	for (; _First != _Last; ++_First)
		++_Off;
	}

template<class _FwdIt,
	class _Diff> inline
		void _Distance2(_FwdIt _First, _FwdIt _Last, _Diff& _Off,
			forward_iterator_tag)
	{	// add to _Off distance between forward iterators (redundant)
	for (; _First != _Last; ++_First)
		++_Off;
	}

template<class _BidIt,
	class _Diff> inline
		void _Distance2(_BidIt _First, _BidIt _Last, _Diff& _Off,
			bidirectional_iterator_tag)
	{	// add to _Off distance between bidirectional iterators (redundant)
	for (; _First != _Last; ++_First)
		++_Off;
	}

template<class _RanIt,
	class _Diff> inline
		void _Distance2(_RanIt _First, _RanIt _Last, _Diff& _Off,
			random_access_iterator_tag)
	{	// add to _Off distance between random-access iterators

# 876 "C:/usr/local/cell\\target\\ppu\\include/xutility" 3

	_Off += _Last - _First;
	}

template<class _InIt> inline
	typename iterator_traits<_InIt>::difference_type
		distance(_InIt _First, _InIt _Last)
	{	// return distance between iterators
	typename iterator_traits<_InIt>::difference_type _Off = 0;
	_Distance2(_First, _Last, _Off, _Iter_cat(_First));
	return (_Off);
	}

template<class _InIt,
	class _Diff> inline
		void _Distance(_InIt _First, _InIt _Last, _Diff& _Off)
	{	// add to _Off distance between iterators
	_Distance2(_First, _Last, _Off, _Iter_cat(_First));
	}

		// TEMPLATE CLASS reverse_iterator
template<class _RanIt>
	class reverse_iterator
		: public iterator<
			typename iterator_traits<_RanIt>::iterator_category,
			typename iterator_traits<_RanIt>::value_type,
			typename iterator_traits<_RanIt>::difference_type,
			typename iterator_traits<_RanIt>::pointer,
			typename iterator_traits<_RanIt>::reference>
	{	// wrap iterator to run it backwards
public:
	typedef reverse_iterator<_RanIt> _Myt;
 	typedef typename iterator_traits<_RanIt>::difference_type difference_type;
	typedef typename iterator_traits<_RanIt>::pointer pointer;
	typedef typename iterator_traits<_RanIt>::reference reference;
	typedef _RanIt iterator_type;

	reverse_iterator()
		{	// construct with default wrapped iterator
		}

	explicit reverse_iterator(_RanIt _Right)
		: current(_Right)
		{	// construct wrapped iterator from _Right
		}

	template<class _Other>
		reverse_iterator(const reverse_iterator<_Other>& _Right)
		: current(_Right.base())
		{	// initialize with compatible base
		}

	_RanIt base() const
		{	// return wrapped iterator
		return (current);
		}

	reference operator*() const
		{	// return designated value
		_RanIt _Tmp = current;
		return (*--_Tmp);
		}

	pointer operator->() const
		{	// return pointer to class object
		return (&**this);
		}

	_Myt& operator++()
		{	// preincrement
		--current;
		return (*this);
		}

	_Myt operator++(int)
		{	// postincrement
		_Myt _Tmp = *this;
		--current;
		return (_Tmp);
		}

	_Myt& operator--()
		{	// predecrement
		++current;
		return (*this);
		}

	_Myt operator--(int)
		{	// postdecrement
		_Myt _Tmp = *this;
		++current;
		return (_Tmp);
		}

	bool _Equal(const _Myt& _Right) const
		{	// test for iterator equality
		return (current == _Right.current);
		}

// N.B. functions valid for random-access iterators only beyond this point

	_Myt& operator+=(difference_type _Off)
		{	// increment by integer
		current -= _Off;
		return (*this);
		}

	_Myt operator+(difference_type _Off) const
		{	// return this + integer
		return (_Myt(current - _Off));
		}

	_Myt& operator-=(difference_type _Off)
		{	// decrement by integer
		current += _Off;
		return (*this);
		}

	_Myt operator-(difference_type _Off) const
		{	// return this - integer
		return (_Myt(current + _Off));
		}

	reference operator[](difference_type _Off) const
		{	// subscript
		return (*(*this + _Off));
		}

	bool _Less(const _Myt& _Right) const
		{	// test if this < _Right
		return (_Right.current < current);
		}

	difference_type _Minus(const _Myt& _Right) const
		{	// return difference of iterators
		return (_Right.current - current);
		}

protected:
	_RanIt current;	// the wrapped iterator
	};

		// reverse_iterator TEMPLATE OPERATORS
template<class _RanIt,
	class _Diff> inline
	reverse_iterator<_RanIt> operator+(_Diff _Off,
		const reverse_iterator<_RanIt>& _Right)
	{	// return reverse_iterator + integer
	return (_Right + _Off);
	}

template<class _RanIt> inline
	typename reverse_iterator<_RanIt>::difference_type
		operator-(const reverse_iterator<_RanIt>& _Left,
		const reverse_iterator<_RanIt>& _Right)
	{	// return difference of reverse_iterators
	return (_Left._Minus(_Right));
	}

template<class _RanIt> inline
	bool operator==(const reverse_iterator<_RanIt>& _Left,
		const reverse_iterator<_RanIt>& _Right)
	{	// test for reverse_iterator equality
	return (_Left._Equal(_Right));
	}

template<class _RanIt> inline
	bool operator!=(const reverse_iterator<_RanIt>& _Left,
		const reverse_iterator<_RanIt>& _Right)
	{	// test for reverse_iterator inequality
	return (!(_Left == _Right));
	}

template<class _RanIt> inline
	bool operator<(const reverse_iterator<_RanIt>& _Left,
		const reverse_iterator<_RanIt>& _Right)
	{	// test for reverse_iterator < reverse_iterator
	return (_Left._Less(_Right));
	}

template<class _RanIt> inline
	bool operator>(const reverse_iterator<_RanIt>& _Left,
		const reverse_iterator<_RanIt>& _Right)
	{	// test for reverse_iterator > reverse_iterator
	return (_Right < _Left);
	}

template<class _RanIt> inline
	bool operator<=(const reverse_iterator<_RanIt>& _Left,
		const reverse_iterator<_RanIt>& _Right)
	{	// test for reverse_iterator <= reverse_iterator
	return (!(_Right < _Left));
	}

template<class _RanIt> inline
	bool operator>=(const reverse_iterator<_RanIt>& _Left,
		const reverse_iterator<_RanIt>& _Right)
	{	// test for reverse_iterator >= reverse_iterator
	return (!(_Left < _Right));
	}

		// TEMPLATE CLASS reverse_bidirectional_iterator (retained)
template<class _BidIt,
	class _Ty,
	class _Reference = _Ty&,
	class _Pointer = _Ty *,
	class _Diff = ptrdiff_t>
	class reverse_bidirectional_iterator
		: public _Bidit<_Ty, _Diff, _Pointer, _Reference>
	{	// wrap bidirectional iterator to run it backwards
public:
	typedef reverse_bidirectional_iterator<_BidIt, _Ty, _Reference,
		_Pointer, _Diff> _Myt;
	typedef _BidIt iterator_type;

	reverse_bidirectional_iterator()
		{	// construct with default wrapped iterator
		}

	explicit reverse_bidirectional_iterator(_BidIt _Right)
		: current(_Right)
		{	// construct wrapped iterator from _Right
		}

	_BidIt base() const
		{	// return wrapped iterator
		return (current);
		}

	_Reference operator*() const
		{	// return designated value
		_BidIt _Tmp = current;
		return (*--_Tmp);
		}

	_Pointer operator->() const
		{       // return pointer to class object
		_Reference _Tmp = **this;
		return (&_Tmp);
		}

	_Myt& operator++()
		{	// preincrement
		--current;
		return (*this);
		}

	_Myt operator++(int)
		{	// postincrement
		_Myt _Tmp = *this;
		--current;
		return (_Tmp);
		}

	_Myt& operator--()
		{	// predecrement
		++current;
		return (*this);
		}

	_Myt operator--(int)
		{	// postdecrement
		_Myt _Tmp = *this;
		++current;
		return (_Tmp);
		}

	bool operator==(const _Myt& _Right) const
		{	// test for iterator equality
		return (current == _Right.current);
		}

	bool operator!=(const _Myt& _Right) const
		{	// test for iterator inequality
		return (!(*this == _Right));
		}

protected:
	_BidIt current;	// the wrapped iterator
	};

		// TEMPLATE CLASS _Revbidit
template<class _BidIt,
	class _BidIt2 = _BidIt>
	class _Revbidit
		: public iterator<
			typename iterator_traits<_BidIt>::iterator_category,
			typename iterator_traits<_BidIt>::value_type,
			typename iterator_traits<_BidIt>::difference_type,
			typename iterator_traits<_BidIt>::pointer,
			typename iterator_traits<_BidIt>::reference>
	{	// wrap bidirectional iterator to run it backwards
public:
	typedef _Revbidit<_BidIt, _BidIt2> _Myt;
	typedef typename iterator_traits<_BidIt>::difference_type _Diff;
	typedef typename iterator_traits<_BidIt>::pointer _Pointer;
	typedef typename iterator_traits<_BidIt>::reference _Reference;
	typedef _BidIt iterator_type;

	_Revbidit()
		{	// construct with default wrapped iterator
		}

	explicit _Revbidit(_BidIt _Right)
		: current(_Right)
		{	// construct wrapped iterator from _Right
		}

	_Revbidit(const _Revbidit<_BidIt2>& _Other)
		: current (_Other.base())
		{	// const converter or copy constructor
		}

	_BidIt base() const
		{	// return wrapped iterator
		return (current);
		}

	_Reference operator*() const
		{	// return designated value
		_BidIt _Tmp = current;
		return (*--_Tmp);
		}

	_Pointer operator->() const
		{	// return pointer to class object
		_Reference _Tmp = **this;
		return (&_Tmp);
		}

	_Myt& operator++()
		{	// preincrement
		--current;
		return (*this);
		}

	_Myt operator++(int)
		{	// postincrement
		_Myt _Tmp = *this;
		--current;
		return (_Tmp);
		}

	_Myt& operator--()
		{	// predecrement
		++current;
		return (*this);
		}

	_Myt operator--(int)
		{	// postdecrement
		_Myt _Tmp = *this;
		++current;
		return (_Tmp);
		}

	bool operator==(const _Myt& _Right) const
		{	// test for iterator equality
		return (current == _Right.current);
		}

	bool operator!=(const _Myt& _Right) const
		{	// test for iterator inequality
		return (!(*this == _Right));
		}

protected:
	_BidIt current;
	};

		// TEMPLATE CLASS istreambuf_iterator

# 1273 "C:/usr/local/cell\\target\\ppu\\include/xutility" 3
template<class _Elem,
	class _Traits>
	class istreambuf_iterator
		: public iterator<input_iterator_tag,
			_Elem, typename _Traits::off_type, _Elem *, _Elem&>
	{	// wrap stream buffer as input iterator
	typedef istreambuf_iterator<_Elem, _Traits> _Myt;
public:
	typedef _Elem char_type;
	typedef _Traits traits_type;
	typedef basic_streambuf<_Elem, _Traits> streambuf_type;
	typedef basic_istream<_Elem, _Traits> istream_type;


	typedef typename traits_type::int_type int_type;

	istreambuf_iterator(streambuf_type *_Sb = 0) 
		: _Strbuf(_Sb), _Got(_Sb == 0)
		{	// construct from stream buffer _Sb
		}

	istreambuf_iterator(istream_type& _Istr) 
		: _Strbuf(_Istr.rdbuf()), _Got(_Istr.rdbuf() == 0)
		{	// construct from stream buffer in istream _Istr
		}

	_Elem operator*() const
		{	// return designated value
		if (!_Got)
			((_Myt *)this)->_Peek();






		return (_Val);
		}

	_Myt& operator++()
		{	// preincrement






		_Inc();
		return (*this);
		}

	_Myt operator++(int)
		{	// postincrement
		if (!_Got)
			_Peek();
		_Myt _Tmp = *this;
		++*this;
		return (_Tmp);
		}

	bool equal(const _Myt& _Right) const
		{	// test for equality
		if (!_Got)
			((_Myt *)this)->_Peek();
		if (!_Right._Got)
			((_Myt *)&_Right)->_Peek();
		return ((_Strbuf == 0 && _Right._Strbuf == 0)
			|| (_Strbuf != 0 && _Right._Strbuf != 0));
		}

private:
	void _Inc()
		{	// skip to next input element
		if (_Strbuf == 0
			|| traits_type::eq_int_type(traits_type::eof(),
				_Strbuf->sbumpc()))
			_Strbuf = 0, _Got = true;
		else
			_Got = false;
		}

	_Elem _Peek()
		{	// peek at next input element
		int_type _Meta;
		if (_Strbuf == 0
			|| traits_type::eq_int_type(traits_type::eof(),
				_Meta = _Strbuf->sgetc()))
			_Strbuf = 0;
		else
			_Val = traits_type::to_char_type(_Meta);
		_Got = true;
		return (_Val);
		}

	streambuf_type *_Strbuf;	// the wrapped stream buffer
	bool _Got;	// true if _Val is valid
	_Elem _Val;	// next element to deliver
	};

		// istreambuf_iterator TEMPLATE OPERATORS
template<class _Elem,
	class _Traits> inline
	bool operator==(
		const istreambuf_iterator<_Elem, _Traits>& _Left,
		const istreambuf_iterator<_Elem, _Traits>& _Right)
	{	// test for istreambuf_iterator equality
	return (_Left.equal(_Right));
	}

template<class _Elem,
	class _Traits> inline
	bool operator!=(
		const istreambuf_iterator<_Elem, _Traits>& _Left,
		const istreambuf_iterator<_Elem, _Traits>& _Right)
	{	// test for istreambuf_iterator inequality
	return (!(_Left == _Right));
	}

		// TEMPLATE CLASS ostreambuf_iterator

# 1417 "C:/usr/local/cell\\target\\ppu\\include/xutility" 3
template<class _Elem,
	class _Traits>
	class ostreambuf_iterator
		: public _Outit
	{	// wrap stream buffer as output iterator
	typedef ostreambuf_iterator<_Elem, _Traits> _Myt;
public:
	typedef _Elem char_type;
	typedef _Traits traits_type;
	typedef basic_streambuf<_Elem, _Traits> streambuf_type;
	typedef basic_ostream<_Elem, _Traits> ostream_type;


	ostreambuf_iterator(streambuf_type *_Sb) 
		: _Failed(false), _Strbuf(_Sb)
		{	// construct from stream buffer _Sb
		}

	ostreambuf_iterator(ostream_type& _Ostr) 
		: _Failed(false), _Strbuf(_Ostr.rdbuf())
		{	// construct from stream buffer in _Ostr
		}

	_Myt& operator=(_Elem _Right)
		{	// store element and increment
		if (_Strbuf == 0
			|| traits_type::eq_int_type(_Traits::eof(),
				_Strbuf->sputc(_Right)))
			_Failed = true;
		return (*this);
		}

	_Myt& operator*()
		{	// pretend to get designated element
		return (*this);
		}

	_Myt& operator++()
		{	// pretend to preincrement
		return (*this);
		}

	_Myt& operator++(int)
		{	// pretend to postincrement
		return (*this);
		}

	bool failed() const 
		{	// return true if any stores failed
		return (_Failed);
		}

private:
	bool _Failed;	// true if any stores have failed
	streambuf_type *_Strbuf;	// the wrapped stream buffer
	};

//	ALGORITHM STUFF (from <algorithm>)

		// TEMPLATE FUNCTION copy
template<class _InIt,
	class _OutIt> inline
	_OutIt _Copy_opt(_InIt _First, _InIt _Last, _OutIt _Dest,
		_Nonscalar_ptr_iterator_tag)
	{	// copy [_First, _Last) to [_Dest, ...), arbitrary iterators
	;
	for (; _First != _Last; ++_Dest, ++_First)
		*_Dest = *_First;
	return (_Dest);
	}

template<class _InIt,
	class _OutIt> inline
	_OutIt _Copy_opt(_InIt _First, _InIt _Last, _OutIt _Dest,
		_Scalar_ptr_iterator_tag)
	{	// copy [_First, _Last) to [_Dest, ...), pointers to scalars







	ptrdiff_t _Off = _Last - _First;	// NB: non-overlapping move
	return ((_OutIt)::std:: memmove(&*_Dest, &*_First,
		_Off * sizeof (*_First)) + _Off);
	}

template<class _InIt,
	class _OutIt> inline
	_OutIt copy(_InIt _First, _InIt _Last, _OutIt _Dest)
	{	// copy [_First, _Last) to [_Dest, ...)
	return (_Copy_opt(_First, _Last, _Dest, _Ptr_cat(_First, _Dest)));
	}

		// TEMPLATE FUNCTION copy_backward
template<class _BidIt1,
	class _BidIt2> inline
	_BidIt2 _Copy_backward_opt(_BidIt1 _First, _BidIt1 _Last, _BidIt2 _Dest,
		_Nonscalar_ptr_iterator_tag)
	{	// copy [_First, _Last) backwards to [..., _Dest), arbitrary iterators
	;
	while (_First != _Last)
		*--_Dest = *--_Last;
	return (_Dest);
	}

template<class _InIt,
	class _OutIt> inline
	_OutIt _Copy_backward_opt(_InIt _First, _InIt _Last, _OutIt _Dest,
		_Scalar_ptr_iterator_tag)
	{	// copy [_First, _Last) backwards to [..., _Dest), pointers to scalars







	ptrdiff_t _Off = _Last - _First;	// NB: non-overlapping move
	return ((_OutIt)memmove(&*_Dest - _Off, &*_First,
		_Off * sizeof (*_First)));
	}

template<class _BidIt1,
	class _BidIt2> inline
	_BidIt2 copy_backward(_BidIt1 _First, _BidIt1 _Last, _BidIt2 _Dest)
	{	// copy [_First, _Last) backwards to [..., _Dest)
	return (_Copy_backward_opt(_First, _Last, _Dest,
		_Ptr_cat(_First, _Dest)));
	}

		// TEMPLATE FUNCTION mismatch
template<class _InIt1,
	class _InIt2> inline
	pair<_InIt1, _InIt2>
		mismatch(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2)
	{	// return [_First1, _Last1) and [_First2, _Last2) mismatch







	for (; _First1 != _Last1 && *_First1 == *_First2; )
		++_First1, ++_First2;
	return (pair<_InIt1, _InIt2>(_First1, _First2));
	}

		// TEMPLATE FUNCTION mismatch WITH PRED
template<class _InIt1,
	class _InIt2,
	class _Pr> inline
	pair<_InIt1, _InIt2>
		mismatch(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _Pr _Pred)
	{	// return [_First1, _Last1) and [_First2, _Last2) mismatch using _Pred

# 1581 "C:/usr/local/cell\\target\\ppu\\include/xutility" 3

	for (; _First1 != _Last1 && _Pred(*_First1, *_First2); )
		++_First1, ++_First2;
	return (pair<_InIt1, _InIt2>(_First1, _First2));
	}

		// TEMPLATE FUNCTION equal
template<class _InIt1,
	class _InIt2> inline
	bool equal(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2)
	{	// compare [_First1, _Last1) to [First2, ...)
	return (::std:: mismatch(_First1, _Last1, _First2).first == _Last1);
	}

inline bool equal(const char *_First1,
	const char *_Last1, const char *_First2)
	{	// compare [_First1, _Last1) to [First2, ...), for chars







	return (::std:: memcmp(_First1, _First2, _Last1 - _First1) == 0);
	}

inline bool equal(const signed char *_First1,
	const signed char *_Last1, const signed char *_First2)
	{	// compare [_First1, _Last1) to [First2, ...), for signed chars







	return (::std:: memcmp(_First1, _First2, _Last1 - _First1) == 0);
	}

inline bool equal(const unsigned char *_First1,
	const unsigned char *_Last1, const unsigned char *_First2)
	{	// compare [_First1, _Last1) to [First2, ...), for unsigned chars







	return (::std:: memcmp(_First1, _First2, _Last1 - _First1) == 0);
	}

		// TEMPLATE FUNCTION equal WITH PRED
template<class _InIt1,
	class _InIt2,
	class _Pr> inline
	bool equal(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _Pr _Pred)
	{	// compare [_First1, _Last1) to [First2, ...) using _Pred
	return (::std:: mismatch(_First1, _Last1, _First2, _Pred).first == _Last1);
	}

		// TEMPLATE FUNCTION fill
template<class _FwdIt,
	class _Ty> inline
	void fill(_FwdIt _First, _FwdIt _Last, const _Ty& _Val)
	{	// copy _Val through [_First, _Last)
	;
	for (; _First != _Last; ++_First)
		*_First = _Val;
	}

inline void fill(char *_First, char *_Last, int _Val)
	{	// copy char _Val through [_First, _Last)
	;
	::std:: memset(_First, _Val, _Last - _First);
	}

inline void fill(signed char *_First, signed char *_Last, int _Val)
	{	// copy signed char _Val through [_First, _Last)
	;
	::std:: memset(_First, _Val, _Last - _First);
	}

inline void fill(unsigned char *_First, unsigned char *_Last, int _Val)
	{	// copy unsigned char _Val through [_First, _Last)
	;
	::std:: memset(_First, _Val, _Last - _First);
	}

		// TEMPLATE FUNCTION fill_n
template<class _OutIt,
	class _Diff,
	class _Ty> inline
	void fill_n(_OutIt _First, _Diff _Count, const _Ty& _Val)
	{	// copy _Val _Count times through [_First, ...)
	for (; 0 < _Count; --_Count, ++_First)
		*_First = _Val;
	}

inline void fill_n(char *_First, size_t _Count, int _Val)
	{	// copy char _Val _Count times through [_First, ...)






	::std:: memset(_First, _Val, _Count);
	}

inline void fill_n(signed char *_First, size_t _Count, int _Val)
	{	// copy signed char _Val _Count times through [_First, ...)






	::std:: memset(_First, _Val, _Count);
	}

inline void fill_n(unsigned char *_First, size_t _Count, int _Val)
	{	// copy unsigned char _Val _Count times through [_First, ...)






	::std:: memset(_First, _Val, _Count);
	}

		// TEMPLATE FUNCTION lexicographical_compare
template<class _InIt1,
	class _InIt2> inline
	bool lexicographical_compare(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2)
	{	// order [_First1, _Last1) vs. [First2, Last2)
	;
	;
	for (; _First1 != _Last1 && _First2 != _Last2; ++_First1, ++_First2)
		if (((*_First1) < (*_First2)))
			return (true);
		else if (*_First2 < *_First1)
			return (false);
	return (_First1 == _Last1 && _First2 != _Last2);
	}

inline bool lexicographical_compare(
	const unsigned char *_First1, const unsigned char *_Last1,
	const unsigned char *_First2, const unsigned char *_Last2)
	{	// order [_First1, _Last1) vs. [First2, Last2), for unsigned char
	;
	;
	ptrdiff_t _Num1 = _Last1 - _First1;
	ptrdiff_t _Num2 = _Last2 - _First2;
	int _Ans = ::std:: memcmp(_First1, _First2, _Num1 < _Num2 ? _Num1 : _Num2);
	return (_Ans < 0 || (_Ans == 0 && _Num1 < _Num2));
	}

# 1755 "C:/usr/local/cell\\target\\ppu\\include/xutility" 3

		// TEMPLATE FUNCTION lexicographical_compare WITH PRED
template<class _InIt1,
	class _InIt2,
	class _Pr> inline
	bool lexicographical_compare(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2, _Pr _Pred)
	{	// order [_First1, _Last1) vs. [First2, Last2) using _Pred
	;
	;
	;
	for (; _First1 != _Last1 && _First2 != _Last2; ++_First1, ++_First2)
		if (_Pred(*_First1, *_First2))
			return (true);
		else if (_Pred(*_First2, *_First1))
			return (false);
	return (_First1 == _Last1 && _First2 != _Last2);
	}











		// TEMPLATE FUNCTION max
template<class _Ty> inline
	const _Ty& max(const _Ty& _Left, const _Ty& _Right)
	{	// return larger of _Left and _Right
	return (((_Left) < (_Right)) ? _Right : _Left);
	}

		// TEMPLATE FUNCTION max WITH PRED
template<class _Ty,
	class _Pr> inline
	const _Ty& max(const _Ty& _Left, const _Ty& _Right, _Pr _Pred)
	{	// return larger of _Left and _Right using _Pred
	return (_Pred(_Left, _Right) ? _Right : _Left);
	}

		// TEMPLATE FUNCTION min
template<class _Ty> inline
	const _Ty& min(const _Ty& _Left, const _Ty& _Right)
	{	// return smaller of _Left and _Right
	return (((_Right) < (_Left)) ? _Right : _Left);
	}

		// TEMPLATE FUNCTION min WITH PRED
template<class _Ty,
	class _Pr> inline
	const _Ty& min(const _Ty& _Left, const _Ty& _Right, _Pr _Pred)
	{	// return smaller of _Left and _Right using _Pred
	return (_Pred(_Right, _Left) ? _Right : _Left);
	}

}


/*
 * Copyright (c) 1992-2003 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
 */

/*
 * This file is derived from software bearing the following
 * restrictions:
 *
 * Copyright (c) 1994
 * Hewlett-Packard Company
 *
 * Permission to use, copy, modify, distribute and sell this
 * software and its documentation for any purpose is hereby
 * granted without fee, provided that the above copyright notice
 * appear in all copies and that both that copyright notice and
 * this permission notice appear in supporting documentation.
 * Hewlett-Packard Company makes no representations about the
 * suitability of this software for any purpose. It is provided
 * "as is" without express or implied warranty.
V4.02:0216 */
# 7 "C:/usr/local/cell\\target\\ppu\\include/xmemory" 3







# 22 "C:/usr/local/cell\\target\\ppu\\include/xmemory" 3

namespace std {
		// TEMPLATE FUNCTION _Allocate
template<class _Ty> inline
	_Ty  *_Allocate(size_t _Count, _Ty  *)
	{	// allocate storage for _Count elements of type _Ty
	return ((_Ty  *)::operator new(_Count * sizeof (_Ty), __alignof__(_Ty)));
	}

		// TEMPLATE FUNCTION _Construct
template<class _T1,
	class _T2> inline
	void _Construct(_T1  *_Ptr, const _T2& _Val)
	{	// construct object at _Ptr with value _Val
	void  *_Vptr = _Ptr;
	new (_Vptr) _T1(_Val);
	}


template<class _T1,
	class _T2> inline
	void _Construct(const _T1 *const *_Ptr, const _T2 *_Val)
	{	// construct pointer object at _Ptr with value _Val
	*(_T1 **)_Ptr = (_T1 *)_Val;
	}


		// TEMPLATE FUNCTION _Destroy
template<class _Ty> inline
	void _Destroy(_Ty  *_Ptr)
	{	// destroy object at _Ptr
	(_Ptr)->~_Ty();
	}

template<> inline
	void _Destroy(char  *)
	{	// destroy a char (do nothing)
	}

template<> inline
	void _Destroy(wchar_t  *)
	{	// destroy a wchar_t (do nothing)
	}

		// TEMPLATE CLASS _Allocator_base
template<class _Ty>
	struct _Allocator_base
	{	// base class for generic allocators
	typedef _Ty value_type;
	};



# 84 "C:/usr/local/cell\\target\\ppu\\include/xmemory" 3

		// TEMPLATE CLASS allocator
template<class _Ty>
	class allocator
		: public _Allocator_base<_Ty>
	{	// generic allocator for objects of class _Ty
public:
	typedef _Allocator_base<_Ty> _Mybase;
	typedef typename _Mybase::value_type value_type;
	typedef value_type  *pointer;
	typedef value_type & reference;
	typedef const value_type  *const_pointer;
	typedef const value_type & const_reference;

	typedef size_t size_type;
	typedef ptrdiff_t difference_type;

	template<class _Other>
		struct rebind
		{	// convert an allocator<_Ty> to an allocator <_Other>
		typedef allocator<_Other> other;
		};

	pointer address(reference _Val) const
		{	// return address of mutable _Val
		return (&_Val);
		}

	const_pointer address(const_reference _Val) const
		{	// return address of nonmutable _Val
		return (&_Val);
		}

	allocator() 
		{	// construct default allocator (do nothing)
		}

	allocator(const allocator<_Ty>&) 
		{	// construct by copying (do nothing)
		}

	template<class _Other>
		allocator(const allocator<_Other>&) 
		{	// construct from a related allocator (do nothing)
		}

	template<class _Other>
		allocator<_Ty>& operator=(const allocator<_Other>&)
		{	// assign from a related allocator (do nothing)
		return (*this);
		}

	void deallocate(pointer _Ptr, size_type)
		{	// deallocate object at _Ptr, ignore size
		::operator delete(_Ptr);
		}

	pointer allocate(size_type _Count)
		{	// allocate array of _Count elements
		return (_Allocate(_Count, (pointer)0));
		}

	pointer allocate(size_type _Count, const void  *)
		{	// allocate array of _Count elements, ignore hint
		return (allocate(_Count));
		}

	void construct(pointer _Ptr, const _Ty& _Val)
		{	// construct object at _Ptr with value _Val
		_Construct(_Ptr, _Val);
		}

	void destroy(pointer _Ptr)
		{	// destroy object at _Ptr
		_Destroy(_Ptr);
		}

	size_t max_size() const 
		{	// estimate maximum array size
		size_t _Count = (size_t)(-1) / sizeof (_Ty);
		return (0 < _Count ? _Count : 1);
		}
	};

		// allocator TEMPLATE OPERATORS
template<class _Ty,
	class _Other> inline
	bool operator==(const allocator<_Ty>&, const allocator<_Other>&) 
	{	// test for allocator equality (always true)
	return (true);
	}

template<class _Ty,
	class _Other> inline
	bool operator!=(const allocator<_Ty>&, const allocator<_Other>&) 
	{	// test for allocator inequality (always false)
	return (false);
	}

		// CLASS allocator<void>
template<> class allocator<void>
	{	// generic allocator for type void
public:
	typedef void _Ty;
	typedef _Ty  *pointer;
	typedef const _Ty  *const_pointer;
	typedef _Ty value_type;

	template<class _Other>
		struct rebind
		{	// convert an allocator<void> to an allocator <_Other>
		typedef allocator<_Other> other;
		};

	allocator() 
		{	// construct default allocator (do nothing)
		}

	allocator(const allocator<_Ty>&) 
		{	// construct by copying (do nothing)
		}

	template<class _Other>
		allocator(const allocator<_Other>&) 
		{	// construct from related allocator (do nothing)
		}

	template<class _Other>
		allocator<_Ty>& operator=(const allocator<_Other>&)
		{	// assign from a related allocator (do nothing)
		return (*this);
		}
	};

		// TEMPLATE FUNCTION _Destroy_range
template<class _Ty,
	class _Alloc> inline
	void _Destroy_range(_Ty *_First, _Ty *_Last, _Alloc& _Al)
	{	// destroy [_First, _Last)
	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));
	}

template<class _Ty,
	class _Alloc> inline
	void _Destroy_range(_Ty *_First, _Ty *_Last, _Alloc& _Al,
		_Nonscalar_ptr_iterator_tag)
	{	// destroy [_First, _Last), arbitrary type
	for (; _First != _Last; ++_First)
		_Al.destroy(_First);
	}

template<class _Ty,
	class _Alloc> inline
	void _Destroy_range(_Ty *, _Ty *, _Alloc&,
		_Scalar_ptr_iterator_tag)
	{	// destroy [_First, _Last), scalar type (do nothing)
	}
}


/*
 * Copyright (c) 1992-2003 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
 */

/*
 * This file is derived from software bearing the following
 * restrictions:
 *
 * Copyright (c) 1994
 * Hewlett-Packard Company
 *
 * Permission to use, copy, modify, distribute and sell this
 * software and its documentation for any purpose is hereby
 * granted without fee, provided that the above copyright notice
 * appear in all copies and that both that copyright notice and
 * this permission notice appear in supporting documentation.
 * Hewlett-Packard Company makes no representations about the
 * suitability of this software for any purpose. It is provided
 * "as is" without express or implied warranty.
V4.02:0216 */
# 10 "C:/usr/local/cell\\target\\ppu\\include/memory" 3
namespace std {

		// TEMPLATE FUNCTION get_temporary_buffer
template<class _Ty> inline
	pair<_Ty  *, ptrdiff_t>
		get_temporary_buffer(ptrdiff_t _Count)
	{	// get raw temporary buffer of up to _Count elements
	_Ty  *_Pbuf;

	for (_Pbuf = 0; 0 < _Count; _Count /= 2)
		if ((_Pbuf = (_Ty  *)operator new(
			(size_t)_Count * sizeof (_Ty), nothrow)) != 0)
			break;

	return (pair<_Ty  *, ptrdiff_t>(_Pbuf, _Count));
	}

		// TEMPLATE FUNCTION return_temporary_buffer
template<class _Ty> inline
	void return_temporary_buffer(_Ty *_Pbuf)
	{	// delete raw temporary buffer
	operator delete(_Pbuf);
	}

		// TEMPLATE FUNCTION uninitialized_copy
template<class _InIt,
	class _FwdIt> inline
	_FwdIt _Uninit_copy(_InIt _First, _InIt _Last, _FwdIt _Dest,
		_Nonscalar_ptr_iterator_tag)
	{	// copy [_First, _Last) to raw _Dest, arbitrary type
	;
	;
	_FwdIt _Next = _Dest;

	{{
	for (; _First != _Last; ++_Dest, ++_First)
		_Construct(&*_Dest, *_First);
	} if (0) {
	for (; _Next != _Dest; ++_Next)
		_Destroy(&*_Next);
	;
	}}
	return (_Dest);
	}

template<class _Ty1,
	class _Ty2> inline
	_Ty2 *_Uninit_copy(_Ty1 *_First, _Ty1 *_Last, _Ty2 *_Dest,
		_Scalar_ptr_iterator_tag)
	{	// copy [_First, _Last) to raw _Dest, scalar type
	;
	;
	size_t _Count = (size_t)(_Last - _First);
	return ((_Ty2 *)memmove(&*_Dest, &*_First,
		_Count * sizeof (*_First)) + _Count);	// NB: non-overlapping move
	}

template<class _InIt,
	class _FwdIt> inline
	_FwdIt uninitialized_copy(_InIt _First, _InIt _Last, _FwdIt _Dest)
	{	// copy [_First, _Last) to raw _Dest
	return (_Uninit_copy(_First, _Last, _Dest,
		_Ptr_cat(_First, _Dest)));
	}

		// TEMPLATE FUNCTION _Uninitialized_copy WITH ALLOCATOR
template<class _InIt,
	class _FwdIt,
	class _Alloc> inline
	_FwdIt _Uninit_copy(_InIt _First, _InIt _Last, _FwdIt _Dest,
		_Alloc& _Al, _Nonscalar_ptr_iterator_tag)
	{	// copy [_First, _Last) to raw _Dest, using _Al, arbitrary type
	;
	;
	_FwdIt _Next = _Dest;

	{{
	for (; _First != _Last; ++_Dest, ++_First)
		_Al.construct(_Dest, *_First);
	} if (0) {
	for (; _Next != _Dest; ++_Next)
		_Al.destroy(_Next);
	;
	}}
	return (_Dest);
	}

template<class _InIt,
	class _FwdIt,
	class _Alloc> inline
	_FwdIt _Uninit_copy(_InIt _First, _InIt _Last, _FwdIt _Dest,
		_Alloc& _Al, _Scalar_ptr_iterator_tag)
	{	// copy [_First, _Last) to raw _Dest, using _Al, scalar type
	return (_Uninit_copy(_First, _Last, _Dest,
		_Al, _Nonscalar_ptr_iterator_tag()));
	}

template<class _Ty1,
	class _Ty2> inline
	_Ty2 *_Uninit_copy(_Ty1 *_First, _Ty1 *_Last, _Ty2 *_Dest,
		allocator<_Ty2>&, _Scalar_ptr_iterator_tag)
	{	// copy [_First, _Last) to raw _Dest, scalar type
	;
	;
	size_t _Count = (size_t)(_Last - _First);
	return ((_Ty2 *)memmove(&*_Dest, &*_First,
		_Count * sizeof (*_First)) + _Count);	// NB: non-overlapping move
	}



# 134 "C:/usr/local/cell\\target\\ppu\\include/memory" 3

template<class _InIt,
	class _FwdIt,
	class _Alloc> inline
	_FwdIt _Uninitialized_copy(_InIt _First, _InIt _Last, _FwdIt _Dest,
		_Alloc& _Al)
	{	// copy [_First, _Last) to raw _Dest, using _Al
	return (_Uninit_copy(_First, _Last, _Dest, _Al,
		_Ptr_cat(_First, _Dest)));
	}

		// TEMPLATE FUNCTION uninitialized_fill
template<class _FwdIt,
	class _Tval> inline
	void _Uninit_fill(_FwdIt _First, _FwdIt _Last, const _Tval& _Val,
		_Nonscalar_ptr_iterator_tag)
	{	// copy _Val throughout raw [_First, _Last), arbitrary type
	;
	_FwdIt _Next = _First;

	{{
	for (; _First != _Last; ++_First)
		_Construct(&*_First, _Val);
	} if (0) {
	for (; _Next != _First; ++_Next)
		_Destroy(&*_Next);
	;
	}}
	}

template<class _Ty,
	class _Tval> inline
	void _Uninit_fill(_Ty *_First, _Ty *_Last, const _Tval& _Val,
		_Scalar_ptr_iterator_tag)
	{	// copy _Val throughout raw [_First, _Last), scalar type
	::std:: fill(_First, _Last, _Val);
	}

template<class _FwdIt,
	class _Tval> inline
	void uninitialized_fill(_FwdIt _First, _FwdIt _Last, const _Tval& _Val)
	{	// copy _Val throughout raw [_First, _Last)
	_Uninit_fill(_First, _Last, _Val, _Ptr_cat(_First, _First));
	}

		// TEMPLATE FUNCTION uninitialized_fill_n
template<class _FwdIt,
	class _Diff,
	class _Tval> inline
	void _Uninit_fill_n(_FwdIt _First, _Diff _Count, const _Tval& _Val,
		_Nonscalar_ptr_iterator_tag)
	{	// copy _Count *_Val to raw _First, arbitrary type






	_FwdIt _Next = _First;

	{{
	for (; 0 < _Count; --_Count, ++_First)
		_Construct(&*_First, _Val);
	} if (0) {
	for (; _Next != _First; ++_Next)
		_Destroy(&*_Next);
	;
	}}
	}

template<class _Ty,
	class _Diff,
	class _Tval> inline
	void _Uninit_fill_n(_Ty *_First, _Diff _Count, const _Tval& _Val,
		_Scalar_ptr_iterator_tag)
	{	// copy _Count *_Val to raw _First, scalar type
	::std:: fill_n(_First, _Count, _Val);
	}

template<class _FwdIt,
	class _Diff,
	class _Tval> inline
	void uninitialized_fill_n(_FwdIt _First, _Diff _Count, const _Tval& _Val)
	{	// copy _Count *_Val to raw _First
	_Uninit_fill_n(_First, _Count, _Val, _Ptr_cat(_First, _First));
	}

		// TEMPLATE FUNCTION _Uninitialized_fill_n WITH ALLOCATOR
template<class _FwdIt,
	class _Diff,
	class _Tval,
	class _Alloc> inline
	void _Uninit_fill_n(_FwdIt _First, _Diff _Count,
		const _Tval& _Val, _Alloc& _Al, _Nonscalar_ptr_iterator_tag)
	{	// copy _Count *_Val to raw _First, using _Al, arbitrary type






	_FwdIt _Next = _First;

	{{
	for (; 0 < _Count; --_Count, ++_First)
		_Al.construct(_First, _Val);
	} if (0) {
	for (; _Next != _First; ++_Next)
		_Al.destroy(_Next);
	;
	}}
	}

template<class _FwdIt,
	class _Diff,
	class _Tval,
	class _Alloc> inline
	void _Uninit_fill_n(_FwdIt _First, _Diff _Count,
		const _Tval& _Val, _Alloc& _Al, _Scalar_ptr_iterator_tag)
	{	// copy _Count *_Val to raw _First, using _Al, arbitrary type
	_Uninit_fill_n(_First, _Count,
		_Val, _Al, _Nonscalar_ptr_iterator_tag());
	}


template<class _Ty,
	class _Diff,
	class _Tval> inline
	void _Uninit_fill_n(_Ty *_First, _Diff _Count,
		const _Tval& _Val, allocator<_Ty>&, _Scalar_ptr_iterator_tag)
	{	// copy _Count *_Val to raw _First, using _Al, scalar type
	::std:: fill_n(_First, _Count, _Val);
	}



# 281 "C:/usr/local/cell\\target\\ppu\\include/memory" 3

template<class _FwdIt,
	class _Diff,
	class _Tval,
	class _Alloc> inline
	void _Uninitialized_fill_n(_FwdIt _First, _Diff _Count,
		const _Tval& _Val, _Alloc& _Al)
	{	// copy _Count *_Val to raw _First, using _Al
	_Uninit_fill_n(_First, _Count, _Val, _Al,
		_Ptr_cat(_First, _First));
	}

		// TEMPLATE CLASS raw_storage_iterator
template<class _FwdIt,
	class _Ty>
	class raw_storage_iterator
		: public _Outit
	{	// wrap stores to raw buffer as output iterator
public:
	typedef _FwdIt iterator_type;	// retained
	typedef _FwdIt iter_type;	// retained
	typedef _Ty element_type;	// retained

	explicit raw_storage_iterator(_FwdIt _First)
		: _Next(_First)
		{	// construct with iterator
		}

	raw_storage_iterator<_FwdIt, _Ty>& operator*()
		{	// pretend to return designated value
		return (*this);
		}

	raw_storage_iterator<_FwdIt, _Ty>& operator=(const _Ty& _Val)
		{	// construct value designated by stored iterator
		_Construct(&*_Next, _Val);
		return (*this);
		}

	raw_storage_iterator<_FwdIt, _Ty>& operator++()
		{	// preincrement
		++_Next;
		return (*this);
		}

	raw_storage_iterator<_FwdIt, _Ty> operator++(int)
		{	// postincrement
		raw_storage_iterator<_FwdIt, _Ty> _Ans = *this;
		++_Next;
		return (_Ans);
		}

private:
	_FwdIt _Next;	// the stored iterator
	};

		// TEMPLATE CLASS _Temp_iterator
template<class _Ty>
	class _Temp_iterator
		: public _Outit
	{	// wrap stores to temporary buffer as output iterator
public:
	typedef _Ty  *_Pty;

	_Temp_iterator(ptrdiff_t _Count = 0)
		{	// construct from desired temporary buffer size
		pair<_Pty, ptrdiff_t> _Pair =
			::std:: get_temporary_buffer<_Ty>(_Count);
		_Buf._Begin = _Pair.first;
		_Buf._Current = _Pair.first;
		_Buf._Hiwater = _Pair.first;
		_Buf._Size = _Pair.second;
		_Pbuf = &_Buf;
		}

	_Temp_iterator(const _Temp_iterator<_Ty>& _Right)
		{	// construct from _Right (share active buffer)
		_Buf._Begin = 0;	// clear stored buffer, to be tidy
		_Buf._Current = 0;
		_Buf._Hiwater = 0;
		_Buf._Size = 0;
		*this = _Right;
		}

	~_Temp_iterator()
		{	// destroy the object
		if (_Buf._Begin != 0)
			{	// destroy any constructed elements in buffer
			for (_Pty _Next = _Buf._Begin;
				_Next != _Buf._Hiwater; ++_Next)
				_Destroy(&*_Next);
			::std:: return_temporary_buffer(_Buf._Begin);
			}
		}

	_Temp_iterator<_Ty>& operator=(const _Temp_iterator<_Ty>& _Right)
		{	// assign _Right (share active buffer)
		_Pbuf = _Right._Pbuf;
		return (*this);
		}

	_Temp_iterator<_Ty>& operator=(const _Ty& _Val)
		{	// assign or construct value into active buffer, and increment
		if (_Pbuf->_Current < _Pbuf->_Hiwater)
			*_Pbuf->_Current++ = _Val;	// below high water mark, assign
		else
			{	// above high water mark, construct
			_Pty _Ptr = &*_Pbuf->_Current;
			_Construct(_Ptr, _Val);
			_Pbuf->_Hiwater = ++_Pbuf->_Current;
			}
		return (*this);
		}

	_Temp_iterator<_Ty>& operator*()
		{	// pretend to return designated value
		return (*this);
		}

	_Temp_iterator<_Ty>& operator++()
		{	// pretend to preincrement
		return (*this);
		}

	_Temp_iterator<_Ty>& operator++(int)
		{	// pretend to postincrement
		return (*this);
		}

	_Temp_iterator<_Ty>& _Init()
		{	// set pointer at beginning of buffer
		_Pbuf->_Current = _Pbuf->_Begin;
		return (*this);
		}

	_Pty _First() const
		{	// return pointer to beginning of buffer
		return (_Pbuf->_Begin);
		}

	_Pty _Last() const
		{	// return pointer past end of buffer contents
		return (_Pbuf->_Current);
		}

	ptrdiff_t _Maxlen() const
		{	// return size of buffer
		return (_Pbuf->_Size);
		}

private:
	struct _Bufpar
		{	// control information for a temporary buffer
		_Pty _Begin;	// pointer to beginning of buffer
		_Pty _Current;	// pointer to next available element
		_Pty _Hiwater;	// pointer to first unconstructed element
		ptrdiff_t _Size;	// length of buffer
		};
	_Bufpar _Buf;	// buffer control stored in iterator
	_Bufpar *_Pbuf;	// pointer to active buffer control
	};

		// TEMPLATE CLASS auto_ptr
template<class _Ty>
	class auto_ptr;

template<class _Ty>
	struct auto_ptr_ref
		{	// proxy reference for auto_ptr copying
	auto_ptr_ref(auto_ptr<_Ty>& _Right)
		: _Ref(_Right)
		{	// construct from compatible auto_ptr
		}

	auto_ptr<_Ty>& _Ref;	// reference to constructor argument
	};

template<class _Ty>
	class auto_ptr
		{	// wrap an object pointer to ensure destruction
public:
	typedef _Ty element_type;

	explicit auto_ptr(_Ty *_Ptr = 0) 
		: _Myptr(_Ptr)
		{	// construct from object pointer
		}

	auto_ptr(auto_ptr<_Ty>& _Right) 
		: _Myptr(_Right.release())
		{	// construct by assuming pointer from _Right auto_ptr
		}

	auto_ptr(auto_ptr_ref<_Ty> _Right) 
		: _Myptr(_Right._Ref.release())
		{	// construct by assuming pointer from _Right auto_ptr_ref
		}

	template<class _Other>
		operator auto_ptr<_Other>() 
		{	// convert to compatible auto_ptr
		return (auto_ptr<_Other>(*this));
		}

	template<class _Other>
		operator auto_ptr_ref<_Other>() 
		{	// convert to compatible auto_ptr_ref
		return (auto_ptr_ref<_Other>(*this));
		}

	template<class _Other>
		auto_ptr<_Ty>& operator=(auto_ptr<_Other>& _Right) 
		{	// assign compatible _Right (assume pointer)
		reset(_Right.release());
		return (*this);
		}

	template<class _Other>
		auto_ptr(auto_ptr<_Other>& _Right) 
		: _Myptr(_Right.release())
		{	// construct by assuming pointer from _Right
		}

	auto_ptr<_Ty>& operator=(auto_ptr<_Ty>& _Right) 
		{	// assign compatible _Right (assume pointer)
		reset(_Right.release());
		return (*this);
		}

	auto_ptr<_Ty>& operator=(auto_ptr_ref<_Ty> _Right) 
		{	// assign compatible _Right._Ref (assume pointer)
		reset(_Right._Ref.release());
		return (*this);
		}

	~auto_ptr()
		{	// destroy the object
		delete _Myptr;
		}

	_Ty& operator*() const 
		{	// return designated value






		return (*_Myptr);
		}

	_Ty *operator->() const 
		{	// return pointer to class object
		return (&**this);
		}

	_Ty *get() const 
		{	// return wrapped pointer
		return (_Myptr);
		}

	_Ty *release() 
		{	// return wrapped pointer and give up ownership
		_Ty *_Tmp = _Myptr;
		_Myptr = 0;
		return (_Tmp);
		}

	void reset(_Ty* _Ptr = 0)
		{	// destroy designated object and store new pointer
		if (_Ptr != _Myptr)
			delete _Myptr;
		_Myptr = _Ptr;
		}

private:
	_Ty *_Myptr;	// the wrapped object pointer
	};
}


/*
 * Copyright (c) 1992-2003 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
 */

/*
 * This file is derived from software bearing the following
 * restrictions:
 *
 * Copyright (c) 1994
 * Hewlett-Packard Company
 *
 * Permission to use, copy, modify, distribute and sell this
 * software and its documentation for any purpose is hereby
 * granted without fee, provided that the above copyright notice
 * appear in all copies and that both that copyright notice and
 * this permission notice appear in supporting documentation.
 * Hewlett-Packard Company makes no representations about the
 * suitability of this software for any purpose. It is provided
 * "as is" without express or implied warranty.
V4.02:0216 */
# 11 "C:/usr/local/cell\\target\\ppu\\include/list" 3
# 1 "C:/usr/local/cell\\target\\ppu\\include/stdexcept" 3
// stdexcept standard header
# 1 "C:/usr/local/cell\\target\\ppu\\include/xstring" 3
// xstring internal header (from <string>)



namespace std {

template<class _Elem,
	class _Traits = char_traits<_Elem>,
	class _Ax = allocator<_Elem> >
	class basic_string;




		// TEMPLATE CLASS _String_const_iterator
template<class _Elem,
	class _Traits,
	class _Alloc>
	class _String_const_iterator
		: public _Ranit<_Elem, typename _Alloc::difference_type,
			typename _Alloc::const_pointer, typename _Alloc::const_reference>
	{	// iterator for nonmutable string
public:
	typedef _String_const_iterator<_Elem, _Traits, _Alloc> _Myt;
	typedef basic_string<_Elem, _Traits, _Alloc> _Mystring;

	typedef random_access_iterator_tag iterator_category;
	typedef _Elem value_type;
	typedef typename _Alloc::difference_type difference_type;
	typedef typename _Alloc::const_pointer pointer;
	typedef typename _Alloc::const_reference reference;

	_String_const_iterator()
		{	// construct with null pointer
		_Myptr = 0;
		}

# 49 "C:/usr/local/cell\\target\\ppu\\include/xstring" 3

	_String_const_iterator(pointer _Ptr)
		{	// construct with pointer _Ptr
		_Myptr = _Ptr;
		}


	reference operator*() const
		{	// return designated object

# 66 "C:/usr/local/cell\\target\\ppu\\include/xstring" 3

		return (*_Myptr);
		}

	pointer operator->() const
		{	// return pointer to class object
		return (&**this);
		}

	_Myt& operator++()
		{	// preincrement
		++_Myptr;
		return (*this);
		}

	_Myt operator++(int)
		{	// postincrement
		_Myt _Tmp = *this;
		++*this;
		return (_Tmp);
		}

	_Myt& operator--()
		{	// predecrement
		--_Myptr;
		return (*this);
		}

	_Myt operator--(int)
		{	// postdecrement
		_Myt _Tmp = *this;
		--*this;
		return (_Tmp);
		}

	_Myt& operator+=(difference_type _Off)
		{	// increment by integer
		_Myptr += _Off;
		return (*this);
		}

	_Myt operator+(difference_type _Off) const
		{	// return this + integer
		_Myt _Tmp = *this;
		return (_Tmp += _Off);
		}

	_Myt& operator-=(difference_type _Off)
		{	// decrement by integer
		return (*this += -_Off);
		}

	_Myt operator-(difference_type _Off) const
		{	// return this - integer
		_Myt _Tmp = *this;
		return (_Tmp -= _Off);
		}

	difference_type operator-(const _Myt& _Right) const
		{	// return difference of iterators





		return (_Myptr - _Right._Myptr);
		}

	reference operator[](difference_type _Off) const
		{	// subscript
		return (*(*this + _Off));
		}

	bool operator==(const _Myt& _Right) const
		{	// test for iterator equality





		return (_Myptr == _Right._Myptr);
		}

	bool operator!=(const _Myt& _Right) const
		{	// test for iterator inequality
		return (!(*this == _Right));
		}

	bool operator<(const _Myt& _Right) const
		{	// test if this < _Right





		return (_Myptr < _Right._Myptr);
		}

	bool operator>(const _Myt& _Right) const
		{	// test if this > _Right
		return (_Right < *this);
		}

	bool operator<=(const _Myt& _Right) const
		{	// test if this <= _Right
		return (!(_Right < *this));
		}

	bool operator>=(const _Myt& _Right) const
		{	// test if this >= _Right
		return (!(*this < _Right));
		}

# 186 "C:/usr/local/cell\\target\\ppu\\include/xstring" 3

	pointer _Myptr;	// offset of element in string
	};

template<class _Elem,
	class _Traits,
	class _Alloc> inline
	_String_const_iterator<_Elem, _Traits, _Alloc> operator+(
		typename _String_const_iterator<_Elem, _Traits, _Alloc>
			::difference_type _Off,
		_String_const_iterator<_Elem, _Traits, _Alloc> _Next)
	{	// add offset to iterator
	return (_Next += _Off);
	}

		// TEMPLATE CLASS _String_iterator
template<class _Elem,
	class _Traits,
	class _Alloc>
	class _String_iterator
		: public _String_const_iterator<_Elem, _Traits, _Alloc>
	{	// iterator for mutable string
public:
	typedef _String_iterator<_Elem, _Traits, _Alloc> _Myt;
	typedef _String_const_iterator<_Elem, _Traits, _Alloc> _Mybase;

	typedef random_access_iterator_tag iterator_category;
	typedef _Elem value_type;
	typedef typename _Alloc::difference_type difference_type;
	typedef typename _Alloc::pointer pointer;
	typedef typename _Alloc::reference reference;

	_String_iterator()
		{	// construct with null string pointer
		}

# 232 "C:/usr/local/cell\\target\\ppu\\include/xstring" 3

	_String_iterator(pointer _Ptr)
		: _Mybase(_Ptr)
		{	// construct with pointer _Ptr
		}


	reference operator*() const
		{	// return designated object
		return ((reference)**(_Mybase *)this);
		}

	pointer operator->() const
		{	// return pointer to class object
		return (&**this);
		}

	_Myt& operator++()
		{	// preincrement
		++this->_Myptr;
		return (*this);
		}

	_Myt operator++(int)
		{	// postincrement
		_Myt _Tmp = *this;
		++*this;
		return (_Tmp);
		}

	_Myt& operator--()
		{	// predecrement
		--this->_Myptr;
		return (*this);
		}

	_Myt operator--(int)
		{	// postdecrement
		_Myt _Tmp = *this;
		--*this;
		return (_Tmp);
		}

	_Myt& operator+=(difference_type _Off)
		{	// increment by integer
		this->_Myptr += _Off;
		return (*this);
		}

	_Myt operator+(difference_type _Off) const
		{	// return this + integer
		_Myt _Tmp = *this;
		return (_Tmp += _Off);
		}

	_Myt& operator-=(difference_type _Off)
		{	// decrement by integer
		return (*this += -_Off);
		}

	_Myt operator-(difference_type _Off) const
		{	// return this - integer
		_Myt _Tmp = *this;
		return (_Tmp -= _Off);
		}

	difference_type operator-(const _Mybase& _Right) const
		{	// return difference of iterators
		return ((_Mybase)*this - _Right);
		}

	reference operator[](difference_type _Off) const
		{	// subscript
		return (*(*this + _Off));
		}
	};

template<class _Elem,
	class _Traits,
	class _Alloc> inline
	_String_iterator<_Elem, _Traits, _Alloc> operator+(
		typename _String_iterator<_Elem, _Traits, _Alloc>
			::difference_type _Off,
		_String_iterator<_Elem, _Traits, _Alloc> _Next)
	{	// add offset to iterator
	return (_Next += _Off);
	}


		// CLASS _String_base
class _String_base
		: public _Container_base
	{	// ultimate base class for basic_string to hold error reporters
public:
	void _Xlen() const;	// report a length_error

	void _Xran() const;	// report an out_of_range error
	};

		// TEMPLATE CLASS _String_val
template<class _Ty,
	class _Alloc>
	class _String_val
		: public _String_base
	{	// base class for basic_string to hold allocator _Alval
protected:
	typedef typename _Alloc::template
		rebind<_Ty>::other _Alty;

	_String_val(_Alty _Al = _Alty())
		: _Alval(_Al)
		{	// construct allocator from _Al
		}

	_Alty _Alval;	// allocator object for strings
	};

		// TEMPLATE CLASS basic_string
template<class _Elem,
	class _Traits,
	class _Ax>
	class basic_string
		: public _String_val<_Elem, _Ax>
	{	// null-terminated transparent array of elements
public:
	typedef basic_string<_Elem, _Traits, _Ax> _Myt;
	typedef _String_val<_Elem, _Ax> _Mybase;
	typedef typename _Mybase::_Alty _Alloc;
	typedef typename _Alloc::size_type size_type;
	typedef typename _Alloc::difference_type _Dift;
	typedef _Dift difference_type;
	typedef typename _Alloc::pointer _Tptr;
	typedef typename _Alloc::const_pointer _Ctptr;
	typedef _Tptr pointer;
	typedef _Ctptr const_pointer;
	typedef typename _Alloc::reference _Reft;
	typedef _Reft reference;
	typedef typename _Alloc::const_reference const_reference;
	typedef typename _Alloc::value_type value_type;

# 380 "C:/usr/local/cell\\target\\ppu\\include/xstring" 3

	typedef _String_iterator<_Elem, _Traits, _Alloc> iterator;
	typedef _String_const_iterator<_Elem, _Traits, _Alloc> const_iterator;

//	friend class _String_iterator<_Elem, _Traits, _Alloc>;
	friend class _String_const_iterator<_Elem, _Traits, _Alloc>;


	typedef ::std:: reverse_iterator<iterator> reverse_iterator;
	typedef ::std:: reverse_iterator<const_iterator> const_reverse_iterator;

	basic_string()
		: _Mybase()
		{	// construct empty string
		_Tidy();
		}

	explicit basic_string(const _Alloc& _Al)
		: _Mybase(_Al)
		{	// construct empty string with allocator
		_Tidy();
		}

	basic_string(const _Myt& _Right)
		: _Mybase(_Right._Alval)
		{	// construct by copying _Right
		_Tidy();
		assign(_Right, 0, npos);
		}

	basic_string(const _Myt& _Right, size_type _Roff,





		size_type _Count = npos)


		: _Mybase()
		{	// construct from _Right [_Roff, _Roff + _Count)
		_Tidy();
		assign(_Right, _Roff, _Count);
		}

	basic_string(const _Myt& _Right, size_type _Roff, size_type _Count,
		const _Alloc& _Al)
		: _Mybase(_Al)
		{	// construct from _Right [_Roff, _Roff + _Count) with allocator
		_Tidy();
		assign(_Right, _Roff, _Count);
		}

	basic_string(const _Elem *_Ptr, size_type _Count)
		: _Mybase()
		{	// construct from [_Ptr, _Ptr + _Count)
		_Tidy();
		assign(_Ptr, _Count);
		}

	basic_string(const _Elem *_Ptr, size_type _Count, const _Alloc& _Al)
		: _Mybase(_Al)
		{	// construct from [_Ptr, _Ptr + _Count) with allocator
		_Tidy();
		assign(_Ptr, _Count);
		}

	basic_string(const _Elem *_Ptr)
		: _Mybase()
		{	// construct from [_Ptr, <null>)
		_Tidy();
		assign(_Ptr);
		}

	basic_string(const _Elem *_Ptr, const _Alloc& _Al)
		: _Mybase(_Al)
		{	// construct from [_Ptr, <null>) with allocator
		_Tidy();
		assign(_Ptr);
		}

	basic_string(size_type _Count, _Elem _Ch)
		: _Mybase()
		{	// construct from _Count * _Ch
		_Tidy();
		assign(_Count, _Ch);
		}

	basic_string(size_type _Count, _Elem _Ch, const _Alloc& _Al)
		: _Mybase(_Al)
		{	// construct from _Count * _Ch with allocator
		_Tidy();
		assign(_Count, _Ch);
		}

	template<class _It>
		basic_string(_It _First, _It _Last)
		: _Mybase()
		{	// construct from [_First, _Last)
		_Tidy();
		_Construct(_First, _Last, _Iter_cat(_First));
		}

	template<class _It>
		basic_string(_It _First, _It _Last, const _Alloc& _Al)
		: _Mybase(_Al)
		{	// construct from [_First, _Last) with allocator
		_Tidy();
		_Construct(_First, _Last, _Iter_cat(_First));
		}

	template<class _It>
		void _Construct(_It _Count,
			_It _Ch, _Int_iterator_tag)
		{	// initialize from _Count * _Ch
		assign((size_type)_Count, (_Elem)_Ch);
		}

	template<class _It>
		void _Construct(_It _First,
			_It _Last, input_iterator_tag)
		{	// initialize from [_First, _Last), input iterators
		{{
		for (; _First != _Last; ++_First)
			append((size_type)1, (_Elem)*_First);
		} if (0) {
		_Tidy(true);
		;
		}}
		}

	template<class _It>
		void _Construct(_It _First,
			_It _Last, forward_iterator_tag)
		{	// initialize from [_First, _Last), forward iterators
		;
		size_type _Count = 0;
		_Distance(_First, _Last, _Count);
		reserve(_Count);

		{{
		for (; _First != _Last; ++_First)
			append((size_type)1, (_Elem)*_First);
		} if (0) {
		_Tidy(true);
		;
		}}
		}





	basic_string(const_pointer _First, const_pointer _Last)
		: _Mybase()
		{	// construct from [_First, _Last), const pointers
		;
		_Tidy();
		if (_First != _Last)
			assign(&*_First, _Last - _First);
		}


	basic_string(const_iterator _First, const_iterator _Last)
		: _Mybase()
		{	// construct from [_First, _Last), const_iterators
		;
		_Tidy();
		if (_First != _Last)
			assign(&*_First, _Last - _First);
		}

	~basic_string()
		{	// destroy the string
		_Tidy(true);
		}

	typedef _Traits traits_type;
	typedef _Alloc allocator_type;

	static const size_type npos;	// generic bad/missing length/position

	_Myt& operator=(const _Myt& _Right)
		{	// assign _Right
		return (assign(_Right));
		}

	_Myt& operator=(const _Elem *_Ptr)
		{	// assign [_Ptr, <null>)
		return (assign(_Ptr));
		}

	_Myt& operator=(_Elem _Ch)
		{	// assign 1 * _Ch
		return (assign(1, _Ch));
		}

	_Myt& operator+=(const _Myt& _Right)
		{	// append _Right
		return (append(_Right));
		}

	_Myt& operator+=(const _Elem *_Ptr)
		{	// append [_Ptr, <null>)
		return (append(_Ptr));
		}

	_Myt& operator+=(_Elem _Ch)
		{	// append 1 * _Ch
		return (append((size_type)1, _Ch));
		}

	_Myt& append(const _Myt& _Right)
		{	// append _Right
		return (append(_Right, 0, npos));
		}

	_Myt& append(const _Myt& _Right,
		size_type _Roff, size_type _Count)
		{	// append _Right [_Roff, _Roff + _Count)
		if (_Right.size() < _Roff)
			_String_base::_Xran();	// _Roff off end
		size_type _Num = _Right.size() - _Roff;
		if (_Num < _Count)
			_Count = _Num;	// trim _Count to size
		if (npos - _Mysize <= _Count)
			_String_base::_Xlen();	// result too long

		if (0 < _Count && _Grow(_Num = _Mysize + _Count))
			{	// make room and append new stuff
			_Traits::copy(_Myptr() + _Mysize,
				_Right._Myptr() + _Roff, _Count);
			_Eos(_Num);
			}
		return (*this);
		}

	_Myt& append(const _Elem *_Ptr, size_type _Count)
		{	// append [_Ptr, _Ptr + _Count)
		if (_Inside(_Ptr))
			return (append(*this, _Ptr - _Myptr(), _Count));	// substring
		if (npos - _Mysize <= _Count)
			_String_base::_Xlen();	// result too long

		size_type _Num;
		if (0 < _Count && _Grow(_Num = _Mysize + _Count))
			{	// make room and append new stuff
			_Traits::copy(_Myptr() + _Mysize, _Ptr, _Count);
			_Eos(_Num);
			}
		return (*this);
		}

	_Myt& append(const _Elem *_Ptr)
		{	// append [_Ptr, <null>)
		return (append(_Ptr, _Traits::length(_Ptr)));
		}

	_Myt& append(size_type _Count, _Elem _Ch)
		{	// append _Count * _Ch
		if (npos - _Mysize <= _Count)
			_String_base::_Xlen();	// result too long

		size_type _Num;
		if (0 < _Count && _Grow(_Num = _Mysize + _Count))
			{	// make room and append new stuff using assign
			_Chassign(_Mysize, _Count, _Ch);
			_Eos(_Num);
			}
		return (*this);
		}

	template<class _It>
		_Myt& append(_It _First, _It _Last)
		{	// append [_First, _Last)
		return (_Append(_First, _Last, _Iter_cat(_First)));
		}

	template<class _It>
		_Myt& _Append(_It _Count, _It _Ch, _Int_iterator_tag)
		{	// append _Count * _Ch
		return (append((size_type)_Count, (_Elem)_Ch));
		}

	template<class _It>
		_Myt& _Append(_It _First, _It _Last, input_iterator_tag)
		{	// append [_First, _Last), input iterators
		return (replace(end(), end(), _First, _Last));
		}





	_Myt& append(const_pointer _First, const_pointer _Last)
		{	// append [_First, _Last), const pointers
		return (replace(end(), end(), _First, _Last));
		}


	_Myt& append(const_iterator _First, const_iterator _Last)
		{	// append [_First, _Last), const_iterators
		return (replace(end(), end(), _First, _Last));
		}

	_Myt& assign(const _Myt& _Right)
		{	// assign _Right
		return (assign(_Right, 0, npos));
		}

	_Myt& assign(const _Myt& _Right,
		size_type _Roff, size_type _Count)
		{	// assign _Right [_Roff, _Roff + _Count)
		if (_Right.size() < _Roff)
			_String_base::_Xran();	// _Roff off end
		size_type _Num = _Right.size() - _Roff;
		if (_Count < _Num)
			_Num = _Count;	// trim _Num to size

		if (this == &_Right)
			erase((size_type)(_Roff + _Num)), erase(0, _Roff);	// substring
		else if (_Grow(_Num))
			{	// make room and assign new stuff
			_Traits::copy(_Myptr(), _Right._Myptr() + _Roff, _Num);
			_Eos(_Num);
			}
		return (*this);
		}

	_Myt& assign(const _Elem *_Ptr, size_type _Num)
		{	// assign [_Ptr, _Ptr + _Num)
		if (_Inside(_Ptr))
			return (assign(*this, _Ptr - _Myptr(), _Num));	// substring

		if (_Grow(_Num))
			{	// make room and assign new stuff
			_Traits::copy(_Myptr(), _Ptr, _Num);
			_Eos(_Num);
			}
		return (*this);
		}

	_Myt& assign(const _Elem *_Ptr)
		{	// assign [_Ptr, <null>)
		return (assign(_Ptr, _Traits::length(_Ptr)));
		}

	_Myt& assign(size_type _Count, _Elem _Ch)
		{	// assign _Count * _Ch
		if (_Count == npos)
			_String_base::_Xlen();	// result too long

		if (_Grow(_Count))
			{	// make room and assign new stuff
			_Chassign(0, _Count, _Ch);
			_Eos(_Count);
			}
		return (*this);
		}

	template<class _It>
		_Myt& assign(_It _First, _It _Last)
		{	// assign [First, _Last)
		return (_Assign(_First, _Last, _Iter_cat(_First)));
		}

	template<class _It>
		_Myt& _Assign(_It _Count, _It _Ch, _Int_iterator_tag)
		{	// assign _Count * _Ch
		return (assign((size_type)_Count, (_Elem)_Ch));
		}

	template<class _It>
		_Myt& _Assign(_It _First, _It _Last, input_iterator_tag)
		{	// assign [First, _Last), input iterators
		return (replace(begin(), end(), _First, _Last));
		}





	_Myt& assign(const_pointer _First, const_pointer _Last)
		{	// assign [First, _Last), const pointers
		return (replace(begin(), end(), _First, _Last));
		}


	_Myt& assign(const_iterator _First, const_iterator _Last)
		{	// assign [First, _Last), const_iterators
		return (replace(begin(), end(), _First, _Last));
		}

	_Myt& insert(size_type _Off, const _Myt& _Right)
		{	// insert _Right at _Off
		return (insert(_Off, _Right, 0, npos));
		}

	_Myt& insert(size_type _Off,
		const _Myt& _Right, size_type _Roff, size_type _Count)
		{	// insert _Right [_Roff, _Roff + _Count) at _Off
		if (_Mysize < _Off || _Right.size() < _Roff)
			_String_base::_Xran();	// _Off or _Roff off end
		size_type _Num = _Right.size() - _Roff;
		if (_Num < _Count)
			_Count = _Num;	// trim _Count to size
		if (npos - _Mysize <= _Count)
			_String_base::_Xlen();	// result too long

		if (0 < _Count && _Grow(_Num = _Mysize + _Count))
			{	// make room and insert new stuff
			_Traits::move(_Myptr() + _Off + _Count,
				_Myptr() + _Off, _Mysize - _Off);	// empty out hole
			if (this == &_Right)
				_Traits::move(_Myptr() + _Off,
					_Myptr() + (_Off < _Roff ? _Roff + _Count : _Roff),
						_Count);	// substring
			else
				_Traits::copy(_Myptr() + _Off,
					_Right._Myptr() + _Roff, _Count);	// fill hole
			_Eos(_Num);
			}
		return (*this);
		}

	_Myt& insert(size_type _Off,
		const _Elem *_Ptr, size_type _Count)
		{	// insert [_Ptr, _Ptr + _Count) at _Off
		if (_Inside(_Ptr))
			return (insert(_Off, *this,
				_Ptr - _Myptr(), _Count));	// substring
		if (_Mysize < _Off)
			_String_base::_Xran();	// _Off off end
		if (npos - _Mysize <= _Count)
			_String_base::_Xlen();	// result too long
		size_type _Num;
		if (0 < _Count && _Grow(_Num = _Mysize + _Count))
			{	// make room and insert new stuff
			_Traits::move(_Myptr() + _Off + _Count,
				_Myptr() + _Off, _Mysize - _Off);	// empty out hole
			_Traits::copy(_Myptr() + _Off, _Ptr, _Count);	// fill hole
			_Eos(_Num);
			}
		return (*this);
		}

	_Myt& insert(size_type _Off, const _Elem *_Ptr)
		{	// insert [_Ptr, <null>) at _Off
		return (insert(_Off, _Ptr, _Traits::length(_Ptr)));
		}

	_Myt& insert(size_type _Off,
		size_type _Count, _Elem _Ch)
		{	// insert _Count * _Ch at _Off
		if (_Mysize < _Off)
			_String_base::_Xran();	// _Off off end
		if (npos - _Mysize <= _Count)
			_String_base::_Xlen();	// result too long
		size_type _Num;
		if (0 < _Count && _Grow(_Num = _Mysize + _Count))
			{	// make room and insert new stuff
			_Traits::move(_Myptr() + _Off + _Count,
				_Myptr() + _Off, _Mysize - _Off);	// empty out hole
			_Chassign(_Off, _Count, _Ch);	// fill hole
			_Eos(_Num);
			}
		return (*this);
		}

	iterator insert(iterator _Where)
		{	// insert <null> at _Where
		return (insert(_Where, _Elem()));
		}

	iterator insert(iterator _Where, _Elem _Ch)
		{	// insert _Ch at _Where
		size_type _Off = _Pdif(_Where, begin());
		insert(_Off, 1, _Ch);
		return (begin() + _Off);
		}

	void insert(iterator _Where, size_type _Count, _Elem _Ch)
		{	// insert _Count * _Elem at _Where
		size_type _Off = _Pdif(_Where, begin());
		insert(_Off, _Count, _Ch);
		}

	template<class _It>
		void insert(iterator _Where, _It _First, _It _Last)
		{	// insert [_First, _Last) at _Where
		_Insert(_Where, _First, _Last, _Iter_cat(_First));
		}

	template<class _It>
		void _Insert(iterator _Where, _It _Count, _It _Ch,
			_Int_iterator_tag)
		{	// insert _Count * _Ch at _Where
		insert(_Where, (size_type)_Count, (_Elem)_Ch);
		}

	template<class _It>
		void _Insert(iterator _Where, _It _First, _It _Last,
			input_iterator_tag)
		{	// insert [_First, _Last) at _Where, input iterators
		replace(_Where, _Where, _First, _Last);
		}





	void insert(iterator _Where, const_pointer _First, const_pointer _Last)
		{	// insert [_First, _Last) at _Where, const pointers
		replace(_Where, _Where, _First, _Last);
		}


	void insert(iterator _Where, const_iterator _First, const_iterator _Last)
		{	// insert [_First, _Last) at _Where, const_iterators
		replace(_Where, _Where, _First, _Last);
		}

	_Myt& erase(size_type _Off = 0,
		size_type _Count = npos)
		{	// erase elements [_Off, _Off + _Count)
		if (_Mysize < _Off)
			_String_base::_Xran();	// _Off off end
		if (_Mysize - _Off < _Count)
			_Count = _Mysize - _Off;	// trim _Count
		if (0 < _Count)
			{	// move elements down
			_Traits::move(_Myptr() + _Off, _Myptr() + _Off + _Count,
				_Mysize - _Off - _Count);
			size_type _Newsize = _Mysize - _Count;
			_Eos(_Newsize);
			}
		return (*this);
		}

	iterator erase(iterator _Where)
		{	// erase element at _Where
		size_type _Count = _Pdif(_Where, begin());
		erase(_Count, 1);
		return (iterator(_Myptr() + _Count));
		}

	iterator erase(iterator _First, iterator _Last)
		{	// erase substring [_First, _Last)
		size_type _Count = _Pdif(_First, begin());
		erase(_Count, _Pdif(_Last, _First));
		return (iterator(_Myptr() + _Count));
		}

	void clear()
		{	// erase all
		erase(begin(), end());
		}

	_Myt& replace(size_type _Off, size_type _N0, const _Myt& _Right)
		{	// replace [_Off, _Off + _N0) with _Right
		return (replace(_Off, _N0, _Right, 0, npos));
		}

	_Myt& replace(size_type _Off,
		size_type _N0, const _Myt& _Right, size_type _Roff, size_type _Count)
		{	// replace [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
		if (_Mysize < _Off || _Right.size() < _Roff)
			_String_base::_Xran();	// _Off or _Roff off end
		if (_Mysize - _Off < _N0)
			_N0 = _Mysize - _Off;	// trim _N0 to size
		size_type _Num = _Right.size() - _Roff;
		if (_Num < _Count)
			_Count = _Num;	// trim _Count to size
		if (npos - _Count <= _Mysize - _N0)
			_String_base::_Xlen();	// result too long

		size_type _Nm = _Mysize - _N0 - _Off;	// length of preserved tail
		size_type _Newsize = _Mysize + _Count - _N0;
		if (_Mysize < _Newsize)
			_Grow(_Newsize);

		if (this != &_Right)
			{	// no overlap, just move down and copy in new stuff
			_Traits::move(_Myptr() + _Off + _Count,
				_Myptr() + _Off + _N0, _Nm);	// empty hole
			_Traits::copy(_Myptr() + _Off,
				_Right._Myptr() + _Roff, _Count);	// fill hole
			}
		else if (_Count <= _N0)
			{	// hole doesn't get larger, just copy in substring
			_Traits::move(_Myptr() + _Off,
				_Myptr() + _Roff, _Count);	// fill hole
			_Traits::move(_Myptr() + _Off + _Count,
				_Myptr() + _Off + _N0, _Nm);	// move tail down
			}
		else if (_Roff <= _Off)
			{	// hole gets larger, substring begins before hole
			_Traits::move(_Myptr() + _Off + _Count,
				_Myptr() + _Off + _N0, _Nm);	// move tail down
			_Traits::move(_Myptr() + _Off,
				_Myptr() + _Roff, _Count);	// fill hole
			}
		else if (_Off + _N0 <= _Roff)
			{	// hole gets larger, substring begins after hole
			_Traits::move(_Myptr() + _Off + _Count,
				_Myptr() + _Off + _N0, _Nm);	// move tail down
			_Traits::move(_Myptr() + _Off,
				_Myptr() + (_Roff + _Count - _N0), _Count);	// fill hole
			}
		else
			{	// hole gets larger, substring begins in hole
			_Traits::move(_Myptr() + _Off,
				_Myptr() + _Roff, _N0);	// fill old hole
			_Traits::move(_Myptr() + _Off + _Count,
				_Myptr() + _Off + _N0, _Nm);	// move tail down
			_Traits::move(_Myptr() + _Off + _N0, _Myptr() + _Roff + _Count,
				_Count - _N0);	// fill rest of new hole
			}

		_Eos(_Newsize);
		return (*this);
		}

	_Myt& replace(size_type _Off,
		size_type _N0, const _Elem *_Ptr, size_type _Count)
		{	// replace [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
		if (_Inside(_Ptr))
			return (replace(_Off, _N0, *this,
				_Ptr - _Myptr(), _Count));	// substring, replace carefully
		if (_Mysize < _Off)
			_String_base::_Xran();	// _Off off end
		if (_Mysize - _Off < _N0)
			_N0 = _Mysize - _Off;	// trim _N0 to size
		if (npos - _Count <= _Mysize - _N0)
			_String_base::_Xlen();	// result too long
		size_type _Nm = _Mysize - _N0 - _Off;

		if (_Count < _N0)
			_Traits::move(_Myptr() + _Off + _Count,
				_Myptr() + _Off + _N0, _Nm);	// smaller hole, move tail up
		size_type _Num;
		if ((0 < _Count || 0 < _N0) && _Grow(_Num = _Mysize + _Count - _N0))
			{	// make room and rearrange
			if (_N0 < _Count)
				_Traits::move(_Myptr() + _Off + _Count,
					_Myptr() + _Off + _N0, _Nm);	// move tail down
			_Traits::copy(_Myptr() + _Off, _Ptr, _Count);	// fill hole
			_Eos(_Num);
			}
		return (*this);
		}

	_Myt& replace(size_type _Off, size_type _N0, const _Elem *_Ptr)
		{	// replace [_Off, _Off + _N0) with [_Ptr, <null>)
		return (replace(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
		}

	_Myt& replace(size_type _Off,
		size_type _N0, size_type _Count, _Elem _Ch)
		{	// replace [_Off, _Off + _N0) with _Count * _Ch
		if (_Mysize < _Off)
			_String_base::_Xran();	// _Off off end
		if (_Mysize - _Off < _N0)
			_N0 = _Mysize - _Off;	// trim _N0 to size
		if (npos - _Count <= _Mysize - _N0)
			_String_base::_Xlen();	// result too long
		size_type _Nm = _Mysize - _N0 - _Off;

		if (_Count < _N0)
			_Traits::move(_Myptr() + _Off + _Count,
				_Myptr() + _Off + _N0, _Nm);	// smaller hole, move tail up
		size_type _Num;
		if ((0 < _Count || 0 < _N0) && _Grow(_Num = _Mysize + _Count - _N0))
			{	// make room and rearrange
			if (_N0 < _Count)
				_Traits::move(_Myptr() + _Off + _Count,
					_Myptr() + _Off + _N0, _Nm);	// move tail down
			_Chassign(_Off, _Count, _Ch);	// fill hole
			_Eos(_Num);
			}
		return (*this);
		}

	_Myt& replace(iterator _First, iterator _Last, const _Myt& _Right)
		{	// replace [_First, _Last) with _Right
		return (replace(
			_Pdif(_First, begin()), _Pdif(_Last, _First), _Right));
		}

	_Myt& replace(iterator _First, iterator _Last, const _Elem *_Ptr,
		size_type _Count)
		{	// replace [_First, _Last) with [_Ptr, _Ptr + _Count)
		return (replace(
			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr, _Count));
		}

	_Myt& replace(iterator _First, iterator _Last, const _Elem *_Ptr)
		{	// replace [_First, _Last) with [_Ptr, <null>)
		return (replace(
			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr));
		}

	_Myt& replace(iterator _First, iterator _Last,
		size_type _Count, _Elem _Ch)
		{	// replace [_First, _Last) with _Count * _Ch
		return (replace(
			_Pdif(_First, begin()), _Pdif(_Last, _First), _Count, _Ch));
		}

	template<class _It>
		_Myt& replace(iterator _First, iterator _Last,
			_It _First2, _It _Last2)
		{	// replace [_First, _Last) with [_First2, _Last2)
		return (_Replace(_First, _Last,
			_First2, _Last2, _Iter_cat(_First2)));
		}

	template<class _It>
		_Myt& _Replace(iterator _First, iterator _Last,
			_It _Count, _It _Ch, _Int_iterator_tag)
		{	// replace [_First, _Last) with _Count * _Ch
		return (replace(_First, _Last, (size_type)_Count, (_Elem)_Ch));
		}

	template<class _It>
		_Myt& _Replace(iterator _First, iterator _Last,
			_It _First2, _It _Last2, input_iterator_tag)
		{	// replace [_First, _Last) with [_First2, _Last2), input iterators
		_Myt _Right(_First2, _Last2);
		replace(_First, _Last, _Right);
		return (*this);
		}





	_Myt& replace(iterator _First, iterator _Last,
		const_pointer _First2, const_pointer _Last2)
		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
		if (_First2 == _Last2)
			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
		else
			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
				&*_First2, _Last2 - _First2);
		return (*this);
		}


	_Myt& replace(iterator _First, iterator _Last,
		const_iterator _First2, const_iterator _Last2)
		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
		if (_First2 == _Last2)
			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
		else
			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
				&*_First2, _Last2 - _First2);
		return (*this);
		}

	iterator begin()
		{	// return iterator for beginning of mutable sequence
		return (iterator(_Myptr()));
		}

	const_iterator begin() const
		{	// return iterator for beginning of nonmutable sequence
		return (const_iterator(_Myptr()));
		}

	iterator end()
		{	// return iterator for end of mutable sequence
		return (iterator(_Myptr() + _Mysize));
		}

	const_iterator end() const
		{	// return iterator for end of nonmutable sequence
		return (const_iterator(_Myptr() + _Mysize));
		}

	reverse_iterator rbegin()
		{	// return iterator for beginning of reversed mutable sequence
		return (reverse_iterator(end()));
		}

	const_reverse_iterator rbegin() const
		{	// return iterator for beginning of reversed nonmutable sequence
		return (const_reverse_iterator(end()));
		}

	reverse_iterator rend()
		{	// return iterator for end of reversed mutable sequence
		return (reverse_iterator(begin()));
		}

	const_reverse_iterator rend() const
		{	// return iterator for end of reversed nonmutable sequence
		return (const_reverse_iterator(begin()));
		}

	reference at(size_type _Off)
		{	// subscript mutable sequence with checking
		if (_Mysize <= _Off)
			_String_base::_Xran();	// _Off off end
		return (_Myptr()[_Off]);
		}

	const_reference at(size_type _Off) const
		{	// subscript nonmutable sequence with checking
		if (_Mysize <= _Off)
			_String_base::_Xran();	// _Off off end
		return (_Myptr()[_Off]);
		}

	reference operator[](size_type _Off)
		{	// subscript mutable sequence






		return (_Myptr()[_Off]);
		}

	const_reference operator[](size_type _Off) const
		{	// subscript nonmutable sequence






		return (_Myptr()[_Off]);
		}

	void push_back(_Elem _Ch)
		{	// insert element at end
		insert(end(), _Ch);
		}

	const _Elem *c_str() const
		{	// return pointer to null-terminated nonmutable array
		return (_Myptr());
		}

	const _Elem *data() const
		{	// return pointer to nonmutable array
		return (c_str());
		}

	size_type length() const
		{	// return length of sequence
		return (_Mysize);
		}

	size_type size() const
		{	// return length of sequence
		return (_Mysize);
		}

	size_type max_size() const
		{	// return maximum possible length of sequence
		size_type _Num = _Mybase::_Alval.max_size();
		return (_Num <= 1 ? 1 : _Num - 1);
		}

	void resize(size_type _Newsize)
		{	// determine new length, padding with null elements as needed
		resize(_Newsize, _Elem());
		}

	void resize(size_type _Newsize, _Elem _Ch)
		{	// determine new length, padding with _Ch elements as needed
		if (_Newsize <= _Mysize)
			erase(_Newsize);
		else
			append(_Newsize - _Mysize, _Ch);
		}

	size_type capacity() const
		{	// return current length of allocated storage
		return (_Myres);
		}

	void reserve(size_type _Newcap = 0)
		{	// determine new minimum length of allocated storage
		if (_Mysize <= _Newcap && _Myres != _Newcap)
			{	// change reservation
			size_type _Size = _Mysize;
			if (_Grow(_Newcap, true))
				_Eos(_Size);
			}
		}

	bool empty() const
		{	// test if sequence is empty
		return (_Mysize == 0);
		}

	size_type copy(_Elem *_Ptr,
		size_type _Count, size_type _Off = 0) const
		{	// copy [_Off, _Off + _Count) to [_Ptr, _Ptr + _Count)
		;
		if (_Mysize < _Off)
			_String_base::_Xran();	// _Off off end
		if (_Mysize - _Off < _Count)
			_Count = _Mysize - _Off;
		_Traits::copy(_Ptr, _Myptr() + _Off, _Count);
		return (_Count);
		}

	void swap(_Myt& _Right)
		{	// exchange contents with _Right
		if (_Mybase::_Alval == _Right._Alval)
			{	// same allocator, swap control information





			_Bxty _Tbx = _Bx;
			_Bx = _Right._Bx, _Right._Bx = _Tbx;

			size_type _Tlen = _Mysize;
			_Mysize = _Right._Mysize, _Right._Mysize = _Tlen;

			size_type _Tres = _Myres;
			_Myres = _Right._Myres, _Right._Myres = _Tres;
			}
		else
			{	// different allocator, do multiple assigns
			_Myt _Tmp = *this; *this = _Right, _Right = _Tmp;
			}
		}

	size_type find(const _Myt& _Right, size_type _Off = 0) const
		{	// look for _Right beginnng at or after _Off
		return (find(_Right._Myptr(), _Off, _Right.size()));
		}

	size_type find(const _Elem *_Ptr,
		size_type _Off, size_type _Count) const
		{	// look for [_Ptr, _Ptr + _Count) beginnng at or after _Off
		;
		if (_Count == 0 && _Off <= _Mysize)
			return (_Off);	// null string always matches (if inside string)

		size_type _Nm;
		if (_Off < _Mysize && _Count <= (_Nm = _Mysize - _Off))
			{	// room for match, look for it
			const _Elem *_Uptr, *_Vptr;
			for (_Nm -= _Count - 1, _Vptr = _Myptr() + _Off;
				(_Uptr = _Traits::find(_Vptr, _Nm, *_Ptr)) != 0;
				_Nm -= _Uptr - _Vptr + 1, _Vptr = _Uptr + 1)
				if (_Traits::compare(_Uptr, _Ptr, _Count) == 0)
					return (_Uptr - _Myptr());	// found a match
			}

		return (npos);	// no match
		}

	size_type find(const _Elem *_Ptr, size_type _Off = 0) const
		{	// look for [_Ptr, <null>) beginnng at or after _Off
		return (find(_Ptr, _Off, _Traits::length(_Ptr)));
		}

	size_type find(_Elem _Ch, size_type _Off = 0) const
		{	// look for _Ch at or after _Off
		return (find((const _Elem *)&_Ch, _Off, 1));
		}

	size_type rfind(const _Myt& _Right, size_type _Off = npos) const
		{	// look for _Right beginning before _Off
		return (rfind(_Right._Myptr(), _Off, _Right.size()));
		}

	size_type rfind(const _Elem *_Ptr,
		size_type _Off, size_type _Count) const
		{	// look for [_Ptr, _Ptr + _Count) beginning before _Off
		;
		if (_Count == 0)
			return (_Off < _Mysize ? _Off : _Mysize);	// null always matches
		if (_Count <= _Mysize)
			{	// room for match, look for it
			const _Elem *_Uptr = _Myptr() +
				(_Off < _Mysize - _Count ? _Off : _Mysize - _Count);
			for (; ; --_Uptr)
				if (_Traits::eq(*_Uptr, *_Ptr)
					&& _Traits::compare(_Uptr, _Ptr, _Count) == 0)
					return (_Uptr - _Myptr());	// found a match
				else if (_Uptr == _Myptr())
					break;	// at beginning, no more chance for match
			}

		return (npos);	// no match
		}

	size_type rfind(const _Elem *_Ptr, size_type _Off = npos) const
		{	// look for [_Ptr, <null>) beginning before _Off
		return (rfind(_Ptr, _Off, _Traits::length(_Ptr)));
		}

	size_type rfind(_Elem _Ch, size_type _Off = npos) const
		{	// look for _Ch before _Off
		return (rfind((const _Elem *)&_Ch, _Off, 1));
		}

	size_type find_first_of(const _Myt& _Right,
		size_type _Off = 0) const
		{	// look for one of _Right at or after _Off
		return (find_first_of(_Right._Myptr(), _Off, _Right.size()));
		}

	size_type find_first_of(const _Elem *_Ptr,
		size_type _Off, size_type _Count) const
		{	// look for one of [_Ptr, _Ptr + _Count) at or after _Off
		;
		if (0 < _Count && _Off < _Mysize)
			{	// room for match, look for it
			const _Elem *const _Vptr = _Myptr() + _Mysize;
			for (const _Elem *_Uptr = _Myptr() + _Off; _Uptr < _Vptr; ++_Uptr)
				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
					return (_Uptr - _Myptr());	// found a match
			}

		return (npos);	// no match
		}

	size_type find_first_of(const _Elem *_Ptr, size_type _Off = 0) const
		{	// look for one of [_Ptr, <null>) at or after _Off
		return (find_first_of(_Ptr, _Off, _Traits::length(_Ptr)));
		}

	size_type find_first_of(_Elem _Ch, size_type _Off = 0) const
		{	// look for _Ch at or after _Off
		return (find((const _Elem *)&_Ch, _Off, 1));
		}

	size_type find_last_of(const _Myt& _Right,
		size_type _Off = npos) const
		{	// look for one of _Right before _Off
		return (find_last_of(_Right._Myptr(), _Off, _Right.size()));
		}

	size_type find_last_of(const _Elem *_Ptr,
		size_type _Off, size_type _Count) const
		{	// look for one of [_Ptr, _Ptr + _Count) before _Off
		;
		if (0 < _Count && 0 < _Mysize)
			for (const _Elem *_Uptr = _Myptr()
				+ (_Off < _Mysize ? _Off : _Mysize - 1); ; --_Uptr)
				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
					return (_Uptr - _Myptr());	// found a match
				else if (_Uptr == _Myptr())
					break;	// at beginning, no more chance for match

		return (npos);	// no match
		}

	size_type find_last_of(const _Elem *_Ptr,
		size_type _Off = npos) const
		{	// look for one of [_Ptr, <null>) before _Off
		return (find_last_of(_Ptr, _Off, _Traits::length(_Ptr)));
		}

	size_type find_last_of(_Elem _Ch, size_type _Off = npos) const
		{	// look for _Ch before _Off
		return (rfind((const _Elem *)&_Ch, _Off, 1));
		}

	size_type find_first_not_of(const _Myt& _Right,
		size_type _Off = 0) const
		{	// look for none of _Right at or after _Off
		return (find_first_not_of(_Right._Myptr(), _Off,
			_Right.size()));
		}

	size_type find_first_not_of(const _Elem *_Ptr,
		size_type _Off, size_type _Count) const
		{	// look for none of [_Ptr, _Ptr + _Count) at or after _Off
		;
		if (_Off < _Mysize)
			{	// room for match, look for it
			const _Elem *const _Vptr = _Myptr() + _Mysize;
			for (const _Elem *_Uptr = _Myptr() + _Off; _Uptr < _Vptr; ++_Uptr)
				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
					return (_Uptr - _Myptr());
			}
		return (npos);
		}

	size_type find_first_not_of(const _Elem *_Ptr,
		size_type _Off = 0) const
		{	// look for one of [_Ptr, <null>) at or after _Off
		return (find_first_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
		}

	size_type find_first_not_of(_Elem _Ch, size_type _Off = 0) const
		{	// look for non _Ch at or after _Off
		return (find_first_not_of((const _Elem *)&_Ch, _Off, 1));
		}

	size_type find_last_not_of(const _Myt& _Right,
		size_type _Off = npos) const
		{	// look for none of _Right before _Off
		return (find_last_not_of(_Right._Myptr(), _Off, _Right.size()));
		}

	size_type find_last_not_of(const _Elem *_Ptr,
		size_type _Off, size_type _Count) const
		{	// look for none of [_Ptr, _Ptr + _Count) before _Off
		;
		if (0 < _Mysize)
			for (const _Elem *_Uptr = _Myptr()
				+ (_Off < _Mysize ? _Off : _Mysize - 1); ; --_Uptr)
				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
					return (_Uptr - _Myptr());
				else if (_Uptr == _Myptr())
					break;
		return (npos);
		}

	size_type find_last_not_of(const _Elem *_Ptr,
		size_type _Off = npos) const
		{	// look for none of [_Ptr, <null>) before _Off
		return (find_last_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
		}

	size_type find_last_not_of(_Elem _Ch, size_type _Off = npos) const
		{	// look for non _Ch before _Off
		return (find_last_not_of((const _Elem *)&_Ch, _Off, 1));
		}

	_Myt substr(size_type _Off = 0, size_type _Count = npos) const
		{	// return [_Off, _Off + _Count) as new string
		return (_Myt(*this, _Off, _Count));
		}

	int compare(const _Myt& _Right) const
		{	// compare [0, _Mysize) with _Right
		return (compare(0, _Mysize, _Right._Myptr(), _Right.size()));
		}

	int compare(size_type _Off, size_type _N0,
		const _Myt& _Right) const
		{	// compare [_Off, _Off + _N0) with _Right
		return (compare(_Off, _N0, _Right, 0, npos));
		}

	int compare(size_type _Off,
		size_type _N0, const _Myt& _Right,
		size_type _Roff, size_type _Count) const
		{	// compare [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
		if (_Right.size() < _Roff)
			_String_base::_Xran();	// _Off off end
		if (_Right._Mysize - _Roff < _Count)
			_Count = _Right._Mysize - _Roff;	// trim _Count to size
		return (compare(_Off, _N0, _Right._Myptr() + _Roff, _Count));
		}

	int compare(const _Elem *_Ptr) const
		{	// compare [0, _Mysize) with [_Ptr, <null>)
		return (compare(0, _Mysize, _Ptr, _Traits::length(_Ptr)));
		}

	int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
		{	// compare [_Off, _Off + _N0) with [_Ptr, <null>)
		return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
		}

	int compare(size_type _Off,
		size_type _N0, const _Elem *_Ptr, size_type _Count) const
		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
		;
		if (_Mysize < _Off)
			_String_base::_Xran();	// _Off off end
		if (_Mysize - _Off < _N0)
			_N0 = _Mysize - _Off;	// trim _N0 to size

		size_type _Ans = _N0 == 0 ? 0
			: _Traits::compare(_Myptr() + _Off, _Ptr,
				_N0 < _Count ? _N0 : _Count);
		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
			: _N0 == _Count ? 0 : +1);
		}

	allocator_type get_allocator() const
		{	// return allocator object for values
		return (_Mybase::_Alval);
		}

	enum
		{	// length of internal buffer, [1, 16]
		_BUF_SIZE = 16 / sizeof (_Elem) < 1 ? 1
			: 16 / sizeof(_Elem)};

protected:
	enum
		{	// roundup mask for allocated buffers, [0, 15]
		_ALLOC_MASK = sizeof (_Elem) <= 1 ? 15
			: sizeof (_Elem) <= 2 ? 7
			: sizeof (_Elem) <= 4 ? 3
			: sizeof (_Elem) <= 8 ? 1 : 0};

	void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
		{	// assign _Count copies of _Ch beginning at _Off 
		if (_Count == 1)
			_Traits::assign(*(_Myptr() + _Off), _Ch);
		else
			_Traits::assign(_Myptr() + _Off, _Count, _Ch);
		}

	void _Copy(size_type _Newsize, size_type _Oldlen)
		{	// copy _Oldlen elements to newly allocated buffer
		size_type _Newres = _Newsize | _ALLOC_MASK;
		if (max_size() < _Newres)
			_Newres = _Newsize;	// undo roundup if too big
		else if (_Newres / 3 < _Myres / 2
			&& _Myres <= max_size() - _Myres / 2)
			_Newres = _Myres + _Myres / 2;	// grow exponentially if possible
		_Elem *_Ptr;

		{{
			_Ptr = _Mybase::_Alval.allocate(_Newres + 1);
		} if (0) {
			_Newres = _Newsize;	// allocation failed, undo roundup and retry
			{{
				_Ptr = _Mybase::_Alval.allocate(_Newres + 1);
			} if (0) {
			_Tidy(true);	// failed again, discard storage and reraise
			;
			}}
		}}

		if (0 < _Oldlen)
			_Traits::copy(_Ptr, _Myptr(), _Oldlen);	// copy existing elements
		_Tidy(true);
		_Bx._Ptr = _Ptr;
		_Myres = _Newres;
		_Eos(_Oldlen);
		}

	void _Eos(size_type _Newsize)
		{	// set new length and null terminator
		_Traits::assign(_Myptr()[_Mysize = _Newsize], _Elem());
		}

	bool _Grow(size_type _Newsize,
		bool _Trim = false)
		{	// ensure buffer is big enough, trim to size if _Trim is true
		if (max_size() < _Newsize)
			_String_base::_Xlen();	// result too long
		if (_Myres < _Newsize)
			_Copy(_Newsize, _Mysize);	// reallocate to grow
		else if (_Trim && _Newsize < _BUF_SIZE)
			_Tidy(true,	// copy and deallocate if trimming to small string
				_Newsize < _Mysize ? _Newsize : _Mysize);
		else if (_Newsize == 0)
			_Eos(0);	// new size is zero, just null terminate
		return (0 < _Newsize);	// return true only if more work to do
		}

	bool _Inside(const _Elem *_Ptr)
		{	// test if _Ptr points inside string
		;
		if (_Ptr < _Myptr() || _Myptr() + _Mysize <= _Ptr)
			return (false);	// don't ask
		else
			return (true);
		}

	static size_type _Pdif(const_iterator _P2,
		const_iterator _P1)
		{	// compute safe iterator difference
		return ((_P2). _Myptr == 0 ? 0 : _P2 - _P1);
		}

	void _Tidy(bool _Built = false,
		size_type _Newsize = 0)
		{	// initialize buffer, deallocating any storage
		if (!_Built)
			;
		else if (_BUF_SIZE <= _Myres)
			{	// copy any leftovers to small buffer and deallocate
			_Elem *_Ptr = _Bx._Ptr;
			if (0 < _Newsize)
				_Traits::copy(_Bx._Buf, _Ptr, _Newsize);
			_Mybase::_Alval.deallocate(_Ptr, _Myres + 1);
			}
		_Myres = _BUF_SIZE - 1;
		_Eos(_Newsize);
		}

	union _Bxty
		{	// storage for small buffer or pointer to larger one
		_Elem _Buf[_BUF_SIZE];
		_Elem *_Ptr;
		} _Bx;

	_Elem *_Myptr()
		{	// determine current pointer to buffer for mutable string
		return (_BUF_SIZE <= _Myres ? _Bx._Ptr : _Bx._Buf);
		}

	const _Elem *_Myptr() const
		{	// determine current pointer to buffer for nonmutable string
		return (_BUF_SIZE <= _Myres ? _Bx._Ptr : _Bx._Buf);
		}

	size_type _Mysize;	// current length of string
	size_type _Myres;	// current storage reserved for string
	};


		// STATIC npos OBJECT
template<class _Elem,
	class _Traits,
	class _Alloc>
	const typename basic_string<_Elem, _Traits, _Alloc>::size_type
		basic_string<_Elem, _Traits, _Alloc>::npos =
			(typename basic_string<_Elem, _Traits, _Alloc>::size_type)(-1);

		// basic_string TEMPLATE OPERATORS
template<class _Elem,
	class _Traits,
	class _Alloc> inline
	void swap(basic_string<_Elem, _Traits, _Alloc>& _Left,
		basic_string<_Elem, _Traits, _Alloc>& _Right)
	{	// swap _Left and _Right strings
	_Left.swap(_Right);
	}

typedef basic_string<char, char_traits<char>, allocator<char> >
	string;
typedef basic_string<wchar_t, char_traits<wchar_t>,
	allocator<wchar_t> > wstring;

# 1747 "C:/usr/local/cell\\target\\ppu\\include/xstring" 3
}


/*
 * Copyright (c) 1992-2003 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
V4.02:0216 */
# 6 "C:/usr/local/cell\\target\\ppu\\include/stdexcept" 3
namespace std {





		// CLASS logic_error
class logic_error
	: public ::std:: exception
	{	// base of all logic-error exceptions
public:
	explicit logic_error(const string& _Message)
		: _Str(_Message)
		{	// construct from message string
		}

	virtual ~logic_error()
		{	// destroy the object
		}

	virtual const char *what() const 
		{	// return pointer to message string
		return (_Str.c_str());
		}





protected:
	virtual void _Doraise() const
		{	// perform class-specific exception handling
		::std:: _Throw(*this);
		}


private:
	string _Str;	// the stored message string
	};

		// CLASS domain_error
class domain_error
	: public logic_error
	{	// base of all domain-error exceptions
public:
	explicit domain_error(const string& _Message)
		: logic_error(_Message)
		{	// construct from message string
		}

	virtual ~domain_error()
		{	// destroy the object
		}





protected:
	virtual void _Doraise() const
		{	// perform class-specific exception handling
		::std:: _Throw(*this);
		}


	};

		// CLASS invalid_argument
class invalid_argument
	: public logic_error
	{	// base of all invalid-argument exceptions
public:
	explicit invalid_argument(const string& _Message)
		: logic_error(_Message)
		{	// construct from message string
		}

	virtual ~invalid_argument()
		{	// destroy the object
		}





protected:
	virtual void _Doraise() const
		{	// perform class-specific exception handling
		::std:: _Throw(*this);
		}


	};

		// CLASS length_error
class length_error
	: public logic_error
	{	// base of all length-error exceptions
public:
	explicit length_error(const string& _Message)
		: logic_error(_Message)
		{	// construct from message string
		}

	virtual ~length_error()
		{	// destroy the object
		}





protected:
	virtual void _Doraise() const
		{	// perform class-specific exception handling
		::std:: _Throw(*this);
		}


	};

		// CLASS out_of_range
class out_of_range
	: public logic_error
	{	// base of all out-of-range exceptions
public:
	explicit out_of_range(const string& _Message)
		: logic_error(_Message)
		{	// construct from message string
		}

	virtual ~out_of_range()
		{	// destroy the object
		}





protected:
	virtual void _Doraise() const
		{	// perform class-specific exception handling
		::std:: _Throw(*this);
		}


	};

		// CLASS runtime_error
class runtime_error
	: public ::std:: exception
	{	// base of all runtime-error exceptions
public:
	explicit runtime_error(const string& _Message)
		: _Str(_Message)
		{	// construct from message string
		}

	virtual ~runtime_error()
		{	// destroy the object
		}

	virtual const char *what() const 
		{	// return pointer to message string
		return (_Str.c_str());
		}





protected:
	virtual void _Doraise() const
		{	// perform class-specific exception handling
		::std:: _Throw(*this);
		}


private:
	string _Str;	// the stored message string
	};

		// CLASS overflow_error
class overflow_error
	: public runtime_error
	{	// base of all overflow-error exceptions
public:
	explicit overflow_error(const string& _Message)
		: runtime_error(_Message)
		{	// construct from message string
		}

	virtual ~overflow_error()
		{	// destroy the object
		}





protected:
	virtual void _Doraise() const
		{	// perform class-specific exception handling
		::std:: _Throw(*this);
		}


	};

		// CLASS underflow_error
class underflow_error
	: public runtime_error
	{	// base of all underflow-error exceptions
public:
	explicit underflow_error(const string& _Message)
		: runtime_error(_Message)
		{	// construct from message string
		}

	virtual ~underflow_error()
		{	// destroy the object
		}





protected:
	virtual void _Doraise() const
		{	// perform class-specific exception handling
		::std:: _Throw(*this);
		}


	};

		// CLASS range_error
class range_error
	: public runtime_error
	{	// base of all range-error exceptions
public:
	explicit range_error(const string& _Message)
		: runtime_error(_Message)
		{	// construct from message string
		}

	virtual ~range_error()
		{	// destroy the object
		}





protected:
	virtual void _Doraise() const
		{	// perform class-specific exception handling
		::std:: _Throw(*this);
		}


	};
}


/*
 * Copyright (c) 1992-2003 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
V4.02:0216 */
# 12 "C:/usr/local/cell\\target\\ppu\\include/list" 3

namespace std {

		// TEMPLATE CLASS _List_nod
template<class _Ty,
	class _Alloc>
	class _List_nod
		: public _Container_base
	{	// base class for _List_ptr to hold allocator _Alnod
protected:
	struct _Node;
	friend struct _Node;





	typedef typename _Alloc::template
		rebind<_Node>::other::pointer _Genptr;


	struct _Node
		{	// list node
		_Genptr _Next;	// successor node, or first element if head
		_Genptr _Prev;	// predecessor node, or last element if head
		_Ty _Myval;	// the stored value, unused if head
		};

	_List_nod(_Alloc _Al)
		: _Alnod(_Al)
		{	// construct allocator from _Al
		}

	typename _Alloc::template rebind<_Node>::other
		_Alnod;	// allocator object for nodes
	};

		// TEMPLATE CLASS _List_ptr
template<class _Ty,
	class _Alloc>
	class _List_ptr
		: public _List_nod<_Ty, _Alloc>
	{	// base class for _List_val to hold allocator _Alptr
protected:
	typedef typename _List_nod<_Ty, _Alloc>::_Node _Node;
	typedef typename _Alloc::template
		rebind<_Node>::other::pointer _Nodeptr;

	_List_ptr(_Alloc _Al)
		: _List_nod<_Ty, _Alloc>(_Al), _Alptr(_Al)
		{	// construct base, and allocator from _Al
		}

	typename _Alloc::template rebind<_Nodeptr>::other
		_Alptr;	// allocator object for pointers to nodes
	};

		// TEMPLATE CLASS _List_val
template<class _Ty,
	class _Alloc>
	class _List_val
		: public _List_ptr<_Ty, _Alloc>
	{	// base class for list to hold allocator _Alval
protected:
	typedef typename _Alloc::template rebind<_Ty>::other _Alty;

	_List_val(_Alloc _Al = _Alloc())
		: _List_ptr<_Ty, _Alloc>(_Al), _Alval(_Al)
		{	// construct base, and allocator from _Al
		}

	_Alty _Alval;	// allocator object for values stored in nodes
	};

		// TEMPLATE CLASS list
template<class _Ty,
	class _Ax = allocator<_Ty> >
	class list
		: public _List_val<_Ty, _Ax>
	{	// bidirectional linked list
public:
	typedef list<_Ty, _Ax> _Myt;
	typedef _List_val<_Ty, _Ax> _Mybase;
	typedef typename _Mybase::_Alty _Alloc;

protected:





	typedef typename _List_nod<_Ty, _Ax>::_Genptr _Genptr;


	typedef typename _List_nod<_Ty, _Ax>::_Node _Node;
	typedef typename _Alloc::template rebind<_Node> ::other::pointer _Nodeptr;
	typedef typename _Alloc::template rebind<_Nodeptr> ::other::reference _Nodepref;
	typedef typename _Alloc::reference _Vref;

	static _Nodepref _Nextnode(_Nodeptr _Pnode)
		{	// return reference to successor pointer in node
		return ((_Nodepref)(*_Pnode)._Next);
		}

	static _Nodepref _Prevnode(_Nodeptr _Pnode)
		{	// return reference to predecessor pointer in node
		return ((_Nodepref)(*_Pnode)._Prev);
		}

	static _Vref _Myval(_Nodeptr _Pnode)
		{	// return reference to value in node
		return ((_Vref)(*_Pnode)._Myval);
		}

public:
	typedef _Alloc allocator_type;
	typedef typename _Alloc::size_type size_type;
	typedef typename _Alloc::difference_type _Dift;
	typedef _Dift difference_type;
	typedef typename _Alloc::pointer _Tptr;
	typedef typename _Alloc::const_pointer _Ctptr;
	typedef _Tptr pointer;
	typedef _Ctptr const_pointer;
	typedef typename _Alloc::reference _Reft;
	typedef _Reft reference;
	typedef typename _Alloc::const_reference const_reference;
	typedef typename _Alloc::value_type value_type;

		// CLASS const_iterator
	class const_iterator;
	friend class const_iterator;

	class const_iterator
		: public _Bidit<_Ty, _Dift, _Ctptr, const_reference>
		{	// iterator for nonmutable list
	public:
		typedef bidirectional_iterator_tag iterator_category;
		typedef _Ty value_type;
		typedef _Dift difference_type;
		typedef _Ctptr pointer;
		typedef const_reference reference;

		const_iterator()
			: _Ptr(0)
			{	// construct with null node pointer
			}

# 167 "C:/usr/local/cell\\target\\ppu\\include/list" 3
		const_iterator(_Nodeptr _Pnode)
			: _Ptr(_Pnode)
			{	// construct with node pointer _Pnode
			}


		const_reference operator*() const
			{	// return designated value







			return (_Myval(_Ptr));
			}

		_Ctptr operator->() const
			{	// return pointer to class object
			return (&**this);
			}

		const_iterator& operator++()
			{	// preincrement







			_Ptr = _Nextnode(_Ptr);
			return (*this);
			}

		const_iterator operator++(int)
			{	// postincrement
			const_iterator _Tmp = *this;
			++*this;
			return (_Tmp);
			}

		const_iterator& operator--()
			{	// predecrement

# 219 "C:/usr/local/cell\\target\\ppu\\include/list" 3
			_Ptr = _Prevnode(_Ptr);


			return (*this);
			}

		const_iterator operator--(int)
			{	// postdecrement
			const_iterator _Tmp = *this;
			--*this;
			return (_Tmp);
			}

		bool operator==(const const_iterator& _Right) const
			{	// test for iterator equality






			return (_Ptr == _Right._Ptr);
			}

		bool operator!=(const const_iterator& _Right) const
			{	// test for iterator inequality
			return (!(*this == _Right));
			}

		_Nodeptr _Mynode() const
			{	// return node pointer
			return (_Ptr);
			}

		_Nodeptr _Ptr;	// pointer to node
		};

		// CLASS iterator
	class iterator;
	friend class iterator;

	class iterator
		: public const_iterator
		{	// iterator for mutable list
	public:
		friend class list<_Ty, _Ax>;
		typedef bidirectional_iterator_tag iterator_category;
		typedef _Ty value_type;
		typedef _Dift difference_type;
		typedef _Tptr pointer;
		typedef _Reft reference;

		iterator()
			{	// construct with null node
			}

# 282 "C:/usr/local/cell\\target\\ppu\\include/list" 3
		iterator(_Nodeptr _Pnode)
			: const_iterator(_Pnode)
			{	// construct with node pointer _Pnode
			}


		reference operator*() const
			{	// return designated value
			return (const_cast<reference>(**(const_iterator *)this));
			}

		_Tptr operator->() const
			{	// return pointer to class object
			return (&**this);
			}

		iterator& operator++()
			{	// preincrement
			++(*(const_iterator *)this);
			return (*this);
			}

		iterator operator++(int)
			{	// postincrement
			iterator _Tmp = *this;
			++*this;
			return (_Tmp);
			}

		iterator& operator--()
			{	// predecrement
			--(*(const_iterator *)this);
			return (*this);
			}

		iterator operator--(int)
			{	// postdecrement
			iterator _Tmp = *this;
			--*this;
			return (_Tmp);
			}
		};

	typedef ::std:: reverse_iterator<iterator> reverse_iterator;
	typedef ::std:: reverse_iterator<const_iterator> const_reverse_iterator;

	list()
		: _Mybase(), _Myhead(_Buynode()), _Mysize(0)
		{	// construct empty list
		}

	explicit list(const _Alloc& _Al)
		: _Mybase(_Al), _Myhead(_Buynode()), _Mysize(0)
		{	// construct empty list, allocator
		}

	explicit list(size_type _Count)
		: _Mybase(), _Mysize(0)
		{	// construct list from _Count * _Ty()
		_Ty _Val = _Ty();
		_Myhead = _Buynode();
		_Construct_n(_Count, _Val);
		}

	list(size_type _Count, const _Ty& _Val)
		: _Mybase(), _Myhead(_Buynode()), _Mysize(0)
		{	// construct list from _Count * _Val
		_Construct_n(_Count, _Val);
		}

	list(size_type _Count, const _Ty& _Val, const _Alloc& _Al)
		: _Mybase(_Al), _Myhead(_Buynode()), _Mysize(0)
		{	// construct list, allocator from _Count * _Val
		_Construct_n(_Count, _Val);
		}

	list(const _Myt& _Right)
		: _Mybase(_Right._Alval),
			_Myhead(_Buynode()), _Mysize(0)
		{	// construct list by copying _Right
		{{
		insert(begin(), _Right.begin(), _Right.end());
		} if (0) {
		_Tidy();
		;
		}}
		}

	template<class _Iter>
		list(_Iter _First, _Iter _Last)
		: _Mybase(), _Myhead(_Buynode()), _Mysize(0)
		{	// construct list from [_First, _Last)
		_Construct(_First, _Last, _Iter_cat(_First));
		}

	template<class _Iter>
		list(_Iter _First, _Iter _Last, const _Alloc& _Al)
		: _Mybase(_Al), _Myhead(_Buynode()), _Mysize(0)
		{	// construct list, allocator from [_First, _Last)
		_Construct(_First, _Last, _Iter_cat(_First));
		}

	template<class _Iter>
		void _Construct(_Iter _Count, _Iter _Val, _Int_iterator_tag)
		{	// construct list from _Count * _Val
		_Construct_n((size_type)_Count, (_Ty)_Val);
		}

	template<class _Iter>
		void _Construct(_Iter _First,
			_Iter _Last, input_iterator_tag)
		{	// construct list from [_First, _Last), input iterators
		{{
		insert(begin(), _First, _Last);
		} if (0) {
		_Tidy();
		;
		}}
		}

	void _Construct_n(size_type _Count,
		const _Ty& _Val)
		{	// construct from _Count * _Val
		{{
		_Insert_n(begin(), _Count, _Val);
		} if (0) {
		_Tidy();
		;
		}}
		}

	~list()
		{	// destroy the object
		_Tidy();
		}

	_Myt& operator=(const _Myt& _Right)
		{	// assign _Right
		if (this != &_Right)
			assign(_Right.begin(), _Right.end());
		return (*this);
		}

# 447 "C:/usr/local/cell\\target\\ppu\\include/list" 3
	iterator begin()
		{	// return iterator for beginning of mutable sequence
		return (iterator(_Nextnode(_Myhead)));
		}

	const_iterator begin() const
		{	// return iterator for beginning of nonmutable sequence
		return (const_iterator(_Nextnode(_Myhead)));
		}

	iterator end()
		{	// return iterator for end of mutable sequence
		return (iterator(_Myhead));
		}

	const_iterator end() const
		{	// return iterator for end of nonmutable sequence
		return (const_iterator(_Myhead));
		}


	reverse_iterator rbegin()
		{	// return iterator for beginning of reversed mutable sequence
		return (reverse_iterator(end()));
		}

	const_reverse_iterator rbegin() const
		{	// return iterator for beginning of reversed nonmutable sequence
		return (const_reverse_iterator(end()));
		}

	reverse_iterator rend()
		{	// return iterator for end of reversed mutable sequence
		return (reverse_iterator(begin()));
		}

	const_reverse_iterator rend() const
		{	// return iterator for end of reversed nonmutable sequence
		return (const_reverse_iterator(begin()));
		}

	void resize(size_type _Newsize)
		{	// determine new length, padding with _Ty() elements as needed
		resize(_Newsize, _Ty());
		}

	void resize(size_type _Newsize, _Ty _Val)
		{	// determine new length, padding with _Val elements as needed
		if (_Mysize < _Newsize)
			_Insert_n(end(), _Newsize - _Mysize, _Val);
		else
			while (_Newsize < _Mysize)
				pop_back();
		}

	size_type size() const
		{	// return length of sequence
		return (_Mysize);
		}

	size_type max_size() const
		{	// return maximum possible length of sequence
		return (this->_Alval.max_size());
		}

	bool empty() const
		{	// test if sequence is empty
		return (_Mysize == 0);
		}

	allocator_type get_allocator() const
		{	// return allocator object for values
		return (this->_Alval);
		}

	reference front()
		{	// return first element of mutable sequence
		return (*begin());
		}

	const_reference front() const
		{	// return first element of nonmutable sequence
		return (*begin());
		}

	reference back()
		{	// return last element of mutable sequence
		return (*(--end()));
		}

	const_reference back() const
		{	// return last element of nonmutable sequence
		return (*(--end()));
		}

	void push_front(const _Ty& _Val)
		{	// insert element at beginning
		_Insert(begin(), _Val);
		}

	void pop_front()
		{	// erase element at beginning
		erase(begin());
		}

	void push_back(const _Ty& _Val)
		{	// insert element at end
		_Insert(end(), _Val);
		}

	void pop_back()
		{	// erase element at end
		erase(--end());
		}

	template<class _Iter>
		void assign(_Iter _First, _Iter _Last)
		{	// assign [_First, _Last)
		_Assign(_First, _Last, _Iter_cat(_First));
		}

	template<class _Iter>
		void _Assign(_Iter _Count, _Iter _Val, _Int_iterator_tag)
		{	// assign _Count * _Val
		_Assign_n((size_type)_Count, (_Ty)_Val);
		}

	template<class _Iter>
		void _Assign(_Iter _First, _Iter _Last, input_iterator_tag)
		{	// assign [_First, _Last), input iterators
		clear();
		insert(begin(), _First, _Last);
		}

	void assign(size_type _Count, const _Ty& _Val)
		{	// assign _Count * _Val
		_Assign_n(_Count, _Val);
		}

	iterator insert(iterator _Where, const _Ty& _Val)
		{	// insert _Val at _Where
		_Insert(_Where, _Val);
		return (--_Where);
		}

	void _Insert(iterator _Where,
		const _Ty& _Val)
		{	// insert _Val at _Where






		_Nodeptr _Pnode = _Where._Mynode();
		_Nodeptr _Newnode = _Buynode(_Pnode, _Prevnode(_Pnode), _Val);
		_Incsize(1);
		_Prevnode(_Pnode) = _Newnode;
		_Nextnode(_Prevnode(_Newnode)) = _Newnode;
		}

	void insert(iterator _Where, size_type _Count, const _Ty& _Val)
		{	// insert _Count * _Val at _Where
		_Insert_n(_Where, _Count, _Val);
		}

	template<class _Iter>
		void insert(iterator _Where, _Iter _First, _Iter _Last)
		{	// insert [_First, _Last) at _Where
		_Insert(_Where, _First, _Last, _Iter_cat(_First));
		}

	template<class _Iter>
		void _Insert(iterator _Where, _Iter _Count, _Iter _Val,
			_Int_iterator_tag)
		{	// insert _Count * _Val at _Where
		_Insert_n(_Where, (size_type)_Count, (_Ty)_Val);
		}

	template<class _Iter>
		void _Insert(iterator _Where,
			_Iter _First, _Iter _Last, input_iterator_tag)
		{	// insert [_First, _Last) at _Where, input iterators
		size_type _Num = 0;

		{{
		for (; _First != _Last; ++_First, ++_Num)
			_Insert(_Where, *_First);
		} if (0) {
		for (; 0 < _Num; --_Num)
			{	// undo inserts
			iterator _Before = _Where;
			erase(--_Before);
			}
		;
		}}
		}

	template<class _Iter>
		void _Insert(iterator _Where,
			_Iter _First, _Iter _Last, forward_iterator_tag)
		{	// insert [_First, _Last) at _Where, forward iterators







		_Iter _Next = _First;

		{{
		for (; _First != _Last; ++_First)
			_Insert(_Where, *_First);
		} if (0) {
		for (; _Next != _First; ++_Next)
			{	// undo inserts
			iterator _Before = _Where;
			erase(--_Before);
			}
		;
		}}
		}

	iterator erase(iterator _Where)
		{	// erase element at _Where

# 681 "C:/usr/local/cell\\target\\ppu\\include/list" 3
		_Nodeptr _Pnode = (_Where++)._Mynode();


		if (_Pnode != _Myhead)
			{	// not list head, safe to erase
			_Nextnode(_Prevnode(_Pnode)) = _Nextnode(_Pnode);
			_Prevnode(_Nextnode(_Pnode)) = _Prevnode(_Pnode);
			this->_Alnod.destroy(_Pnode);
			this->_Alnod.deallocate(_Pnode, 1);
			--_Mysize;
			}
		return (_Where);
		}

	iterator erase(iterator _First, iterator _Last)
		{	// erase [_First, _Last)
		if (_First == begin() && _Last == end())
			clear();
		else
			while (_First != _Last)
				_First = erase(_First);
		return (_Last);
		}

	void clear()
		{	// erase all





		_Nodeptr _Pnext;
		_Nodeptr _Pnode = _Nextnode(_Myhead);
		_Nextnode(_Myhead) = _Myhead;
		_Prevnode(_Myhead) = _Myhead;
		_Mysize = 0;

		for (; _Pnode != _Myhead; _Pnode = _Pnext)
			{	// delete an element
			_Pnext = _Nextnode(_Pnode);
			this->_Alnod.destroy(_Pnode);
			this->_Alnod.deallocate(_Pnode, 1);
			}
		}

	void swap(_Myt& _Right)
		{	// exchange contents with _Right
		if (this->_Alval == _Right._Alval)
			{	// same allocator, swap control information





			::std:: swap(_Myhead, _Right._Myhead);
			::std:: swap(_Mysize, _Right._Mysize);
			}
		else
			{	// different allocator, do splices
			iterator _Where = begin();
			splice(_Where, _Right);
			_Right.splice(_Right.begin(), *this, _Where, end());
			}
		}

	void splice(iterator _Where, _Myt& _Right)
		{	// splice all of _Right at _Where
		if (this != &_Right && !_Right.empty())
			{	// worth splicing, do it
			_Splice(_Where, _Right, _Right.begin(), _Right.end(),
				_Right._Mysize);
			}
		}

	void splice(iterator _Where, _Myt& _Right, iterator _First)
		{	// splice _Right [_First, _First + 1) at _Where

# 764 "C:/usr/local/cell\\target\\ppu\\include/list" 3
		if (_First != _Right.end())


			{	// element exists, try splice
			iterator _Last = _First;
			++_Last;
			if (this != &_Right
				|| (_Where != _First && _Where != _Last))
				_Splice(_Where, _Right, _First, _Last, 1);
			}
		}

	void splice(iterator _Where,
		_Myt& _Right, iterator _First, iterator _Last)
		{	// splice _Right [_First, _Last) at _Where
		if (_First != _Last && (this != &_Right || _Where != _Last))
			{	// worth splicing, do it
			size_type _Count = 0;
			if (this == &_Right)
				;	// just rearrange this list
			else if (_First == _Right.begin() && _Last == _Right.end())
				_Count = _Right._Mysize;	// splice in whole list
			else
				_Distance(_First, _Last, _Count);	// splice in partial list
			_Splice(_Where, _Right, _First, _Last, _Count);
			}
		}

	void remove(const _Ty& _Val)
		{	// erase each element matching _Val
		iterator _Last = end();
		for (iterator _First = begin(); _First != _Last; )
			if (*_First == _Val)
				_First = erase(_First);
			else
				++_First;
		}

	template<class _Pr1>
		void remove_if(_Pr1 _Pred)
		{	// erase each element satisfying _Pr1
		iterator _Last = end();
		for (iterator _First = begin(); _First != _Last; )
			if (_Pred(*_First))
				_First = erase(_First);
			else
				++_First;
		}

	void unique()
		{	// erase each element matching previous
		if (2 <= _Mysize)
			{	// worth doing
			iterator _First = begin();
			iterator _After = _First;
			for (++_After; _After != end(); )
				if (*_First == *_After)
					_After = erase(_After);
				else
					_First = _After++;
			}
		}

	template<class _Pr2>
		void unique(_Pr2 _Pred)
		{	// erase each element satisfying _Pred with previous
		if (2 <= _Mysize)
			{	// worth doing
			iterator _First = begin();
			iterator _After = _First;
			for (++_After; _After != end(); )
				if (_Pred(*_First, *_After))
					_After = erase(_After);
				else
					_First = _After++;
			}
		}

	void merge(_Myt& _Right)
		{	// merge in elements from _Right, both ordered by operator<
		if (&_Right != this)
			{	// safe to merge, do it
			iterator _First1 = begin(), _Last1 = end();
			iterator _First2 = _Right.begin(), _Last2 = _Right.end();
			;
			;

			while (_First1 != _Last1 && _First2 != _Last2)
				if (((*_First2) < (*_First1)))
					{	// splice in an element from _Right
					iterator _Mid2 = _First2;
					_Splice(_First1, _Right, _First2, ++_Mid2, 1);
					_First2 = _Mid2;
					}
				else
					++_First1;

			if (_First2 != _Last2)
				_Splice(_Last1, _Right, _First2, _Last2,
					_Right._Mysize);	// splice remainder of _Right
			}
		}

	template<class _Pr3>
		void merge(_Myt& _Right, _Pr3 _Pred)
		{	// merge in elements from _Right, both ordered by _Pred
		if (&_Right != this)
			{	// safe to merge, do it
			iterator _First1 = begin(), _Last1 = end();
			iterator _First2 = _Right.begin(), _Last2 = _Right.end();
			;
			;

			while (_First1 != _Last1 && _First2 != _Last2)
				if (_Pred(*_First2, *_First1))
					{	// splice in an element from _Right
					iterator _Mid2 = _First2;
					_Splice(_First1, _Right, _First2, ++_Mid2, 1);
					_First2 = _Mid2;
					}
				else
					++_First1;

			if (_First2 != _Last2)
				_Splice(_Last1, _Right, _First2, _Last2,
					_Right._Mysize);	// splice remainder of _Right
			}
		}

	void sort()
		{	// order sequence, using operator<
		if (2 <= _Mysize)
			{	// worth sorting, do it
			const size_t _MAXBINS = 25;
			_Myt _Templist(this->_Alval), _Binlist[_MAXBINS + 1];
			size_t _Maxbin = 0;

			while (!empty())
				{	// sort another element, using bins
				_Templist.splice(_Templist.begin(), *this, begin());
				size_t _Bin;

				for (_Bin = 0; _Bin < _Maxbin && !_Binlist[_Bin].empty();
					++_Bin)
					{	// merge into ever larger bins
					_Binlist[_Bin].merge(_Templist);
					_Binlist[_Bin].swap(_Templist);
					}

				if (_Bin == _MAXBINS)
					_Binlist[_Bin - 1].merge(_Templist);
				else
					{	// spill to new bin, while they last
					_Binlist[_Bin].swap(_Templist);
					if (_Bin == _Maxbin)
						++_Maxbin;
					}
				}

			for (size_t _Bin = 1; _Bin < _Maxbin; ++_Bin)
				_Binlist[_Bin].merge(_Binlist[_Bin - 1]);	// merge up
			swap(_Binlist[_Maxbin - 1]);	// replace from last bin
			}
		}

	template<class _Pr3>
		void sort(_Pr3 _Pred)
		{	// order sequence, using _Pred
		if (2 <= _Mysize)
			{	// worth sorting, do it
			const size_t _MAXBINS = 25;
			_Myt _Templist(this->_Alval), _Binlist[_MAXBINS + 1];
			size_t _Maxbin = 0;

			while (!empty())
				{	// sort another element, using bins
				_Templist.splice(_Templist.begin(), *this, begin());
				size_t _Bin;

				for (_Bin = 0; _Bin < _Maxbin && !_Binlist[_Bin].empty();
					++_Bin)
					{	// merge into ever larger bins
					_Binlist[_Bin].merge(_Templist, _Pred);
					_Binlist[_Bin].swap(_Templist);
					}

				if (_Bin == _MAXBINS)
					_Binlist[_Bin - 1].merge(_Templist, _Pred);
				else
					{	// spill to new bin, while they last
					_Binlist[_Bin].swap(_Templist);
					if (_Bin == _Maxbin)
						++_Maxbin;
					}
				}

			for (size_t _Bin = 1; _Bin < _Maxbin; ++_Bin)
				_Binlist[_Bin].merge(_Binlist[_Bin - 1],
					_Pred);	// merge up
			swap(_Binlist[_Maxbin - 1]);	// replace with last bin
			}
		}

	void reverse()
		{	// reverse sequence
		if (2 <= _Mysize)
			{	// worth doing
			iterator _Last = end();
			for (iterator _Next = ++begin(); _Next != _Last; )
				{	// move next element to beginning
				iterator _Before = _Next;
				_Splice(begin(), *this, _Before, ++_Next, 1);
				}
			}
		}

	void _Splice(iterator _Where,
		_Myt& _Right, iterator _First, iterator _Last, size_type _Count)
		{	// splice _Right [_First, _Last) before _Where

# 994 "C:/usr/local/cell\\target\\ppu\\include/list" 3
		if (this->_Alval == _Right._Alval)
			{	// same allocator, just relink


			if (this != &_Right)
				{	// splicing from another list, adjust counts
				_Incsize(_Count);
				_Right._Mysize -= _Count;
				}
			_Nextnode(_Prevnode(_First._Mynode())) = _Last._Mynode();
			_Nextnode(_Prevnode(_Last._Mynode())) = _Where._Mynode();
			_Nextnode(_Prevnode(_Where._Mynode())) = _First._Mynode();
			_Nodeptr _Pnode = _Prevnode(_Where._Mynode());
			_Prevnode(_Where._Mynode()) = _Prevnode(_Last._Mynode());
			_Prevnode(_Last._Mynode()) = _Prevnode(_First._Mynode());
			_Prevnode(_First._Mynode()) = _Pnode;
			}
		else
			{	// different allocator, copy nodes then erase source
			insert(_Where, _First, _Last);
			_Right.erase(_First, _Last);
			}
			}

protected:
	void _Assign_n(size_type _Count, const _Ty& _Val)
		{	// assign _Count * _Val
		_Ty _Tmp = _Val;	// in case _Val is in sequence
		clear();
		_Insert_n(begin(), _Count, _Tmp);
		}

	_Nodeptr _Buynode()
		{	// allocate a head node and set links
		_Nodeptr _Pnode = this->_Alnod.allocate(1);
		int _Linkcnt = 0;

		{{
		this->_Alptr.construct(&_Nextnode(_Pnode), _Pnode);
		++_Linkcnt;
		this->_Alptr.construct(&_Prevnode(_Pnode), _Pnode);
		} if (0) {
		if (0 < _Linkcnt)
			this->_Alptr.destroy(&_Nextnode(_Pnode));
		this->_Alnod.deallocate(_Pnode, 1);
		;
		}}
		return (_Pnode);
		}

	_Nodeptr _Buynode(_Nodeptr _Next,
		_Nodeptr _Prev, const _Ty& _Val)
		{	// allocate a node and set links and value
		_Nodeptr _Pnode = this->_Alnod.allocate(1);
		{{
		this->_Alptr.construct(&_Nextnode(_Pnode), _Next);
		this->_Alptr.construct(&_Prevnode(_Pnode), _Prev);
		this->_Alval.construct(&_Myval(_Pnode), _Val);
		} if (0) {
		this->_Alnod.deallocate(_Pnode, 1);
		;
		}}
		return (_Pnode);
		}

	void _Tidy()
		{	// free all storage
		clear();
		this->_Alptr.destroy(&_Nextnode(_Myhead));
		this->_Alptr.destroy(&_Prevnode(_Myhead));
		this->_Alnod.deallocate(_Myhead, 1);
		_Myhead = 0;
		}

	void _Insert_n(iterator _Where,
		size_type _Count, const _Ty& _Val)
		{	// insert _Count * _Val at _Where
		size_type _Countsave = _Count;

		{{
		for (; 0 < _Count; --_Count)
			_Insert(_Where, _Val);
		} if (0) {
		for (; _Count < _Countsave; ++_Count)
			{	// undo inserts
			iterator _Before = _Where;
			erase(--_Before);
			}
		;
		}}
		}

	void _Incsize(size_type _Count)
		{	// alter element count, with checking
		if (max_size() - _Mysize < _Count)
			length_error("list<T> too long"). _Raise();
		_Mysize += _Count;
		}

# 1108 "C:/usr/local/cell\\target\\ppu\\include/list" 3

	_Nodeptr _Myhead;	// pointer to head node
	size_type _Mysize;	// number of elements
	};

		// list TEMPLATE OPERATORS
template<class _Ty,
	class _Alloc> inline
	void swap(list<_Ty, _Alloc>& _Left, list<_Ty, _Alloc>& _Right)
	{	// swap _Left and _Right lists
	_Left.swap(_Right);
	}

template<class _Ty,
	class _Alloc> inline
	bool operator==(const list<_Ty, _Alloc>& _Left,
		const list<_Ty, _Alloc>& _Right)
	{	// test for list equality
	return (_Left.size() == _Right.size()
		&& ::std:: equal(_Left.begin(), _Left.end(), _Right.begin()));
	}

template<class _Ty,
	class _Alloc> inline
	bool operator!=(const list<_Ty, _Alloc>& _Left,
		const list<_Ty, _Alloc>& _Right)
	{	// test for list inequality
	return (!(_Left == _Right));
	}

template<class _Ty,
	class _Alloc> inline
	bool operator<(const list<_Ty, _Alloc>& _Left,
		const list<_Ty, _Alloc>& _Right)
	{	// test if _Left < _Right for lists
	return (::std:: lexicographical_compare(_Left.begin(), _Left.end(),
		_Right.begin(), _Right.end()));
	}

template<class _Ty,
	class _Alloc> inline
	bool operator>(const list<_Ty, _Alloc>& _Left,
		const list<_Ty, _Alloc>& _Right)
	{	// test if _Left > _Right for lists
	return (_Right < _Left);
	}

template<class _Ty,
	class _Alloc> inline
	bool operator<=(const list<_Ty, _Alloc>& _Left,
		const list<_Ty, _Alloc>& _Right)
	{	// test if _Left <= _Right for lists
	return (!(_Right < _Left));
	}

template<class _Ty,
	class _Alloc> inline
	bool operator>=(const list<_Ty, _Alloc>& _Left,
		const list<_Ty, _Alloc>& _Right)
	{	// test if _Left >= _Right for lists
	return (!(_Left < _Right));
	}





}


/*
 * Copyright (c) 1992-2003 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
 */

/*
 * This file is derived from software bearing the following
 * restrictions:
 *
 * Copyright (c) 1994
 * Hewlett-Packard Company
 *
 * Permission to use, copy, modify, distribute and sell this
 * software and its documentation for any purpose is hereby
 * granted without fee, provided that the above copyright notice
 * appear in all copies and that both that copyright notice and
 * this permission notice appear in supporting documentation.
 * Hewlett-Packard Company makes no representations about the
 * suitability of this software for any purpose. It is provided
 * "as is" without express or implied warranty.
V4.02:0216 */
# 13 "C:/usr/local/cell\\target\\ppu\\include/xhash" 3
# 1 "C:/usr/local/cell\\target\\ppu\\include/vector" 3
/* SCE CONFIDENTIAL
 PlayStation(R)3 Programmer Tool Runtime Library 475.001
 * Copyright (C) 2012 Sony Computer Entertainment Inc.
 * All Rights Reserved.
 */
// vector standard header





namespace std {
template<class _Ty,
	class _Ax = allocator<_Ty> >
	class vector;




		// TEMPLATE CLASS _Vector_const_iterator
template<class _Ty,
	class _Alloc>
	class _Vector_const_iterator
		: public _Ranit<_Ty, typename _Alloc::difference_type,
			typename _Alloc::const_pointer, typename _Alloc::const_reference>
	{	// iterator for nonmutable vector
public:
	typedef _Vector_const_iterator<_Ty, _Alloc> _Myt;
	typedef vector<_Ty, _Alloc> _Myvec;
	typedef typename _Alloc::pointer _Tptr;

	typedef random_access_iterator_tag iterator_category;
	typedef _Ty value_type;
	typedef typename _Alloc::difference_type difference_type;
	typedef typename _Alloc::const_pointer pointer;
	typedef typename _Alloc::const_reference reference;

	_Vector_const_iterator()
		{	// construct with null pointer
		_Myptr = 0;
		}

# 51 "C:/usr/local/cell\\target\\ppu\\include/vector" 3
	_Vector_const_iterator(_Tptr _Ptr)
		{	// construct with pointer _Ptr
		_Myptr = _Ptr;
		}


	reference operator*() const
		{	// return designated object

# 66 "C:/usr/local/cell\\target\\ppu\\include/vector" 3

		return (*_Myptr);
		}

	pointer operator->() const
		{	// return pointer to class object
		return (&**this);
		}

	_Myt& operator++()
		{	// preincrement
		++_Myptr;
		return (*this);
		}

	_Myt operator++(int)
		{	// postincrement
		_Myt _Tmp = *this;
		++*this;
		return (_Tmp);
		}

	_Myt& operator--()
		{	// predecrement
		--_Myptr;
		return (*this);
		}

	_Myt operator--(int)
		{	// postdecrement
		_Myt _Tmp = *this;
		--*this;
		return (_Tmp);
		}

	_Myt& operator+=(difference_type _Off)
		{	// increment by integer
		_Myptr += _Off;
		return (*this);
		}

	_Myt operator+(difference_type _Off) const
		{	// return this + integer
		_Myt _Tmp = *this;
		return (_Tmp += _Off);
		}

	_Myt& operator-=(difference_type _Off)
		{	// decrement by integer
		return (*this += -_Off);
		}

	_Myt operator-(difference_type _Off) const
		{	// return this - integer
		_Myt _Tmp = *this;
		return (_Tmp -= _Off);
		}

	difference_type operator-(const _Myt& _Right) const
		{	// return difference of iterators





		return (_Myptr - _Right._Myptr);
		}

	reference operator[](difference_type _Off) const
		{	// subscript
		return (*(*this + _Off));
		}

	bool operator==(const _Myt& _Right) const
		{	// test for iterator equality





		return (_Myptr == _Right._Myptr);
		}

	bool operator!=(const _Myt& _Right) const
		{	// test for iterator inequality
		return (!(*this == _Right));
		}

	bool operator<(const _Myt& _Right) const
		{	// test if this < _Right





		return (_Myptr < _Right._Myptr);
		}

	bool operator>(const _Myt& _Right) const
		{	// test if this > _Right
		return (_Right < *this);
		}

	bool operator<=(const _Myt& _Right) const
		{	// test if this <= _Right
		return (!(_Right < *this));
		}

	bool operator>=(const _Myt& _Right) const
		{	// test if this >= _Right
		return (!(*this < _Right));
		}

# 186 "C:/usr/local/cell\\target\\ppu\\include/vector" 3

	_Tptr _Myptr;	// offset of element in vector
	};

template<class _Ty,
	class _Alloc> inline
	_Vector_const_iterator<_Ty, _Alloc> operator+(
		typename _Vector_const_iterator<_Ty, _Alloc>::difference_type _Off,
		_Vector_const_iterator<_Ty, _Alloc> _Next)
	{	// add offset to iterator
	return (_Next += _Off);
	}

		// TEMPLATE CLASS _Vector_iterator
template<class _Ty,
	class _Alloc>
	class _Vector_iterator
		: public _Vector_const_iterator<_Ty, _Alloc>
		{	// iterator for mutable vector
public:
	typedef _Vector_iterator<_Ty, _Alloc> _Myt;
	typedef _Vector_const_iterator<_Ty, _Alloc> _Mybase;

	typedef random_access_iterator_tag iterator_category;
	typedef _Ty value_type;
	typedef typename _Alloc::difference_type difference_type;
	typedef typename _Alloc::pointer pointer;
	typedef typename _Alloc::reference reference;

	_Vector_iterator()
		{	// construct with null vector pointer
		}

# 226 "C:/usr/local/cell\\target\\ppu\\include/vector" 3
	_Vector_iterator(pointer _Ptr)
		: _Mybase(_Ptr)
		{	// construct with pointer _Ptr
		}


	reference operator*() const
		{	// return designated object
		  return (const_cast<reference>(**(_Mybase *)this));
		}

	pointer operator->() const
		{	// return pointer to class object
		return (&**this);
		}

	_Myt& operator++()
		{	// preincrement
		++this->_Myptr;
		return (*this);
		}

	_Myt operator++(int)
		{	// postincrement
		_Myt _Tmp = *this;
		++*this;
		return (_Tmp);
		}

	_Myt& operator--()
		{	// predecrement
		--this->_Myptr;
		return (*this);
		}

	_Myt operator--(int)
		{	// postdecrement
		_Myt _Tmp = *this;
		--*this;
		return (_Tmp);
		}

	_Myt& operator+=(difference_type _Off)
		{	// increment by integer
		this->_Myptr += _Off;
		return (*this);
		}

	_Myt operator+(difference_type _Off) const
		{	// return this + integer
		_Myt _Tmp = *this;
		return (_Tmp += _Off);
		}

	_Myt& operator-=(difference_type _Off)
		{	// decrement by integer
		return (*this += -_Off);
		}

	_Myt operator-(difference_type _Off) const
		{	// return this - integer
		_Myt _Tmp = *this;
		return (_Tmp -= _Off);
		}

	difference_type operator-(const _Mybase& _Right) const
		{	// return difference of iterators
		return (*(_Mybase *)this - _Right);
		}

	reference operator[](difference_type _Off) const
		{	// subscript
		return (*(*this + _Off));
		}
	};

template<class _Ty,
	class _Alloc> inline
	_Vector_iterator<_Ty, _Alloc> operator+(
		typename _Vector_iterator<_Ty, _Alloc>::difference_type _Off,
		_Vector_iterator<_Ty, _Alloc> _Next)
	{	// add offset to iterator
	return (_Next += _Off);
	}


		// TEMPLATE CLASS _Vector_val
template<class _Ty,
	class _Alloc>
	class _Vector_val
		: public _Container_base
	{	// base class for vector to hold allocator _Alval
protected:
	_Vector_val(_Alloc _Al = _Alloc())
		: _Alval(_Al)
		{	// construct allocator from _Al
		}

	typedef typename _Alloc::template
		rebind<_Ty>::other _Alty;

	_Alty _Alval;	// allocator object for values
	};

		// TEMPLATE CLASS vector
template<class _Ty,
	class _Ax>
	class vector
		: public _Vector_val<_Ty, _Ax>
	{	// varying size array of values
public:
	typedef vector<_Ty, _Ax> _Myt;
	typedef _Vector_val<_Ty, _Ax> _Mybase;
	typedef typename _Mybase::_Alty _Alloc;
	typedef _Alloc allocator_type;
	typedef typename _Alloc::size_type size_type;
	typedef typename _Alloc::difference_type _Dift;
	typedef _Dift difference_type;
	typedef typename _Alloc::pointer _Tptr;
	typedef typename _Alloc::const_pointer _Ctptr;
	typedef _Tptr pointer;
	typedef _Ctptr const_pointer;
	typedef typename _Alloc::reference _Reft;
	typedef _Reft reference;
	typedef typename _Alloc::const_reference const_reference;
	typedef typename _Alloc::value_type value_type;

# 361 "C:/usr/local/cell\\target\\ppu\\include/vector" 3

	typedef _Vector_iterator<_Ty, _Alloc> iterator;
	typedef _Vector_const_iterator<_Ty, _Alloc> const_iterator;

//	friend class _Vector_iterator<_Ty, _Alloc>;
	friend class _Vector_const_iterator<_Ty, _Alloc>;


	typedef ::std:: reverse_iterator<iterator> reverse_iterator;
	typedef ::std:: reverse_iterator<const_iterator> const_reverse_iterator;

	vector()
		: _Mybase()
		{	// construct empty vector
		_Buy(0);
		}

	explicit vector(const _Alloc& _Al)
		: _Mybase(_Al)
		{	// construct empty vector with allocator
		_Buy(0);
		}

	explicit vector(size_type _Count)
		: _Mybase()
		{	// construct from _Count * _Ty()
		_Construct_n(_Count, _Ty());
		}

	vector(size_type _Count, const _Ty& _Val)
		: _Mybase()
		{	// construct from _Count * _Val
		_Construct_n(_Count, _Val);
		}

	vector(size_type _Count, const _Ty& _Val, const _Alloc& _Al)
		: _Mybase(_Al)
		{	// construct from _Count * _Val, with allocator
		_Construct_n(_Count, _Val);
		}

	vector(const _Myt& _Right)
		: _Mybase(_Right._Alval)
		{	// construct by copying _Right
		if (_Buy(_Right.size()))
			{{
			_Mylast = _Ucopy(_Right.begin(), _Right.end(), _Myfirst);
			} if (0) {
			_Tidy();
			;
			}}
		}

	template<class _Iter>
		vector(_Iter _First, _Iter _Last)
		: _Mybase()
		{	// construct from [_First, _Last)
		_Construct(_First, _Last, _Iter_cat(_First));
		}

	template<class _Iter>
		vector(_Iter _First, _Iter _Last, const _Alloc& _Al)
		: _Mybase(_Al)
		{	// construct from [_First, _Last), with allocator
		_Construct(_First, _Last, _Iter_cat(_First));
		}

	template<class _Iter>
		void _Construct(_Iter _Count, _Iter _Val, _Int_iterator_tag)
		{	// initialize with _Count * _Val
		size_type _Size = (size_type)_Count;
		_Construct_n(_Size, _Val);
		}

	template<class _Iter>
		void _Construct(_Iter _First,
			_Iter _Last, input_iterator_tag)
		{	// initialize with [_First, _Last), input iterators
		_Buy(0);
		{{
		insert(begin(), _First, _Last);
		} if (0) {
		_Tidy();
		;
		}}
		}

	void _Construct_n(size_type _Count, const _Ty& _Val)
		{	// construct from _Count * _Val
		if (_Buy(_Count))
			{	// nonzero, fill it
			{{
			_Mylast = _Ufill(_Myfirst, _Count, _Val);
			} if (0) {
			_Tidy();
			;
			}}
			}
		}

	~vector()
		{	// destroy the object
		_Tidy();
		}

	_Myt& operator=(const _Myt& _Right)
		{	// assign _Right
		if (this != &_Right)
			{	// worth doing





			if (_Right.size() == 0)
				clear();	// new sequence empty, free storage
			else if (_Right.size() <= size())
				{	// enough elements, copy new and destroy old
				pointer _Ptr = copy(_Right._Myfirst, _Right._Mylast,
					_Myfirst);	// copy new
				_Destroy(_Ptr, _Mylast);	// destroy old
				_Mylast = _Myfirst + _Right.size();
				}
			else if (_Right.size() <= capacity())
				{	// enough room, copy and construct new
				pointer _Ptr = _Right._Myfirst + size();
				copy(_Right._Myfirst, _Ptr, _Myfirst);
				_Mylast = _Ucopy(_Ptr, _Right._Mylast, _Mylast);
				}
			else
				{	// not enough room, allocate new array and construct new
				if (_Myfirst != 0)
					{	// discard old array
					_Destroy(_Myfirst, _Mylast);
					this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);
					}
				if (_Buy(_Right.size()))
					_Mylast = _Ucopy(_Right._Myfirst, _Right._Mylast,
						_Myfirst);
				}
			}
		return (*this);
		}

	void reserve(size_type _Count)
		{	// determine new minimum length of allocated storage
		if (max_size() < _Count)
			_Xlen();	// result too long
		else if (capacity() < _Count)
			{	// not enough room, reallocate
			pointer _Ptr = this->_Alval.allocate(_Count);

			{{
			_Ucopy(begin(), end(), _Ptr);
			} if (0) {
			this->_Alval.deallocate(_Ptr, _Count);
			;
			}}

			size_type _Size = size();
			if (_Myfirst != 0)
				{	// destroy and deallocate old array
				_Destroy(_Myfirst, _Mylast);
				this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);
				}





			_Myend = _Ptr + _Count;
			_Mylast = _Ptr + _Size;
			_Myfirst = _Ptr;
			}
		}

	size_type capacity() const
		{	// return current length of allocated storage
		return (_Myfirst == 0 ? 0 : _Myend - _Myfirst);
		}

# 564 "C:/usr/local/cell\\target\\ppu\\include/vector" 3
	iterator begin()
		{	// return iterator for beginning of mutable sequence
		return (iterator(_Myfirst));
		}

	const_iterator begin() const
		{	// return iterator for beginning of nonmutable sequence
		return (const_iterator(_Myfirst));
		}

	iterator end()
		{	// return iterator for end of mutable sequence
		return (iterator(_Mylast));
		}

	const_iterator end() const
		{	// return iterator for end of nonmutable sequence
		return (const_iterator(_Mylast));
		}


	reverse_iterator rbegin()
		{	// return iterator for beginning of reversed mutable sequence
		return (reverse_iterator(end()));
		}

	const_reverse_iterator rbegin() const
		{	// return iterator for beginning of reversed nonmutable sequence
		return (const_reverse_iterator(end()));
		}

	reverse_iterator rend()
		{	// return iterator for end of reversed mutable sequence
		return (reverse_iterator(begin()));
		}

	const_reverse_iterator rend() const
		{	// return iterator for end of reversed nonmutable sequence
		return (const_reverse_iterator(begin()));
		}

	void resize(size_type _Newsize)
		{	// determine new length, padding with _Ty() elements as needed
		resize(_Newsize, _Ty());
		}

	void resize(size_type _Newsize, _Ty _Val)
		{	// determine new length, padding with _Val elements as needed
		if (size() < _Newsize)
			_Insert_n(end(), _Newsize - size(), _Val);
		else if (_Newsize < size())
			erase(begin() + _Newsize, end());
		}

	size_type size() const
		{	// return length of sequence
		return (_Myfirst == 0 ? 0 : _Mylast - _Myfirst);
		}

	size_type max_size() const
		{	// return maximum possible length of sequence
		return (this->_Alval.max_size());
		}

	bool empty() const
		{	// test if sequence is empty
		return (size() == 0);
		}

	_Alloc get_allocator() const
		{	// return allocator object for values
		return (this->_Alval);
		}

	const_reference at(size_type _Pos) const
		{	// subscript nonmutable sequence with checking
		if (size() <= _Pos)
			_Xran();
		return (*(begin() + _Pos));
		}

	reference at(size_type _Pos)
		{	// subscript mutable sequence with checking
		if (size() <= _Pos)
			_Xran();
		return (*(begin() + _Pos));
		}

	const_reference operator[](size_type _Pos) const
		{	// subscript nonmutable sequence






		return (*(begin() + _Pos));
		}

	reference operator[](size_type _Pos)
		{	// subscript mutable sequence






		return (*(begin() + _Pos));
		}

	reference front()
		{	// return first element of mutable sequence
		return (*begin());
		}

	const_reference front() const
		{	// return first element of nonmutable sequence
		return (*begin());
		}

	reference back()
		{	// return last element of mutable sequence
		return (*(end() - 1));
		}

	const_reference back() const
		{	// return last element of nonmutable sequence
		return (*(end() - 1));
		}

	void push_back(const _Ty& _Val)
		{	// insert element at end
		if (size() < capacity())

# 705 "C:/usr/local/cell\\target\\ppu\\include/vector" 3
			_Mylast = _Ufill(_Mylast, 1, _Val);


		else
			insert(end(), _Val);
		}

# 726 "C:/usr/local/cell\\target\\ppu\\include/vector" 3
	void pop_back()
		{	// erase element at end
		if (!empty())
			{	// erase last element
			_Destroy(_Mylast - 1, _Mylast);
			--_Mylast;
			}
		}


	template<class _Iter>
		void assign(_Iter _First, _Iter _Last)
		{	// assign [_First, _Last)
		_Assign(_First, _Last, _Iter_cat(_First));
		}

	template<class _Iter>
		void _Assign(_Iter _Count, _Iter _Val, _Int_iterator_tag)
		{	// assign _Count * _Val
		_Assign_n((size_type)_Count, (_Ty)_Val);
		}

	template<class _Iter>
		void _Assign(_Iter _First, _Iter _Last, input_iterator_tag)
		{	// assign [_First, _Last), input iterators
		erase(begin(), end());
		insert(begin(), _First, _Last);
		}

	void assign(size_type _Count, const _Ty& _Val)
		{	// assign _Count * _Val
		_Assign_n(_Count, _Val);
		}

	iterator insert(iterator _Where, const _Ty& _Val)
		{	// insert _Val at _Where
		size_type _Off = size() == 0 ? 0 : _Where - begin();
		_Insert_n(_Where, (size_type)1, _Val);
		return (begin() + _Off);
		}

	void insert(iterator _Where, size_type _Count, const _Ty& _Val)
		{	// insert _Count * _Val at _Where
		_Insert_n(_Where, _Count, _Val);
		}

	template<class _Iter>
		void insert(iterator _Where, _Iter _First, _Iter _Last)
		{	// insert [_First, _Last) at _Where
		_Insert(_Where, _First, _Last, _Iter_cat(_First));
		}

	template<class _Iter>
		void _Insert(iterator _Where, _Iter _First, _Iter _Last,
			_Int_iterator_tag)
		{	// insert _Count * _Val at _Where
		_Insert_n(_Where, (size_type)_First, (_Ty)_Last);
		}

	template<class _Iter>
		void _Insert(iterator _Where, _Iter _First, _Iter _Last,
			input_iterator_tag)
		{	// insert [_First, _Last) at _Where, input iterators
		for (; _First != _Last; ++_First, ++_Where)
			_Where = insert(_Where, *_First);
		}

	template<class _Iter>
		void _Insert(iterator _Where,
			_Iter _First, _Iter _Last, forward_iterator_tag)
		{	// insert [_First, _Last) at _Where, forward iterators

# 806 "C:/usr/local/cell\\target\\ppu\\include/vector" 3

		size_type _Count = 0;
		_Distance(_First, _Last, _Count);
		size_type _Capacity = capacity();

		if (_Count == 0)
			;
		else if (max_size() - size() < _Count)
			_Xlen();	// result too long
		else if (_Capacity < size() + _Count)
			{	// not enough room, reallocate
			_Capacity = max_size() - _Capacity / 2 < _Capacity
				? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%
			if (_Capacity < size() + _Count)
				_Capacity = size() + _Count;
			pointer _Newvec = this->_Alval.allocate(_Capacity);
			pointer _Ptr = _Newvec;

			{{
			_Ptr = _Ucopy(_Myfirst, (_Where). _Myptr,
				_Newvec);	// copy prefix
			_Ptr = _Ucopy(_First, _Last, _Ptr);	// add new stuff
			_Ucopy((_Where). _Myptr, _Mylast, _Ptr);	// copy suffix
			} if (0) {
			_Destroy(_Newvec, _Ptr);
			this->_Alval.deallocate(_Newvec, _Capacity);
			;
			}}

			_Count += size();
			if (_Myfirst != 0)
				{	// destroy and deallocate old array
				_Destroy(_Myfirst, _Mylast);
				this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);
				}





			_Myend = _Newvec + _Capacity;
			_Mylast = _Newvec + _Count;
			_Myfirst = _Newvec;
			}
		else if ((size_type)(end() - _Where) < _Count)
			{	// new stuff spills off end
			_Ucopy((_Where). _Myptr, _Mylast,
				(_Where). _Myptr + _Count);	// copy suffix
			_Iter _Mid = _First;
			::std:: advance(_Mid, end() - _Where);

			{{
			_Ucopy(_Mid, _Last, _Mylast);	// insert new stuff off end
			} if (0) {
			_Destroy((_Where). _Myptr + _Count, _Mylast + _Count);
			;
			}}

			_Mylast += _Count;





			copy(_First, _Mid,
				(_Where). _Myptr);	// insert to old end
			}
		else
			{	// new stuff can all be assigned
			pointer _Oldend = _Mylast;
			_Mylast = _Ucopy(_Oldend - _Count, _Oldend,
				_Mylast);	// copy suffix
			::std:: copy_backward((_Where). _Myptr, _Oldend - _Count,
				_Oldend);	// copy hole





			copy(_First, _Last,
				(_Where). _Myptr);	// insert into hole
			}
		}

# 904 "C:/usr/local/cell\\target\\ppu\\include/vector" 3
	iterator erase(iterator _Where)
		{	// erase element at where
		copy((_Where). _Myptr + 1, _Mylast, (_Where). _Myptr);
		_Destroy(_Mylast - 1, _Mylast);
		--_Mylast;
		return (_Where);
		}


	iterator erase(iterator _First, iterator _Last)
		{	// erase [_First, _Last)
		if (_First != _Last)
			{	// worth doing, copy down over hole

# 927 "C:/usr/local/cell\\target\\ppu\\include/vector" 3
			pointer _Ptr = copy((_Last). _Myptr, _Mylast,
				(_First). _Myptr);


			_Destroy(_Ptr, _Mylast);
			_Mylast = _Ptr;
			}
		return (_First);
		}

	void clear()
		{	// erase all
		erase(begin(), end());
		}

	void swap(_Myt& _Right)
		{	// exchange contents with _Right
		if (this->_Alval == _Right._Alval)
			{	// same allocator, swap control information





			::std:: swap(_Myfirst, _Right._Myfirst);
			::std:: swap(_Mylast, _Right._Mylast);
			::std:: swap(_Myend, _Right._Myend);
			}
		else
			{	// different allocator, do multiple assigns
			_Myt _Ts = *this; *this = _Right, _Right = _Ts;
			}
		}

protected:
	void _Assign_n(size_type _Count, const _Ty& _Val)
		{	// assign _Count * _Val
		_Ty _Tmp = _Val;	// in case _Val is in sequence
		erase(begin(), end());
		insert(begin(), _Count, _Tmp);
		}

	bool _Buy(size_type _Capacity)
		{	// allocate array with _Capacity elements
		_Myfirst = 0, _Mylast = 0, _Myend = 0;
		if (_Capacity == 0)
			return (false);
		else if (max_size() < _Capacity)
			_Xlen();	// result too long
		else
			{	// nonempty array, allocate storage
			_Myfirst = this->_Alval.allocate(_Capacity);
			_Mylast = _Myfirst;
			_Myend = _Myfirst + _Capacity;
			}
		return (true);
		}

	void _Destroy(pointer _First, pointer _Last)
		{	// destroy [_First, _Last) using allocator
		_Destroy_range(_First, _Last, this->_Alval);
		}

	void _Tidy()
		{	// free all storage
		if (_Myfirst != 0)
			{	// something to free, destroy and deallocate it





			_Destroy(_Myfirst, _Mylast);
			this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);
			}
		_Myfirst = 0, _Mylast = 0, _Myend = 0;
		}

	template<class _Iter>
		pointer _Ucopy(_Iter _First, _Iter _Last, pointer _Ptr)
		{	// copy initializing [_First, _Last), using allocator
		return (_Uninitialized_copy(_First, _Last,
			_Ptr, this->_Alval));
		}

	void _Insert_n(iterator _Where,
		size_type _Count, const _Ty& _Val)
		{	// insert _Count * _Val at _Where







		_Ty _Tmp = _Val;	// in case _Val is in sequence
		size_type _Capacity = capacity();

		if (_Count == 0)
			;
		else if (max_size() - size() < _Count)
			_Xlen();	// result too long
		else if (_Capacity < size() + _Count)
			{	// not enough room, reallocate
			_Capacity = max_size() - _Capacity / 2 < _Capacity
				? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%
			if (_Capacity < size() + _Count)
				_Capacity = size() + _Count;
			pointer _Newvec = this->_Alval.allocate(_Capacity);
			pointer _Ptr = _Newvec;

			{{
			_Ptr = _Ucopy(_Myfirst, (_Where). _Myptr,
				_Newvec);	// copy prefix
			_Ptr = _Ufill(_Ptr, _Count, _Tmp);	// add new stuff
			_Ucopy((_Where). _Myptr, _Mylast, _Ptr);	// copy suffix
			} if (0) {
			_Destroy(_Newvec, _Ptr);
			this->_Alval.deallocate(_Newvec, _Capacity);
			;
			}}

			_Count += size();
			if (_Myfirst != 0)
				{	// destroy and deallocate old array
				_Destroy(_Myfirst, _Mylast);
				this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);
				}





			_Myend = _Newvec + _Capacity;
			_Mylast = _Newvec + _Count;
			_Myfirst = _Newvec;
			}
		else if ((size_type)(_Mylast - (_Where). _Myptr) < _Count)
			{	// new stuff spills off end
			_Ucopy((_Where). _Myptr, _Mylast,
				(_Where). _Myptr + _Count);	// copy suffix

			{{
			_Ufill(_Mylast, _Count - (_Mylast - (_Where). _Myptr),
				_Tmp);	// insert new stuff off end
			} if (0) {
			_Destroy((_Where). _Myptr + _Count, _Mylast + _Count);
			;
			}}

			_Mylast += _Count;





			::std:: fill((_Where). _Myptr, _Mylast - _Count,
				_Tmp);	// insert up to old end
			}
		else
			{	// new stuff can all be assigned
			pointer _Oldend = _Mylast;
			_Mylast = _Ucopy(_Oldend - _Count, _Oldend,
				_Mylast);	// copy suffix





			::std:: copy_backward((_Where). _Myptr, _Oldend - _Count,
				_Oldend);	// copy hole
			::std:: fill((_Where). _Myptr, (_Where). _Myptr + _Count,
				_Tmp);	// insert into hole
			}
		}

	pointer _Ufill(pointer _Ptr, size_type _Count, const _Ty &_Val)
		{	// copy initializing _Count * _Val, using allocator
		_Uninitialized_fill_n(_Ptr, _Count, _Val, this->_Alval);
		return (_Ptr + _Count);
		}

	void _Xlen() const
		{	// report a length_error
		length_error("vector<T> too long"). _Raise();
		}

	void _Xran() const
		{	// report an out_of_range error
		out_of_range("invalid vector<T> subscript"). _Raise();
		}

# 1134 "C:/usr/local/cell\\target\\ppu\\include/vector" 3

	pointer _Myfirst;	// pointer to beginning of array
	pointer _Mylast;	// pointer to current end of sequence
	pointer _Myend;	// pointer to end of array
	};

		// vector TEMPLATE FUNCTIONS
template<class _Ty,
	class _Alloc> inline
	bool operator==(const vector<_Ty, _Alloc>& _Left,
		const vector<_Ty, _Alloc>& _Right)
	{	// test for vector equality
	return (_Left.size() == _Right.size()
		&& ::std:: equal(_Left.begin(), _Left.end(), _Right.begin()));
	}

template<class _Ty,
	class _Alloc> inline
	bool operator!=(const vector<_Ty, _Alloc>& _Left,
		const vector<_Ty, _Alloc>& _Right)
	{	// test for vector inequality
	return (!(_Left == _Right));
	}

template<class _Ty,
	class _Alloc> inline
	bool operator<(const vector<_Ty, _Alloc>& _Left,
		const vector<_Ty, _Alloc>& _Right)
	{	// test if _Left < _Right for vectors
	return (::std:: lexicographical_compare(_Left.begin(), _Left.end(),
		_Right.begin(), _Right.end()));
	}

template<class _Ty,
	class _Alloc> inline
	bool operator>(const vector<_Ty, _Alloc>& _Left,
		const vector<_Ty, _Alloc>& _Right)
	{	// test if _Left > _Right for vectors
	return (_Right < _Left);
	}

template<class _Ty,
	class _Alloc> inline
	bool operator<=(const vector<_Ty, _Alloc>& _Left,
		const vector<_Ty, _Alloc>& _Right)
	{	// test if _Left <= _Right for vectors
	return (!(_Right < _Left));
	}

template<class _Ty,
	class _Alloc> inline
	bool operator>=(const vector<_Ty, _Alloc>& _Left,
		const vector<_Ty, _Alloc>& _Right)
	{	// test if _Left >= _Right for vectors
	return (!(_Left < _Right));
	}

template<class _Ty,
	class _Alloc> inline
	void swap(vector<_Ty, _Alloc>& _Left, vector<_Ty, _Alloc>& _Right)
	{	// swap _Left and _Right vectors
	_Left.swap(_Right);
	}

		// CLASS vector<bool>
typedef unsigned _Vbase;	// word type for vector<bool> representation
const int _VBITS = 8 * sizeof (_Vbase);	// at least CHAR_BITS bits per word

template<class _Alloc>
	class vector<_Bool, _Alloc>
		: public _Container_base
	{	// varying size array of bits
public:
	typedef typename _Alloc::size_type size_type;
	typedef typename _Alloc::difference_type _Dift;
	typedef ::std:: vector<_Vbase,
		typename _Alloc::template rebind<_Vbase>::other>
			_Vbtype;
	typedef ::std:: vector<_Bool, _Alloc> _Myt;
	typedef _Dift difference_type;
	typedef _Bool _Ty;
	typedef _Alloc allocator_type;

	typedef bool const_reference;
	typedef bool value_type;



		// CLASS _Vb_iter_base
	class _Vb_iter_base
		: public _Ranit<_Bool, _Dift, value_type *, value_type>
		{	// store information common to reference and iterators
	public:
		_Vb_iter_base()
			: _Myoff(0), _Myptr(0)
			{	// construct with null pointer
			}

# 1246 "C:/usr/local/cell\\target\\ppu\\include/vector" 3
		_Vb_iter_base(const _Vb_iter_base& _Right)
			: _Myoff(_Right._Myoff), _Myptr(_Right._Myptr)
			{	// construct with copy of _Right
			}

		_Vb_iter_base(_Vbase *_Ptr)
			: _Myoff(0), _Myptr(_Ptr)
			{	// construct with offset and pointer
			}


		size_type _Myoff;
		_Vbase *_Myptr;
		};

		// CLASS reference
	class reference;
	friend class reference;

	class reference
		: public _Vb_iter_base
		{	// reference to a bit within a base word
	public:
		reference()
			{	// construct with null pointer
			}

		reference(const _Vb_iter_base& _Right)
			: _Vb_iter_base(_Right)
			{	// construct with base
			}

		reference& operator=(const reference& _Right)
			{	// assign reference _Right to bit
			return (*this = bool(_Right));
			}

		reference& operator=(bool _Val)
			{	// assign _Val to bit
			if (_Val)
				*_Getptr() |= _Mask();
			else
				*_Getptr() &= ~_Mask();
			return (*this);
			}

		void flip()
			{	// toggle the bit
			*_Getptr() ^= _Mask();
			}

		bool operator~() const
			{	// test if bit is reset
			return (!bool(*this));
			}

		operator bool() const
			{	// test if bit is set
			return ((*_Getptr() & _Mask()) != 0);
			}

		_Vbase *_Getptr() const
			{	// get pointer to base word







			return (this->_Myptr);
			}

	protected:
		_Vbase _Mask() const
			{	// convert offset to mask
			return ((_Vbase)(1 << this->_Myoff));
			}
		};

	typedef reference _Reft;

		// CLASS const_iterator
	class const_iterator
		: public _Vb_iter_base
		{	// iterator for nonmutable vector<bool>
	public:
		typedef random_access_iterator_tag iterator_category;
		typedef _Bool value_type;
		typedef _Dift difference_type;
		typedef const_reference *pointer;
		typedef const_reference reference;

		const_iterator()
			{	// construct with null reference
			}






		const_iterator(const _Vbase *_Ptr)
			: _Vb_iter_base(const_cast<_Vbase *>(_Ptr))


			{	// construct with offset and pointer
			}

		const_reference operator*() const
			{	// return (reference to) designated object
			return (_Reft(*this));
			}

		const_iterator& operator++()
			{	// preincrement
			_Inc();
			return (*this);
			}

		const_iterator operator++(int)
			{	// postincrement
			const_iterator _Tmp = *this;
			++*this;
			return (_Tmp);
			}

		const_iterator& operator--()
			{	// predecrement
			_Dec();
			return (*this);
			}

		const_iterator operator--(int)
			{	// postdecrement
			const_iterator _Tmp = *this;
			--*this;
			return (_Tmp);
			}

		const_iterator& operator+=(difference_type _Off)
			{	// increment by integer
			if (_Off < 0 && this->_Myoff < 0 - (size_type)_Off)
				{	/* add negative increment */
	        		this->_Myoff += _Off;
		        	this->_Myptr -= 1 + ((size_type)(-1) - this->_Myoff) / _VBITS;
			        this->_Myoff %= _VBITS;
				}
			else
				{	/* add non-negative increment */
				this->_Myoff += _Off;
				this->_Myptr += this->_Myoff / _VBITS;
				this->_Myoff %= _VBITS;
				}
			return (*this);
			}

		const_iterator operator+(difference_type _Off) const
			{	// return this + integer
			const_iterator _Tmp = *this;
			return (_Tmp += _Off);
			}

		const_iterator& operator-=(difference_type _Off)
			{	// decrement by integer
			return (*this += -_Off);
			}

		const_iterator operator-(difference_type _Off) const
			{	// return this - integer
			const_iterator _Tmp = *this;
			return (_Tmp -= _Off);
			}

		difference_type operator-(const const_iterator _Right) const
			{	// return difference of iterators





			return (_VBITS * (this->_Myptr - _Right._Myptr)
				+ (difference_type)this->_Myoff
				- (difference_type)_Right._Myoff);
			}

		const_reference operator[](difference_type _Off) const
			{	// subscript
			return (*(*this + _Off));
			}

		bool operator==(const const_iterator& _Right) const
			{	// test for iterator equality





			return (this->_Myptr == _Right._Myptr
				&& this->_Myoff == _Right._Myoff);
			}

		bool operator!=(const const_iterator& _Right) const
			{	// test for iterator inequality
			return (!(*this == _Right));
			}

		bool operator<(const const_iterator& _Right) const
			{	// test if this < _Right





			return (this->_Myptr < _Right._Myptr
				|| this->_Myptr == _Right._Myptr
					&& this->_Myoff < _Right._Myoff);
			}

		bool operator>(const const_iterator& _Right) const
			{	// test if this > _Right
			return (_Right < *this);
			}

		bool operator<=(const const_iterator& _Right) const
			{	// test if this <= _Right
			return (!(_Right < *this));
			}

		bool operator>=(const const_iterator& _Right) const
			{	// test if this >= _Right
			return (!(*this < _Right));
			}

	protected:

# 1489 "C:/usr/local/cell\\target\\ppu\\include/vector" 3

		void _Dec()
			{	// decrement bit position
			if (this->_Myoff != 0)
				--this->_Myoff;
			else
				this->_Myoff = _VBITS - 1, --this->_Myptr;
			}

		void _Inc()
			{	// increment bit position
			if (this->_Myoff < _VBITS - 1)
				++this->_Myoff;
			else
				this->_Myoff = 0, ++this->_Myptr;
			}
		};

		// CLASS iterator
	class iterator
		: public const_iterator
		{	// iterator for mutable vector<bool>
	public:
		typedef random_access_iterator_tag iterator_category;
		typedef _Bool value_type;
		typedef _Dift difference_type;
		typedef _Reft *pointer;
		typedef _Reft reference;

		iterator()
			{	// construct with null reference
			}






		iterator( _Vbase *_Ptr)
			: const_iterator(_Ptr)


			{	// construct with offset and pointer
			}

		reference operator*() const
			{	// return (reference to) designated object
			return (_Reft(*this));
			}

		iterator& operator++()
			{	// preincrement
			++*(const_iterator *)this;
			return (*this);
			}

		iterator operator++(int)
			{	// postincrement
			iterator _Tmp = *this;
			++*this;
			return (_Tmp);
			}

		iterator& operator--()
			{	// predecrement
			--*(const_iterator *)this;
			return (*this);
			}

		iterator operator--(int)
			{	// postdecrement
			iterator _Tmp = *this;
			--*this;
			return (_Tmp);
			}

		iterator& operator+=(difference_type _Off)
			{	// increment by integer
			*(const_iterator *)this += _Off;
			return (*this);
			}

		iterator operator+(difference_type _Off) const
			{	// return this + integer
			iterator _Tmp = *this;
			return (_Tmp += _Off);
			}

		iterator& operator-=(difference_type _Off)
			{	// decrement by integer
			return (*this += -_Off);
			}

		iterator operator-(difference_type _Off) const
			{	// return this - integer
			iterator _Tmp = *this;
			return (_Tmp -= _Off);
			}

		difference_type operator-(const const_iterator _Right) const
			{	// return difference of iterators
			return (*(const_iterator *)this - _Right);
			}

		reference operator[](difference_type _Off) const
			{	// subscript
			return (*(*this + _Off));
			}

		};

	typedef iterator pointer;
	typedef const_iterator const_pointer;
	typedef ::std:: reverse_iterator<iterator> reverse_iterator;
	typedef ::std:: reverse_iterator<const_iterator> const_reverse_iterator;

	vector()
		: _Mysize(0), _Myvec()
		{	// construct empty vector
		}

	explicit vector(const _Alloc& _Al)
		: _Mysize(0), _Myvec(_Al)
		{	// construct empty vector, with allocator
		}

	explicit vector(size_type _Count, bool _Val = false)
		: _Mysize(0), _Myvec(_Nw(_Count), (_Vbase)(_Val ? -1 : 0))
		{	// construct from _Count * _Val
		_Trim(_Count);
		}

	vector(size_type _Count, bool _Val, const _Alloc& _Al)
		: _Mysize(0), _Myvec(_Nw(_Count), (_Vbase)(_Val ? -1 : 0), _Al)
		{	// construct from _Count * _Val, with allocator
		_Trim(_Count);
		}

	template<class _Iter>
		vector(_Iter _First, _Iter _Last)
		: _Mysize(0), _Myvec()
		{	// construct from [_First, _Last)
		_BConstruct(_First, _Last, _Iter_cat(_First));
		}

	template<class _Iter>
		vector(_Iter _First, _Iter _Last, const _Alloc& _Al)
		: _Mysize(0), _Myvec(_Al)
		{	// construct from [_First, _Last), with allocator
		_BConstruct(_First, _Last, _Iter_cat(_First));
		}

	template<class _Iter>
		void _BConstruct(_Iter _Count, _Iter _Val, _Int_iterator_tag)
		{	// initialize from _Count * _Val
		size_type _Num = (size_type)_Count;
		_Myvec.assign(_Num, (_Ty)_Val ? -1 : 0);
		_Trim(_Num);
		}

	template<class _Iter>
		void _BConstruct(_Iter _First, _Iter _Last, input_iterator_tag)
		{	// initialize from [_First, _Last), input iterators
		insert(begin(), _First, _Last);
		}

	~vector()
		{	// destroy the object
		_Mysize = 0;
		}

	void reserve(size_type _Count)
		{	// determine new minimum length of allocated storage
		_Myvec.reserve(_Nw(_Count));
		}

	size_type capacity() const
		{	// return current length of allocated storage
		return (_Myvec.capacity() * _VBITS);
		}

# 1682 "C:/usr/local/cell\\target\\ppu\\include/vector" 3
	iterator begin()
		{	// return iterator for beginning of mutable sequence
		return (iterator((_Myvec . begin()). _Myptr));
		}

	const_iterator begin() const
		{	// return iterator for beginning of nonmutable sequence
		return (const_iterator((_Myvec . begin()). _Myptr));
		}


	iterator end()
		{	// return iterator for end of mutable sequence
		iterator _Tmp = begin();
		if (0 < _Mysize)
			_Tmp += _Mysize;
		return (_Tmp);
		}

	const_iterator end() const
		{	// return iterator for end of nonmutable sequence
		const_iterator _Tmp = begin();
		if (0 < _Mysize)
			_Tmp += _Mysize;
		return (_Tmp);
		}

	reverse_iterator rbegin()
		{	// return iterator for beginning of reversed mutable sequence
		return (reverse_iterator(end()));
		}

	const_reverse_iterator rbegin() const
		{	// return iterator for beginning of reversed nonmutable sequence
		return (const_reverse_iterator(end()));
		}

	reverse_iterator rend()
		{	// return iterator for end of reversed mutable sequence
		return (reverse_iterator(begin()));
		}

	const_reverse_iterator rend() const
		{	// return iterator for end of reversed nonmutable sequence
		return (const_reverse_iterator(begin()));
		}

	void resize(size_type _Newsize, bool _Val = false)
		{	// determine new length, padding with _Val elements as needed
		if (size() < _Newsize)
			_Insert_n(end(), _Newsize - size(), _Val);
		else if (_Newsize < size())
			erase(begin() + _Newsize, end());
		}

	size_type size() const
		{	// return length of sequence
		return (_Mysize);
		}

	size_type max_size() const
		{	// return maximum possible length of sequence
		const size_type _Maxsize = _Myvec.max_size();
		return (_Maxsize < (size_type)(-1) / _VBITS
			? _Maxsize * _VBITS : (size_type)(-1));
		}

	bool empty() const
		{	// test if sequence is empty
		return (size() == 0);
		}

	_Alloc get_allocator() const
		{	// return allocator object for values
		return (_Myvec.get_allocator());
		}

	const_reference at(size_type _Off) const
		{	// subscript nonmutable sequence with checking
		if (size() <= _Off)
			_Xran();
		return (*(begin() + _Off));
		}

	reference at(size_type _Off)
		{	// subscript mutable sequence with checking
		if (size() <= _Off)
			_Xran();
		return (*(begin() + _Off));
		}

	const_reference operator[](size_type _Off) const
		{	// subscript nonmutable sequence
		return (*(begin() + _Off));
		}

	reference operator[](size_type _Off)
		{	// subscript mutable sequence
		return (*(begin() + _Off));
		}

	reference front()
		{	// return first element of mutable sequence
		return (*begin());
		}

	const_reference front() const
		{	// return first element of nonmutable sequence
		return (*begin());
		}

	reference back()
		{	// return last element of mutable sequence
		return (*(end() - 1));
		}

	const_reference back() const
		{	// return last element of nonmutable sequence
		return (*(end() - 1));
		}

	void push_back(bool _Val)
		{	// insert element at end
		insert(end(), _Val);
		}

	void pop_back()
		{	// erase element at end
		if (!empty())
			erase(end() - 1);
		}

	template<class _Iter>
		void assign(_Iter _First, _Iter _Last)
		{	// assign [_First, _Last)
		_Assign(_First, _Last, _Iter_cat(_First));
		}

	template<class _Iter>
		void _Assign(_Iter _Count, _Iter _Val, _Int_iterator_tag)
		{	// assign _Count * _Val
		_Assign_n((size_type)_Count, (bool)_Val);
		}

	template<class _Iter>
		void _Assign(_Iter _First, _Iter _Last, input_iterator_tag)
		{	// assign [_First, _Last), input iterators
		erase(begin(), end());
		insert(begin(), _First, _Last);
		}

	void assign(size_type _Count, bool _Val)
		{	// assign _Count * _Val
		_Assign_n(_Count, _Val);
		}

	iterator insert(iterator _Where, bool _Val)
		{	// insert _Val at _Where
		size_type _Off = _Where - begin();
		_Insert_n(_Where, (size_type)1, _Val);
		return (begin() + _Off);
		}

	void insert(iterator _Where, size_type _Count, bool _Val)
		{	// insert _Count * _Val at _Where
		_Insert_n(_Where, _Count, _Val);
		}

	template<class _Iter>
		void insert(iterator _Where, _Iter _First, _Iter _Last)
		{	// insert [_First, _Last) at _Where
		_Insert(_Where, _First, _Last, _Iter_cat(_First));
		}

	template<class _Iter>
		void _Insert(iterator _Where, _Iter _Count, _Iter _Val,
			_Int_iterator_tag)
		{	// insert _Count * _Val at _Where
		_Insert_n(_Where, (size_type)_Count, (bool)_Val);
		}

	template<class _Iter>
		void _Insert(iterator _Where, _Iter _First, _Iter _Last,
			input_iterator_tag)
		{	// insert [_First, _Last) at _Where, input iterators
		size_type _Off = _Where - begin();

		for (; _First != _Last; ++_First, ++_Off)
			insert(begin() + _Off, *_First);
		}

	template<class _Iter>
		void _Insert(iterator _Where,
			_Iter _First, _Iter _Last,
			forward_iterator_tag)
		{	// insert [_First, _Last) at _Where, forward iterators







		size_type _Count = 0;
		_Distance(_First, _Last, _Count);

		size_type _Off = _Insert_x(_Where, _Count);
		copy(_First, _Last, begin() + _Off);
		}

	iterator erase(iterator _Where)
		{	// erase element at _Where
		size_type _Off = _Where - begin();

# 1903 "C:/usr/local/cell\\target\\ppu\\include/vector" 3
		copy(_Where + 1, end(), _Where);


		_Trim(_Mysize - 1);
		return (begin() + _Off);
		}

	iterator erase(iterator _First, iterator _Last)
		{	// erase [_First, _Last)
		size_type _Off = _First - begin();

# 1923 "C:/usr/local/cell\\target\\ppu\\include/vector" 3
		iterator _Next = copy(_Last, end(), _First);
		_Trim(_Next - begin());


		return (begin() + _Off);
		}

	void clear()
		{	// erase all elements
		erase(begin(), end());
		}

	void flip()
		{	// toggle all elements
		for (typename _Vbtype::iterator _Next = _Myvec.begin();
			_Next != _Myvec.end(); ++_Next)
			*_Next = (_Vbase)~*_Next;
		_Trim(_Mysize);
		}

	void swap(_Myt& _Right)
		{	// exchange contents with right





		::std:: swap(_Mysize, _Right._Mysize);
		_Myvec.swap(_Right._Myvec);
		}

	static void swap(reference _Left, reference _Right)
		{	// swap _Left and _Right vector<bool> elements
		bool _Val = _Left;
		_Left = _Right;
		_Right = _Val;
		}

# 1994 "C:/usr/local/cell\\target\\ppu\\include/vector" 3

protected:
	void _Assign_n(size_type _Count, bool _Val)
		{	// assign _Count * _Val
		erase(begin(), end());
		_Insert_n(begin(), _Count, _Val);
		}

	void _Insert_n(iterator _Where,
		size_type _Count, bool _Val)
		{	// insert _Count * _Val at _Where
		size_type _Off = _Insert_x(_Where, _Count);
		::std:: fill(begin() + _Off, begin() + (_Off + _Count), _Val);
		}

	size_type _Insert_x(iterator _Where, size_type _Count)
		{	// make room to insert _Count elements at _Where
		size_type _Off = _Where - begin();







		if (_Count == 0)
			;
		else if (max_size() - size() < _Count)
			_Xlen();	// result too long
		else
			{	// worth doing
			_Myvec.resize(_Nw(size() + _Count), 0);
			if (size() == 0)
				_Mysize += _Count;
			else
				{	// make room and copy down suffix
				iterator _Oldend = end();
				_Mysize += _Count;
				::std:: copy_backward(begin() + _Off, _Oldend, end());
				}





			}
		return (_Off);
		}

	static size_type _Nw(size_type _Count)
		{	// return number of base words from number of bits
		return ((_Count + _VBITS - 1) / _VBITS);
		}

# 2069 "C:/usr/local/cell\\target\\ppu\\include/vector" 3

	void _Trim(size_type _Size)
		{	// trim base vector to exact length in bits
		if (max_size() < _Size)
			_Xlen();	// result too long
		size_type _Words = _Nw(_Size);

		if (_Words < _Myvec.size())
			_Myvec.erase(_Myvec.begin() + _Words, _Myvec.end());
		_Mysize = _Size;
		_Size %= _VBITS;
		if (0 < _Size)
			_Myvec[_Words - 1] &= (_Vbase)((1 << _Size) - 1);
		}

	void _Xlen() const
		{	// report a length_error
		length_error("vector<bool> too long"). _Raise();
		}

	void _Xran() const
		{	// throw an out_of_range error
		out_of_range("invalid vector<bool> subscript"). _Raise();
		}

	size_type _Mysize;	// current length of sequence
	_Vbtype _Myvec;	// base vector of words
	};

typedef vector<bool, allocator<bool> > _Bvector;









}


/*
 * Copyright (c) 1992-2003 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
 */

/*
 * This file is derived from software bearing the following
 * restrictions:
 *
 * Copyright (c) 1994
 * Hewlett-Packard Company
 *
 * Permission to use, copy, modify, distribute and sell this
 * software and its documentation for any purpose is hereby
 * granted without fee, provided that the above copyright notice
 * appear in all copies and that both that copyright notice and
 * this permission notice appear in supporting documentation.
 * Hewlett-Packard Company makes no representations about the
 * suitability of this software for any purpose. It is provided
 * "as is" without express or implied warranty.
V4.02:0216 */
# 14 "C:/usr/local/cell\\target\\ppu\\include/xhash" 3







namespace std {

		// TEMPLATE FUNCTION hash_value


template<class _Kty> inline
	size_t hash_value(const _Kty& _Keyval)
	{	// hash _Keyval to size_t value one-to-one
	return ((size_t)_Keyval ^ (size_t)0xdeadbeef);
	}

# 55 "C:/usr/local/cell\\target\\ppu\\include/xhash" 3
template <class _Init>
	inline size_t _Hash_value(_Init _Begin, _Init _End)
	{	// hash range of elements
	size_t _Val = 2166136261U;
	while(_Begin != _End)
		_Val = 16777619U * _Val ^ (size_t)*_Begin++;
	return (_Val);
	}

template<class _Elem,
	class _Traits,
	class _Alloc> inline
	size_t hash_value(const basic_string<_Elem, _Traits, _Alloc>& _Str)
	{	// hash string to size_t value
	return (_Hash_value(_Str.begin(), _Str.end()));
	}


inline size_t hash_value(const char *_Str)
	{	// hash NTBS to size_t value
	return (_Hash_value(_Str, _Str + ::std:: strlen(_Str)));
	}

inline size_t hash_value(const wchar_t *_Str)
	{	// hash NTWCS to size_t value
	return (_Hash_value(_Str, _Str + ::std:: wcslen(_Str)));
	}

		// TEMPLATE CLASS hash_compare
template<class _Kty,
	class _Pr = less<_Kty> >
	class hash_compare
	{	// traits class for hash containers
public:
	enum
		{	// parameters for hash table
		bucket_size = 4,	// 0 < bucket_size
		min_buckets = 8};	// min_buckets = 2 ^^ N, 0 < N

	hash_compare()
		: comp()
		{	// construct with default comparator
		}

	hash_compare(_Pr _Pred)
		: comp(_Pred)
		{	// construct with _Pred comparator
		}

	size_t operator()(const _Kty& _Keyval) const
		{	// hash _Keyval to size_t value by pseudorandomizing transform
		ldiv_t _Qrem = ldiv((long)hash_value(_Keyval), 127773L);
		_Qrem.rem = 16807 * _Qrem.rem - 2836 * _Qrem.quot;
		if (_Qrem.rem < 0)
			_Qrem.rem += 2147483647;
		return ((size_t)_Qrem.rem);
		}

	bool operator()(const _Kty& _Keyval1, const _Kty& _Keyval2) const
		{	// test if _Keyval1 ordered before _Keyval2
		return (comp(_Keyval1, _Keyval2));
		}

protected:
	_Pr comp;	// the comparator object
	};

# 179 "C:/usr/local/cell\\target\\ppu\\include/xhash" 3

		// TEMPLATE CLASS _Hash
template<class _Traits>
	class _Hash
		: public _Traits	// traits serves as base class
	{	// hash table -- list with vector of iterators for quick access
public:
	typedef _Hash<_Traits> _Myt;
	typedef typename _Traits::key_type key_type;
	typedef typename _Traits::key_compare key_compare;
	typedef typename _Traits::value_compare value_compare;
	enum
		{	// hoist constants from key_compare
		bucket_size = key_compare::bucket_size,
		min_buckets = key_compare::min_buckets,
		_Multi = _Traits::_Multi};
	typedef list<typename _Traits::value_type,
		typename _Traits::allocator_type> _Mylist;

	typedef typename _Mylist::allocator_type allocator_type;
	typedef typename _Mylist::size_type size_type;
	typedef typename _Mylist::difference_type difference_type;
	typedef typename _Mylist::pointer pointer;
	typedef typename _Mylist::const_pointer const_pointer;
	typedef typename _Mylist::reference reference;
	typedef typename _Mylist::const_reference const_reference;


	typedef typename _Mylist::iterator _Myiterator;
	typedef typename _Traits::_ITptr _ITptr;
	typedef typename _Traits::_IReft _IReft;

		// CLASS iterator
	class iterator
		: public _Myiterator
		{	// possibly non-mutable iterator
	public:
		typedef _ITptr pointer;
		typedef _IReft reference;

		iterator()
			{	// construct default iterator
			}

		iterator(const _Myiterator& _Iter)
			: _Myiterator(_Iter)
			{	// construct from _Myiterator
			}

		_IReft operator*() const
			{	// change to const_reference
			return ((_IReft)**(_Myiterator *)this);
			}

		_ITptr operator->() const
			{	// change to const_pointer
			return ((_ITptr)&**(_Myiterator *)this);
			}
		};





	typedef typename _Mylist::const_iterator const_iterator;
	typedef typename _Mylist::reverse_iterator
		reverse_iterator;
	typedef typename _Mylist::const_reverse_iterator
		const_reverse_iterator;
	typedef typename _Mylist::value_type value_type;

	typedef vector<iterator,
		typename allocator_type::template
			rebind<iterator>::other> _Myvec;
	typedef pair<iterator, bool> _Pairib;
	typedef pair<iterator, iterator> _Pairii;
	typedef pair<const_iterator, const_iterator> _Paircc;

	explicit _Hash(const key_compare& _Parg,
		const allocator_type& _Al)
		: _Traits(_Parg), _List(_Al),
			_Vec(min_buckets + 1, end(), _Al),
			_Mask(1), _Maxidx(1)
		{	// construct empty hash table
		}

	_Hash(const value_type *_First, const value_type *_Last,
		const key_compare& _Parg, const allocator_type& _Al)
		: _Traits(_Parg), _List(_Al),
			_Vec(min_buckets + 1, end(), _Al),
			_Mask(1), _Maxidx(1)
		{	// construct hash table from [_First, _Last) array
		insert(_First, _Last);
		}

	_Hash(const _Myt& _Right)
		: _Traits(_Right.comp), _List(_Right.get_allocator()),
			_Vec(_Right.get_allocator())
		{	// construct hash table by copying right
		_Copy(_Right);
		}

	~_Hash()
		{	// destroy hash table
		}

	_Myt& operator=(const _Myt& _Right)
		{	// replace contents from _Right
		if (this != &_Right)
			_Copy(_Right);
		return (*this);
		}

	iterator begin()
		{	// return iterator for beginning of mutable sequence
		return (_List.begin());
		}

	const_iterator begin() const
		{	// return iterator for beginning of nonmutable sequence
		return (_List.begin());
		}

	iterator end()
		{	// return iterator for end of mutable sequence
		return (_List.end());
		}

	const_iterator end() const
		{	// return iterator for end of nonmutable sequence
		return (_List.end());
		}

	reverse_iterator rbegin()
		{	// return iterator for beginning of reversed mutable sequence
		return (_List.rbegin());
		}

	const_reverse_iterator rbegin() const
		{	// return iterator for beginning of reversed nonmutable sequence
		return (_List.rbegin());
		}

	reverse_iterator rend()
		{	// return iterator for end of reversed mutable sequence
		return (_List.rend());
		}

	const_reverse_iterator rend() const
		{	// return iterator for end of reversed nonmutable sequence
		return (_List.rend());
		}

	size_type size() const
		{	// return length of sequence
		return (_List.size());
		}

	size_type max_size() const
		{	// return maximum possible length of sequence
		return (_List.max_size());
		}

	bool empty() const
		{	// return true only if sequence is empty
		return (_List.empty());
		}

	allocator_type get_allocator() const
		{	// return allocator object for values
		return (_List.get_allocator());
		}

	key_compare key_comp() const
		{	// return object for comparing keys
		return (this->comp);
		}

	value_compare value_comp() const
		{	// return object for comparing values
		return (value_compare(key_comp()));
		}

	_Pairib insert(const value_type& _Val)
		{	// try to insert node with value _Val
		iterator _Plist, _Where;
		if (_Maxidx <= size() / bucket_size)
			{	// too dense, need to grow hash table
			if (_Vec.size() - 1 <= _Maxidx)
				{	// table full, double its size
				_Mask = ((_Vec.size() - 1) << 1) - 1;
				_Vec.resize(_Mask + 2, end());
				}
			else if (_Mask < _Maxidx)
				_Mask = (_Mask << 1) + 1;

			size_type _Bucket = _Maxidx - (_Mask >> 1) - 1;
			for (_Plist = _Vec[_Bucket]; _Plist != _Vec[_Bucket + 1]; )
				{	// split old bucket
				size_type _Newbucket =
					this->comp(this->_Kfn(*_Plist)) & _Mask;
				if (_Newbucket == _Bucket)
					++_Plist;	// leave element in old bucket






				else
					{	// move element to new bucket
					size_type _Idx;
					iterator _Pnext = _Plist;
					if (++_Pnext != end())
						{	// not at end, move it
						for (_Idx = _Bucket; _Plist == _Vec[_Idx]; --_Idx)
							{	// update end iterators if moving first
							_Vec[_Idx] = _Pnext;
							if (_Idx == 0)
								break;
							}
						_List._Splice(end(), _List, _Plist, _Pnext, 0);
						_Plist = --end();
						_Vec[_Maxidx + 1] = end();
						}

					for (_Idx = _Maxidx; _Bucket < _Idx; --_Idx)
						{	// update end iterators if new bucket filled
						if (_Vec[_Idx] != end())
							break;
						_Vec[_Idx] = _Plist;
						}

					if (_Pnext == end())
						break;
					else
						_Plist = _Pnext;
					}
				}
			++_Maxidx;	// open new bucket for hash lookup
			}

		size_type _Bucket = _Hashval(this->_Kfn(_Val));
		for (_Plist = _Vec[_Bucket + 1]; _Plist != _Vec[_Bucket]; )
			if (this->comp(this->_Kfn(_Val), this->_Kfn(*--_Plist)))
				;	// still too high in bucket list
			else if (this->comp(this->_Kfn(*_Plist), this->_Kfn(_Val)))
				{	// found insertion point, back up to it
				++_Plist;
				break;
				}
			else if (_Multi)
				break;	// equivalent, insert only if multi
			else
				return (_Pairib(_Plist, false));	// already present

		_Where = _List.insert(_Plist, _Val);	// insert new element
		for (; _Plist == _Vec[_Bucket]; --_Bucket)
			{	// update end iterators if new first bucket element
			_Vec[_Bucket] = _Where;
			if (_Bucket == 0)
				break;
			}

		return (_Pairib(_Where, true));	// return iterator for new element
		}

	iterator insert(iterator, const value_type& _Val)
		{	// try to insert node with value _Val, ignore hint
		return (insert(_Val).first);
		}

	template<class _Iter>
		void insert(_Iter _First, _Iter _Last)
		{	// insert [_First, _Last) one at a time







		for (; _First != _Last; ++_First)
			insert(*_First);
		}

	iterator erase(iterator _Where)
		{	// erase element at _Where
		size_type _Bucket = _Hashval(this->_Kfn(*_Where));
		for (; _Where == _Vec[_Bucket]; --_Bucket)
			{	// update end iterators if erasing first
			++_Vec[_Bucket];
			if (_Bucket == 0)
				break;
			}
		return (_List.erase(_Where));
		}

	iterator erase(iterator _First, iterator _Last)
		{	// erase [_First, _Last)
		;
		if (_First == begin() && _Last == end())
			{	// erase all
			clear();
			return (begin());
			}
		else
			{	// partial erase, one at a time
			while (_First != _Last)
				erase(_First++);
			return (_First);
			}
		}

	size_type erase(const key_type& _Keyval)
		{	// erase and count all that match _Keyval
		_Pairii _Where = equal_range(_Keyval);
		size_type _Num = 0;
		_Distance(_Where.first, _Where.second, _Num);
		erase(_Where.first, _Where.second);
		return (_Num);
		}

	void erase(const key_type *_First,
		const key_type *_Last)
		{	// erase all that match array of keys [_First, _Last)
		;
		for (; _First != _Last; ++_First)
			erase(*_First);
		}

	void clear()
		{	// erase all
		_List.clear();
		_Vec.assign(min_buckets + 1, end());
		_Mask = 1;
		_Maxidx = 1;
		}

	iterator find(const key_type& _Keyval)
		{	// find an element in mutable hash table that matches _Keyval
		return (lower_bound(_Keyval));
		}

	const_iterator find(const key_type& _Keyval) const
		{	// find an element in nonmutable hash table that matches _Keyval
		return (lower_bound(_Keyval));
		}

	size_type count(const key_type& _Keyval) const
		{	// count all elements that match _Keyval
		_Paircc _Ans = equal_range(_Keyval);
		size_type _Num = 0;
		_Distance(_Ans.first, _Ans.second, _Num);
		return (_Num);
		}

	iterator lower_bound(const key_type& _Keyval)
		{	// find leftmost not less than _Keyval in mutable hash table
		size_type _Bucket = _Hashval(_Keyval);
		iterator _Where;
		for (_Where = _Vec[_Bucket]; _Where != _Vec[_Bucket + 1]; ++_Where)
			if (!this->comp(this->_Kfn(*_Where), _Keyval))
				return (this->comp(_Keyval,
					this->_Kfn(*_Where)) ? end() : _Where);
		return (end());
		}

	const_iterator lower_bound(const key_type& _Keyval) const
		{	// find leftmost not less than _Keyval in nonmutable hash table
		size_type _Bucket = _Hashval(_Keyval);
		const_iterator _Where;
		for (_Where = _Vec[_Bucket]; _Where != _Vec[_Bucket + 1]; ++_Where)
			if (!this->comp(this->_Kfn(*_Where), _Keyval))
				return (this->comp(_Keyval,
					this->_Kfn(*_Where)) ? end() : _Where);
		return (end());
		}

	iterator upper_bound(const key_type& _Keyval)
		{	// find leftmost not greater than _Keyval in mutable hash table
		size_type _Bucket = _Hashval(_Keyval);
		iterator _Where;
		for (_Where = _Vec[_Bucket + 1]; _Where != _Vec[_Bucket]; )
			if (!this->comp(_Keyval, this->_Kfn(*--_Where)))
				return (this->comp(this->_Kfn(*_Where),
					_Keyval) ? end() : (iterator)++_Where);
		return (end());
		}

	const_iterator upper_bound(const key_type& _Keyval) const
		{	// find leftmost not greater than _Keyval in nonmutable hash table
		size_type _Bucket = _Hashval(_Keyval);
		const_iterator _Where;
		for (_Where = _Vec[_Bucket + 1]; _Where != _Vec[_Bucket]; )
			if (!this->comp(_Keyval, this->_Kfn(*--_Where)))
				return (this->comp(this->_Kfn(*_Where),
					_Keyval) ? end() : (const_iterator)++_Where);
		return (end());
		}

	_Pairii equal_range(const key_type& _Keyval)
		{	// find range equivalent to _Keyval in mutable hash table
		size_type _Bucket = _Hashval(_Keyval);
		iterator _First, _Where;
		for (_Where = _Vec[_Bucket]; _Where != _Vec[_Bucket + 1]; ++_Where)
			if (!this->comp(this->_Kfn(*_Where), _Keyval))
				{	// found _First, look for end of range
				for (_First = _Where; _Where != _Vec[_Bucket + 1]; ++_Where)
					if (this->comp(_Keyval, this->_Kfn(*_Where)))
						break;
				if (_First == _Where)
					break;
				return (_Pairii(_First, _Where));
				}
		return (_Pairii(end(), end()));
		}

	_Paircc equal_range(const key_type& _Keyval) const
		{	// find range equivalent to _Keyval in nonmutable hash table
		size_type _Bucket = _Hashval(_Keyval);
		iterator _First, _Where;
		for (_Where = _Vec[_Bucket]; _Where != _Vec[_Bucket + 1]; ++_Where)
			if (!this->comp(this->_Kfn(*_Where), _Keyval))
				{	// found _First, look for end of range
				for (_First = _Where; _Where != _Vec[_Bucket + 1]; ++_Where)
					if (this->comp(_Keyval, this->_Kfn(*_Where)))
						break;
				if (_First == _Where)
					break;
				return (_Paircc(_First, _Where));
				}
		return (_Paircc(end(), end()));
		}

	void swap(_Myt& _Right)

# 622 "C:/usr/local/cell\\target\\ppu\\include/xhash" 3
		{	// exchange contents with _Right
		if (get_allocator() == _Right.get_allocator())
			{	// same allocator, swap control information
			_List.swap(_Right._List);
			::std:: swap(_Vec, _Right._Vec);
			::std:: swap(_Mask, _Right._Mask);
			::std:: swap(_Maxidx, _Right._Maxidx);
			::std:: swap(this->comp, _Right.comp);
			}
		else
			{	// different allocator, do multiple assigns
			_Myt _Tmp = *this; *this = _Right, _Right = _Tmp;
			}
		}


# 659 "C:/usr/local/cell\\target\\ppu\\include/xhash" 3

protected:
	void _Copy(const _Myt& _Right)
		{	// copy entire hash table
		_Vec.resize(_Right._Vec.size(), end());
		_Mask = _Right._Mask;
		_Maxidx = _Right._Maxidx;
		_List.clear();

		{{
		_List.insert(end(), _Right._List.begin(), _Right._List.end());
		this->comp = _Right.comp;
		} if (0) {
		_List.clear();	// list or compare copy failed, bail out
		::std:: fill(_Vec.begin(), _Vec.end(), end());
		;
		}}

		iterator _Whereto = begin();
		const_iterator _Wherefrom = _Right.begin();
		for (size_type _Bucket = 0; _Bucket < _Vec.size(); )
			if (_Wherefrom == _Right._Vec[_Bucket])
				_Vec[_Bucket] = _Whereto, ++_Bucket;
			else
				++_Whereto, ++_Wherefrom;
		}

	size_type _Hashval(const key_type& _Keyval) const
		{	// return hash value, masked and wrapped to current table size
		size_type _Num = this->comp(_Keyval) & _Mask;
		if (_Maxidx <= _Num)
			_Num -= (_Mask >> 1) + 1;
		return (_Num);
		}

	_Mylist _List;	// the list of elements, must initialize before _Vec
	_Myvec _Vec;	// the vector of list iterators
	size_type _Mask;	// the key mask
	size_type _Maxidx;	// current maximum key value
	};

		// _Hash TEMPLATE OPERATORS
template<class _Ty> inline
	bool operator==(const _Hash<_Ty>& _Left, const _Hash<_Ty>& _Right)
	{	// test for hash table equality
	return (_Left.size() == _Right.size()
		&& ::std:: equal(_Left.begin(), _Left.end(), _Right.begin()));
	}

template<class _Ty> inline
	bool operator!=(const _Hash<_Ty>& _Left, const _Hash<_Ty>& _Right)
	{	// test for hash table inequality
	return (!(_Left == _Right));
	}

template<class _Ty> inline
	bool operator<(const _Hash<_Ty>& _Left, const _Hash<_Ty>& _Right)
	{	// test if _Left < _Right for hash tables
	return (::std:: lexicographical_compare(_Left.begin(), _Left.end(),
		_Right.begin(), _Right.end()));
	}

template<class _Ty> inline
	bool operator>(const _Hash<_Ty>& _Left, const _Hash<_Ty>& _Right)
	{	// test if _Left > _Right for hash tables
	return (_Right < _Left);
	}

template<class _Ty> inline
	bool operator<=(const _Hash<_Ty>& _Left, const _Hash<_Ty>& _Right)
	{	// test if _Left <= _Right for hash tables
	return (!(_Right < _Left));
	}

template<class _Ty> inline
	bool operator>=(const _Hash<_Ty>& _Left, const _Hash<_Ty>& _Right)
	{	// test if _Left >= _Right for hash tables
	return (!(_Left < _Right));
	}
}

# 768 "C:/usr/local/cell\\target\\ppu\\include/xhash" 3



/*
 * Copyright (c) 1992-2003 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
V4.02:0216 */
# 5 "C:/usr/local/cell\\target\\ppu\\include/hash_map" 3
namespace std {

		// TEMPLATE CLASS _Hmap_traits
template<class _Kty,	// key type
	class _Ty,	// mapped type
	class _Tr,	// comparator predicate type
	class _Alloc,	// actual allocator type (should be value allocator)
	bool _Mfl>	// true if multiple equivalent keys are permitted
	class _Hmap_traits
		: public _Container_base
	{	// traits required to make _Hash behave like a map
public:
	typedef _Kty key_type;
	typedef pair<const _Kty, _Ty> value_type;
	typedef _Tr key_compare;
	typedef typename _Alloc::template rebind<value_type>::other
		allocator_type;


	typedef typename allocator_type::template rebind<value_type> ::other::pointer _ITptr;
	typedef typename allocator_type::template rebind<value_type> ::other::reference _IReft;


	enum
		{	// make multi parameter visible as an enum constant
		_Multi = _Mfl};

	_Hmap_traits()
		: comp()
		{	// construct with default comparator
		}

	_Hmap_traits(const _Tr& _Traits)
		: comp(_Traits)
		{	// construct with specified comparator
		}

	class value_compare
		: public binary_function<value_type, value_type, bool>
		{	// functor for comparing two element values
		friend class _Hmap_traits<_Kty, _Ty, _Tr, _Alloc, _Mfl>;

	public:
		bool operator()(const value_type& _Left,
			const value_type& _Right) const
			{	// test if _Left precedes _Right by comparing just keys
			return (comp(_Left.first, _Right.first));
			}

		value_compare(const key_compare& _Traits)
			: comp(_Traits)
			{	// construct with specified predicate
			}

	protected:
		key_compare comp;	// the comparator predicate for keys
		};

	static const _Kty& _Kfn(const value_type& _Val)
		{	// extract key from element value
		return (_Val.first);
		}

	_Tr comp;	// the comparator predicate for keys
	};

		// TEMPLATE CLASS hash_map
template<class _Kty,
	class _Ty,
	class _Tr = hash_compare<_Kty, less<_Kty> >,
	class _Alloc = allocator<pair<const _Kty, _Ty> > >
	class hash_map
		: public _Hash<_Hmap_traits<_Kty, _Ty, _Tr, _Alloc, false> >
	{	// hash table of {key, mapped} values, unique keys
public:
	typedef hash_map<_Kty, _Ty, _Tr, _Alloc> _Myt;
	typedef _Hash<_Hmap_traits<_Kty, _Ty, _Tr, _Alloc, false> > _Mybase;
	typedef _Kty key_type;
	typedef _Ty mapped_type;
	typedef _Ty referent_type;
	typedef _Tr key_compare;
	typedef typename _Mybase::value_compare value_compare;
	typedef typename _Mybase::allocator_type allocator_type;
	typedef typename _Mybase::size_type size_type;
	typedef typename _Mybase::difference_type difference_type;
	typedef typename _Mybase::pointer pointer;
	typedef typename _Mybase::const_pointer const_pointer;
	typedef typename _Mybase::reference reference;
	typedef typename _Mybase::const_reference const_reference;
	typedef typename _Mybase::iterator iterator;
	typedef typename _Mybase::const_iterator const_iterator;
	typedef typename _Mybase::reverse_iterator reverse_iterator;
	typedef typename _Mybase::const_reverse_iterator
		const_reverse_iterator;
	typedef typename _Mybase::value_type value_type;

	hash_map()
		: _Mybase(key_compare(), allocator_type())
		{	// construct empty map from defaults
		}

	explicit hash_map(const key_compare& _Traits)
		: _Mybase(_Traits, allocator_type())
		{	// construct empty map from comparator
		}

	hash_map(const key_compare& _Traits, const allocator_type& _Al)
		: _Mybase(_Traits, _Al)
		{	// construct empty map from comparator and allocator
		}

	template<class _Iter>
		hash_map(_Iter _First, _Iter _Last)
		: _Mybase(key_compare(), allocator_type())
		{	// construct map from sequence, defaults
		;
		for (; _First != _Last; ++_First)
			this->insert(*_First);
		}

	template<class _Iter>
		hash_map(_Iter _First, _Iter _Last,
			const key_compare& _Traits)
		: _Mybase(_Traits, allocator_type())
		{	// construct map from sequence, comparator
		;
		for (; _First != _Last; ++_First)
			this->insert(*_First);
		}

	template<class _Iter>
		hash_map(_Iter _First, _Iter _Last,
			const key_compare& _Traits,
			const allocator_type& _Al)
		: _Mybase(_Traits, _Al)
		{	// construct map from sequence, comparator, and allocator
		;
		for (; _First != _Last; ++_First)
			this->insert(*_First);
		}

	mapped_type& operator[](const key_type& _Keyval)
		{	// find element matching _Keyval or insert with default mapped
		iterator _Where = this->lower_bound(_Keyval);
		if (_Where == this->end())
			_Where = this->insert(value_type(_Keyval, mapped_type())).first;
		return ((*_Where).second);
		}
	};

template<class _Kty,
	class _Ty,
	class _Tr,
	class _Alloc> inline
	void swap(hash_map<_Kty, _Ty, _Tr, _Alloc>& _Left,
		hash_map<_Kty, _Ty, _Tr, _Alloc>& _Right)
	{	// swap _Left and _Right hash_maps
	_Left.swap(_Right);
	}

# 405 "C:/usr/local/cell\\target\\ppu\\include/hash_map" 3

		// TEMPLATE CLASS hash_multimap
template<class _Kty,
	class _Ty,
	class _Tr = hash_compare<_Kty, less<_Kty> >,
	class _Alloc = allocator<pair<const _Kty, _Ty> > >
	class hash_multimap
		: public _Hash<_Hmap_traits<_Kty, _Ty, _Tr, _Alloc, true> >
	{	// hash table of {key, mapped} values, non-unique keys
public:
	typedef hash_multimap<_Kty, _Ty, _Tr, _Alloc> _Myt;
	typedef _Hash<_Hmap_traits<_Kty, _Ty, _Tr, _Alloc, true> > _Mybase;
	typedef _Kty key_type;
	typedef _Ty mapped_type;
	typedef _Ty referent_type;	// old name, magically gone
	typedef _Tr key_compare;
	typedef typename _Mybase::value_compare value_compare;
	typedef typename _Mybase::allocator_type allocator_type;
	typedef typename _Mybase::size_type size_type;
	typedef typename _Mybase::difference_type difference_type;
	typedef typename _Mybase::pointer pointer;
	typedef typename _Mybase::const_pointer const_pointer;
	typedef typename _Mybase::reference reference;
	typedef typename _Mybase::const_reference const_reference;
	typedef typename _Mybase::iterator iterator;
	typedef typename _Mybase::const_iterator const_iterator;
	typedef typename _Mybase::reverse_iterator reverse_iterator;
	typedef typename _Mybase::const_reverse_iterator
		const_reverse_iterator;
	typedef typename _Mybase::value_type value_type;

	hash_multimap()
		: _Mybase(key_compare(), allocator_type())
		{	// construct empty map from defaults
		}

	explicit hash_multimap(const key_compare& _Traits)
		: _Mybase(_Traits, allocator_type())
		{	// construct empty map from comparator
		}

	hash_multimap(const key_compare& _Traits,
		const allocator_type& _Al)
		: _Mybase(_Traits, _Al)
		{	// construct empty map from comparator and allocator
		}

	template<class _Iter>
		hash_multimap(_Iter _First, _Iter _Last)
		: _Mybase(key_compare(), allocator_type())
		{	// construct map from sequence, defaults
		;
		for (; _First != _Last; ++_First)
			this->insert(*_First);
		}

	template<class _Iter>
		hash_multimap(_Iter _First, _Iter _Last,
			const key_compare& _Traits)
		: _Mybase(_Traits, allocator_type())
		{	// construct map from sequence, comparator
		;
		for (; _First != _Last; ++_First)
			this->insert(*_First);
		}

	template<class _Iter>
		hash_multimap(_Iter _First, _Iter _Last,
			const key_compare& _Traits,
			const allocator_type& _Al)
		: _Mybase(_Traits, _Al)
		{	// construct map from sequence, comparator, and allocator
		;
		for (; _First != _Last; ++_First)
			this->insert(*_First);
		}

	iterator insert(const value_type& _Val)
		{	// insert a {key, mapped} value
		return (_Mybase::insert(_Val).first);
		}

	iterator insert(iterator _Where, const value_type& _Val)
		{	// insert a {key, mapped} value, with hint
		return (_Mybase::insert(_Where, _Val));
		}

	template<class _Iter>
		void insert(_Iter _First, _Iter _Last)
		{	// insert [_First, _Last), arbitrary iterators







		for (; _First != _Last; ++_First)
			insert(*_First);
		}
	};

template<class _Kty,
	class _Ty,
	class _Tr,
	class _Alloc> inline
	void swap(hash_multimap<_Kty, _Ty, _Tr, _Alloc>& _Left,
		hash_multimap<_Kty, _Ty, _Tr, _Alloc>& _Right)
	{	// swap _Left and _Right hash_multimaps
	_Left.swap(_Right);
	}

# 777 "C:/usr/local/cell\\target\\ppu\\include/hash_map" 3

}


/*
 * Copyright (c) 1992-2003 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
V4.02:0216 */
# 44 "C:\\Users\\USER\\Documents\\Visual Studio 2013\\Projects\\mp3_plugin_PS3\\mp3_plugin_PS3\\main.cpp"
# 1 "C:/usr/local/cell\\target\\ppu\\include/hash_set" 3
// hash_set standard header



namespace std {

		// TEMPLATE CLASS _Hset_traits
template<class _Kty,	// key type (same as value type)
	class _Tr,	// comparator predicate type
	class _Alloc,	// actual allocator type (should be value allocator)
	bool _Mfl>	// true if multiple equivalent keys are permitted
	class _Hset_traits
		: public _Container_base
	{	// traits required to make _Hash behave like a set
public:
	typedef _Kty key_type;
	typedef _Kty value_type;
	typedef _Tr key_compare;
	typedef typename _Alloc::template rebind<value_type>::other
		allocator_type;


	typedef typename allocator_type::template rebind<value_type> ::other::const_pointer _ITptr;
	typedef typename allocator_type::template rebind<value_type> ::other::const_reference _IReft;


	enum
		{	// make multi parameter visible as an enum constant
		_Multi = _Mfl};

	_Hset_traits()
		: comp()
		{	// construct with default comparator
		}

	_Hset_traits(const _Tr& _Traits)
		: comp(_Traits)
		{	// construct with specified comparator
		}

	typedef key_compare value_compare;

	static const _Kty& _Kfn(const value_type& _Val)
		{	// return entire value as key
		return (_Val);
		}

	_Tr comp;	// the comparator predicate for keys
	};

		// TEMPLATE CLASS hash_set
template<class _Kty,
	class _Tr = hash_compare<_Kty, less<_Kty> >,
	class _Alloc = allocator<_Kty> >
	class hash_set
		: public _Hash<_Hset_traits<_Kty, _Tr, _Alloc, false> >
	{	// hash table of key values, unique keys
public:
	typedef hash_set<_Kty, _Tr, _Alloc> _Myt;
	typedef _Hash<_Hset_traits<_Kty, _Tr, _Alloc, false> > _Mybase;
	typedef _Kty key_type;
	typedef _Tr key_compare;
	typedef typename _Mybase::value_compare value_compare;
	typedef typename _Mybase::allocator_type allocator_type;
	typedef typename _Mybase::size_type size_type;
	typedef typename _Mybase::difference_type difference_type;
	typedef typename _Mybase::pointer pointer;
	typedef typename _Mybase::const_pointer const_pointer;
	typedef typename _Mybase::reference reference;
	typedef typename _Mybase::const_reference const_reference;
	typedef typename _Mybase::iterator iterator;
	typedef typename _Mybase::const_iterator const_iterator;
	typedef typename _Mybase::reverse_iterator reverse_iterator;
	typedef typename _Mybase::const_reverse_iterator
		const_reverse_iterator;
	typedef typename _Mybase::value_type value_type;

	hash_set()
		: _Mybase(key_compare(), allocator_type())
		{	// construct empty set from defaults
		}

	explicit hash_set(const key_compare& _Traits)
		: _Mybase(_Traits, allocator_type())
		{	// construct empty set from comparator
		}

	hash_set(const key_compare& _Traits, const allocator_type& _Al)
		: _Mybase(_Traits, _Al)
		{	// construct empty set from comparator and allocator
		}

	template<class _Iter>
		hash_set(_Iter _First, _Iter _Last)
		: _Mybase(key_compare(), allocator_type())
		{	// construct set from sequence, defaults
		;
		for (; _First != _Last; ++_First)
			this->insert(*_First);
		}

	template<class _Iter>
		hash_set(_Iter _First, _Iter _Last,
			const key_compare& _Traits)
		: _Mybase(_Traits, allocator_type())
		{	// construct set from sequence, comparator
		;
		for (; _First != _Last; ++_First)
			this->insert(*_First);
		}

	template<class _Iter>
		hash_set(_Iter _First, _Iter _Last,
			const key_compare& _Traits, const allocator_type& _Al)
		: _Mybase(_Traits, _Al)
		{	// construct set from sequence, comparator, and allocator
		;
		for (; _First != _Last; ++_First)
			this->insert(*_First);
		}
	};

template<class _Kty,
	class _Tr,
	class _Alloc> inline
	void swap(hash_set<_Kty, _Tr, _Alloc>& _Left,
		hash_set<_Kty, _Tr, _Alloc>& _Right)
	{	// swap _Left and _Right hash_sets
	_Left.swap(_Right);
	}

# 350 "C:/usr/local/cell\\target\\ppu\\include/hash_set" 3

		// TEMPLATE CLASS hash_multiset
template<class _Kty,
	class _Tr = hash_compare<_Kty, less<_Kty> >,
	class _Alloc = allocator<_Kty> >
	class hash_multiset
		: public _Hash<_Hset_traits<_Kty, _Tr, _Alloc, true> >
	{	// hash table of key values, non-unique keys
public:
	typedef hash_multiset<_Kty, _Tr, _Alloc> _Myt;
	typedef _Hash<_Hset_traits<_Kty, _Tr, _Alloc, true> > _Mybase;
	typedef _Kty key_type;
	typedef _Tr key_compare;
	typedef typename _Mybase::value_compare value_compare;
	typedef typename _Mybase::allocator_type allocator_type;
	typedef typename _Mybase::size_type size_type;
	typedef typename _Mybase::difference_type difference_type;
	typedef typename _Mybase::pointer pointer;
	typedef typename _Mybase::const_pointer const_pointer;
	typedef typename _Mybase::reference reference;
	typedef typename _Mybase::const_reference const_reference;
	typedef typename _Mybase::iterator iterator;
	typedef typename _Mybase::const_iterator const_iterator;
	typedef typename _Mybase::reverse_iterator reverse_iterator;
	typedef typename _Mybase::const_reverse_iterator
		const_reverse_iterator;
	typedef typename _Mybase::value_type value_type;

	hash_multiset()
		: _Mybase(key_compare(), allocator_type())
		{	// construct empty set from defaults
		}

	explicit hash_multiset(const key_compare& _Traits)
		: _Mybase(_Traits, allocator_type())
		{	// construct empty set from comparator
		}

	hash_multiset(const key_compare& _Traits,
		const allocator_type& _Al)
		: _Mybase(_Traits, _Al)
		{	// construct empty set from comparator and allocator
		}

	template<class _Iter>
		hash_multiset(_Iter _First, _Iter _Last)
		: _Mybase(key_compare(), allocator_type())
		{	// construct from sequence, defaults
		;
		for (; _First != _Last; ++_First)
			this->insert(*_First);
		}

	template<class _Iter>
		hash_multiset(_Iter _First, _Iter _Last,
			const key_compare& _Traits)
		: _Mybase(_Traits, allocator_type())
		{	// construct from sequence, comparator
		;
		for (; _First != _Last; ++_First)
			this->insert(*_First);
		}

	template<class _Iter>
		hash_multiset(_Iter _First, _Iter _Last,
			const key_compare& _Traits, const allocator_type& _Al)
		: _Mybase(_Traits, _Al)
		{	// construct from sequence, comparator, and allocator
		;
		for (; _First != _Last; ++_First)
			this->insert(*_First);
		}

	iterator insert(const value_type& _Val)
		{	// insert a key value
		return (_Mybase::insert(_Val).first);
		}

	iterator insert(iterator _Where, const value_type& _Val)
		{	// insert a key value, with hint
		return (_Mybase::insert(_Where, _Val));
		}

	template<class _Iter>
		void insert(_Iter _First, _Iter _Last)
		{	// insert [_First, _Last), arbitrary iterators







		for (; _First != _Last; ++_First)
			insert(*_First);
		}
	};

template<class _Kty,
	class _Tr,
	class _Alloc> inline
	void swap(hash_multiset<_Kty, _Tr, _Alloc>& _Left,
		hash_multiset<_Kty, _Tr, _Alloc>& _Right)
	{	// swap _Left and _Right hash_multisets
	_Left.swap(_Right);
	}

# 711 "C:/usr/local/cell\\target\\ppu\\include/hash_set" 3

}


/*
 * Copyright (c) 1992-2003 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
V4.02:0216 */
# 45 "C:\\Users\\USER\\Documents\\Visual Studio 2013\\Projects\\mp3_plugin_PS3\\mp3_plugin_PS3\\main.cpp"
# 1 "C:/usr/local/cell\\target\\ppu\\include/map" 3
// map standard header
# 1 "C:/usr/local/cell\\target\\ppu\\include/xtree" 3
/* SCE CONFIDENTIAL
 PlayStation(R)3 Programmer Tool Runtime Library 475.001
 * Copyright (C) 2011 Sony Computer Entertainment Inc.
 * All Rights Reserved.
 */
// xtree internal header
# 13 "C:/usr/local/cell\\target\\ppu\\include/xtree" 3
namespace std {

		// TEMPLATE CLASS _Tree_nod
template<class _Traits>
	class _Tree_nod
		: public _Traits	// traits form ultimate base
	{	// base class for _Tree_ptr to hold allocator _Alnod
protected:
	struct _Node;
	friend struct _Node;

	typedef typename _Traits::allocator_type allocator_type;
	typedef typename _Traits::key_compare key_compare;
	typedef typename _Traits::value_type value_type;





	typedef typename allocator_type::template
		rebind<_Node>::other::pointer _Genptr;


	struct _Node
		{	// tree node
		_Node(_Genptr _Larg, _Genptr _Parg, _Genptr _Rarg,
			const value_type& _Val, char _Carg)
			: _Left(_Larg), _Parent(_Parg), _Right(_Rarg),
				_Myval(_Val), _Color(_Carg), _Isnil(false)
			{	// construct a node with value
			}

		_Genptr _Left;	// left subtree, or smallest element if head
		_Genptr _Parent;	// parent, or root of tree if head
		_Genptr _Right;	// right subtree, or largest element if head
		value_type _Myval;	// the stored value, unused if head
		char _Color;	// _Red or _Black, _Black if head
		char _Isnil;	// true only if head (also nil) node
		};

	_Tree_nod(const key_compare& _Parg,
		allocator_type _Al)
		: _Traits(_Parg), _Alnod(_Al)
		{	// construct traits from _Parg and allocator from _Al
		}

	typename allocator_type::template rebind<_Node>::other
		_Alnod;	// allocator object for nodes
	};

		// TEMPLATE CLASS _Tree_ptr
template<class _Traits>
	class _Tree_ptr
		: public _Tree_nod<_Traits>
	{	// base class for _Tree_val to hold allocator _Alptr
public:
	typedef typename _Tree_nod<_Traits>::_Node _Node;
	typedef typename _Traits::allocator_type allocator_type;
	typedef typename _Traits::key_compare key_compare;
	typedef typename allocator_type::template
		rebind<_Node>::other::pointer _Nodeptr;

	_Tree_ptr(const key_compare& _Parg,
		allocator_type _Al)
		: _Tree_nod<_Traits>(_Parg, _Al), _Alptr(_Al)
		{	// construct base, and allocator from _Al
		}

	typename allocator_type::template rebind<_Nodeptr>::other
		_Alptr;	// allocator object for pointers to nodes
	};

		// TEMPLATE CLASS _Tree_val
template<class _Traits>
	class _Tree_val
		: public _Tree_ptr<_Traits>
	{	// base class for _Tree to hold allocator _Alval
protected:
	typedef typename _Traits::allocator_type allocator_type;
	typedef typename _Traits::key_compare key_compare;

	_Tree_val(const key_compare& _Parg,
		allocator_type _Al)
		: _Tree_ptr<_Traits>(_Parg, _Al), _Alval(_Al)
		{	// construct base, and allocator from _Al
		}

	allocator_type _Alval;	// allocator object for values stored in nodes
	};

		// TEMPLATE CLASS _Tree
template<class _Traits>
	class _Tree
		: public _Tree_val<_Traits>
	{	// ordered red-black tree for [multi_]{map set}
public:
	typedef _Tree<_Traits> _Myt;
	typedef _Tree_val<_Traits> _Mybase;
	typedef typename _Traits::key_type key_type;
	typedef typename _Traits::key_compare key_compare;
	typedef typename _Traits::value_compare value_compare;
	typedef typename _Traits::value_type value_type;
	typedef typename _Traits::allocator_type allocator_type;
	typedef typename _Traits::_ITptr _ITptr;
	typedef typename _Traits::_IReft _IReft;

protected:





	typedef typename _Tree_nod<_Traits>::_Genptr _Genptr;


	typedef typename _Tree_nod<_Traits>::_Node _Node;

	enum _Redbl
		{	// colors for link to parent
		_Red, _Black};
	typedef typename allocator_type::template rebind<_Node> ::other::pointer _Nodeptr;
	typedef typename allocator_type::template rebind<_Nodeptr> ::other::reference _Nodepref;
	typedef typename allocator_type::template rebind<key_type> ::other::const_reference _Keyref;
	typedef typename allocator_type::template rebind<char> ::other::reference _Charref;
	typedef typename allocator_type::template rebind<value_type> ::other::reference _Vref;

	static _Charref _Color(_Nodeptr _Pnode)
		{	// return reference to color in node
		return ((_Charref)(*_Pnode)._Color);
		}

	static _Charref _Isnil(_Nodeptr _Pnode)
		{	// return reference to nil flag in node
		return ((_Charref)(*_Pnode)._Isnil);
		}

	static _Keyref _Key(_Nodeptr _Pnode)
		{	// return reference to key in node
		return (_Mybase::_Kfn(_Myval(_Pnode)));
		}

	static _Nodepref _Left(_Nodeptr _Pnode)
		{	// return reference to left pointer in node
		return ((_Nodepref)(*_Pnode)._Left);
		}

	static _Nodepref _Parent(_Nodeptr _Pnode)
		{	// return reference to parent pointer in node
		return ((_Nodepref)(*_Pnode)._Parent);
		}

	static _Nodepref _Right(_Nodeptr _Pnode)
		{	// return reference to right pointer in node
		return ((_Nodepref)(*_Pnode)._Right);
		}

	static _Vref _Myval(_Nodeptr _Pnode)
		{	// return reference to value in node
		return ((_Vref)(*_Pnode)._Myval);
		}

public:
	typedef typename allocator_type::size_type size_type;
	typedef typename allocator_type::difference_type _Dift;
	typedef _Dift difference_type;
	typedef typename allocator_type::template rebind<value_type> ::other::pointer _Tptr;
	typedef typename allocator_type::template rebind<value_type> ::other::const_pointer _Ctptr;
	typedef typename allocator_type::template rebind<value_type> ::other::reference _Reft;
	typedef _Tptr pointer;
	typedef _Ctptr const_pointer;
	typedef _Reft reference;
	typedef typename allocator_type::template rebind<value_type> ::other::const_reference
		const_reference;

		// CLASS const_iterator
	class const_iterator;
	friend class const_iterator;

	class const_iterator
		: public _Bidit<value_type, _Dift, _Ctptr, const_reference>
	{	// iterator for nonmutable _Tree
	public:
		friend class _Tree<_Traits>;
		typedef bidirectional_iterator_tag iterator_category;
		typedef _Dift difference_type;
		typedef _Ctptr pointer;
		typedef const_reference reference;

		const_iterator()
			: _Ptr(0)
			{	// construct with null node pointer
			}

# 217 "C:/usr/local/cell\\target\\ppu\\include/xtree" 3

		const_iterator(_Nodeptr _Pnode)
			: _Ptr(_Pnode)
			{	// construct with node pointer _Pnode
			}


		const_reference operator*() const
			{	// return designated value







			return (_Myval(_Ptr));
			}

		_Ctptr operator->() const
			{	// return pointer to class object
			return (&**this);
			}

		const_iterator& operator++()
			{	// preincrement
			_Inc();
			return (*this);
			}

		const_iterator operator++(int)
			{	// postincrement
			const_iterator _Tmp = *this;
			++*this;
			return (_Tmp);
			}

		const_iterator& operator--()
			{	// predecrement
			_Dec();
			return (*this);
			}

		const_iterator operator--(int)
			{	// postdecrement
			const_iterator _Tmp = *this;
			--*this;
			return (_Tmp);
			}

		bool operator==(const const_iterator& _RightArg) const
			{	// test for iterator equality






			return (_Ptr == _RightArg._Ptr);
			}

		bool operator!=(const const_iterator& _RightArg) const
			{	// test for iterator inequality
			return (!(*this == _RightArg));
			}

		void _Dec()
			{	// move to node with next smaller value






			if (_Isnil(_Ptr))
				_Ptr = _Right(_Ptr);	// end() ==> rightmost
			else if (!_Isnil(_Left(_Ptr)))
				_Ptr = _Max(_Left(_Ptr));	// ==> largest of left subtree
			else
				{	// climb looking for left subtree
				_Nodeptr _Pnode;
				while (!_Isnil(_Pnode = _Parent(_Ptr))
					&& _Ptr == _Left(_Pnode))
					_Ptr = _Pnode;	// ==> parent while left subtree

# 308 "C:/usr/local/cell\\target\\ppu\\include/xtree" 3
				if (!_Isnil(_Pnode))


					_Ptr = _Pnode;	// ==> parent if not head
				}
			}

		void _Inc()
			{	// move to node with next larger value






			if (_Isnil(_Ptr))
				;	// end() shouldn't be incremented, don't move


			else if (!_Isnil(_Right(_Ptr)))
				_Ptr = _Min(_Right(_Ptr));	// ==> smallest of right subtree
			else
				{	// climb looking for right subtree
				_Nodeptr _Pnode;
				while (!_Isnil(_Pnode = _Parent(_Ptr))
					&& _Ptr == _Right(_Pnode))
					_Ptr = _Pnode;	// ==> parent while right subtree
				_Ptr = _Pnode;	// ==> parent (head if end())
				}
			}

		_Nodeptr _Mynode() const
			{	// return node pointer
			return (_Ptr);
			}

protected:
		_Nodeptr _Ptr;	// pointer to node
		};

		// CLASS iterator
	class iterator;
	friend class iterator;

	class iterator
		: public const_iterator
	{	// iterator for mutable _Tree
	public:
		typedef bidirectional_iterator_tag iterator_category;
		typedef _Dift difference_type;
		typedef _ITptr pointer;
		typedef _IReft reference;

		iterator()
			{	// construct with null node pointer
			}

# 375 "C:/usr/local/cell\\target\\ppu\\include/xtree" 3

		iterator(_Nodeptr _Pnode)
			: const_iterator(_Pnode)
			{	// construct with node pointer _Pnode
			}


		reference operator*() const
			{	// return designated value
			return ((reference)**(const_iterator *)this);
			}

		pointer operator->() const
			{	// return pointer to class object
			return (&**this);
			}

		iterator& operator++()
			{	// preincrement
			++(*(const_iterator *)this);
			return (*this);
			}

		iterator operator++(int)
			{	// postincrement
			iterator _Tmp = *this;
			++*this;
			return (_Tmp);
			}

		iterator& operator--()
			{	// predecrement
			--(*(const_iterator *)this);
			return (*this);
			}

		iterator operator--(int)
			{	// postdecrement
			iterator _Tmp = *this;
			--*this;
			return (_Tmp);
			}
		};

	typedef ::std:: reverse_iterator<iterator> reverse_iterator;
	typedef ::std:: reverse_iterator<const_iterator> const_reverse_iterator;
	typedef pair<iterator, bool> _Pairib;
	typedef pair<iterator, iterator> _Pairii;
	typedef pair<const_iterator, const_iterator> _Paircc;

	explicit _Tree(const key_compare& _Parg,
		const allocator_type& _Al)
		: _Mybase(_Parg, _Al)
		{	// construct empty tree
		_Init();
		}

	_Tree(const value_type *_First, const value_type *_Last,
		const key_compare& _Parg, const allocator_type& _Al)
		: _Mybase(_Parg, _Al)
		{	// construct tree from [_First, _Last) array
		_Init();
		{{
		insert(_First, _Last);
		} if (0) {
		_Tidy();
		;
		}}
		}

	_Tree(const _Myt& _RightArg)
		: _Mybase(_RightArg.key_comp(), _RightArg.get_allocator())
		{	// construct tree by copying _RightArg
		_Init();
		{{
		_Copy(_RightArg);
		} if (0) {
		_Tidy();
		;
		}}
		}

	~_Tree()
		{	// destroy tree
		_Tidy();
		}

	_Myt& operator=(const _Myt& _RightArg)
		{	// replace contents from _RightArg
		if (this != &_RightArg)
			{	// worth doing
			erase(begin(), end());
			this->comp = _RightArg.comp;
			_Copy(_RightArg);
			}
		return (*this);
		}

	iterator begin()
		{	// return iterator for beginning of mutable sequence
		return (iterator(_Lmost()));
		}

	const_iterator begin() const
		{	// return iterator for beginning of nonmutable sequence
		return (const_iterator(_Lmost()));
		}

	iterator end()
		{	// return iterator for end of mutable sequence
		return (iterator(_Myhead));
		}

	const_iterator end() const
		{	// return iterator for end of nonmutable sequence
		return (const_iterator(_Myhead));
		}

	reverse_iterator rbegin()
		{	// return iterator for beginning of reversed mutable sequence
		return (reverse_iterator(end()));
		}

	const_reverse_iterator rbegin() const
		{	// return iterator for beginning of reversed nonmutable sequence
		return (const_reverse_iterator(end()));
		}

	reverse_iterator rend()
		{	// return iterator for end of reversed mutable sequence
		return (reverse_iterator(begin()));
		}

	const_reverse_iterator rend() const
		{	// return iterator for end of reversed nonmutable sequence
		return (const_reverse_iterator(begin()));
		}

	size_type size() const
		{	// return length of sequence
		return (_Mysize);
		}

	size_type max_size() const
		{	// return maximum possible length of sequence
		return (this->_Alval.max_size());
		}

	bool empty() const
		{	// return true only if sequence is empty
		return (size() == 0);
		}

	allocator_type get_allocator() const
		{	// return allocator object for values
		return (this->_Alval);
		}

	key_compare key_comp() const
		{	// return object for comparing keys
		return (this->comp);
		}

	value_compare value_comp() const
		{	// return object for comparing values
		return (value_compare(key_comp()));
		}

	_Pairib insert(const value_type& _Val)
		{	// try to insert node with value _Val
		_Nodeptr _Trynode = _Root();
		_Nodeptr _Wherenode = _Myhead;
		bool _Addleft = true;	// add to left of head if tree empty
		while (!_Isnil(_Trynode))
			{	// look for leaf to insert before (_Addleft) or after
			_Wherenode = _Trynode;
			_Addleft = this->comp(this->_Kfn(_Val), _Key(_Trynode));

			_Trynode = _Addleft ? _Left(_Trynode) : _Right(_Trynode);
			}

		if (this->_Multi)
			return (_Pairib(_Insert(_Addleft, _Wherenode, _Val), true));
		else
			{	// insert only if unique
			iterator _Where = iterator(_Wherenode);
			if (!_Addleft)
				;	// need to test if insert after is okay
			else if (_Where == begin())
				return (_Pairib(_Insert(true, _Wherenode, _Val), true));
			else
				--_Where;	// need to test if insert before is okay

			if (this->comp(_Key(_Where . _Mynode()), this->_Kfn(_Val)))

				return (_Pairib(_Insert(_Addleft, _Wherenode, _Val), true));
			else
				return (_Pairib(_Where, false));
			}
		}

	iterator insert(iterator _Where,
		const value_type& _Val)
		{	// try to insert node with value _Val using _Where as a hint






		iterator _Next;

		if (size() == 0)
			return (_Insert(true, _Myhead, _Val));	// insert into empty tree
		else if (this->_Multi)
			{	// insert even if duplicate
			if (_Where == begin())
				{	// insert at beginning if before first element
				if (!this->comp(_Key(_Where . _Mynode()), this->_Kfn(_Val)))

					return (_Insert(true, _Where._Mynode(), _Val));
				}
			else if (_Where == end())
				{	// insert at end if after last element
				if (!this->comp(this->_Kfn(_Val), _Key(_Rmost())))

					return (_Insert(false, _Rmost(), _Val));
				}
			else if (!this->comp(_Key(_Where . _Mynode()), this->_Kfn(_Val))

				&& !this->comp(this->_Kfn(_Val), _Key((--(_Next = _Where)). _Mynode())))

				{	// insert before _Where
				if (_Isnil(_Right(_Next._Mynode())))
					return (_Insert(false, _Next._Mynode(), _Val));
				else
					return (_Insert(true, _Where._Mynode(), _Val));
				}
			else if (!this->comp(this->_Kfn(_Val), _Key(_Where . _Mynode()))

				&& (++(_Next = _Where) == end()
					|| !this->comp(_Key(_Next . _Mynode()), this->_Kfn(_Val))))

				{	// insert after _Where
				if (_Isnil(_Right(_Where._Mynode())))
					return (_Insert(false, _Where._Mynode(), _Val));
				else
					return (_Insert(true, _Next._Mynode(), _Val));
				}
			}
		else
			{	// insert only if unique
			if (_Where == begin())
				{	// insert at beginning if before first element
				if (this->comp(this->_Kfn(_Val), _Key(_Where . _Mynode())))

					return (_Insert(true, _Where._Mynode(), _Val));
				}
			else if (_Where == end())
				{	// insert at end if after last element
				if (this->comp(_Key(_Rmost()), this->_Kfn(_Val)))

					return (_Insert(false, _Rmost(), _Val));
				}
			else if (this->comp(this->_Kfn(_Val), _Key(_Where . _Mynode()))

				&& this->comp(_Key((--(_Next = _Where)). _Mynode()), this->_Kfn(_Val)))

				{	// insert before _Where
				if (_Isnil(_Right(_Next._Mynode())))
					return (_Insert(false, _Next._Mynode(), _Val));
				else
					return (_Insert(true, _Where._Mynode(), _Val));
				}
			else if (this->comp(_Key(_Where . _Mynode()), this->_Kfn(_Val))

				&& (++(_Next = _Where) == end()
					|| this->comp(this->_Kfn(_Val), _Key(_Next . _Mynode()))))

				{	// insert after _Where
				if (_Isnil(_Right(_Where._Mynode())))
					return (_Insert(false, _Where._Mynode(), _Val));
				else
					return (_Insert(true, _Next._Mynode(), _Val));
				}
			}

		return (insert(_Val).first);	// try usual insert if all else fails
		}

	template<class _Iter>
		void insert(_Iter _First, _Iter _Last)
		{	// insert [_First, _Last) one at a time







		for (; _First != _Last; ++_First)
			insert(*_First);
		}

	iterator erase(iterator _Where)
		{	// erase element at _Where

# 690 "C:/usr/local/cell\\target\\ppu\\include/xtree" 3
		if (_Isnil(_Where._Mynode()))
			out_of_range("invalid map/set<T> iterator"). _Raise();
		_Nodeptr _Erasednode = _Where._Mynode();	// node to erase
		++_Where;	// save successor iterator for return


		_Nodeptr _Fixnode;	// the node to recolor as needed
		_Nodeptr _Fixnodeparent;	// parent of _Fixnode (which may be nil)
		_Nodeptr _Pnode = _Erasednode;

		if (_Isnil(_Left(_Pnode)))
			_Fixnode = _Right(_Pnode);	// must stitch up right subtree
		else if (_Isnil(_Right(_Pnode)))
			_Fixnode = _Left(_Pnode);	// must stitch up left subtree
		else
			{	// two subtrees, must lift successor node to replace erased
			_Pnode = _Where._Mynode();	// _Pnode is successor node
			_Fixnode = _Right(_Pnode);	// _Fixnode is its only subtree
			}

		if (_Pnode == _Erasednode)
			{	// at most one subtree, relink it
			_Fixnodeparent = _Parent(_Erasednode);
			if (!_Isnil(_Fixnode))
				_Parent(_Fixnode) = _Fixnodeparent;	// link up

			if (_Root() == _Erasednode)
				_Root() = _Fixnode;	// link down from root
			else if (_Left(_Fixnodeparent) == _Erasednode)
				_Left(_Fixnodeparent) = _Fixnode;	// link down to left
			else
				_Right(_Fixnodeparent) = _Fixnode;	// link down to right

			if (_Lmost() == _Erasednode)
				_Lmost() = _Isnil(_Fixnode)
					? _Fixnodeparent	// smallest is parent of erased node
					: _Min(_Fixnode);	// smallest in relinked subtree

			if (_Rmost() == _Erasednode)
				_Rmost() = _Isnil(_Fixnode)
					? _Fixnodeparent	// largest is parent of erased node
					: _Max(_Fixnode);	// largest in relinked subtree
			}
		else
			{	// erased has two subtrees, _Pnode is successor to erased
			_Parent(_Left(_Erasednode)) = _Pnode;	// link left up
			_Left(_Pnode) = _Left(_Erasednode);	// link successor down

			if (_Pnode == _Right(_Erasednode))
				_Fixnodeparent = _Pnode;	// successor is next to erased
			else
				{	// successor further down, link in place of erased
				_Fixnodeparent = _Parent(_Pnode);	// parent is successor's
				if (!_Isnil(_Fixnode))
					_Parent(_Fixnode) = _Fixnodeparent;	// link fix up
				_Left(_Fixnodeparent) = _Fixnode;	// link fix down
				_Right(_Pnode) = _Right(_Erasednode);	// link successor down
				_Parent(_Right(_Erasednode)) = _Pnode;	// link right up
				}

			if (_Root() == _Erasednode)
				_Root() = _Pnode;	// link down from root
			else if (_Left(_Parent(_Erasednode)) == _Erasednode)
				_Left(_Parent(_Erasednode)) = _Pnode;	// link down to left
			else
				_Right(_Parent(_Erasednode)) = _Pnode;	// link down to right

			_Parent(_Pnode) = _Parent(_Erasednode);	// link successor up
			::std:: swap(_Color(_Pnode), _Color(_Erasednode));	// recolor it
			}

		if (_Color(_Erasednode) == _Black)
			{	// erasing black link, must recolor/rebalance tree
			for (; _Fixnode != _Root() && _Color(_Fixnode) == _Black;
				_Fixnodeparent = _Parent(_Fixnode))
				if (_Fixnode == _Left(_Fixnodeparent))
					{	// fixup left subtree
					_Pnode = _Right(_Fixnodeparent);
					if (_Color(_Pnode) == _Red)
						{	// rotate red up from right subtree
						_Color(_Pnode) = _Black;
						_Color(_Fixnodeparent) = _Red;
						_Lrotate(_Fixnodeparent);
						_Pnode = _Right(_Fixnodeparent);
						}

					if (_Isnil(_Pnode))
						_Fixnode = _Fixnodeparent;	// shouldn't happen
					else if (_Color(_Left(_Pnode)) == _Black
						&& _Color(_Right(_Pnode)) == _Black)
						{	// redden right subtree with black children
						_Color(_Pnode) = _Red;
						_Fixnode = _Fixnodeparent;
						}
					else
						{	// must rearrange right subtree
						if (_Color(_Right(_Pnode)) == _Black)
							{	// rotate red up from left sub-subtree
							_Color(_Left(_Pnode)) = _Black;
							_Color(_Pnode) = _Red;
							_Rrotate(_Pnode);
							_Pnode = _Right(_Fixnodeparent);
							}

						_Color(_Pnode) = _Color(_Fixnodeparent);
						_Color(_Fixnodeparent) = _Black;
						_Color(_Right(_Pnode)) = _Black;
						_Lrotate(_Fixnodeparent);
						break;	// tree now recolored/rebalanced
						}
					}
				else
					{	// fixup right subtree
					_Pnode = _Left(_Fixnodeparent);
					if (_Color(_Pnode) == _Red)
						{	// rotate red up from left subtree
						_Color(_Pnode) = _Black;
						_Color(_Fixnodeparent) = _Red;
						_Rrotate(_Fixnodeparent);
						_Pnode = _Left(_Fixnodeparent);
						}
					if (_Isnil(_Pnode))
						_Fixnode = _Fixnodeparent;	// shouldn't happen
					else if (_Color(_Right(_Pnode)) == _Black
						&& _Color(_Left(_Pnode)) == _Black)
						{	// redden left subtree with black children
						_Color(_Pnode) = _Red;
						_Fixnode = _Fixnodeparent;
						}
					else
						{	// must rearrange left subtree
						if (_Color(_Left(_Pnode)) == _Black)
							{	// rotate red up from right sub-subtree
							_Color(_Right(_Pnode)) = _Black;
							_Color(_Pnode) = _Red;
							_Lrotate(_Pnode);
							_Pnode = _Left(_Fixnodeparent);
							}

						_Color(_Pnode) = _Color(_Fixnodeparent);
						_Color(_Fixnodeparent) = _Black;
						_Color(_Left(_Pnode)) = _Black;
						_Rrotate(_Fixnodeparent);
						break;	// tree now recolored/rebalanced
						}
					}

			_Color(_Fixnode) = _Black;	// ensure stopping node is black
			}

		this->_Alnod.destroy(_Erasednode);	// destroy, free erased node
		this->_Alnod.deallocate(_Erasednode, 1);
		if (0 < _Mysize)
			--_Mysize;

		return (_Where);	// return successor iterator
		}

	iterator erase(iterator _First, iterator _Last)
		{	// erase [_First, _Last)
		if (_First == begin() && _Last == end())
			{	// erase all
			clear();
			return (begin());
			}
		else
			{	// partial erase, one at a time
			while (_First != _Last)
				erase(_First++);
			return (_First);
			}
		}

	size_type erase(const key_type& _Keyval)
		{	// erase and count all that match _Keyval
		_Pairii _Where = equal_range(_Keyval);
		size_type _Num = 0;
		_Distance(_Where.first, _Where.second, _Num);
		erase(_Where.first, _Where.second);
		return (_Num);
		}

	void erase(const key_type *_First, const key_type *_Last)
		{	// erase all that match array of keys [_First, _Last)
		;
		while (_First != _Last)
			erase(*_First++);
		}

	void clear()
		{	// erase all





		_Erase(_Root());
		_Root() = _Myhead, _Mysize = 0;
		_Lmost() = _Myhead, _Rmost() = _Myhead;
		}

	iterator find(const key_type& _Keyval)
		{	// find an element in mutable sequence that matches _Keyval
		iterator _Where = lower_bound(_Keyval);
		return (_Where == end()
			|| this->comp(_Keyval, _Key(_Where . _Mynode()))

					? end() : _Where);
		}

	const_iterator find(const key_type& _Keyval) const
		{	// find an element in nonmutable sequence that matches _Keyval
		const_iterator _Where = lower_bound(_Keyval);
		return (_Where == end()
			|| this->comp(_Keyval, _Key(_Where . _Mynode()))

					? end() : _Where);
		}

	size_type count(const key_type& _Keyval) const
		{	// count all elements that match _Keyval
		_Paircc _Ans = equal_range(_Keyval);
		size_type _Num = 0;
		_Distance(_Ans.first, _Ans.second, _Num);
		return (_Num);
		}

	iterator lower_bound(const key_type& _Keyval)
		{	// find leftmost node not less than _Keyval in mutable tree
		return (iterator(_Lbound(_Keyval)));
		}

	const_iterator lower_bound(const key_type& _Keyval) const
		{	// find leftmost node not less than _Keyval in nonmutable tree
		return (const_iterator(_Lbound(_Keyval)));
		}

	iterator upper_bound(const key_type& _Keyval)
		{	// find leftmost node greater than _Keyval in mutable tree
		return (iterator(_Ubound(_Keyval)));
		}

	const_iterator upper_bound(const key_type& _Keyval) const
		{	// find leftmost node greater than _Keyval in nonmutable tree
		return (const_iterator(_Ubound(_Keyval)));
		}

	_Pairii equal_range(const key_type& _Keyval)
		{	// find range equivalent to _Keyval in mutable tree
		return (_Pairii(lower_bound(_Keyval), upper_bound(_Keyval)));
		}

	_Paircc equal_range(const key_type& _Keyval) const
		{	// find range equivalent to _Keyval in nonmutable tree
		return (_Paircc(lower_bound(_Keyval), upper_bound(_Keyval)));
		}

	void swap(_Myt& _RightArg)
		{	// exchange contents with _RightArg
		if (get_allocator() == _RightArg.get_allocator())
			{	// same allocator, swap control information





			::std:: swap(this->comp, _RightArg.comp);
			::std:: swap(_Myhead, _RightArg._Myhead);
			::std:: swap(_Mysize, _RightArg._Mysize);
			}
		else
			{	// different allocator, do multiple assigns
			_Myt _Tmp = *this; *this = _RightArg, _RightArg = _Tmp;
			}
		}

protected:
	void _Copy(const _Myt& _RightArg)
		{	// copy entire tree from _RightArg
		_Root() = _Copy(_RightArg._Root(), _Myhead);
		_Mysize = _RightArg.size();
		if (!_Isnil(_Root()))
			{	// nonempty tree, look for new smallest and largest
			_Lmost() = _Min(_Root());
			_Rmost() = _Max(_Root());
			}
		else
			_Lmost() = _Myhead, _Rmost() = _Myhead;	// empty tree
		}

	_Nodeptr _Copy(_Nodeptr _Rootnode, _Nodeptr _Wherenode)
		{	// copy entire subtree, recursively
		_Nodeptr _Newroot = _Myhead;	// point at nil node

		if (!_Isnil(_Rootnode))
			{	// copy a node, then any subtrees
			_Nodeptr _Pnode = _Buynode(_Myhead, _Wherenode, _Myhead,
				_Myval(_Rootnode), _Color(_Rootnode));
			if (_Isnil(_Newroot))
				_Newroot = _Pnode;	// memorize new root

			{{
			_Left(_Pnode) = _Copy(_Left(_Rootnode), _Pnode);
			_Right(_Pnode) = _Copy(_Right(_Rootnode), _Pnode);
			} if (0) {
			_Erase(_Newroot);	// subtree copy failed, bail out
			;
			}}
			}

		return (_Newroot);	// return newly constructed tree
		}

	void _Erase(_Nodeptr _Rootnode)
		{	// free entire subtree, recursively
		for (_Nodeptr _Pnode = _Rootnode; !_Isnil(_Pnode); _Rootnode = _Pnode)
			{	// free subtrees, then node
			_Erase(_Right(_Pnode));
			_Pnode = _Left(_Pnode);
			this->_Alnod.destroy(_Rootnode);	// destroy, free erased node
			this->_Alnod.deallocate(_Rootnode, 1);
			}
		}

	void _Init()
		{	// create head/nil node and make tree empty
		_Myhead = _Buynode();
		_Isnil(_Myhead) = true;
		_Root() = _Myhead;
		_Lmost() = _Myhead, _Rmost() = _Myhead;
		_Mysize = 0;
		}

	iterator _Insert(bool _Addleft, _Nodeptr _Wherenode,
		const value_type& _Val)
		{	// add node with value next to _Wherenode, to left if _Addnode
		if (max_size() - 1 <= _Mysize)
			length_error("map/set<T> too long"). _Raise();
		_Nodeptr _Newnode = _Buynode(_Myhead, _Wherenode, _Myhead,
			_Val, _Red);

		++_Mysize;
		if (_Wherenode == _Myhead)
			{	// first node in tree, just set head values
			_Root() = _Newnode;
			_Lmost() = _Newnode, _Rmost() = _Newnode;
			}
		else if (_Addleft)
			{	// add to left of _Wherenode
			_Left(_Wherenode) = _Newnode;
			if (_Wherenode == _Lmost())
				_Lmost() = _Newnode;
			}
		else
			{	// add to right of _Wherenode
			_Right(_Wherenode) = _Newnode;
			if (_Wherenode == _Rmost())
				_Rmost() = _Newnode;
			}

		for (_Nodeptr _Pnode = _Newnode; _Color(_Parent(_Pnode)) == _Red; )
			if (_Parent(_Pnode) == _Left(_Parent(_Parent(_Pnode))))
				{	// fixup red-red in left subtree
				_Wherenode = _Right(_Parent(_Parent(_Pnode)));
				if (_Color(_Wherenode) == _Red)
					{	// parent has two red children, blacken both
					_Color(_Parent(_Pnode)) = _Black;
					_Color(_Wherenode) = _Black;
					_Color(_Parent(_Parent(_Pnode))) = _Red;
					_Pnode = _Parent(_Parent(_Pnode));
					}
				else
					{	// parent has red and black children
					if (_Pnode == _Right(_Parent(_Pnode)))
						{	// rotate right child to left
						_Pnode = _Parent(_Pnode);
						_Lrotate(_Pnode);
						}
					_Color(_Parent(_Pnode)) = _Black;	// propagate red up
					_Color(_Parent(_Parent(_Pnode))) = _Red;
					_Rrotate(_Parent(_Parent(_Pnode)));
					}
				}
			else
				{	// fixup red-red in right subtree
				_Wherenode = _Left(_Parent(_Parent(_Pnode)));
				if (_Color(_Wherenode) == _Red)
					{	// parent has two red children, blacken both
					_Color(_Parent(_Pnode)) = _Black;
					_Color(_Wherenode) = _Black;
					_Color(_Parent(_Parent(_Pnode))) = _Red;
					_Pnode = _Parent(_Parent(_Pnode));
					}
				else
					{	// parent has red and black children
					if (_Pnode == _Left(_Parent(_Pnode)))
						{	// rotate left child to right
						_Pnode = _Parent(_Pnode);
						_Rrotate(_Pnode);
						}
					_Color(_Parent(_Pnode)) = _Black;	// propagate red up
					_Color(_Parent(_Parent(_Pnode))) = _Red;
					_Lrotate(_Parent(_Parent(_Pnode)));
					}
				}

		_Color(_Root()) = _Black;	// root is always black
		return (iterator(_Newnode));
		}

	_Nodeptr _Lbound(const key_type& _Keyval) const
		{	// find leftmost node not less than _Keyval
		_Nodeptr _Pnode = _Root();
		_Nodeptr _Wherenode = _Myhead;	// end() if search fails

		while (!_Isnil(_Pnode))
			if (this->comp(_Key(_Pnode), _Keyval))
				_Pnode = _Right(_Pnode);	// descend right subtree
			else
				{	// _Pnode not less than _Keyval, remember it
				_Wherenode = _Pnode;
				_Pnode = _Left(_Pnode);	// descend left subtree
				}

		return (_Wherenode);	// return best remembered candidate
		}

	_Nodeptr& _Lmost()
		{	// return leftmost node in mutable tree
		return (_Left(_Myhead));
		}

	_Nodeptr& _Lmost() const
		{	// return leftmost node in nonmutable tree
		return (_Left(_Myhead));
		}

	void _Lrotate(_Nodeptr _Wherenode)
		{	// promote right node to root of subtree
		_Nodeptr _Pnode = _Right(_Wherenode);
		_Right(_Wherenode) = _Left(_Pnode);

		if (!_Isnil(_Left(_Pnode)))
			_Parent(_Left(_Pnode)) = _Wherenode;
		_Parent(_Pnode) = _Parent(_Wherenode);

		if (_Wherenode == _Root())
			_Root() = _Pnode;
		else if (_Wherenode == _Left(_Parent(_Wherenode)))
			_Left(_Parent(_Wherenode)) = _Pnode;
		else
			_Right(_Parent(_Wherenode)) = _Pnode;

		_Left(_Pnode) = _Wherenode;
		_Parent(_Wherenode) = _Pnode;
		}

	static _Nodeptr _Max(_Nodeptr _Pnode)
		{	// return rightmost node in subtree at _Pnode
		while (!_Isnil(_Right(_Pnode)))
			_Pnode = _Right(_Pnode);
		return (_Pnode);
		}

	static _Nodeptr _Min(_Nodeptr _Pnode)
		{	// return leftmost node in subtree at _Pnode
		while (!_Isnil(_Left(_Pnode)))
			_Pnode = _Left(_Pnode);
		return (_Pnode);
		}

	_Nodeptr& _Rmost()
		{	// return rightmost node in mutable tree
		return (_Right(_Myhead));
		}

	_Nodeptr& _Rmost() const
		{	// return rightmost node in nonmutable tree
		return (_Right(_Myhead));
		}

	_Nodeptr& _Root()
		{	// return root of mutable tree
		return (_Parent(_Myhead));
		}

	_Nodeptr& _Root() const
		{	// return root of nonmutable tree
		return (_Parent(_Myhead));
		}

	void _Rrotate(_Nodeptr _Wherenode)
		{	// promote left node to root of subtree
		_Nodeptr _Pnode = _Left(_Wherenode);
		_Left(_Wherenode) = _Right(_Pnode);

		if (!_Isnil(_Right(_Pnode)))
			_Parent(_Right(_Pnode)) = _Wherenode;
		_Parent(_Pnode) = _Parent(_Wherenode);

		if (_Wherenode == _Root())
			_Root() = _Pnode;
		else if (_Wherenode == _Right(_Parent(_Wherenode)))
			_Right(_Parent(_Wherenode)) = _Pnode;
		else
			_Left(_Parent(_Wherenode)) = _Pnode;

		_Right(_Pnode) = _Wherenode;
		_Parent(_Wherenode) = _Pnode;
		}

	_Nodeptr _Ubound(const key_type& _Keyval) const
		{	// find leftmost node greater than _Keyval
		_Nodeptr _Pnode = _Root();
		_Nodeptr _Wherenode = _Myhead;	// end() if search fails

		while (!_Isnil(_Pnode))
			if (this->comp(_Keyval, _Key(_Pnode)))
				{	// _Pnode greater than _Keyval, remember it
				_Wherenode = _Pnode;
				_Pnode = _Left(_Pnode);	// descend left subtree
				}
			else
				_Pnode = _Right(_Pnode);	// descend right subtree

		return (_Wherenode);	// return best remembered candidate
		}

# 1233 "C:/usr/local/cell\\target\\ppu\\include/xtree" 3

	_Nodeptr _Buynode()
		{	// allocate a head/nil node
		_Nodeptr _Wherenode = this->_Alnod.allocate(1);
		int _Linkcnt = 0;

		{{
		this->_Alptr.construct(&_Left(_Wherenode), 0);
		++_Linkcnt;
		this->_Alptr.construct(&_Parent(_Wherenode), 0);
		++_Linkcnt;
		this->_Alptr.construct(&_Right(_Wherenode), 0);
		} if (0) {
		if (1 < _Linkcnt)
			this->_Alptr.destroy(&_Parent(_Wherenode));
		if (0 < _Linkcnt)
			this->_Alptr.destroy(&_Left(_Wherenode));
		this->_Alnod.deallocate(_Wherenode, 1);
		;
		}}
		_Color(_Wherenode) = _Black;
		_Isnil(_Wherenode) = false;
		return (_Wherenode);
		}

	_Nodeptr _Buynode(_Nodeptr _Larg, _Nodeptr _Parg,
		_Nodeptr _Rarg, const value_type& _Val, char _Carg)
		{	// allocate a node with pointers, value, and color
		_Nodeptr _Wherenode = this->_Alnod.allocate(1);
		{{
		new (_Wherenode) _Node(_Larg, _Parg, _Rarg, _Val, _Carg);
		} if (0) {
		this->_Alnod.deallocate(_Wherenode, 1);
		;
		}}
		return (_Wherenode);
		}

	void _Tidy()
		{	// free all storage
		erase(begin(), end());
		this->_Alptr.destroy(&_Left(_Myhead));
		this->_Alptr.destroy(&_Parent(_Myhead));
		this->_Alptr.destroy(&_Right(_Myhead));
		this->_Alnod.deallocate(_Myhead, 1);
		_Myhead = 0, _Mysize = 0;
		}

	_Nodeptr _Myhead;	// pointer to head node
	size_type _Mysize;	// number of elements
	};

		// _Tree TEMPLATE OPERATORS
template<class _Traits> inline
	bool operator==(const _Tree<_Traits>& _LeftArg, const _Tree<_Traits>& _RightArg)
	{	// test for _Tree equality
	return (_LeftArg.size() == _RightArg.size()
		&& ::std:: equal(_LeftArg.begin(), _LeftArg.end(), _RightArg.begin()));
	}

template<class _Traits> inline
	bool operator!=(const _Tree<_Traits>& _LeftArg, const _Tree<_Traits>& _RightArg)
	{	// test for _Tree inequality
	return (!(_LeftArg == _RightArg));
	}

template<class _Traits> inline
	bool operator<(const _Tree<_Traits>& _LeftArg, const _Tree<_Traits>& _RightArg)
	{	// test if _Less < _RightArg for _Trees
	return (::std:: lexicographical_compare(_LeftArg.begin(), _LeftArg.end(),
		_RightArg.begin(), _RightArg.end()));
	}

template<class _Traits> inline
	bool operator>(const _Tree<_Traits>& _LeftArg, const _Tree<_Traits>& _RightArg)
	{	// test if _Less > _RightArg for _Trees
	return (_RightArg < _LeftArg);
	}

template<class _Traits> inline
	bool operator<=(const _Tree<_Traits>& _LeftArg, const _Tree<_Traits>& _RightArg)
	{	// test if _Less <= _RightArg for _Trees
	return (!(_RightArg < _LeftArg));
	}

template<class _Traits> inline
	bool operator>=(const _Tree<_Traits>& _LeftArg, const _Tree<_Traits>& _RightArg)
	{	// test if _Less >= _RightArg for _Trees
	return (!(_LeftArg < _RightArg));
	}
}


/*
 * Copyright (c) 1992-2003 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
 */

/*
 * This file is derived from software bearing the following
 * restrictions:
 *
 * Copyright (c) 1994
 * Hewlett-Packard Company
 *
 * Permission to use, copy, modify, distribute and sell this
 * software and its documentation for any purpose is hereby
 * granted without fee, provided that the above copyright notice
 * appear in all copies and that both that copyright notice and
 * this permission notice appear in supporting documentation.
 * Hewlett-Packard Company makes no representations about the
 * suitability of this software for any purpose. It is provided
 * "as is" without express or implied warranty.
V4.02:0216 */
# 5 "C:/usr/local/cell\\target\\ppu\\include/map" 3
namespace std {

		// TEMPLATE CLASS _Tmap_traits
template<class _Kty,	// key type
	class _Ty,	// mapped type
	class _Pr,	// comparator predicate type
	class _Alloc,	// actual allocator type (should be value allocator)
	bool _Mfl>	// true if multiple equivalent keys are permitted
	class _Tmap_traits
		: public _Container_base
	{	// traits required to make _Tree behave like a map
public:
	typedef _Kty key_type;
	typedef pair<const _Kty, _Ty> value_type;
	typedef _Pr key_compare;
	typedef typename _Alloc::template rebind<value_type>::other
		allocator_type;
	typedef typename allocator_type::template rebind<value_type> ::other::pointer _ITptr;
	typedef typename allocator_type::template rebind<value_type> ::other::reference _IReft;
	enum
		{	// make multi parameter visible as an enum constant
		_Multi = _Mfl};

	_Tmap_traits()
		: comp()
		{	// construct with default comparator
		}

	_Tmap_traits(_Pr _Parg)
		: comp(_Parg)
		{	// construct with specified comparator
		}

	class value_compare
		: public binary_function<value_type, value_type, bool>
		{	// functor for comparing two element values
		friend class _Tmap_traits<_Kty, _Ty, _Pr, _Alloc, _Mfl>;

	public:
		bool operator()(const value_type& _Left,
			const value_type& _Right) const
			{	// test if _Left precedes _Right by comparing just keys
			return (comp(_Left.first, _Right.first));
			}

		value_compare(key_compare _Pred)
			: comp(_Pred)
			{	// construct with specified predicate
			}

	protected:
		key_compare comp;	// the comparator predicate for keys
		};

	static const _Kty& _Kfn(const value_type& _Val)
		{	// extract key from element value
		return (_Val.first);
		}

	_Pr comp;	// the comparator predicate for keys
	};

		// TEMPLATE CLASS map
template<class _Kty,
	class _Ty,
	class _Pr = less<_Kty>,
	class _Alloc = allocator<pair<const _Kty, _Ty> > >
	class map
		: public _Tree<_Tmap_traits<_Kty, _Ty, _Pr, _Alloc, false> >
	{	// ordered red-black tree of {key, mapped} values, unique keys
public:
	typedef map<_Kty, _Ty, _Pr, _Alloc> _Myt;
	typedef _Tree<_Tmap_traits<_Kty, _Ty, _Pr, _Alloc, false> > _Mybase;
	typedef _Kty key_type;
	typedef _Ty mapped_type;
	typedef _Ty referent_type;	// retained
	typedef _Pr key_compare;
	typedef typename _Mybase::value_compare value_compare;
	typedef typename _Mybase::allocator_type allocator_type;
	typedef typename _Mybase::size_type size_type;
	typedef typename _Mybase::difference_type difference_type;
	typedef typename _Mybase::pointer pointer;
	typedef typename _Mybase::const_pointer const_pointer;
	typedef typename _Mybase::reference reference;
	typedef typename _Mybase::const_reference const_reference;
	typedef typename _Mybase::iterator iterator;
	typedef typename _Mybase::const_iterator const_iterator;
	typedef typename _Mybase::reverse_iterator reverse_iterator;
	typedef typename _Mybase::const_reverse_iterator
		const_reverse_iterator;
	typedef typename _Mybase::value_type value_type;

	map()
		: _Mybase(key_compare(), allocator_type())
		{	// construct empty map from defaults
		}

	explicit map(const key_compare& _Pred)
		: _Mybase(_Pred, allocator_type())
		{	// construct empty map from comparator
		}

	map(const key_compare& _Pred, const allocator_type& _Al)
		: _Mybase(_Pred, _Al)
		{	// construct empty map from comparator and allocator
		}

	template<class _Iter>
		map(_Iter _First, _Iter _Last)
		: _Mybase(key_compare(), allocator_type())
		{	// construct map from [_First, _Last), defaults
		;
		for (; _First != _Last; ++_First)
			this->insert(*_First);
		}

	template<class _Iter>
		map(_Iter _First, _Iter _Last,
			const key_compare& _Pred)
		: _Mybase(_Pred, allocator_type())
		{	// construct map from [_First, _Last), comparator
		;
		for (; _First != _Last; ++_First)
			this->insert(*_First);
		}

	template<class _Iter>
		map(_Iter _First, _Iter _Last,
			const key_compare& _Pred, const allocator_type& _Al)
		: _Mybase(_Pred, _Al)
		{	// construct map from [_First, _Last), comparator, and allocator
		;
		for (; _First != _Last; ++_First)
			this->insert(*_First);
		}

# 157 "C:/usr/local/cell\\target\\ppu\\include/map" 3

	mapped_type& operator[](const key_type& _Keyval)
		{	// find element matching _Keyval or insert with default mapped
		iterator _Where = this->lower_bound(_Keyval);
		if (_Where == this->end()
			|| this->comp(_Keyval, this->_Key(_Where._Mynode())))
			_Where = this->insert(_Where,
				value_type(_Keyval, mapped_type()));
		return ((*_Where).second);
		}
	};

template<class _Kty,
	class _Ty,
	class _Pr,
	class _Alloc> inline
	void swap(map<_Kty, _Ty, _Pr, _Alloc>& _Left,
		map<_Kty, _Ty, _Pr, _Alloc>& _Right)
	{	// swap _Left and _Right maps
	_Left.swap(_Right);
	}

		// TEMPLATE CLASS multimap
template<class _Kty,
	class _Ty,
	class _Pr = less<_Kty>,
	class _Alloc = allocator<pair<const _Kty, _Ty> > >
	class multimap
		: public _Tree<_Tmap_traits<_Kty, _Ty, _Pr, _Alloc, true> >
	{	// ordered red-black tree of {key, mapped} values, non-unique keys
public:
	typedef multimap<_Kty, _Ty, _Pr, _Alloc> _Myt;
	typedef _Tree<_Tmap_traits<_Kty, _Ty, _Pr, _Alloc, true> > _Mybase;
	typedef _Kty key_type;
	typedef _Ty mapped_type;
	typedef _Ty referent_type;	// retained
	typedef _Pr key_compare;
	typedef typename _Mybase::value_compare value_compare;
	typedef typename _Mybase::allocator_type allocator_type;
	typedef typename _Mybase::size_type size_type;
	typedef typename _Mybase::difference_type difference_type;
	typedef typename _Mybase::pointer pointer;
	typedef typename _Mybase::const_pointer const_pointer;
	typedef typename _Mybase::reference reference;
	typedef typename _Mybase::const_reference const_reference;
	typedef typename _Mybase::iterator iterator;
	typedef typename _Mybase::const_iterator const_iterator;
	typedef typename _Mybase::reverse_iterator reverse_iterator;
	typedef typename _Mybase::const_reverse_iterator
		const_reverse_iterator;
	typedef typename _Mybase::value_type value_type;

	multimap()
		: _Mybase(key_compare(), allocator_type())
		{	// construct empty map from defaults
		}

	explicit multimap(const key_compare& _Pred)
		: _Mybase(_Pred, allocator_type())
		{	// construct empty map from comparator
		}
	multimap(const key_compare& _Pred, const allocator_type& _Al)
		: _Mybase(_Pred, _Al)
		{	// construct empty map from comparator and allocator
		}

	template<class _Iter>
		multimap(_Iter _First, _Iter _Last)
		: _Mybase(key_compare(), allocator_type())
		{	// construct map from [_First, _Last), defaults
		;
		for (; _First != _Last; ++_First)
			insert(*_First);
		}

	template<class _Iter>
		multimap(_Iter _First, _Iter _Last,
			const key_compare& _Pred)
		: _Mybase(_Pred, allocator_type())
		{	// construct map from [_First, _Last), comparator
		;
		for (; _First != _Last; ++_First)
			insert(*_First);
		}

	template<class _Iter>
		multimap(_Iter _First, _Iter _Last,
			const key_compare& _Pred, const allocator_type& _Al)
		: _Mybase(_Pred, _Al)
		{	// construct map from [_First, _Last), comparator, and allocator
		;
		for (; _First != _Last; ++_First)
			insert(*_First);
		}

	iterator insert(const value_type& _Val)
		{	// insert a {key, mapped} value
		return (_Mybase::insert(_Val).first);
		}

	iterator insert(iterator _Where, const value_type& _Val)
		{	// insert a {key, mapped} value, with hint
		return (_Mybase::insert(_Where, _Val));
		}

# 278 "C:/usr/local/cell\\target\\ppu\\include/map" 3

	template<class _Iter>
		void insert(_Iter _First, _Iter _Last)
		{	// insert [_First, _Last), arbitrary iterators







		for (; _First != _Last; ++_First)
			insert(*_First);
		}
	};

template<class _Kty,
	class _Ty,
	class _Pr,
	class _Alloc> inline
	void swap(multimap<_Kty, _Ty, _Pr, _Alloc>& _Left,
		multimap<_Kty, _Ty, _Pr, _Alloc>& _Right)
	{	// swap _Left and _Right multimaps
	_Left.swap(_Right);
	}






}


/*
 * Copyright (c) 1992-2003 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
V4.02:0216 */
# 46 "C:\\Users\\USER\\Documents\\Visual Studio 2013\\Projects\\mp3_plugin_PS3\\mp3_plugin_PS3\\main.cpp"
# 1 "C:/usr/local/cell\\target\\ppu\\include/typeinfo" 3
/* SCE CONFIDENTIAL
PlayStation(R)3 Programmer Tool Runtime Library 475.001
* Copyright (C) 2004 Sony Computer Entertainment Inc. 
* All Rights Reserved.
*/
// typeinfo standard header for gcc/EDG










namespace std {
		// CLASS bad_cast
class bad_cast
	: public ::std:: exception
	{	// base of all bad-cast exceptions
public:
	bad_cast() 
		{	// construct with no message string
		}

	virtual const char *what() const 
		{	// report a bad cast
		return ("bad cast");
		}





protected:
	virtual void _Doraise() const
		{	// perform class-specific exception handling
		::std:: _Throw(*this);
		}


	};

		// CLASS bad_typeid
class bad_typeid
	: public ::std:: exception
	{	// base of all bad-typeid exceptions
public:
	bad_typeid() 
		{	// construct with no message string
		}

	virtual const char *what() const 
		{	// report a bad typeid
		return ("bad typeid");
		}





protected:
	virtual void _Doraise() const
		{	// perform class-specific exception handling
		::std:: _Throw(*this);
		}


	};
}




namespace __cxxabiv1
	{	// declare forward reference to __class_type_info
	class __class_type_info;
	}


namespace std {





		// CLASS type_info
class type_info
	{	// translator-supplied descriptor for a type
public:
	virtual ~type_info();	// destroy the object

# 118 "C:/usr/local/cell\\target\\ppu\\include/typeinfo" 3

# 125 "C:/usr/local/cell\\target\\ppu\\include/typeinfo" 3
	bool before(const type_info& _Right) const
		{	// test if this precedes arg
		return (strcmp (_Myname, _Right._Myname) < 0);
		}

	bool operator==(const type_info& _Right) const
		{	// test for equality
		return (this == &_Right
			|| strcmp (_Myname, _Right._Myname) == 0);
		}


	bool operator!=(const type_info& _Right) const
		{	// test for inequality
		return (!(*this == _Right));
		}

	const char *name() const
		{	// return name of type
		return (_Myname);
		}

	virtual bool __is_pointer_p() const;
	virtual bool __is_function_p() const;
	virtual bool __do_catch(const type_info *, void **, unsigned) const;
	virtual bool __do_upcast(const __cxxabiv1::__class_type_info *, void **)
		const;

protected:
	explicit type_info(const char *_Name)
		: _Myname(_Name)
		{	// construct with name
		}

	const char *_Myname;


protected:	// to shut up compiler
	type_info(const type_info&);	// not defined

private:
	type_info& operator=(const type_info&);	// not defined
	};
}	/* namespace std */










/*
 * Copyright (c) 1992-2003 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
V4.02:0216 */
# 49 "C:\\Users\\USER\\Documents\\Visual Studio 2013\\Projects\\mp3_plugin_PS3\\mp3_plugin_PS3\\main.cpp"
# 1 "C:/usr/local/cell\\target\\ppu\\include/pthread.h" 3
/*
 *   SCE CONFIDENTIAL
 *   PlayStation(R)3 Programmer Tool Runtime Library 475.001
 *   Copyright (C) 2007 Sony Computer Entertainment Inc.
 *   All Rights Reserved.
 */

/* Copyright 2005  Sony Corporation */








# 1 "C:/usr/local/cell\\target\\ppu\\include/time.h" 3
/* SCE CONFIDENTIAL
PlayStation(R)3 Programmer Tool Runtime Library 475.001
* Copyright (C) 2007 Sony Computer Entertainment Inc. 
* All Rights Reserved.
*/
/* time.h standard header */
# 94 "C:/usr/local/cell\\target\\ppu\\include/time.h" 3

# 115 "C:/usr/local/cell\\target\\ppu\\include/time.h" 3

/*
 * Copyright (c) 1992-2003 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
V4.02:0216 */
# 19 "C:/usr/local/cell\\target\\ppu\\include/pthread.h" 3
# 1 "C:/usr/local/cell\\target\\ppu\\include/sched.h" 3
/*
 *   SCE CONFIDENTIAL
 *   PlayStation(R)3 Programmer Tool Runtime Library 475.001
 *   Copyright (C) 2005 Sony Computer Entertainment Inc.
 *   All Rights Reserved.
 */

/* Copyright 2005  Sony Corporation */










namespace std {





struct sched_param {
  int sched_priority ;
} ;

extern "C" {

}

}


using ::std:: sched_param ;


# 20 "C:/usr/local/cell\\target\\ppu\\include/pthread.h" 3

# 1 "C:/usr/local/cell\\target\\ppu\\include/pthread_types.h" 3
/*
 *   SCE CONFIDENTIAL
 *   PlayStation(R)3 Programmer Tool Runtime Library 475.001
 *   Copyright (C) 2007 Sony Computer Entertainment Inc.
 *   All Rights Reserved.
 */

/* Copyright 2005  Sony Corporation */









namespace std {

struct pthread ;
typedef struct	pthread	*pthread_t;

typedef struct s_pthread_attr_t 
{
  int    schedpolicy ;
  int    sched_priority ;
  int    detachstate ;
  int    scope ;
  int    inheritsched ;
  void*  stackaddr;
  size_t stacksize;
  char*  name ;
} pthread_attr_t ;

typedef struct s_pthread_mutexattr_t 
{
  int   protocol ;
  int   pshared ;
  int   type ; 
  int   prioceiling ;
} pthread_mutexattr_t ;

typedef struct s_pthread_mutex_t 
{
  pthread_mutexattr_t attr ;
  int type ;
  int status ;
  sys_mutex_t sys_mutex ;
} pthread_mutex_t ;

typedef struct s_pthread_condattr_t 
{
  long int rsvd0 ;
  int  pshared ;
} pthread_condattr_t ;

typedef struct s_pthread_cond_t 
{
  pthread_condattr_t attr ;
  int status ;
  sys_cond_t  sys_cond ;
  sys_mutex_t sys_mutex ;
} pthread_cond_t ;

typedef int pthread_key_t;
typedef int pthread_once_t ;

typedef struct s_pthread_rwlockattr_t 
{
  int type ;
  int pshared;
} pthread_rwlockattr_t;

typedef struct s_pthread_rwlock_t 
{
  pthread_rwlockattr_t attr ;
  int     type ;
  pthread_mutex_t mutex;
  pthread_cond_t read_cond;
  pthread_cond_t write_cond;
  int blocked_writer;
  signed int state;
} pthread_rwlock_t ;

struct timespec
{	/* POSIX.4, needed for pthread_cond_timedwait */
  long tv_sec;
  long tv_nsec;
};

extern "C" {

}

}

using ::std:: pthread_t ;
using ::std:: pthread_attr_t ;
using ::std:: pthread_mutex_t ;
using ::std:: pthread_mutexattr_t ;
using ::std:: pthread_condattr_t ;
using ::std:: pthread_cond_t ;
using ::std:: pthread_key_t;
using ::std:: pthread_once_t ;
using ::std:: pthread_rwlockattr_t;
using ::std::  pthread_rwlock_t ;
using ::std:: timespec;


# 22 "C:/usr/local/cell\\target\\ppu\\include/pthread.h" 3

namespace std {














/*
 * Flags for read/write lock attributes
 */



/*
 * Flags for once initialization.
 */



/*
 * Static once initialization values. 
 */







/*
 * Mutex types (Single UNIX Specification, Version 2, 1997).
 */












/*
 * Static initialization values. 
 */
# 84 "C:/usr/local/cell\\target\\ppu\\include/pthread.h" 3


















# 108 "C:/usr/local/cell\\target\\ppu\\include/pthread.h" 3

/* This should be in limits.h according to the POSIX spec.. */

/* maximum number of data keys that can be created by a process */



/* minimum size in bytes of thread stack storage */



/* maximum number of threads that can be created per process */





/*
 * Thread function prototype definitions:
 */

extern "C" {
int pthread_attr_destroy(pthread_attr_t *);
int pthread_attr_getdetachstate(const pthread_attr_t *, int *);
int pthread_attr_getinheritsched(const pthread_attr_t *, int *);
int pthread_attr_getschedparam(const pthread_attr_t *,struct sched_param *);
int pthread_attr_getschedpolicy(const pthread_attr_t *, int *);
int pthread_attr_getscope(const pthread_attr_t *, int *);
int pthread_attr_getstackaddr(const pthread_attr_t *, void **);
int pthread_attr_getstacksize(const pthread_attr_t *, size_t *);
int pthread_attr_init(pthread_attr_t *);
int pthread_attr_setdetachstate(pthread_attr_t *, int);
int pthread_attr_setinheritsched(pthread_attr_t *, int);
int pthread_attr_setschedparam(pthread_attr_t *,struct sched_param *);
int pthread_attr_setschedpolicy(pthread_attr_t *, int);
int pthread_attr_setscope(pthread_attr_t *, int);
int pthread_attr_setstackaddr(pthread_attr_t *, void *);
int pthread_attr_setstacksize(pthread_attr_t *, size_t);

int pthread_cond_broadcast(pthread_cond_t *);
int pthread_cond_destroy(pthread_cond_t *);
int pthread_cond_init(pthread_cond_t *,const pthread_condattr_t *) ;
int pthread_cond_signal(pthread_cond_t *);
int pthread_cond_timedwait(pthread_cond_t *,pthread_mutex_t *,const struct timespec *);
int pthread_cond_wait(pthread_cond_t *, pthread_mutex_t *);
int pthread_condattr_init(pthread_condattr_t *);
int pthread_condattr_destroy(pthread_condattr_t *);
int pthread_condattr_setpshared(pthread_condattr_t *, int);
int pthread_condattr_getpshared(const pthread_condattr_t *, int *);

int pthread_create(pthread_t *, const pthread_attr_t *,void *(*) (void *),void *);
int pthread_detach(pthread_t);
int pthread_equal(pthread_t, pthread_t);
void pthread_exit(void *);
int pthread_getschedparam(pthread_t pthread, int *,struct sched_param *) ;
int pthread_setschedparam(pthread_t, int,const struct sched_param *) ;
pthread_t pthread_self(void);
int pthread_join(pthread_t, void **);
int pthread_once(pthread_once_t *, void (*) (void));

int pthread_mutex_init(pthread_mutex_t *,const pthread_mutexattr_t *) ;
int pthread_mutex_destroy(pthread_mutex_t *);
int pthread_mutex_lock(pthread_mutex_t *);
int pthread_mutex_trylock(pthread_mutex_t *);
int pthread_mutex_unlock(pthread_mutex_t *);

int pthread_mutexattr_init(pthread_mutexattr_t *);
int pthread_mutexattr_destroy(pthread_mutexattr_t *);
int pthread_mutexattr_getprioceiling(const pthread_mutexattr_t *,int *) ;
int pthread_mutexattr_getprotocol(const pthread_mutexattr_t *, int *);
int pthread_mutexattr_getpshared(const pthread_mutexattr_t *, int *);
int pthread_mutexattr_setprioceiling(pthread_mutexattr_t *,int) ;
int pthread_mutexattr_setprotocol(pthread_mutexattr_t *, int);
int pthread_mutexattr_setpshared(pthread_mutexattr_t *, int);
int pthread_mutexattr_setkind_np(pthread_mutexattr_t *, int);
int pthread_mutexattr_settype(pthread_mutexattr_t *, int);

int  pthread_key_create(pthread_key_t *,void (*) (void *)) ;
int  pthread_key_delete(pthread_key_t);
void *pthread_getspecific(pthread_key_t);
int  pthread_setspecific(pthread_key_t, const void *);

void pthread_cleanup_pop(int);
void pthread_cleanup_push(void (*) (void *), void *routine_arg);

int pthread_rwlock_init(pthread_rwlock_t *,const pthread_rwlockattr_t *);
int pthread_rwlock_destroy(pthread_rwlock_t *);
int pthread_rwlock_rdlock(pthread_rwlock_t *);
int pthread_rwlock_tryrdlock(pthread_rwlock_t *);
int pthread_rwlock_wrlock(pthread_rwlock_t *);
int pthread_rwlock_trywrlock(pthread_rwlock_t *);
int pthread_rwlock_unlock(pthread_rwlock_t *);
int pthread_rwlockattr_init(pthread_rwlockattr_t *);
int pthread_rwlockattr_destroy(pthread_rwlockattr_t *);
int pthread_rwlockattr_getpshared(const pthread_rwlockattr_t *, int *);
int pthread_rwlockattr_setpshared(pthread_rwlockattr_t *, int);

}
}


using ::std:: pthread_attr_destroy ;
using ::std:: pthread_attr_getdetachstate ;
using ::std:: pthread_attr_getinheritsched ;
using ::std:: pthread_attr_getschedparam ;
using ::std:: pthread_attr_getschedpolicy ;
using ::std:: pthread_attr_getscope ;
using ::std:: pthread_attr_getstackaddr ;
using ::std:: pthread_attr_getstacksize ;
using ::std:: pthread_attr_init ;
using ::std:: pthread_attr_setdetachstate ;
using ::std:: pthread_attr_setinheritsched ;
using ::std:: pthread_attr_setschedparam ;
using ::std:: pthread_attr_setschedpolicy ;
using ::std:: pthread_attr_setscope ;
using ::std:: pthread_attr_setstackaddr ;
using ::std:: pthread_attr_setstacksize ;
using ::std:: pthread_cond_broadcast ;
using ::std:: pthread_cond_destroy ;
using ::std:: pthread_cond_init ;
using ::std:: pthread_cond_signal ;
using ::std:: pthread_cond_timedwait ;
using ::std:: pthread_cond_wait ;
using ::std:: pthread_condattr_init ;
using ::std:: pthread_condattr_destroy ;
using ::std:: pthread_condattr_setpshared ;
using ::std:: pthread_condattr_getpshared ;
using ::std:: pthread_create ;
using ::std:: pthread_detach ;
using ::std:: pthread_equal ;
using ::std:: pthread_exit ;
using ::std:: pthread_getschedparam ;
using ::std:: pthread_setschedparam ;
using ::std:: pthread_self ;
using ::std:: pthread_join ;
using ::std:: pthread_once ;
using ::std:: pthread_mutex_init ;
using ::std:: pthread_mutex_destroy ;
using ::std:: pthread_mutex_lock ;
using ::std:: pthread_mutex_trylock ;
using ::std:: pthread_mutex_unlock ;
using ::std:: pthread_mutexattr_init ;
using ::std:: pthread_mutexattr_destroy ;
using ::std:: pthread_mutexattr_getprotocol ;
using ::std:: pthread_mutexattr_getpshared ;
using ::std:: pthread_mutexattr_setprotocol ;
using ::std:: pthread_mutexattr_setpshared ;
using ::std:: pthread_mutexattr_setkind_np ;
using ::std:: pthread_mutexattr_settype ;
using ::std:: pthread_key_create ;
using ::std:: pthread_key_delete ;
using ::std:: pthread_getspecific ;
using ::std:: pthread_setspecific ;
using ::std:: pthread_cleanup_pop ;
using ::std:: pthread_cleanup_push ;
using ::std:: pthread_rwlock_init ;
using ::std:: pthread_rwlock_destroy ;
using ::std:: pthread_rwlock_rdlock ;
using ::std:: pthread_rwlock_tryrdlock ;
using ::std:: pthread_rwlock_wrlock ;
using ::std:: pthread_rwlock_trywrlock ;
using ::std:: pthread_rwlock_unlock ;
using ::std:: pthread_rwlockattr_init ;
using ::std:: pthread_rwlockattr_destroy ;
using ::std:: pthread_rwlockattr_getpshared ;
using ::std:: pthread_rwlockattr_setpshared ;



# 50 "C:\\Users\\USER\\Documents\\Visual Studio 2013\\Projects\\mp3_plugin_PS3\\mp3_plugin_PS3\\main.cpp"
# 1 "C:/usr/local/cell\\target\\ppu\\include/time.h" 3
/* SCE CONFIDENTIAL
PlayStation(R)3 Programmer Tool Runtime Library 475.001
* Copyright (C) 2007 Sony Computer Entertainment Inc. 
* All Rights Reserved.
*/
/* time.h standard header */
# 94 "C:/usr/local/cell\\target\\ppu\\include/time.h" 3

# 115 "C:/usr/local/cell\\target\\ppu\\include/time.h" 3

/*
 * Copyright (c) 1992-2003 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
V4.02:0216 */
# 51 "C:\\Users\\USER\\Documents\\Visual Studio 2013\\Projects\\mp3_plugin_PS3\\mp3_plugin_PS3\\main.cpp"
# 1 "C:/usr/local/cell\\target\\ppu\\include/locale.h" 3
/* locale.h standard header */






namespace std {

		/* MACROS */




		/* LOCALE CATEGORY INDEXES */
# 22 "C:/usr/local/cell\\target\\ppu\\include/locale.h" 3
	/* ADD YOURS HERE, THEN UPDATE _NCAT */


		/* LOCALE CATEGORY MASKS */
# 34 "C:/usr/local/cell\\target\\ppu\\include/locale.h" 3

		/* LOCALE CATEGORY HANDLES */
# 44 "C:/usr/local/cell\\target\\ppu\\include/locale.h" 3

		/* MACROS FOR LOCKING GLOBAL LOCALES */

# 55 "C:/usr/local/cell\\target\\ppu\\include/locale.h" 3

		/* TYPE DEFINITIONS */
struct lconv
	{	/* locale-specific information */
		/* controlled by LC_MONETARY */
	char *currency_symbol;
	char *int_curr_symbol;
	char *mon_decimal_point;
	char *mon_grouping;
	char *mon_thousands_sep;
	char *negative_sign;
	char *positive_sign;

	char frac_digits;
	char n_cs_precedes;
	char n_sep_by_space;
	char n_sign_posn;
	char p_cs_precedes;
	char p_sep_by_space;
	char p_sign_posn;

	char int_frac_digits;
/* vv added with C99 vv */
	char int_n_cs_precedes;
	char int_n_sep_by_space;
	char int_n_sign_posn;
	char int_p_cs_precedes;
	char int_p_sep_by_space;
	char int_p_sign_posn;
/* ^^ added with C99 ^^ */

		/* controlled by LC_NUMERIC */
	char *decimal_point;
	char *grouping;
	char *thousands_sep;
	char *_Frac_grouping;
	char *_Frac_sep;
	char *_False;
	char *_True;

		/* controlled by LC_MESSAGES */
	char *_No;
	char *_Yes;
	};

struct _Linfo;

		/* DECLARATIONS */
extern "C" {
struct lconv *localeconv(void);
char *setlocale(int, const char *);
extern struct lconv _Locale;
}




		/* INLINES, FOR C++ */
//inline struct lconv *localeconv(void)
//	{	// return pointer to current locale
//	return (&_Locale); }







}





using ::std:: lconv; using ::std:: localeconv; using ::std:: setlocale;


/*
 * Copyright (c) 1992-2003 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
V4.02:0216 */
# 52 "C:\\Users\\USER\\Documents\\Visual Studio 2013\\Projects\\mp3_plugin_PS3\\mp3_plugin_PS3\\main.cpp"
# 1 "C:/usr/local/cell\\target\\ppu\\include/np.h" 3
/*  SCE CONFIDENTIAL                                      */
/*  PlayStation(R)3 Programmer Tool Runtime Library 475.001 */
/*  Copyright (C) 2007 Sony Computer Entertainment Inc.   */
/*  All Rights Reserved.                                  */



# 1 "C:/usr/local/cell\\target\\ppu\\include/stdint.h" 3
/* SCE CONFIDENTIAL
PlayStation(R)3 Programmer Tool Runtime Library 475.001
* Copyright (C) 2006 Sony Computer Entertainment Inc. 
* All Rights Reserved.
*/
/* stdint.h standard header */
# 201 "C:/usr/local/cell\\target\\ppu\\include/stdint.h" 3

# 220 "C:/usr/local/cell\\target\\ppu\\include/stdint.h" 3

/*
 * Copyright (c) 1992-2003 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
V4.02:0216 */
# 9 "C:/usr/local/cell\\target\\ppu\\include/np.h" 3
# 1 "C:/usr/local/cell\\target\\ppu\\include/netinet/in.h" 3
/*   SCE CONFIDENTIAL                                       */
/*   PlayStation(R)3 Programmer Tool Runtime Library 475.001 */
/*   Copyright (C) 2014 Sony Computer Entertainment Inc.    */
/*   All Rights Reserved.                                   */







extern "C" {


# 21 "C:/usr/local/cell\\target\\ppu\\include/netinet/in.h" 3

struct in_addr {
	in_addr_t s_addr;
};




























struct sockaddr_in {
	unsigned char sin_len;
	sa_family_t sin_family;
	in_port_t sin_port;
	struct in_addr sin_addr;
	char sin_zero[8];
};

struct sockaddr_in_p2p {
	unsigned char sin_len;
	sa_family_t	sin_family;
	in_port_t sin_port;
	struct in_addr sin_addr;
	in_port_t sin_vport;
	char sin_zero[6];
};



# 83 "C:/usr/local/cell\\target\\ppu\\include/netinet/in.h" 3




struct ip_mreq {
	struct in_addr imr_multiaddr;
	struct in_addr imr_interface;
};







}




# 12 "C:/usr/local/cell\\target\\ppu\\include/np.h" 3
# 1 "C:/usr/local/cell\\target\\ppu\\include/cell/rtc.h" 3
/*  SCE CONFIDENTIAL                                      */
/*  PlayStation(R)3 Programmer Tool Runtime Library 475.001 */
/*  Copyright (C) 2008 Sony Computer Entertainment Inc.   */
/*  All Rights Reserved.                                  */



# 1 "C:/usr/local/cell\\target\\ppu\\include/stdint.h" 3
/* SCE CONFIDENTIAL
PlayStation(R)3 Programmer Tool Runtime Library 475.001
* Copyright (C) 2006 Sony Computer Entertainment Inc. 
* All Rights Reserved.
*/
/* stdint.h standard header */
# 201 "C:/usr/local/cell\\target\\ppu\\include/stdint.h" 3

# 220 "C:/usr/local/cell\\target\\ppu\\include/stdint.h" 3

/*
 * Copyright (c) 1992-2003 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
V4.02:0216 */
# 9 "C:/usr/local/cell\\target\\ppu\\include/cell/rtc.h" 3


# 1 "C:/usr/local/cell\\target\\ppu\\include/sys/time.h" 3
/*   SCE CONFIDENTIAL                                       */
/*   PlayStation(R)3 Programmer Tool Runtime Library 475.001 */
/*   Copyright (C) 2005 Sony Computer Entertainment Inc.    */
/*   All Rights Reserved.                                   */







extern "C" {


	struct timeval {
		int64_t tv_sec;			/* seconds */
		int64_t tv_usec;		/* and microseconds */
	};


}
# 13 "C:/usr/local/cell\\target\\ppu\\include/cell/rtc.h" 3


/* librtc error codes */
# 1 "C:/usr/local/cell\\target\\ppu\\include/cell/rtc/error.h" 3
/*  SCE CONFIDENTIAL                                      */
/*  PlayStation(R)3 Programmer Tool Runtime Library 475.001 */
/*  Copyright (C) 2006 Sony Computer Entertainment Inc.   */
/*  All Rights Reserved.                                  */




extern "C" {


/*
	CELL_ERROR_FACILITY_SYSTEM_SERVICE	 0x001
		librtc		: 0x8001_0601 - 0x8001_06ff
 */




/*J 初期化処理が行われていない           */
/* ERR: CELL_RTC_MAKE_ERROR(0x0001) */


/*J ポインタを意味する引数が不正         */
/* ERR: CELL_RTC_MAKE_ERROR(0x0002) */


/*J 一般的な意味で引数が不正             */
/* ERR: CELL_RTC_MAKE_ERROR(0x0003) */


/*J 一般的な意味で引数が不正             */
/* ERR: CELL_RTC_MAKE_ERROR(0x0004) */


/*E The feature is not supported     */
/* ERR: CELL_RTC_MAKE_ERROR(0x0005) */


/*E The clock is not available       */
/* ERR: CELL_RTC_MAKE_ERROR(0x0006) */


/*E error occured in parsing (unknown format?) */
/* ERR: CELL_RTC_MAKE_ERROR(0x0007) */


/*E The year value is invalid       */
/* ERR: CELL_RTC_MAKE_ERROR(0x0021) */


/*E The month value is invalid       */
/* ERR: CELL_RTC_MAKE_ERROR(0x0022) */


/*E The day value is invalid       */
/* ERR: CELL_RTC_MAKE_ERROR(0x0023) */


/*E The hour value is invalid       */
/* ERR: CELL_RTC_MAKE_ERROR(0x0024) */


/*E The minute value is invalid       */
/* ERR: CELL_RTC_MAKE_ERROR(0x0025) */


/*E The second value is invalid       */
/* ERR: CELL_RTC_MAKE_ERROR(0x0026) */


/*E The microsecond value is invalid  */
/* ERR: CELL_RTC_MAKE_ERROR(0x0027) */



}


# 17 "C:/usr/local/cell\\target\\ppu\\include/cell/rtc.h" 3

/* librtc library */
# 1 "C:/usr/local/cell\\target\\ppu\\include/cell/rtc/rtcsvc.h" 3
/*                 -*- mode: c; tab-width: 4; indent-tabs-mode: t; -*- */
/*  SCE CONFIDENTIAL                                      */
/*  PlayStation(R)3 Programmer Tool Runtime Library 475.001 */
/*  Copyright (C) 2006 Sony Computer Entertainment Inc.   */
/*  All Rights Reserved.                                  */




extern "C" {


/*J フィールドごとに分解した時刻表現 */
/*E representation of time using individual members */
typedef struct CellRtcDateTime {
	unsigned short year;
	unsigned short month;
	unsigned short day;
	unsigned short hour;
	unsigned short minute;
	unsigned short second;
	unsigned int   microsecond;
} CellRtcDateTime;

/*J UTC 0001/01/01 00:00:00からの累積時間(1usec刻み) */
/*E Cumulative numbver of Ticks from 0001/01/01 00:00:00 */
typedef struct CellRtcTick {
	uint64_t tick;
} CellRtcTick;


/*J プロトタイプ宣言 */
/*E prototype declaration */

/*J 現在時刻を取得する関数 */
/*E Get current time(UTC) in Tick representation */

int cellRtcGetCurrentTick(CellRtcTick *pTick);

/*J 指定されたタイムゾーンで現在時刻を取得 */
/*E Get current time in specified time zone */

int cellRtcGetCurrentClock(CellRtcDateTime *pTime, int iTimeZone);

/*J 地方時で取得 サマータイム設定の影響あり */
/*E Get current time (local time) */
int cellRtcGetCurrentClockLocalTime(CellRtcDateTime *pTime);

/*J 指定されたUTC時刻を地方時に変換 */
/*E Convert Tick-representation UTC time into local time */
int cellRtcConvertUtcToLocalTime(const CellRtcTick *pUtc, CellRtcTick *pLocalTime);

/*J 指定されたローカル時刻をUTC時刻に変換 */
/*E Convert Tick-representation local time into UTC time */
int cellRtcConvertLocalTimeToUtc(const CellRtcTick *pLocalTime, CellRtcTick *pUtc);

/*J うるう年かどうか判別 */
/*E Check leap year */
int cellRtcIsLeapYear(int year);

/*J 指定された月の日数を取得 */
/*E Get number of days in specified month */
int cellRtcGetDaysInMonth(int year, int month);

/*J 指定された日が何曜日が返す */
/*E Calculate day of the week */
# 74 "C:/usr/local/cell\\target\\ppu\\include/cell/rtc/rtcsvc.h" 3
int cellRtcGetDayOfWeek(int year, int month, int day);

/*J 各フィールドの範囲が正しいかどうかチェック */
/*E Check range of each field */
int cellRtcCheckValid(const CellRtcDateTime *pTime);


/*J 各種ライブラリとの互換形式 */
/*E Format Conversion Functions */


/*J POSIX time_t形式の時間を設定 */
/*E Get time information in POSIX time_t format */

int cellRtcSetTime_t(CellRtcDateTime *pTime, time_t llTime);

/*J POSIX time_t形式の時間を取得 */
/*E Set time information in POSIX time_t format */

int cellRtcGetTime_t(const CellRtcDateTime *pTime, time_t *pllTime);




/*J MS-DOS形式の時間を設定 */
/*E Set time information in MS-DOS format */

int cellRtcSetDosTime(CellRtcDateTime *pTime, unsigned int uiDosTime);

/*J MS-DOS形式の時間を取得 */
/*E Get time information in MS-DOS format */

int cellRtcGetDosTime(const CellRtcDateTime *pTime, unsigned int *puiDosTime);

/*J Win32 FILETIME形式の時間を設定 */
/*E Set time information in Win32 FILETIME format */

int cellRtcSetWin32FileTime(CellRtcDateTime *pTime, uint64_t ulWin32Time);

/*J Win32 FILETIME形式の時間を取得 */
/*E Get time information in Win32 FILETIME format */

int cellRtcGetWin32FileTime(const CellRtcDateTime *pTime, uint64_t *ulWin32Time);

/*J CellRtcDateTime構造体とCellRtcTick構造体の変換 */
/*E conversion between CellRtcDateTime and CellRtcTick */

/*J CellRtcTick形式の時間を設定 */
/*E Set time information according to Tick format */

int cellRtcSetTick(CellRtcDateTime *pTime, const CellRtcTick *pTick);

/*J CellRtcTick形式の時間を取得 */
/*E Get time information in Tick format */

int cellRtcGetTick(const CellRtcDateTime *pTime, CellRtcTick *pTick);


int cellRtcCompareTick(const CellRtcTick *pTick1, const CellRtcTick *pTick2);



/*J 時間の加減算 */
/*E Time Manipurator Functions */

/*E Add specified number of Ticks to time having Tick representation */
int cellRtcTickAddTicks(CellRtcTick *pTick0, const CellRtcTick *pTick1, int64_t lAdd);

/*E Add specified number of microseconds to time having Tick representation */
int cellRtcTickAddMicroseconds(CellRtcTick *pTick0, const CellRtcTick *pTick1, int64_t lAdd);

/*E Add specified number of seconds to time having Tick representation */
int cellRtcTickAddSeconds(CellRtcTick *pTick0, const CellRtcTick *pTick1, int64_t lAdd);

/*E Add specified number of minutes to time having Tick representation */
int cellRtcTickAddMinutes(CellRtcTick *pTick0, const CellRtcTick *pTick1, int64_t lAdd);

/*E Add specified number of houres to time having Tick representation */
int cellRtcTickAddHours(CellRtcTick *pTick0, const CellRtcTick *pTick1, int lAdd);

/*E Add specified number of days to time having Tick representation */
int cellRtcTickAddDays(CellRtcTick *pTick0, const CellRtcTick *pTick1, int lAdd);

/*E Add specified number of weeks to time having Tick representation */
int cellRtcTickAddWeeks(CellRtcTick *pTick0, const CellRtcTick *pTick1, int lAdd);

/*E Add specified number of months to time having Tick representation */
int cellRtcTickAddMonths(CellRtcTick *pTick0, const CellRtcTick *pTick1, int lAdd);

/*E Add specified number of years to time having Tick representation */
int cellRtcTickAddYears(CellRtcTick *pTick0, const CellRtcTick *pTick1, int lAdd);



/*J 文字列へのフォーマット関数 */
/*E Formatting Functions */

/*J 指定されたタイムゾーンでRFC2822形式にフォーマット */
/*E Format Tick-representation UTC time in RFC2822 format */
int cellRtcFormatRfc2822(char *pszDateTime, const CellRtcTick *pUtc, int iTimeZoneMinutes);

/*J RFC2822形式にフォーマット */
/*E Format Tick-representation UTC time in RFC2822 format */
int cellRtcFormatRfc2822LocalTime(char *pszDateTime, const CellRtcTick *pUtc);

/*J 指定されたタイムゾーンでRFC3339形式にフォーマット */
/*E Format Tick-representation UTC time in RFC3339(ISO8601) format */
int cellRtcFormatRfc3339(char *pszDateTime, const CellRtcTick *pUtc, int iTimeZoneMinutes);

/*J RFC3339形式にフォーマット */
/*E Format Tick-representation UTC time in RFC3339(ISO8601) format */
int cellRtcFormatRfc3339LocalTime(char *pszDateTime, const CellRtcTick *pUtc);

/*J 文字列の時刻をパース */
/*E Parse time information represented as a string */
int cellRtcParseDateTime(CellRtcTick *pUtc, const char *pszDateTime);

/*J RFC3339形式の文字列を時刻としてパース */
/*E Parse time information represented in RFC3339 format */
int cellRtcParseRfc3339(CellRtcTick *pUtc, const char *pszDateTime);



/*J CellRtcDateTime構造体の操作 */
/*E Time Information Manipulation Functions */
static __inline__ int cellRtcSetYear(CellRtcDateTime *pTime, int year);
static __inline__ int cellRtcSetMonth(CellRtcDateTime *pTime, int month);
static __inline__ int cellRtcSetDay(CellRtcDateTime *pTime, int day);
static __inline__ int cellRtcSetHour(CellRtcDateTime *pTime, int hour);
static __inline__ int cellRtcSetMinute(CellRtcDateTime *pTime, int minute);
static __inline__ int cellRtcSetSecond(CellRtcDateTime *pTime, int second);
static __inline__ int cellRtcSetMicrosecond(CellRtcDateTime *pTime, int microsecond);

static __inline__ int cellRtcGetYear(const CellRtcDateTime *pTime);
static __inline__ int cellRtcGetMonth(const CellRtcDateTime *pTime);
static __inline__ int cellRtcGetDay(const CellRtcDateTime *pTime);
static __inline__ int cellRtcGetHour(const CellRtcDateTime *pTime);
static __inline__ int cellRtcGetMinute(const CellRtcDateTime *pTime);
static __inline__ int cellRtcGetSecond(const CellRtcDateTime *pTime);
static __inline__ int cellRtcGetMicrosecond(const CellRtcDateTime *pTime);

/*J 年フィールドの設定(1〜9999) */
/*E Set year field(1-9999) */
static __inline__ int cellRtcSetYear(CellRtcDateTime *pTime, int year)
{
	if (year<1 || year>9999) {
		return (0x80010604);
	}

	pTime->year = static_cast<unsigned short>(year);



	return (0);
}

/*J 月フィールドの設定(1〜12) */
/*E Set month field(1-12) */
static __inline__ int cellRtcSetMonth(CellRtcDateTime *pTime, int month)
{
	if (month<1 || month>12) {
		return (0x80010604);
	}

	pTime->month = static_cast<unsigned short>(month);



	return (0);
}

/*J 日フィールドの設定(1〜31) */
/*E Set day field(1-31) */
static __inline__ int cellRtcSetDay(CellRtcDateTime *pTime, int day)
{
	if (day<1 || day>31) {
		return (0x80010604);
	}

	pTime->day = static_cast<unsigned short>(day);



	return (0);
}

/*J 時フィールドの設定(0〜23) */
/*E Set hour field(0-23) */
static __inline__ int cellRtcSetHour(CellRtcDateTime *pTime, int hour)
{
	if (hour<0 || hour>23) {
		return (0x80010604);
	}

	pTime->hour = static_cast<unsigned short>(hour);



	return (0);
}

/*J 分フィールドの設定(0〜59) */
/*E Set minute field(0-59) */
static __inline__ int cellRtcSetMinute(CellRtcDateTime *pTime, int minute)
{
	if (minute<0 || minute>59) {
		return (0x80010604);
	}

	pTime->minute = static_cast<unsigned short>(minute);



	return (0);
}

/*J 秒フィールドの設定(0〜59) */
/*E Set second field(0-59) */
static __inline__ int cellRtcSetSecond(CellRtcDateTime *pTime, int second)
{
	if (second<0 || second>59) {
		return (0x80010604);
	}

	pTime->second = static_cast<unsigned short>(second);



	return (0);
}

/*J μ秒フィールドの設定(0〜999999) */
/*E Set microsecond field(0-999999) */
static __inline__ int cellRtcSetMicrosecond(CellRtcDateTime *pTime, int microsecond)
{
	if (microsecond<0 || microsecond>999999) {
		return (0x80010604);
	}

	pTime->microsecond = static_cast<unsigned int>(microsecond);



	return (0);
}

/*J 年フィールドの取得(0〜9999) */
/*E Get year field(0-9999) */
static __inline__ int cellRtcGetYear(const CellRtcDateTime *pTime)
{
	return (pTime->year);
}

/*J 月フィールドの取得(1〜12) */
/*E Get month field(1-12) */
static __inline__ int cellRtcGetMonth(const CellRtcDateTime *pTime)
{
	return (pTime->month);
}

/*J 日フィールドの取得(1〜31) */
/*E Get day field(1-31) */
static __inline__ int cellRtcGetDay(const CellRtcDateTime *pTime)
{
	return (pTime->day);
}

/*J 時フィールドの取得(0〜23) */
/*E Get hour field(0-23) */
static __inline__ int cellRtcGetHour(const CellRtcDateTime *pTime)
{
	return (pTime->hour);
}

/*J 分フィールドの取得(0〜59) */
/*E Get minute field(0-59) */
static __inline__ int cellRtcGetMinute(const CellRtcDateTime *pTime)
{
	return (pTime->minute);
}

/*J 秒フィールドの取得(0〜59) */
/*E Get second field(0-59) */
static __inline__ int cellRtcGetSecond(const CellRtcDateTime *pTime)
{
	return (pTime->second);
}

/*J μ秒フィールドの取得(0〜999999) */
/*E Get microsecond field(0-999999) */
static __inline__ int cellRtcGetMicrosecond(const CellRtcDateTime *pTime)
{
	return (pTime->microsecond);
}



}




/* Local variables: */
/* tab-width: 4 */
/* End: */
/* vi:set tabstop=4: */
# 20 "C:/usr/local/cell\\target\\ppu\\include/cell/rtc.h" 3

# 13 "C:/usr/local/cell\\target\\ppu\\include/np.h" 3

# 1 "C:/usr/local/cell\\target\\ppu\\include/np/common.h" 3
/*  SCE CONFIDENTIAL                                      */
/*  PlayStation(R)3 Programmer Tool Runtime Library 475.001 */
/*  Copyright (C) 2014 Sony Computer Entertainment Inc.   */
/*  All Rights Reserved.                                  */




extern "C" {


# 24 "C:/usr/local/cell\\target\\ppu\\include/np/common.h" 3















/* SCE_NP_LANG_XXX and CELL_SYSUTIL_LANG_XXX are same value, but some codes exist only in SCE_NP_LANG_XXX.*/

										/*E Japanese */

										/*E English(US) */

										/*E French */

										/*E Spanish */

										/*E German */

										/*E Italian */

										/*E Dutch */

										/*E Portuguese */

										/*E Russian */

										/*E Korean */

										/*E Chinese (traditional) */

										/*E Chinese (simplified) */

										/*E Finnish */

										/*E Swedish */

										/*E Danish */

										/*E Norwegian */

										/*E Polish */

										/*E Brazil Portuguese */

											/*E English(GB) */

											/*E Turkish */

											/*E Spanish(LA) */

											/*E Arabic */

											/*E French (Canada) */



										/*E English(for compatible) */										

										/*E Portuguese(for compatible) */



typedef int SceNpPlatformType;





/* Communication ID */
typedef struct SceNpCommunicationId {
	char data[9];
	char term;
	uint8_t num;
	char dummy;
} SceNpCommunicationId;
typedef SceNpCommunicationId SceNpTitleId;

/* Communication Passphrase */
typedef struct SceNpCommunicationPassphrase {
	uint8_t data[(128)];
} SceNpCommunicationPassphrase;

/* Communication Signature */
typedef struct SceNpCommunicationSignature {
	uint8_t data[(160)];
} SceNpCommunicationSignature;

/* Online ID */
typedef struct SceNpOnlineId {
	char data[16];
	char term;
	char dummy[3];
} SceNpOnlineId;
typedef struct SceNpOnlineId SceNpPsHandle; 

/* NP ID */
typedef struct SceNpId {
	SceNpOnlineId handle;
	uint8_t opt[8];
	uint8_t reserved[8];
} SceNpId;

/* NP Online Name */
typedef struct SceNpOnlineName {
	char data[48];
	char term;
	char padding[3];
} SceNpOnlineName;
typedef struct SceNpOnlineName SceNpSubHandle;

/* NP Avatar URL */
typedef struct SceNpAvatarUrl {
	char data[127];
	char term;
} SceNpAvatarUrl;
typedef struct SceNpAvatarUrl SceNpUserIcon;

/* NP USER INFO */
typedef struct SceNpUserInfo {
	SceNpId userId;
	SceNpOnlineName name;		/* Online Name */
	SceNpAvatarUrl icon;		/* Avatar URL */
} SceNpUserInfo;

/* NP USER INFO 2 */
typedef struct SceNpUserInfo2 {
	SceNpId npId;
	SceNpOnlineName *onlineName;	/* (pointer) Online Name */
	SceNpAvatarUrl  *avatarUrl;		/* (pointer) Avatar URL */
} SceNpUserInfo2;

/* LOBBY ID */
typedef struct SceNpLobbyId {
	uint8_t opt[28];
	uint8_t reserved[8];
} SceNpLobbyId;

/* ROOM ID */
typedef struct SceNpRoomId {
	uint8_t opt[28];
	uint8_t reserved[8];
} SceNpRoomId;

/* My Languages */
typedef	struct SceNpMyLanguages{
	int32_t	language1;	/* It will always be set */
	int32_t	language2;	/* Negative when not set */
	int32_t	language3;	/* Negative when not set */
	uint8_t padding[4];
} SceNpMyLanguages;

/* NP Avatar Image(for Large Size) */
typedef struct SceNpAvatarImage {
	uint8_t data[(200 * 1024U)];
	size_t	size;
	uint8_t	reserved[12];
} SceNpAvatarImage;

typedef enum {
	SCE_NP_AVATAR_SIZE_LARGE,
	SCE_NP_AVATAR_SIZE_MIDDLE,
	SCE_NP_AVATAR_SIZE_SMALL
} SceNpAvatarSizeType;

typedef	struct SceNpAboutMe{
	char	data[63];
	char	term;
} SceNpAboutMe;

typedef struct SceNpManagerCacheParam {
	size_t size;
	struct SceNpOnlineId onlineId;
	struct SceNpId npId;
	struct SceNpOnlineName onlineName;
	struct SceNpAvatarUrl avatarUrl;
} SceNpManagerCacheParam;





int
sceNpInit(
	size_t poolsize,
	void *poolptr
	);

int
sceNpTerm(
	void
	);

int
sceNp2Init(
	size_t poolsize,
	void *poolptr
	);

int
sceNp2Term(
	void
	);


}


# 15 "C:/usr/local/cell\\target\\ppu\\include/np.h" 3

# 1 "C:/usr/local/cell\\target\\ppu\\include/np/ticket.h" 3
/*  SCE CONFIDENTIAL                                      */
/*  PlayStation(R)3 Programmer Tool Runtime Library 475.001 */
/*  Copyright (C) 2007 Sony Computer Entertainment Inc.   */
/*  All Rights Reserved.                                  */




extern "C" {


/*E
 * ----------------------------------------------------------------
 * NP Ticket and Ticket parameter sizes
 * ----------------------------------------------------------------
 */
/*E maximum size of NP Ticket */


/*E size of NP Ticket Serial ID */


/*E size of Subject Region */


/*E size of Subject Domain */


/*E size of Service ID */


/*E size of Entitlement ID */


/*E maximum size of Cookie Information */


/*E NP Ticket version */
typedef struct SceNpTicketVersion {
	uint16_t major;
	uint16_t minor;
} SceNpTicketVersion;

int
sceNpManagerRequestTicket(
	const SceNpId *npId,
	const char *serviceId,
	const void *cookie,
	size_t cookieSize,
	const char *entitlementId,
	unsigned int consumedCount
	);

int
sceNpManagerRequestTicket2(
	const SceNpId *npId,
	const SceNpTicketVersion *version,
	const char *serviceId,
	const void *cookie,
	size_t cookieSize,
	const char *entitlementId,
	unsigned int consumedCount
	);

int
sceNpManagerGetTicket(
	void *buffer,
	size_t *bufferSize
	);

/*E
 * ----------------------------------------------------------------
 * NP Ticket parameter types and functions
 * ----------------------------------------------------------------
 */


typedef int64_t SceNpTime;	/*E time in milliseconds */

typedef struct SceNpDate {
	uint16_t year;
	uint8_t month;
	uint8_t day;
} SceNpDate;

union SceNpTicketParam {
	int32_t		i32;
	int64_t		i64;
	uint32_t	u32;
	uint64_t	u64;
	SceNpDate	date;
	uint8_t		data[(256)];
};

typedef enum {
	SCE_NP_TICKET_PARAM_SERIAL_ID = 0,       /* Binary */
	SCE_NP_TICKET_PARAM_ISSUER_ID,           /* uint32 */
	SCE_NP_TICKET_PARAM_ISSUED_DATE,         /* SceNpTime */
	SCE_NP_TICKET_PARAM_EXPIRE_DATE,         /* SceNpTime */
	SCE_NP_TICKET_PARAM_SUBJECT_ACCOUNT_ID,  /* uint64 */
	SCE_NP_TICKET_PARAM_SUBJECT_ONLINE_ID,   /* String */
	SCE_NP_TICKET_PARAM_SUBJECT_REGION,      /* Binary */
	SCE_NP_TICKET_PARAM_SUBJECT_DOMAIN,      /* String */
	SCE_NP_TICKET_PARAM_SERVICE_ID,          /* String */
	SCE_NP_TICKET_PARAM_SUBJECT_STATUS,      /* uint32 */
	SCE_NP_TICKET_PARAM_STATUS_DURATION,     /* SceNpTime */
	SCE_NP_TICKET_PARAM_SUBJECT_DOB,         /* SceNpDate */

	SCE_NP_TICKET_PARAM_MAX
} SceNpTicketParamId;

int
sceNpManagerGetTicketParam(
	int paramId,
	union SceNpTicketParam *param
	);










# 133 "C:/usr/local/cell\\target\\ppu\\include/np/ticket.h" 3


/*E NP country code (ISO 3166-1 two-letter system) */
typedef struct SceNpCountryCode {
	char data[2];
	char term;
	char padding[1];
} SceNpCountryCode;


/*E
 * ----------------------------------------------------------------
 * NP Entitlement types and functions
 * ----------------------------------------------------------------
 */
typedef struct SceNpEntitlementId {
	unsigned char data[(32)];
} SceNpEntitlementId;

typedef enum {
	SCE_NP_ENTITLEMENT_TYPE_NON_CONSUMABLE = 0,
	SCE_NP_ENTITLEMENT_TYPE_CONSUMABLE
} SceNpEntitlementType;

typedef struct SceNpEntitlement {
	SceNpEntitlementId	id;
	SceNpTime	created_date;
	SceNpTime	expire_date;
	uint32_t	type;
	int32_t		remaining_count;  /*E may be negative */
	uint32_t	consumed_count;
	uint8_t		padding[4];
} SceNpEntitlement;

int
sceNpManagerGetEntitlementIdList(
	SceNpEntitlementId *entIdList,
	size_t entIdListNum
	);

int 
sceNpManagerGetEntitlementById(
	const char *entId,
	SceNpEntitlement *ent
	);






}


# 17 "C:/usr/local/cell\\target\\ppu\\include/np.h" 3

# 1 "C:/usr/local/cell\\target\\ppu\\include/np/manager.h" 3
/*  SCE CONFIDENTIAL                                      */
/*  PlayStation(R)3 Programmer Tool Runtime Library 475.001 */
/*  Copyright (C) 2008 Sony Computer Entertainment Inc.   */
/*  All Rights Reserved.                                  */






extern "C" {






typedef void (*SceNpManagerSubSigninCallback)(int result, SceNpId *npId, void *cb_arg);

static inline int sceNpManagerInit(void) {return(0);}
static inline int sceNpManagerTerm(void) {return(0);}

/*
 * Np Manager Status
 */








/*
 * Np Manager API
 */
int
sceNpManagerGetStatus(
	int *status
	);

int
sceNpManagerGetOnlineId(
	SceNpOnlineId *onlineId
	);

int
sceNpManagerGetNpId(
	SceNpId *npId
	);

/*
 * NP manager callback
 */
typedef void (*SceNpManagerCallback)(
	int event,
	int result,
	void *arg);

int
sceNpManagerRegisterCallback(
	SceNpManagerCallback callback,
	void *arg
	);

int
sceNpManagerUnregisterCallback(
	void
	);

int
sceNpManagerGetOnlineName(
	SceNpOnlineName *onlineName
	);

int
sceNpManagerGetAvatarUrl(
	SceNpAvatarUrl *avatarUrl
	);

int
sceNpManagerGetMyLanguages(
	SceNpMyLanguages *myLang
	);

int
sceNpManagerGetNetworkTime(
	CellRtcTick *pTick
	);

int
sceNpManagerGetAccountRegion(
	SceNpCountryCode *countryCode,
	int *languageCode
	);

int
sceNpManagerGetAccountAge(
	int *age
	);

int
sceNpManagerGetContentRatingFlag(
	int *isRestricted,
	int *age
	);

int
sceNpManagerGetChatRestrictionFlag(
	int *isRestricted
	);

int
sceNpManagerSubSignin(
	CellSysutilUserId userId,
	SceNpManagerSubSigninCallback cb_func,
	void *cb_arg,
	int flag
	);

int
sceNpManagerSubSignout(
	SceNpId *npId
	);

int
sceNpManagerSubSigninAbortGui(
	void
	);


int
sceNpManagerGetCachedInfo(
	CellSysutilUserId userID, 
	struct SceNpManagerCacheParam *param
	);

/* obsolete */
int
sceNpManagerGetPsHandle(
	SceNpPsHandle *psHandle
	);


}


# 19 "C:/usr/local/cell\\target\\ppu\\include/np.h" 3

# 1 "C:/usr/local/cell\\target\\ppu\\include/np/signaling.h" 3
/*  SCE CONFIDENTIAL                                      */
/*  PlayStation(R)3 Programmer Tool Runtime Library 475.001 */
/*  Copyright (C) 2007 Sony Computer Entertainment Inc.   */
/*  All Rights Reserved.                                  */




extern "C" {


/*
 * Np Signaling Context
 */


/*
 * Np Signaling Event
 */





/*
 * Np Signaling Event for Extended Handnler Only
 */



/* obsolete */


/*
 * Np Connection Status
 */




/*
 * Np Connection Info
 */
# 50 "C:/usr/local/cell\\target\\ppu\\include/np/signaling.h" 3

/*
 * Np Signaling Context Option
 */





typedef union SceNpSignalingConnectionInfo {
	uint32_t rtt;
	uint32_t bandwidth;
	SceNpId npId;
	struct {
		struct in_addr addr;
		in_port_t port;
	} address;
	uint32_t packet_loss;
} SceNpSignalingConnectionInfo;

/*
 * Np Signaling Handler
 */
typedef void (*SceNpSignalingHandler)(
	uint32_t ctx_id,
	uint32_t subject_id,
	int event,
	int error_code,
	void *arg
	);

static inline int sceNpSignalingInit(void) {return(0);}
static inline int sceNpSignalingTerm(void) {return(0);}

/*
 * Np Signaling API
 */
int
sceNpSignalingCreateCtx(
	const SceNpId *npId,
	SceNpSignalingHandler handler,
	void *arg,
	uint32_t *ctx_id
	);

int
sceNpSignalingDestroyCtx(
	uint32_t ctx_id
	);

int
sceNpSignalingActivateConnection(
	uint32_t ctx_id,
	const SceNpId *npId,
	uint32_t *conn_id
	);

int
sceNpSignalingDeactivateConnection(
	uint32_t ctx_id,
	uint32_t conn_id
	);

int
sceNpSignalingTerminateConnection(
	uint32_t ctx_id,
	uint32_t conn_id
	);

int
sceNpSignalingGetConnectionStatus(
	uint32_t ctx_id,
	uint32_t conn_id,
	int *conn_status,
	struct in_addr *peer_addr,
	in_port_t *peer_port
	);

int
sceNpSignalingGetConnectionInfo(
	uint32_t ctx_id,
	uint32_t conn_id,
	int code,
	SceNpSignalingConnectionInfo *info
	);

int
sceNpSignalingAddExtendedHandler(
	uint32_t ctx_id,
	SceNpSignalingHandler handler,
	void *arg
	);

int
sceNpSignalingGetConnectionFromNpId(
	uint32_t ctx_id,
	const SceNpId *npId,
	uint32_t *conn_id
	);

int
sceNpSignalingGetConnectionFromPeerAddress(
	uint32_t ctx_id,
	struct in_addr peer_addr,
	in_port_t peer_port,
	uint32_t *conn_id
	);

int
sceNpSignalingSetCtxOpt(
	uint32_t ctx_id,
	int optname,
	int optval
	);

int
sceNpSignalingGetCtxOpt(
	uint32_t ctx_id,
	int optname,
	int *optval
	);

/*
 * Np Signaling NetInfo
 */

typedef struct SceNpSignalingNetInfo {
	size_t size;
	struct in_addr local_addr;
	struct in_addr mapped_addr;
	int nat_status;
	int upnp_status;
	int npport_status;
	uint16_t npport;
} SceNpSignalingNetInfo;

/* nat staus */




/* upnp status */



/* npport status */



/*
 * Np Signaling NetInfo API
 */

int
sceNpSignalingGetLocalNetInfo(
	uint32_t ctx_id,
	SceNpSignalingNetInfo *netinfo
	);

int
sceNpSignalingGetPeerNetInfo(
	uint32_t ctx_id,
	const SceNpId *npId,
	uint32_t *req_id
	);

int
sceNpSignalingCancelPeerNetInfo(
	uint32_t ctx_id,
	uint32_t req_id
	);

int
sceNpSignalingGetPeerNetInfoResult(
	uint32_t ctx_id,
	uint32_t req_id,
	SceNpSignalingNetInfo *netinfo
	);


}


# 21 "C:/usr/local/cell\\target\\ppu\\include/np.h" 3

# 1 "C:/usr/local/cell\\target\\ppu\\include/np/basic.h" 3
/*  SCE CONFIDENTIAL                                      */
/*  PlayStation(R)3 Programmer Tool Runtime Library 475.001 */
/*  Copyright (C) 2009 Sony Computer Entertainment Inc.   */
/*  All Rights Reserved.                                  */






extern "C" {


# 30 "C:/usr/local/cell\\target\\ppu\\include/np/basic.h" 3


/* Incoming events */
# 60 "C:/usr/local/cell\\target\\ppu\\include/np/basic.h" 3









/* Presence states */










/* Message types */
# 87 "C:/usr/local/cell\\target\\ppu\\include/np/basic.h" 3

# 95 "C:/usr/local/cell\\target\\ppu\\include/np/basic.h" 3

/* Message feature flags */
# 106 "C:/usr/local/cell\\target\\ppu\\include/np/basic.h" 3






# 119 "C:/usr/local/cell\\target\\ppu\\include/np/basic.h" 3

/* Message Info Types */
# 129 "C:/usr/local/cell\\target\\ppu\\include/np/basic.h" 3

typedef uint64_t SceNpBasicMessageId;
typedef uint16_t SceNpBasicMessageMainType;
typedef uint16_t SceNpBasicMessageSubType;
typedef uint32_t SceNpBasicMessageFeatures;
typedef uint32_t SceNpBasicMessageRecvOptions;
typedef uint32_t SceNpBasicMessageRecvAction;
typedef uint32_t SceNpBasicMessageInfoType;

typedef struct SceNpBasicMessageDetails {
	SceNpBasicMessageId msgId;
	SceNpBasicMessageMainType mainType;
	SceNpBasicMessageSubType subType;
	SceNpBasicMessageFeatures msgFeatures;
	const SceNpId *npids;
	size_t count;
	const char *subject;
	const char *body;
	const void *data;
	size_t size;
} SceNpBasicMessageDetails;

typedef uint32_t SceNpBasicAttachmentDataId;

typedef struct SceNpBasicAttachmentData {
	SceNpBasicAttachmentDataId id;
	size_t size;
} SceNpBasicAttachmentData;

typedef struct SceNpBasicExtendedAttachmentData {
	uint64_t flags;
	SceNpBasicMessageId msgId;
	SceNpBasicAttachmentData data;
	SceNpBasicMessageRecvAction userAction;
	bool markedAsUsed;
	uint8_t reserved[3];
} SceNpBasicExtendedAttachmentData;

typedef struct SceNpBasicPresenceDetails {
	char title[(128)];
	char status[(64)];
	char comment[(64)];
	uint8_t data[(128)];
	size_t size;
	int state;
} SceNpBasicPresenceDetails;

typedef struct SceNpBasicPresenceDetails2 {
	size_t struct_size;
	int state;
	char title[(128)];
	char status[(192)];
	char comment[(64)];
	uint8_t data[(128)];
	size_t size;
} SceNpBasicPresenceDetails2;

typedef int (*SceNpBasicEventHandler)(
	int event,
	int retCode,
	uint32_t reqId,
	void *arg
	);

/* obsolete */
static inline int sceNpBasicInit(void) {return(0);}
static inline int sceNpBasicTerm(void) {return(0);}

/*
 * Np Basic API
 */

/*
 * Registration Functions
 */
int
sceNpBasicRegisterHandler(
	const SceNpCommunicationId *context,
	SceNpBasicEventHandler handler,
	void *arg
	);

int
sceNpBasicRegisterContextSensitiveHandler(
	const SceNpCommunicationId *context,
	SceNpBasicEventHandler handler,
	void *arg
	);

int
sceNpBasicUnregisterHandler(
	void
	);

/*
 * IM Functions
 */
int sceNpBasicSetPresence(
	const void *data,
	size_t size
	);

int sceNpBasicSetPresenceDetails(
	const SceNpBasicPresenceDetails *pres,
	uint32_t options
	);

int sceNpBasicSetPresenceDetails2(
	const SceNpBasicPresenceDetails2 *pres,
	uint32_t options
	);

int sceNpBasicSendMessage(
	const SceNpId *to,
	const void *data,
	size_t size
	);

int sceNpBasicSendMessageGui(
	const SceNpBasicMessageDetails *msg,
	sys_memory_container_t containerId
	);

int sceNpBasicSendMessageAttachment(
	const SceNpId *to,
	const char *subject,
	const char *body,
	const void *data,
	size_t size,
	sys_memory_container_t containerId
	);

int sceNpBasicRecvMessageAttachment(
	sys_memory_container_t containerId
	);

int sceNpBasicRecvMessageAttachmentLoad(
	SceNpBasicAttachmentDataId id,
	void *buffer,
	size_t *size
	);

int sceNpBasicRecvMessageCustom(
	SceNpBasicMessageMainType mainType,
	SceNpBasicMessageRecvOptions recvOptions,
	sys_memory_container_t containerId
	);

int sceNpBasicMarkMessageAsUsed(
	SceNpBasicMessageId msgId
	);

int sceNpBasicAbortGui(
	void
	);


/*
 * Friend Management Functions
 */
int sceNpBasicAddFriend(
	const SceNpId *contact,
	const char *body,
	sys_memory_container_t containerId
	);

int sceNpBasicGetFriendListEntryCount(
	uint32_t *count
	);

int sceNpBasicGetFriendListEntry(
	uint32_t index,
	SceNpId *npid
	);

int sceNpBasicGetFriendPresenceByIndex(
	uint32_t index,
	SceNpUserInfo *user,
	SceNpBasicPresenceDetails *pres,
	uint32_t options
	);

int sceNpBasicGetFriendPresenceByNpId(
	const SceNpId *npid,
	SceNpBasicPresenceDetails *pres,
	uint32_t options
	);

int sceNpBasicGetFriendPresenceByIndex2(
	uint32_t index,
	SceNpUserInfo *user,
	SceNpBasicPresenceDetails2 *pres,
	uint32_t options
	);

int sceNpBasicGetFriendPresenceByNpId2(
	const SceNpId *npid,
	SceNpBasicPresenceDetails2 *pres,
	uint32_t options
	);

/*
 * Utility Functions
 */
int sceNpBasicAddPlayersHistory(
	const SceNpId *npid,
	const char *description
	);

int sceNpBasicAddPlayersHistoryAsync(
	const SceNpId *npids,
	size_t count,
	const char *description,
	uint32_t *reqId
	);

int sceNpBasicGetPlayersHistoryEntryCount(
	uint32_t options,
	uint32_t *count
	);

int sceNpBasicGetPlayersHistoryEntry(
	uint32_t options,
	uint32_t index,
	SceNpId *npid
	);

int sceNpBasicAddBlockListEntry(
	const SceNpId *user
	);

int sceNpBasicGetBlockListEntryCount(
	uint32_t *count
	);

int sceNpBasicGetBlockListEntry(
	uint32_t index,
	SceNpId *npid
	);

int sceNpBasicGetMessageAttachmentEntryCount(
	uint32_t *count
	);

int sceNpBasicGetMessageAttachmentEntry(
	uint32_t index,
	SceNpUserInfo *from
	);

int sceNpBasicGetMatchingInvitationEntryCount(
	uint32_t *count
	);

int sceNpBasicGetMatchingInvitationEntry(
	uint32_t index,
	SceNpUserInfo *from
	);

int sceNpBasicGetCustomInvitationEntryCount(
	uint32_t *count
	);

int sceNpBasicGetCustomInvitationEntry(
	uint32_t index,
	SceNpUserInfo *from
	);

int sceNpBasicGetClanMessageEntryCount(
	uint32_t *count
	);

int sceNpBasicGetClanMessageEntry(
	uint32_t index,
	SceNpUserInfo *from
	);

int sceNpBasicGetMessageEntryCount(
	SceNpBasicMessageInfoType type,
	uint32_t *count
	);

int sceNpBasicGetMessageEntry(
	SceNpBasicMessageInfoType type,
	uint32_t index,
	SceNpUserInfo *from
	);

/*
 * Get Event Functions
 */
int sceNpBasicGetEvent(
	int *event,
	SceNpUserInfo *from,
	void *data,
	size_t *size
	);


}


# 23 "C:/usr/local/cell\\target\\ppu\\include/np.h" 3

# 1 "C:/usr/local/cell\\target\\ppu\\include/np/util.h" 3
/*  SCE CONFIDENTIAL                                      */
/*  PlayStation(R)3 Programmer Tool Runtime Library 475.001 */
/*  Copyright (C) 2012 Sony Computer Entertainment Inc.   */
/*  All Rights Reserved.                                  */




extern "C" {


int sceNpUtilCmpNpId(const SceNpId *npid1, const SceNpId *npid2);
int sceNpUtilCmpNpIdInOrder(const SceNpId *npid1, const SceNpId *npid2, int *order);
int sceNpUtilCmpOnlineId(const SceNpId *npid1, const SceNpId *npid2);

int sceNpUtilGetPlatformType(const SceNpId *npId);
int sceNpUtilSetPlatformType(SceNpId *npId, SceNpPlatformType platformType);

int sceNpUtilBuildCdnUrl(const char *url, char *buf, size_t bufSize, size_t *required, void *option );


typedef struct SceNpUtilBandwidthTestResult {
	double upload_bps;
	double download_bps;
	int result;
	char padding[4];
} SceNpUtilBandwidthTestResult;





int sceNpUtilBandwidthTestInitStart(int prio, size_t stack);
int sceNpUtilBandwidthTestGetStatus(void);
int sceNpUtilBandwidthTestShutdown(struct SceNpUtilBandwidthTestResult *result);
int sceNpUtilBandwidthTestAbort(void);


}


# 25 "C:/usr/local/cell\\target\\ppu\\include/np.h" 3

# 1 "C:/usr/local/cell\\target\\ppu\\include/np/friendlist.h" 3
/*  SCE CONFIDENTIAL                                      */
/*  PlayStation(R)3 Programmer Tool Runtime Library 475.001 */
/*  Copyright (C) 2008 Sony Computer Entertainment Inc.   */
/*  All Rights Reserved.                                  */






extern "C" {


typedef uint64_t SceNpFriendlistCustomOptions;

typedef int (*SceNpFriendlistResultHandler)(
	int retCode,
	void *arg
	);

int sceNpFriendlist(
	SceNpFriendlistResultHandler resultHandler,
	void *userArg,
	sys_memory_container_t containerId
	);

int sceNpFriendlistCustom(
	SceNpFriendlistCustomOptions options,
	SceNpFriendlistResultHandler resultHandler,
	void *userArg,
	sys_memory_container_t containerId
	);

int sceNpFriendlistAbortGui(
	void
	);


}


# 27 "C:/usr/local/cell\\target\\ppu\\include/np.h" 3

# 1 "C:/usr/local/cell\\target\\ppu\\include/np/lookup.h" 3
/*   SCE CONFIDENTIAL
PlayStation(R)3 Programmer Tool Runtime Library 475.001
*   Copyright (C) 2009 Sony Computer Entertainment Inc.
*   All Rights Reserved.
*/



# 1 "C:/usr/local/cell\\target\\ppu\\include/np.h" 3
/*  SCE CONFIDENTIAL                                      */
/*  PlayStation(R)3 Programmer Tool Runtime Library 475.001 */
/*  Copyright (C) 2007 Sony Computer Entertainment Inc.   */
/*  All Rights Reserved.                                  */
# 10 "C:/usr/local/cell\\target\\ppu\\include/np/lookup.h" 3




extern "C" {


int sceNpLookupInit(void);
int	sceNpLookupTerm(void);

int	sceNpLookupCreateTitleCtx(
	const SceNpCommunicationId *titleId,
	const SceNpId *selfNpId
);

int	sceNpLookupDestroyTitleCtx (
	int32_t titleCtxId
);

int	sceNpLookupCreateTransactionCtx(
	int32_t	titleCtxId
);

int	sceNpLookupDestroyTransactionCtx (
	int32_t transId
);

int sceNpLookupAbortTransaction (
	int32_t transId
);

int sceNpLookupSetTimeout(
	int32_t transId,
	usecond_t timeout
);

int	sceNpLookupWaitAsync (
	int32_t transId,
	int32_t *result
);

int	sceNpLookupPollAsync (
	int32_t transId,
	int32_t *result
);

int	sceNpLookupNpId(
	int32_t				transId,
	const SceNpOnlineId	*onlineId,
	SceNpId				*npId,
	void				*option
);

int	sceNpLookupNpIdAsync(
	int32_t				transId,
	const SceNpOnlineId	*onlineId,
	SceNpId				*npId,
	int32_t				prio,
	void				*option
);

int	sceNpLookupUserProfile(
	int32_t				transId,
	const SceNpId		*npId,
	SceNpUserInfo		*userInfo,
	SceNpAboutMe		*aboutMe,
	SceNpMyLanguages	*languages,
	SceNpCountryCode	*countryCode,
	SceNpAvatarImage	*avatarImage,
	void *option
);

int	sceNpLookupUserProfileAsync(
	int32_t				transId,
	const SceNpId		*npId,
	SceNpUserInfo		*userInfo,
	SceNpAboutMe		*aboutMe,
	SceNpMyLanguages	*languages,
	SceNpCountryCode	*countryCode,
	SceNpAvatarImage	*avatarImage,
	int32_t				prio,
	void				*option
);

int	sceNpLookupUserProfileWithAvatarSize(
	int32_t				transId,
	int32_t				avatarSizeType,
	const SceNpId		*npId,
	SceNpUserInfo		*userInfo,
	SceNpAboutMe		*aboutMe,
	SceNpMyLanguages	*languages,
	SceNpCountryCode	*countryCode,
	void				*avatarImageData,
	size_t				avatarImageDataMaxSize,
	size_t				*avatarImageDataSize,
	void *option
);

int	sceNpLookupUserProfileWithAvatarSizeAsync(
	int32_t				transId,
	int32_t				avatarSizeType,
	const SceNpId		*npId,
	SceNpUserInfo		*userInfo,
	SceNpAboutMe		*aboutMe,
	SceNpMyLanguages	*languages,
	SceNpCountryCode	*countryCode,
	void				*avatarImageData,
	size_t				avatarImageDataMaxSize,
	size_t				*avatarImageDataSize,
	int32_t				prio,
	void				*option
);



int	sceNpLookupAvatarImage(
	int32_t					transId,
	const SceNpAvatarUrl	*avatarUrl,
	SceNpAvatarImage		*avatarImage,
	void					*option
);


int	sceNpLookupAvatarImageAsync(
	int32_t					transId,
	const SceNpAvatarUrl	*avatarUrl,
	SceNpAvatarImage		*avatarImage,
	int32_t					prio,
	void					*option
);

int	sceNpLookupTitleSmallStorage(
	int32_t					transId,
	void					*data,
	size_t					maxSize,
	size_t					*contentLength,
	void *option
);

int	sceNpLookupTitleSmallStorageAsync(
	int32_t					transId,
	void					*data,
	size_t					maxSize,
	size_t					*contentLength,
	int32_t					prio,
	void *option
);


}





# 29 "C:/usr/local/cell\\target\\ppu\\include/np.h" 3

# 1 "C:/usr/local/cell\\target\\ppu\\include/np/clans.h" 3
/*  SCE CONFIDENTIAL                                      */
/*  PlayStation(R)3 Programmer Tool Runtime Library 475.001 */
/*  Copyright (C) 2009 Sony Computer Entertainment Inc.   */
/*  All Rights Reserved.                                  */




extern "C" {


/* sizes */
# 29 "C:/usr/local/cell\\target\\ppu\\include/np/clans.h" 3

/* roles */






/* bit fields */
# 72 "C:/usr/local/cell\\target\\ppu\\include/np/clans.h" 3

/* search operators */
# 81 "C:/usr/local/cell\\target\\ppu\\include/np/clans.h" 3

/* status */





/* message options */








struct SceNpClansRequest;
typedef struct SceNpClansRequest* SceNpClansRequestHandle;
typedef uint32_t SceNpClanId;
typedef uint32_t SceNpClansMessageId;
typedef uint32_t SceNpClansRole;
typedef int32_t SceNpClansMemberStatus;
typedef int32_t SceNpClansSearchOperator;

typedef struct SceNpClansPagingRequest {
	size_t startPos;
	size_t max;
} SceNpClansPagingRequest;

typedef struct SceNpClansPagingResult {
	size_t count;
	size_t total;
} SceNpClansPagingResult;

typedef struct SceNpClansClanBasicInfo {
	SceNpClanId clanId;
	size_t numMembers;
	char name[(64)+1];
	char tag[(8)+1];
	uint8_t reserved[2];
} SceNpClansClanBasicInfo;

typedef struct SceNpClansEntry {
	SceNpClansClanBasicInfo info;
	SceNpClansRole role;
	SceNpClansMemberStatus status;
	bool allowMsg;
	uint8_t reserved[3];
} SceNpClansEntry;

typedef struct SceNpClansSearchableAttr {
	uint32_t fields;
	uint32_t intAttr1;
	uint32_t intAttr2;
	uint32_t intAttr3;
	uint8_t binAttr1[(190)];
	uint8_t reserved[2];
} SceNpClansSearchableAttr;

typedef struct SceNpClansSearchableProfile {
	SceNpClansSearchableAttr attr;
	uint32_t fields;
	size_t numMembers;
	SceNpClansSearchOperator tagSearchOp;
	SceNpClansSearchOperator numMembersSearchOp;
	SceNpClansSearchOperator intAttr1SearchOp;
	SceNpClansSearchOperator intAttr2SearchOp;
	SceNpClansSearchOperator intAttr3SearchOp;
	SceNpClansSearchOperator binAttr1SearchOp;
	char tag[(8)+1];
	uint8_t reserved[3];
} SceNpClansSearchableProfile;

typedef struct SceNpClansSearchableName {
	SceNpClansSearchOperator nameSearchOp;
	char name[(64)+1];
	uint8_t reserved[3];
} SceNpClansSearchableName;

typedef struct SceNpClansUpdatableClanInfo {
	uint32_t fields;
	char description[(255)+1];
	SceNpClansSearchableAttr attr;
	uint8_t *binData1;
	size_t binData1Size;
} SceNpClansUpdatableClanInfo;

typedef struct SceNpClansClanInfo {
	CellRtcTick dateCreated;
	SceNpClansClanBasicInfo info;
	SceNpClansUpdatableClanInfo updatable;
} SceNpClansClanInfo;

typedef struct SceNpClansUpdatableMemberInfo {
	uint32_t fields;
	uint8_t *binData1;
	size_t binData1Size;
	uint8_t binAttr1[(16)];
	char description[(255)+1];
	bool allowMsg;
	uint8_t reserved[3];
} SceNpClansUpdatableMemberInfo;

typedef struct SceNpClansMemberEntry {
	SceNpId npid;
	SceNpClansRole role;
	SceNpClansMemberStatus status;
	SceNpClansUpdatableMemberInfo updatable;
} SceNpClansMemberEntry;

typedef struct SceNpClansMessage {
	char subject[(54)+1];
	char body[(1536)+1];
	uint32_t options;
} SceNpClansMessage;

typedef struct SceNpClansMessageData {
	uint8_t *binData1;
	size_t binData1Size;
} SceNpClansMessageData;

typedef struct SceNpClansMessageEntry {
	CellRtcTick postDate;
	SceNpClansMessageId mId;
	SceNpClansMessage message;
	SceNpClansMessageData data;
	SceNpId npid;
	SceNpClanId postedBy;
} SceNpClansMessageEntry;

typedef struct SceNpClansBlacklistEntry {
	SceNpId entry;
	SceNpId registeredBy;
} SceNpClansBlacklistEntry;

/*
 * Clan Library Functions
 */
int sceNpClansInit(
	const SceNpCommunicationId *commId,
	const SceNpCommunicationPassphrase *passphrase,
	void *pool,
	size_t poolSize,
	uint32_t flags
	);

int sceNpClansTerm(
	void
	);

int sceNpClansCreateRequest(
	SceNpClansRequestHandle *handle,
	uint64_t flags
	);

int sceNpClansDestroyRequest(
	SceNpClansRequestHandle handle
	);

int sceNpClansAbortRequest(
	SceNpClansRequestHandle handle
	);

/*
 * General Clan Functions
 */
int sceNpClansCreateClan(
	SceNpClansRequestHandle handle,
	const char *name,
	const char *tag,
	SceNpClanId *clanId
	);

int sceNpClansDisbandClan(
	SceNpClansRequestHandle handle,
	SceNpClanId clanId
	);

int sceNpClansGetClanList(
	SceNpClansRequestHandle handle,
	const SceNpClansPagingRequest *paging,
	SceNpClansEntry *clanList,
	SceNpClansPagingResult *pageResult
	);

int sceNpClansGetClanListByNpId(
	SceNpClansRequestHandle handle,
	const SceNpClansPagingRequest *paging,
	const SceNpId *npid,
	SceNpClansEntry *clanList,
	SceNpClansPagingResult *pageResult
	);

/*
 * Clan Search Functions
 */
int sceNpClansSearchByProfile(
	SceNpClansRequestHandle handle,
	const SceNpClansPagingRequest *paging,
	const SceNpClansSearchableProfile *search,
	SceNpClansClanBasicInfo *results,
	SceNpClansPagingResult *pageResult
	);

int sceNpClansSearchByName(
	SceNpClansRequestHandle handle,
	const SceNpClansPagingRequest *paging,
	const SceNpClansSearchableName *search,
	SceNpClansClanBasicInfo *results,
	SceNpClansPagingResult *pageResult
	);

/*
 * Clan Information Functions
 */
int sceNpClansGetClanInfo(
	SceNpClansRequestHandle handle,
	SceNpClanId clanId,
	SceNpClansClanInfo *info
	);

int sceNpClansUpdateClanInfo(
	SceNpClansRequestHandle handle,
	SceNpClanId clanId,
	const SceNpClansUpdatableClanInfo *info
	);

int sceNpClansGetMemberList(
	SceNpClansRequestHandle handle,
	SceNpClanId clanId,
	const SceNpClansPagingRequest *paging,
	SceNpClansMemberStatus status,
	SceNpClansMemberEntry *memList,
	SceNpClansPagingResult *pageResult
	);

int sceNpClansGetMemberInfo(
	SceNpClansRequestHandle handle,
	SceNpClanId clanId,
	const SceNpId *npid,
	SceNpClansMemberEntry *memInfo
	);

int sceNpClansUpdateMemberInfo(
	SceNpClansRequestHandle handle,
	SceNpClanId clanId,
	const SceNpClansUpdatableMemberInfo *info
	);

int sceNpClansChangeMemberRole(
	SceNpClansRequestHandle handle,
	SceNpClanId clanId,
	const SceNpId *npid,
	SceNpClansRole role
	);

int sceNpClansUpdateAutoAcceptStatus(
	SceNpClansRequestHandle handle,
	SceNpClanId clanId,
	bool enable
	);

int sceNpClansGetAutoAcceptStatus(
	SceNpClansRequestHandle handle,
	SceNpClanId clanId,
	bool *enable
	);

/*
 * Clan Membership Functions
 */
int sceNpClansJoinClan(
	SceNpClansRequestHandle handle,
	SceNpClanId clanId
	);

int sceNpClansLeaveClan(
	SceNpClansRequestHandle handle,
	SceNpClanId clanId
	);

int sceNpClansKickMember(
	SceNpClansRequestHandle handle,
	SceNpClanId clanId,
	const SceNpId *npid,
	const SceNpClansMessage *message
	);

int sceNpClansSendInvitation(
	SceNpClansRequestHandle handle,
	SceNpClanId clanId,
	const SceNpId *npid,
	const SceNpClansMessage *message
	);

int sceNpClansCancelInvitation(
	SceNpClansRequestHandle handle,
	SceNpClanId clanId,
	const SceNpId *npid
	);

int sceNpClansSendInvitationResponse(
	SceNpClansRequestHandle handle,
	SceNpClanId clanId,
	const SceNpClansMessage *message,
	bool accept
	);

int sceNpClansSendMembershipRequest(
	SceNpClansRequestHandle handle,
	SceNpClanId clanId,
	const SceNpClansMessage *message
	);

int sceNpClansCancelMembershipRequest(
	SceNpClansRequestHandle handle,
	SceNpClanId clanId
	);

int sceNpClansSendMembershipResponse(
	SceNpClansRequestHandle handle,
	SceNpClanId clanId,
	const SceNpId *npid,
	const SceNpClansMessage *message,
	bool allow
	);

/*
 * Clan Blacklist Functions
 */
int sceNpClansGetBlacklist(
	SceNpClansRequestHandle handle,
	SceNpClanId clanId,
	const SceNpClansPagingRequest *paging,
	SceNpClansBlacklistEntry *bl,
	SceNpClansPagingResult *pageResult
	);

int sceNpClansAddBlacklistEntry(
	SceNpClansRequestHandle handle,
	SceNpClanId clanId,
	const SceNpId *npid
	);

int sceNpClansRemoveBlacklistEntry(
	SceNpClansRequestHandle handle,
	SceNpClanId clanId,
	const SceNpId *npid
	);

/*
 * Clan Announcements Functions
 */
int sceNpClansRetrieveAnnouncements(
	SceNpClansRequestHandle handle,
	SceNpClanId clanId,
	const SceNpClansPagingRequest *paging,
	SceNpClansMessageEntry *mList,
	SceNpClansPagingResult *pageResult
	);

int sceNpClansPostAnnouncement(
	SceNpClansRequestHandle handle,
	SceNpClanId clanId,
	const SceNpClansMessage *message,
	const SceNpClansMessageData *data,
	uint32_t duration,
	SceNpClansMessageId *mId
	);

int sceNpClansRemoveAnnouncement(
	SceNpClansRequestHandle handle,
	SceNpClanId clanId,
	SceNpClansMessageId mId
	);

/*
 * Clan Challenge Functions
 */
int sceNpClansPostChallenge(
	SceNpClansRequestHandle handle,
	SceNpClanId clanId,
	SceNpClanId targetClan,
	const SceNpClansMessage *message,
	const SceNpClansMessageData *data,
	uint32_t duration,
	SceNpClansMessageId *mId
	);

int sceNpClansRetrievePostedChallenges(
	SceNpClansRequestHandle handle,
	SceNpClanId clanId,
	SceNpClanId targetClan,
	const SceNpClansPagingRequest *paging,
	SceNpClansMessageEntry *mList,
	SceNpClansPagingResult *pageResult
	);

int sceNpClansRemovePostedChallenge(
	SceNpClansRequestHandle handle,
	SceNpClanId clanId,
	SceNpClanId targetClan,
	SceNpClansMessageId mId
	);

int sceNpClansRetrieveChallenges(
	SceNpClansRequestHandle handle,
	SceNpClanId clanId,
	const SceNpClansPagingRequest *paging,
	SceNpClansMessageEntry *mList,
	SceNpClansPagingResult *pageResult
	);

int sceNpClansRemoveChallenge(
	SceNpClansRequestHandle handle,
	SceNpClanId clanId,
	SceNpClansMessageId mId
	);


}


# 31 "C:/usr/local/cell\\target\\ppu\\include/np.h" 3

# 1 "C:/usr/local/cell\\target\\ppu\\include/np/ranking.h" 3
/*   SCE CONFIDENTIAL
PlayStation(R)3 Programmer Tool Runtime Library 475.001
*   Copyright (C) 2014 Sony Computer Entertainment Inc.
*   All Rights Reserved.
*/





# 18 "C:/usr/local/cell\\target\\ppu\\include/np/ranking.h" 3

















extern "C" {


typedef	uint32_t	SceNpScoreBoardId;
typedef int64_t		SceNpScoreValue;
typedef	uint32_t	SceNpScoreRankNumber;
typedef	int32_t		SceNpScorePcId;
// for compatibility
typedef SceNpCommunicationPassphrase SceNpScorePassphrase;

typedef	struct SceNpScoreGameInfo{
	uint8_t	nativeData[64];
} SceNpScoreGameInfo;

typedef	struct SceNpScoreGameDataId{
	char	data[63];
	char	term[1];
} SceNpScoreGameDataId;

typedef	struct SceNpScoreComment{
	char data[63];
	char term[1];
} SceNpScoreComment;

typedef	struct SceNpScoreRankData{
	SceNpId					npId;
	SceNpOnlineName			onlineName;
	SceNpScorePcId			pcId;
	SceNpScoreRankNumber	serialRank;
	SceNpScoreRankNumber	rank;
	SceNpScoreRankNumber	highestRank;
	int32_t					hasGameData;
	uint8_t					pad0[4];
	SceNpScoreValue			scoreValue;
	CellRtcTick				recordDate;
} SceNpScoreRankData;

typedef	struct SceNpScorePlayerRankData{
	int32_t				hasData;
	uint8_t				pad0[4];
	SceNpScoreRankData	rankData;
} SceNpScorePlayerRankData;

typedef	struct SceNpScoreBoardInfo{
	uint32_t		rankLimit;
	uint32_t		updateMode;
	uint32_t		sortMode;
	uint32_t		uploadNumLimit;
	size_t		uploadSizeLimit;
} SceNpScoreBoardInfo;

typedef struct SceNpScoreNpIdPcId {
	SceNpId npId;
	SceNpScorePcId pcId;
	uint8_t pad[4];
} SceNpScoreNpIdPcId;

typedef	uint32_t	SceNpScoreClansBoardId;
typedef struct SceNpScoreClanBasicInfo{
	char					clanName[(64)+1];
	char					clanTag[(8)+1];
	uint8_t					reserved[10];
}SceNpScoreClanBasicInfo;

typedef struct SceNpScoreClansMemberDescription{
	char	description[(255)+1];
}SceNpScoreClansMemberDescription;


typedef	struct SceNpScoreClanRankData{
	SceNpClanId				clanId;
	SceNpScoreClanBasicInfo clanInfo;
	uint32_t				regularMemberCount;
	uint32_t				recordMemberCount;
	SceNpScoreRankNumber	serialRank;
	SceNpScoreRankNumber	rank;
	SceNpScoreValue			scoreValue;
	CellRtcTick				recordDate;
	SceNpId					npId;
	SceNpOnlineName			onlineName;
	uint8_t					reserved[32];
} SceNpScoreClanRankData;

typedef	struct SceNpScoreClanIdRankData{
	int32_t					hasData;
	uint8_t					pad0[4];
	SceNpScoreClanRankData	rankData;
} SceNpScoreClanIdRankData;

typedef	struct SceNpScoreVariableSizeGameInfo{
	size_t		infoSize;
	uint8_t		data[189];
	uint8_t		pad2[3];
} SceNpScoreVariableSizeGameInfo;

typedef struct SceNpScoreRecordOptParam{
	size_t size;
	SceNpScoreVariableSizeGameInfo *vsInfo;
	CellRtcTick *compareDate;
} SceNpScoreRecordOptParam;


int sceNpScoreInit(void);
int	sceNpScoreTerm(void);

int	sceNpScoreCreateTitleCtx(
	const SceNpCommunicationId *titleId,
	const SceNpCommunicationPassphrase *passphrase,
	const SceNpId *selfNpId
);

int	sceNpScoreDestroyTitleCtx(
	int32_t titleCtxId
);

int	sceNpScoreCreateTransactionCtx(
	int32_t titleCtxId
);

int	sceNpScoreDestroyTransactionCtx (
	int32_t transId
);

int sceNpScoreAbortTransaction (
	int32_t transId
);

int sceNpScoreSetTimeout(
	int32_t ctxId,
	usecond_t timeout
);

int sceNpScoreSetPlayerCharacterId (
	int32_t ctxId,
	SceNpScorePcId pcId
);

int	sceNpScoreWaitAsync (
	int32_t transId,
	int32_t *result
);
int	sceNpScorePollAsync (
	int32_t transId,
	int32_t *result
);

int	sceNpScoreGetBoardInfo(
	int32_t	transId,
	SceNpScoreBoardId boardId,
	SceNpScoreBoardInfo *boardInfo,
	void *option
);

int	sceNpScoreGetBoardInfoAsync(
	int32_t	transId,
	SceNpScoreBoardId boardId,
	SceNpScoreBoardInfo *boardInfo,
	int32_t	prio,
	void *option
);

int32_t	sceNpScoreRecordScore (
	int32_t	transId,
	SceNpScoreBoardId boardId,
	SceNpScoreValue score,
	const SceNpScoreComment *scoreComment,
	const SceNpScoreGameInfo *gameInfo,
	SceNpScoreRankNumber *tmpRank,
	SceNpScoreRecordOptParam *option
);

int	sceNpScoreRecordScoreAsync (
	int32_t	transId,
	SceNpScoreBoardId boardId,
	SceNpScoreValue score,
	const SceNpScoreComment *scoreComment,
	const SceNpScoreGameInfo *gameInfo,
	SceNpScoreRankNumber *tmpRank,
	int32_t prio,
	SceNpScoreRecordOptParam *option
);

int	sceNpScoreRecordGameData (
	int32_t	transId,
	SceNpScoreBoardId boardId,
	SceNpScoreValue score,
	size_t	totalSize,
	size_t	sendSize,
	const void	*data,
	void *option
);

int	sceNpScoreRecordGameDataAsync (
	int32_t	transId,
	SceNpScoreBoardId boardId,
	SceNpScoreValue score,
	size_t	totalSize,
	size_t	sendSize,
	const void	*data,
	int32_t	prio,
	void *option
);

int	sceNpScoreGetGameData (
	int32_t	transId,
	SceNpScoreBoardId boardId,
	const SceNpId *npId,
	size_t	*totalSize,
	size_t	recvSize,
	void		*data,
	void *option
);

int	sceNpScoreGetGameDataAsync (
	int32_t	transId,
	SceNpScoreBoardId boardId,
	const SceNpId *npId,
	size_t	*totalSize,
	size_t	recvSize,
	void		*data,
	int32_t	prio,
	void *option
);

int	sceNpScoreGetRankingByNpId(
	int32_t	transId,
	SceNpScoreBoardId boardId,
	const SceNpId			*npIdArray,
	size_t					npIdArraySize,
	SceNpScorePlayerRankData *rankArray,
	size_t					rankArraySize,
	SceNpScoreComment	*commentArray,
	size_t				commentArraySize,
	void 				*infoArray,
	size_t				infoArraySize,
	size_t	arrayNum,
	CellRtcTick	*lastSortDate,
	SceNpScoreRankNumber	*totalRecord,
	void *option
);

int	sceNpScoreGetRankingByNpIdAsync(
	int32_t	transId,
	SceNpScoreBoardId boardId,
	const SceNpId		*npIdArray,
	size_t				npIdArraySize,
	SceNpScorePlayerRankData *rankArray,
	size_t				rankArraySize,
	SceNpScoreComment  *commentArray,
	size_t				commentArraySize,
	void 				*infoArray,
	size_t				infoArraySize,
	size_t	arrayNum,
	CellRtcTick	*lastSortDate,
	SceNpScoreRankNumber	*totalRecord,
	int32_t	prio,
	void *option
);

int	sceNpScoreGetRankingByRange(
	int32_t					transId,
	SceNpScoreBoardId		boardId,
	SceNpScoreRankNumber	startSerialRank,
	SceNpScoreRankData		*rankArray,
	size_t					rankArraySize,
	SceNpScoreComment		*commentArray,
	size_t					commentArraySize,
	void					*infoArray,
	size_t					infoArraySize,
	size_t					arrayNum,
	CellRtcTick				*lastSortDate,
	SceNpScoreRankNumber	 *totalRecord,
	void *option
);

int	sceNpScoreGetRankingByRangeAsync(
	int32_t					transId,
	SceNpScoreBoardId		boardId,
	SceNpScoreRankNumber	startSerialRank,
	SceNpScoreRankData		*rankArray,
	size_t					rankArraySize,
	SceNpScoreComment		*commentArray,
	size_t					commentArraySize,
	void					*infoArray,
	size_t					infoArraySize,
	size_t					arrayNum,
	CellRtcTick				*lastSortDate,
	SceNpScoreRankNumber	 *totalRecord,
	int32_t	prio,
	void *option
);

int sceNpScoreGetRankingByNpIdPcId(
	int32_t transId,
	SceNpScoreBoardId boardId,
	const SceNpScoreNpIdPcId *idArray,
	size_t idArraySize,
	SceNpScorePlayerRankData *rankArray,
	size_t rankArraySize,
	SceNpScoreComment *commentArray,
	size_t commentArraySize,
	void *infoArray,
	size_t infoArraySize,
	size_t arrayNum,
	CellRtcTick *lastSortDate,
	SceNpScoreRankNumber *totalRecord,
	void *option
);

int sceNpScoreGetRankingByNpIdPcIdAsync(
	int32_t transId,
	SceNpScoreBoardId boardId,
	const SceNpScoreNpIdPcId *idArray,
	size_t idArraySize,
	SceNpScorePlayerRankData *rankArray,
	size_t rankArraySize,
	SceNpScoreComment *commentArray,
	size_t commentArraySize,
	void *infoArray,
	size_t infoArraySize,
	size_t arrayNum,
	CellRtcTick *lastSortDate,
	SceNpScoreRankNumber *totalRecord,
	int32_t prio,
	void *option
);

int sceNpScoreGetFriendsRanking (
	int32_t transId,
	SceNpScoreBoardId boardId,
	int32_t includeSelf,
	SceNpScoreRankData *rankArray,
	size_t rankArraySize,
	SceNpScoreComment *commentArray,
	size_t commentArraySize,
	void *infoArray,
	size_t infoArraySize,
	size_t arrayNum,
	CellRtcTick *lastSortDate,
	SceNpScoreRankNumber *totalRecord,
	void *option
);

int sceNpScoreGetFriendsRankingAsync(
	int32_t transId,
	SceNpScoreBoardId boardId,
	int32_t includeSelf,
	SceNpScoreRankData *rankArray,
	size_t rankArraySize,
	SceNpScoreComment *commentArray,
	size_t commentArraySize,
	void *infoArray,
	size_t infoArraySize,
	size_t arrayNum,
	CellRtcTick *lastSortDate,
	SceNpScoreRankNumber *totalRecord,
	int32_t	prio,
	void *option
);

/*
Temporary prototype for compatibility.
It will change as follows in the future SDK version. 

int	sceNpScoreCensorComment (
	int32_t	transId,
	const char *comment,
	void *option
);
int	sceNpScoreCensorCommentAsync (
	int32_t	transId,
	const char *comment,
	int32_t	prio,
	void *option
);
*/
int	sceNpScoreCensorComment (
	int32_t	transId,
	const void *comment,
	void *option
);

int	sceNpScoreCensorCommentAsync (
	int32_t	transId,
	const void *comment,
	int32_t	prio,
	void *option
);

int	sceNpScoreSanitizeComment (
	int32_t	transId,
	const char *comment,
	char *sanitizedComment,
	void *option
);

int	sceNpScoreSanitizeCommentAsync (
	int32_t	transId,
	const char *comment,
	char *sanitizedComment,
	int32_t	prio,
	void *option
);

int	sceNpScoreGetClanMemberGameData (
	int32_t	transId,
	SceNpScoreClansBoardId boardId,
	SceNpClanId clanId,
	const SceNpId *npId,
	size_t	*totalSize,
	size_t	recvSize,
	void		*data,
	void *option
);

int	sceNpScoreGetClanMemberGameDataAsync (
	int32_t	transId,
	SceNpScoreClansBoardId boardId,
	SceNpClanId clanId,
	const SceNpId *npId,
	size_t	*totalSize,
	size_t	recvSize,
	void		*data,
	int32_t	prio,
	void *option
);

int	sceNpScoreGetClansMembersRankingByRange(
	int32_t					transId,
	SceNpClanId				clanId,
	SceNpScoreBoardId		boardId,
	SceNpScoreRankNumber	startSerialRank,
	SceNpScoreRankData		*rankArray,
	size_t					rankArraySize,
	SceNpScoreComment	*commentArray,
	size_t				commentArraySize,
	SceNpScoreGameInfo *infoArray,
	size_t				infoArraySize,
	SceNpScoreClansMemberDescription *descriptArray,
	size_t				descriptArraySize,
	size_t					arrayNum,
	SceNpScoreClanBasicInfo *clanInfo,
	CellRtcTick				*lastSortDate,
	SceNpScoreRankNumber	 *totalRecord,
	void *option
);

int	sceNpScoreGetClansMembersRankingByRangeAsync(
	int32_t					transId,
	SceNpClanId				clanId,
	SceNpScoreBoardId		boardId,
	SceNpScoreRankNumber	startSerialRank,
	SceNpScoreRankData		*rankArray,
	size_t					rankArraySize,
	SceNpScoreComment	*commentArray,
	size_t				commentArraySize,
	SceNpScoreGameInfo *infoArray,
	size_t				infoArraySize,
	SceNpScoreClansMemberDescription *descriptArray,
	size_t				descriptArraySize,
	size_t					arrayNum,
	SceNpScoreClanBasicInfo *clanInfo,
	CellRtcTick				*lastSortDate,
	SceNpScoreRankNumber	 *totalRecord,
	int32_t	prio,
	void *option
);

int	sceNpScoreGetClansMembersRankingByNpId(
	int32_t					transId,
	SceNpClanId				clanId,
	SceNpScoreBoardId 		boardId,
	const SceNpId			*idArray,
	size_t					idArraySize,
	SceNpScorePlayerRankData	*rankArray,
	size_t					rankArraySize,
	SceNpScoreComment	*commentArray,
	size_t				commentArraySize,
	SceNpScoreGameInfo *infoArray,
	size_t				infoArraySize,
	SceNpScoreClansMemberDescription *descriptArray,
	size_t				descriptArraySize,
	size_t	arrayNum,
	SceNpScoreClanBasicInfo *clanInfo,
	CellRtcTick	*lastSortDate,
	SceNpScoreRankNumber	*totalRecord,
	void *option
);

int	sceNpScoreGetClansMembersRankingByNpIdAsync(
	int32_t					transId,
	SceNpClanId				clanId,
	SceNpScoreBoardId 		boardId,
	const SceNpId			*idArray,
	size_t					idArraySize,
	SceNpScorePlayerRankData	*rankArray,
	size_t					rankArraySize,
	SceNpScoreComment	*commentArray,
	size_t				commentArraySize,
	SceNpScoreGameInfo *infoArray,
	size_t				infoArraySize,
	SceNpScoreClansMemberDescription *descriptArray,
	size_t				descriptArraySize,
	size_t	arrayNum,
	SceNpScoreClanBasicInfo *clanInfo,
	CellRtcTick	*lastSortDate,
	SceNpScoreRankNumber	*totalRecord,
	int32_t prio,
	void *option
);

int	sceNpScoreGetClansMembersRankingByNpIdPcId(
	int32_t					transId,
	SceNpClanId				clanId,
	SceNpScoreBoardId 		boardId,
	const SceNpScoreNpIdPcId *idArray,
	size_t					idArraySize,
	SceNpScorePlayerRankData	*rankArray,
	size_t					rankArraySize,
	SceNpScoreComment	*commentArray,
	size_t				commentArraySize,
	SceNpScoreGameInfo *infoArray,
	size_t				infoArraySize,
	SceNpScoreClansMemberDescription *descriptArray,
	size_t				descriptArraySize,
	size_t	arrayNum,
	SceNpScoreClanBasicInfo *clanInfo,
	CellRtcTick	*lastSortDate,
	SceNpScoreRankNumber	*totalRecord,
	void *option
);

int	sceNpScoreGetClansMembersRankingByNpIdPcIdAsync(
	int32_t					transId,
	SceNpClanId				clanId,
	SceNpScoreBoardId 		boardId,
	const SceNpScoreNpIdPcId *idArray,
	size_t					idArraySize,
	SceNpScorePlayerRankData	*rankArray,
	size_t					rankArraySize,
	SceNpScoreComment	*commentArray,
	size_t				commentArraySize,
	SceNpScoreGameInfo *infoArray,
	size_t				infoArraySize,
	SceNpScoreClansMemberDescription *descriptArray,
	size_t				descriptArraySize,
	size_t	arrayNum,
	SceNpScoreClanBasicInfo *clanInfo,
	CellRtcTick	*lastSortDate,
	SceNpScoreRankNumber	*totalRecord,
	int32_t prio,
	void *option
);

int	sceNpScoreGetClansRankingByRange(
	int32_t					transId,
	SceNpScoreClansBoardId	clanBoardId,
	SceNpScoreRankNumber	startSerialRank,
	SceNpScoreClanRankData	*clanRankArray,
	size_t					rankArraySize,
	void					*reserved1,
	size_t					reservedSize1,
	void					*reserved2,
	size_t					reservedSize2,
	size_t					arrayNum,
	CellRtcTick				*lastSortDate,
	SceNpScoreRankNumber	 *totalRecord,
	void *option
);

int	sceNpScoreGetClansRankingByRangeAsync(
	int32_t					transId,
	SceNpScoreClansBoardId	clanBoardId,
	SceNpScoreRankNumber	startSerialRank,
	SceNpScoreClanRankData	*clanRankArray,
	size_t					rankArraySize,
	void					*reserved1,
	size_t					reservedSize1,
	void					*reserved2,
	size_t					reservedSize2,
	size_t					arrayNum,
	CellRtcTick				*lastSortDate,
	SceNpScoreRankNumber	 *totalRecord,
	int32_t					prio,
	void *option);


int	sceNpScoreGetClansRankingByClanId(
	int32_t					transId,
	SceNpScoreClansBoardId 	clanBoardId,
	const SceNpClanId		*clanIdArray,
	size_t					clanIdArraySize,
	SceNpScoreClanIdRankData *rankArray,
	size_t					rankArraySize,
	void					*reserved1,
	size_t				reservedSize1,
	void				 *reserved2,
	size_t				reservedSize2,
	size_t	arrayNum,
	CellRtcTick	*lastSortDate,
	SceNpScoreRankNumber	*totalRecord,
	void *option
);

int	sceNpScoreGetClansRankingByClanIdAsync(
	int32_t					transId,
	SceNpScoreClansBoardId 	clanBoardId,
	const SceNpClanId		*clanIdArray,
	size_t					clanIdArraySize,
	SceNpScoreClanIdRankData *rankArray,
	size_t					rankArraySize,
	void					*reserved1,
	size_t				reservedSize1,
	void				 *reserved2,
	size_t				reservedSize2,
	size_t	arrayNum,
	CellRtcTick	*lastSortDate,
	SceNpScoreRankNumber	*totalRecord,
	int32_t	prio,
	void *option
);


}


# 33 "C:/usr/local/cell\\target\\ppu\\include/np.h" 3

# 1 "C:/usr/local/cell\\target\\ppu\\include/np/matching2.h" 3
/* SCE CONFIDENTIAL
 PlayStation(R)3 Programmer Tool Runtime Library 475.001
 *
 *      Copyright (C) 2007 Sony Computer Entertainment Inc.
 *                        All Rights Reserved.
 *
 */







extern "C" {


/*J
 *******************************************************************************
 * サイズ
 *******************************************************************************
 */

# 36 "C:/usr/local/cell\\target\\ppu\\include/np/matching2.h" 3

# 55 "C:/usr/local/cell\\target\\ppu\\include/np/matching2.h" 3

# 68 "C:/usr/local/cell\\target\\ppu\\include/np/matching2.h" 3

//E Some Struct Max Sizes
/*E
 * In many circumstances using the MAX_SIZE of each event data is quite wasteful.
 * For example the JoinRoom and GetRoomDataInternal MAX_SIZEs were calculated
 * based on the max number of member slots that the library supports. To make a
 * better assessment of how much buffer space will be needed you can substract
 * the number of slots that won't be used. For example, if only 4 players are
 * supported in the game then (buffer size needed for JoinRoom and GetRoomDataInternal) =
 * _EVENT_DATA_MAX_SIZE_JoinRoom - ((SCE_NP_MATCHING2_ROOM_MAX_SLOT - 4) *
 * _MAX_SIZE_RoomMemberDataInternal).
 * The same goes for SearchRoom, GetLobbyMemberDataInternalList and GetUserInfo.
 */






/*J
 *******************************************************************************
 * ID および雑多な構造体
 *******************************************************************************
 */

/*J ユーティリティ初期化パラメータ */
typedef struct SceNpMatching2UtilityInitParam {
	sys_memory_container_t containerId;
	uint32_t requestCbQueueLen;
	uint32_t sessionEventCbQueueLen;
	uint32_t sessionMsgCbQueueLen;
	uint8_t reserved[16];
} SceNpMatching2UtilityInitParam;

/*J メモリ情報 */
typedef struct SceNpMatching2MemoryInfo {
	size_t totalMemSize;    /*J メモリサイズ */
	size_t curMemUsage;     /*J 現在のメモリ消費量 */
	size_t maxMemUsage;     /*J 最大メモリ消費量 */
	uint8_t reserved[12];
} SceNpMatching2MemoryInfo;

/*J システムキュー情報 */
typedef struct SceNpMatching2CbQueueInfo {
	uint32_t requestCbQueueLen;
	uint32_t curRequestCbQueueLen;
	uint32_t maxRequestCbQueueLen;
	uint32_t sessionEventCbQueueLen;
	uint32_t curSessionEventCbQueueLen;
	uint32_t maxSessionEventCbQueueLen;
	uint32_t sessionMsgCbQueueLen;
	uint32_t curSessionMsgCbQueueLen;
	uint32_t maxSessionMsgCbQueueLen;
	uint8_t reserved[12];
} SceNpMatching2CbQueueInfo;

/*J サーバ ID */
typedef uint16_t SceNpMatching2ServerId;

/*J ワールド ID、ワールド番号 */
typedef uint32_t SceNpMatching2WorldId;
typedef uint16_t SceNpMatching2WorldNumber;



/*J ロビーID、ロビー番号 */
typedef uint64_t SceNpMatching2LobbyId;
typedef uint16_t SceNpMatching2LobbyNumber;



/*J ルーム ID、ルーム番号 */
typedef uint64_t SceNpMatching2RoomId;
typedef uint16_t SceNpMatching2RoomNumber;



/*J コンテキスト ID */
typedef uint16_t SceNpMatching2ContextId;

/*J リクエスト ID */
typedef uint32_t SceNpMatching2RequestId;
typedef uint32_t SceNpMatching2SignalingRequestId;

/*J タイトル用パスフレーズ for compatibility */

typedef SceNpCommunicationPassphrase SceNpMatching2TitlePassphrase;

/*J NAT タイプ */
typedef uint8_t SceNpMatching2NatType;

/*J 検索条件 */
# 166 "C:/usr/local/cell\\target\\ppu\\include/np/matching2.h" 3
typedef uint8_t SceNpMatching2Operator;

/*J メッセージ送信タイプ */




typedef uint8_t SceNpMatching2CastType;

/*J セッションパスワード */

typedef struct SceNpMatching2SessionPassword {
	uint8_t data[8];
} SceNpMatching2SessionPassword;

/*J セッションタイプ */


typedef uint8_t SceNpMatching2SessionType;

/*J イベント要因 */
# 198 "C:/usr/local/cell\\target\\ppu\\include/np/matching2.h" 3
typedef uint8_t SceNpMatching2EventCause;

/*J ルームもしくはロビーに参加、退出などをする際に付随可能なデータ */

typedef struct SceNpMatching2PresenceOptionData {
	uint8_t data[16];
	size_t len;
} SceNpMatching2PresenceOptionData;


/*J
 *******************************************************************************
 * 属性、検索条件
 *******************************************************************************
 */

/*J 属性 ID */
typedef uint16_t SceNpMatching2AttributeId;

/*J
 * フラグ属性
 */

/*J ロビーフラグ属性 */




/*J ルームフラグ属性 */
# 234 "C:/usr/local/cell\\target\\ppu\\include/np/matching2.h" 3

/*J ロビーメンバフラグ属性 */


/*J ルームメンバフラグ属性 */

typedef uint32_t SceNpMatching2FlagAttr;

/*J
 * 数値属性
 */

/*J ルーム数値属性 */
/*J ルーム外部検索数値属性(8つ) */
# 257 "C:/usr/local/cell\\target\\ppu\\include/np/matching2.h" 3

/*J 数値属性構造体 */
typedef struct SceNpMatching2IntAttr {
	SceNpMatching2AttributeId id;
	uint8_t  padding[2];
	uint32_t num;
} SceNpMatching2IntAttr;

/*J
 * バイナリ属性
 */
/*J ロビー内部バイナリ属性(2つ) */




/*J ロビー内部ロビーメンババイナリ属性(1つ) */



/*J ルーム内部バイナリ属性(2つ) */




/*J ルーム内部ルームメンババイナリ属性(1つ) */



/*J ルーム外部検索バイナリ属性(1つ) */



/*J ルーム外部バイナリ属性(2つ) */




/*J ユーザバイナリ属性(1つ) */



/*J バイナリ属性構造体 */
typedef struct SceNpMatching2BinAttr {
	SceNpMatching2AttributeId id;
	uint8_t padding[2];
	void   *ptr;
	size_t  size;
} SceNpMatching2BinAttr;

/*J
 * 検索条件
 */

/*J 検索対象範囲 */
typedef struct SceNpMatching2RangeFilter {
	unsigned int startIndex;
	unsigned int max;
} SceNpMatching2RangeFilter;
/*J StartIndexの最小値 */

/*J 一度に取得できるルームリストの最大数 */


/*J 数値検索条件 */
typedef struct SceNpMatching2IntSearchFilter {
	SceNpMatching2Operator searchOperator;
	uint8_t padding[3];
	SceNpMatching2IntAttr attr;
} SceNpMatching2IntSearchFilter;

/*J バイナリ検索条件 */
typedef struct SceNpMatching2BinSearchFilter {
	SceNpMatching2Operator searchOperator;
	uint8_t padding[3];
	SceNpMatching2BinAttr attr;
} SceNpMatching2BinSearchFilter;

/*J 検索結果の範囲 */
typedef struct SceNpMatching2Range {
	unsigned int startIndex;
	unsigned int total;
	unsigned int size;
} SceNpMatching2Range;

/*J
 *******************************************************************************
 * ユーザ情報
 *******************************************************************************
 */

/*J ユーザが参加中のセッション情報 */
typedef struct SceNpMatching2JoinedSessionInfo {
	SceNpMatching2SessionType sessionType;
	uint8_t padding1[1];
	SceNpMatching2ServerId serverId;	
	SceNpMatching2WorldId worldId;
	SceNpMatching2LobbyId lobbyId;
	SceNpMatching2RoomId  roomId;
	CellRtcTick joinDate;
} SceNpMatching2JoinedSessionInfo;

/*J ユーザ情報構造体 */
typedef struct SceNpMatching2UserInfo {
	struct SceNpMatching2UserInfo *next;
	SceNpUserInfo2 userInfo;
	SceNpMatching2BinAttr *userBinAttr;
	unsigned int userBinAttrNum;
	SceNpMatching2JoinedSessionInfo *joinedSessionInfo;
	unsigned int joinedSessionInfoNum;
} SceNpMatching2UserInfo;

/*J
 *******************************************************************************
 * サーバ情報
 *******************************************************************************
 */

/*J サーバステータス */




typedef uint8_t SceNpMatching2ServerStatus;

/*J サーバ構造体 */
typedef struct SceNpMatching2Server {
	SceNpMatching2ServerId     serverId;
	SceNpMatching2ServerStatus status;
	uint8_t padding[1];
} SceNpMatching2Server;


/*J
 *******************************************************************************
 * ワールド情報
 *******************************************************************************
 */

/*J ワールド構造体 */
typedef struct SceNpMatching2World {
	SceNpMatching2WorldId worldId;
	unsigned int numOfLobby;
	unsigned int maxNumOfTotalLobbyMember;
	unsigned int curNumOfTotalLobbyMember;
	unsigned int curNumOfRoom;
	unsigned int curNumOfTotalRoomMember;
	bool withEntitlementId;
	SceNpEntitlementId entitlementId;	
	uint8_t padding[3];
} SceNpMatching2World;


/*J
 *******************************************************************************
 * ロビー情報
 *******************************************************************************
 */

/*J ロビーの最大参加人数 */


/*J ロビーメンバ ID */
typedef uint16_t SceNpMatching2LobbyMemberId;

/*J ロビー内部ロビーメンババイナリ属性 */
typedef struct SceNpMatching2LobbyMemberBinAttrInternal {
	CellRtcTick updateDate;
	SceNpMatching2BinAttr data;
	uint8_t padding[4];
} SceNpMatching2LobbyMemberBinAttrInternal;

/*J ロビー内部から取得するロビーメンバ情報 */
typedef struct SceNpMatching2LobbyMemberDataInternal {
	struct SceNpMatching2LobbyMemberDataInternal *next;
	SceNpUserInfo2 userInfo;

	CellRtcTick joinDate;
	SceNpMatching2LobbyMemberId memberId;
	uint8_t padding[2];
	
	SceNpMatching2FlagAttr flagAttr; /*J 未使用 */

	SceNpMatching2JoinedSessionInfo *joinedSessionInfo;
	unsigned int joinedSessionInfoNum;
	SceNpMatching2LobbyMemberBinAttrInternal *lobbyMemberBinAttrInternal;
	unsigned int lobbyMemberBinAttrInternalNum;
} SceNpMatching2LobbyMemberDataInternal;

/*J ロビー内部用ロビーメンバIDリスト */
typedef struct SceNpMatching2LobbyMemberIdList {
	SceNpMatching2LobbyMemberId *memberId;
	unsigned int memberIdNum;
	SceNpMatching2LobbyMemberId me;
	uint8_t padding[6];
} SceNpMatching2LobbyMemberIdList;

/*J ロビー内部バイナリ属性 */
typedef struct SceNpMatching2LobbyBinAttrInternal {
	CellRtcTick updateDate;
	SceNpMatching2LobbyMemberId updateMemberId;	
	uint8_t padding[2];
	SceNpMatching2BinAttr data;
} SceNpMatching2LobbyBinAttrInternal;

/*J ロビー外部から取得するロビー情報 */
typedef struct SceNpMatching2LobbyDataExternal {
	struct SceNpMatching2LobbyDataExternal *next;
	SceNpMatching2ServerId serverId;
	uint8_t padding1[2];
	SceNpMatching2WorldId worldId;
	uint8_t padding2[4];
	SceNpMatching2LobbyId lobbyId;
	unsigned int maxSlot;
	unsigned int curMemberNum;
	SceNpMatching2FlagAttr flagAttr;
	/*J 未使用 */
	SceNpMatching2IntAttr *lobbySearchableIntAttrExternal;
	unsigned int lobbySearchableIntAttrExternalNum;
	SceNpMatching2BinAttr *lobbySearchableBinAttrExternal;
	unsigned int lobbySearchableBinAttrExternalNum;
	SceNpMatching2BinAttr *lobbyBinAttrExternal;
	unsigned int lobbyBinAttrExternalNum;
	uint8_t padding3[4];
} SceNpMatching2LobbyDataExternal;

/*J ロビー内部から取得するロビー情報 */
typedef struct SceNpMatching2LobbyDataInternal {
	SceNpMatching2ServerId serverId;
	uint8_t padding1[2];
	SceNpMatching2WorldId worldId;
	SceNpMatching2LobbyId lobbyId;
	
	unsigned int maxSlot;	
	SceNpMatching2LobbyMemberIdList memberIdList;
	SceNpMatching2FlagAttr flagAttr;
	
	/*J 未使用 */
	SceNpMatching2LobbyBinAttrInternal *lobbyBinAttrInternal;
	unsigned int lobbyBinAttrInternalNum;	
} SceNpMatching2LobbyDataInternal;

/*J ロビーメッセージの送信先指定 */
typedef union SceNpMatching2LobbyMessageDestination {
	SceNpMatching2LobbyMemberId unicastTarget;
	struct {
		SceNpMatching2LobbyMemberId *memberId;
		unsigned int memberIdNum;
	} multicastTarget;
} SceNpMatching2LobbyMessageDestination;

/*J
 *******************************************************************************
 * ルーム情報
 *******************************************************************************
 */

/*J ルームの最大参加人数 */


/*J ルームグループ ID */

typedef uint8_t SceNpMatching2RoomGroupId;

/*J ルームメンバ ID */
typedef uint16_t SceNpMatching2RoomMemberId;

/*J チーム ID */
typedef uint8_t SceNpMatching2TeamId;

/*J ルーム内での権限 */


typedef uint8_t SceNpMatching2Role;

/*J キックアウトしたメンバの再参加に関する設定 */


typedef uint8_t SceNpMatching2BlockKickFlag;

/*J グループラベル */

typedef struct SceNpMatching2GroupLabel {
	uint8_t data[8];
} SceNpMatching2GroupLabel;

/*J ルームパスワード用スロットマスク */
typedef uint64_t SceNpMatching2RoomPasswordSlotMask;
typedef uint64_t SceNpMatching2RoomJoinedSlotMask;

typedef struct SceNpMatching2RoomSlotInfo {
	SceNpMatching2RoomId roomId;
	SceNpMatching2RoomJoinedSlotMask joinedSlotMask;
	SceNpMatching2RoomPasswordSlotMask passwordSlotMask;
	uint16_t publicSlotNum;
	uint16_t privateSlotNum;
	uint16_t openPublicSlotNum;
	uint16_t openPrivateSlotNum;
} SceNpMatching2RoomSlotInfo;

/*J ルームのグループ設定 */
typedef struct SceNpMatching2RoomGroupConfig {
	unsigned int slotNum;
	bool withLabel;
	SceNpMatching2GroupLabel label;
	bool withPassword;
	uint8_t padding[2];
} SceNpMatching2RoomGroupConfig;

/*J ルームグループのパスワード使用設定用構造体 */
typedef struct SceNpMatching2RoomGroupPasswordConfig {
	SceNpMatching2RoomGroupId groupId;	
	bool withPassword;
	uint8_t padding[1];
} SceNpMatching2RoomGroupPasswordConfig;

/*J ルーム内部ルームメンババイナリデータ */
typedef struct SceNpMatching2RoomMemberBinAttrInternal {
	CellRtcTick updateDate;
	SceNpMatching2BinAttr data;
	uint8_t padding[4];
} SceNpMatching2RoomMemberBinAttrInternal;

/*J ルームグループ */
typedef struct SceNpMatching2RoomGroup {
	SceNpMatching2RoomGroupId groupId;	
	bool withPassword;
	bool withLabel;
	uint8_t padding[1];
	SceNpMatching2GroupLabel label;
	unsigned int slotNum;
	unsigned int curGroupMemberNum;
} SceNpMatching2RoomGroup;

/*J ルーム外部から取得するルームメンバ情報 */
typedef struct SceNpMatching2RoomMemberDataExternal {
	struct SceNpMatching2RoomMemberDataExternal *next;
	SceNpUserInfo2 userInfo;
	CellRtcTick joinDate;
	SceNpMatching2Role role;
	uint8_t padding[7];
} SceNpMatching2RoomMemberDataExternal;

/*J ルーム内部から取得するルームメンバ情報 */
typedef struct SceNpMatching2RoomMemberDataInternal {
	struct SceNpMatching2RoomMemberDataInternal *next;
	SceNpUserInfo2 userInfo;

	CellRtcTick joinDate;
	SceNpMatching2RoomMemberId memberId;
	SceNpMatching2TeamId teamId;
	uint8_t padding1[1];
	
	SceNpMatching2RoomGroup *roomGroup;

	SceNpMatching2NatType natType;
	uint8_t padding2[3];
	SceNpMatching2FlagAttr flagAttr;
	SceNpMatching2RoomMemberBinAttrInternal *roomMemberBinAttrInternal;
	unsigned int roomMemberBinAttrInternalNum;
} SceNpMatching2RoomMemberDataInternal;

/*J ルーム内部用ルームメンバリスト */
typedef struct SceNpMatching2RoomMemberDataInternalList {
	SceNpMatching2RoomMemberDataInternal *members;
	unsigned int membersNum;
	SceNpMatching2RoomMemberDataInternal *me;
	SceNpMatching2RoomMemberDataInternal *owner;
} SceNpMatching2RoomMemberDataInternalList;

/*J ソートメソッド */



/*J ルーム内部バイナリ属性 */
typedef struct SceNpMatching2RoomBinAttrInternal {
	CellRtcTick updateDate;
	SceNpMatching2RoomMemberId updateMemberId;
	uint8_t padding[2];
	SceNpMatching2BinAttr data;
} SceNpMatching2RoomBinAttrInternal;

/*J ルーム外部から取得するルーム情報 */
typedef struct SceNpMatching2RoomDataExternal {
	struct SceNpMatching2RoomDataExternal *next;
	
	SceNpMatching2ServerId serverId;
	uint8_t padding1[2];
	SceNpMatching2WorldId worldId;
	uint16_t publicSlotNum;
	uint16_t privateSlotNum;
	SceNpMatching2LobbyId lobbyId;
	SceNpMatching2RoomId roomId;

	uint16_t openPublicSlotNum;
	uint16_t maxSlot;
	uint16_t openPrivateSlotNum;
	uint16_t curMemberNum;
	SceNpMatching2RoomPasswordSlotMask passwordSlotMask;

	/*J ルームオーナー情報 */
	SceNpUserInfo2 *owner;

	/*J ルームグループ情報 */
	SceNpMatching2RoomGroup *roomGroup;
	unsigned int roomGroupNum;

	SceNpMatching2FlagAttr flagAttr;

	/*J 検索数値属性 */
	SceNpMatching2IntAttr *roomSearchableIntAttrExternal;
	unsigned int roomSearchableIntAttrExternalNum;

	/*J 検索バイナリ属性 */
	SceNpMatching2BinAttr *roomSearchableBinAttrExternal;
	unsigned int roomSearchableBinAttrExternalNum;

	/*J バイナリ属性 */
	SceNpMatching2BinAttr *roomBinAttrExternal;
	unsigned int roomBinAttrExternalNum;
} SceNpMatching2RoomDataExternal;

/*J ルーム内部から取得するルーム情報 */
typedef struct SceNpMatching2RoomDataInternal {
	SceNpMatching2ServerId serverId;
	uint8_t padding1[2];
	SceNpMatching2WorldId worldId;
	SceNpMatching2LobbyId lobbyId;
	SceNpMatching2RoomId roomId;

	SceNpMatching2RoomPasswordSlotMask passwordSlotMask;
	unsigned int maxSlot;

	/*J ルームメンバ */
	SceNpMatching2RoomMemberDataInternalList memberList;

	/*J ルームグループ情報 */
	SceNpMatching2RoomGroup *roomGroup;
	unsigned int roomGroupNum;

	SceNpMatching2FlagAttr flagAttr;
	SceNpMatching2RoomBinAttrInternal *roomBinAttrInternal;
	unsigned int roomBinAttrInternalNum;
} SceNpMatching2RoomDataInternal;

/*J ルームメッセージの送信先指定 */
typedef union SceNpMatching2RoomMessageDestination {
	SceNpMatching2RoomMemberId unicastTarget;
	struct {
		SceNpMatching2RoomMemberId *memberId;
		unsigned int memberIdNum;
	} multicastTarget;
	SceNpMatching2TeamId multicastTargetTeamId;
} SceNpMatching2RoomMessageDestination;

/*J sceNpMatching2CreateContext() で指定するオプション */



/*J sceNpMatching2GetUserInfoList() で指定するオプション */



/*J sceNpMatching2SearchRoom() で指定するオプション */






/*J
 * sceNpMatching2SendRoomChatMessage()
 * sceNpMatching2SendRoomMessage()
 * sceNpMatching2SendLobbyChatMessage()
 * sceNpMatching2SendLobbyInvitation()
 * で指定するオプション
 */




/*J ルーム入室許可ユーザ最大数 */

/*J ルーム入室拒否ユーザ最大数 */


/*J
 *******************************************************************************
 * 招待データ
 *******************************************************************************
 */
typedef struct SceNpMatching2InvitationData {
	SceNpMatching2JoinedSessionInfo *targetSession;
	unsigned int targetSessionNum;
	void *optData;
	size_t optDataLen;
} SceNpMatching2InvitationData;

/*J 招待先セッション最大数 */

/*J 招待情報オプションデータ最大サイズ */


/*J
 *******************************************************************************
 * コールバック関数
 *******************************************************************************
 */

/*J コールバック関数イベント */
typedef uint16_t SceNpMatching2Event;
# 821 "C:/usr/local/cell\\target\\ppu\\include/np/matching2.h" 3

/*J イベントデータ取得キー */
typedef uint32_t SceNpMatching2EventKey;

/* リクエストコールバック */
typedef void (*SceNpMatching2RequestCallback)(
	SceNpMatching2ContextId        ctxId,
	SceNpMatching2RequestId        reqId,
	SceNpMatching2Event            event,
	SceNpMatching2EventKey         eventKey,
	int     errorCode,
	size_t  dataSize,
	void   *arg
	);

/*J ロビーイベントコールバック */
typedef void (*SceNpMatching2LobbyEventCallback)(
	SceNpMatching2ContextId         ctxId,	
	SceNpMatching2LobbyId           lobbyId,
	SceNpMatching2Event             event,
	SceNpMatching2EventKey          eventKey,
	int     errorCode,
	size_t  dataSize,
	void   *arg
	);

/*J ルームイベントコールバック */
typedef void (*SceNpMatching2RoomEventCallback)(
	SceNpMatching2ContextId         ctxId,	
	SceNpMatching2RoomId            roomId,
	SceNpMatching2Event             event,
	SceNpMatching2EventKey          eventKey,
	int     errorCode,
	size_t  dataSize,
	void   *arg
	);

/*J ロビーメッセージコールバック */
typedef void (*SceNpMatching2LobbyMessageCallback)(
	SceNpMatching2ContextId        ctxId,	
	SceNpMatching2LobbyId          lobbyId,
	SceNpMatching2LobbyMemberId    srcMemberId,
	SceNpMatching2Event            event,
	SceNpMatching2EventKey         eventKey,
	int     errorCode,
	size_t  dataSize,
	void   *arg
	);

/*J ルームメッセージコールバック */
typedef void (*SceNpMatching2RoomMessageCallback)(
	SceNpMatching2ContextId        ctxId,	
	SceNpMatching2RoomId           roomId,
	SceNpMatching2RoomMemberId     srcMemberId,
	SceNpMatching2Event            event,
	SceNpMatching2EventKey         eventKey,
	int     errorCode,
	size_t  dataSize,
	void   *arg
	);

/*J シグナリングコールバック */
typedef void (*SceNpMatching2SignalingCallback)(
	SceNpMatching2ContextId        ctxId,	
	SceNpMatching2RoomId           roomId,
	SceNpMatching2RoomMemberId     peerMemberId,
	SceNpMatching2Event            event,
	int     errorCode,
	void   *arg
	);

/*J コンテキストコールバック */
typedef void (*SceNpMatching2ContextCallback)(
    SceNpMatching2ContextId  ctxId,
    SceNpMatching2Event      event,
    SceNpMatching2EventCause eventCause,
    int   errorCode,
	void *arg
    );

/*J
 *******************************************************************************
 * API 毎のリクエスト、レスポンス構造体
 *******************************************************************************
 */

/*J 共通のオプション構造体 */
typedef struct SceNpMatching2RequestOptParam {
	SceNpMatching2RequestCallback cbFunc;
	void *cbFuncArg;
	uint32_t timeout;
	uint16_t appReqId;
	uint8_t padding[2];
} SceNpMatching2RequestOptParam;

/*
 * sceNpMatching2CreateServerContext()
 */
typedef struct SceNpMatching2CreateServerContextRequest {
	SceNpMatching2ServerId serverId;
} SceNpMatching2CreateServerContextRequest;

/*
 * sceNpMatching2DeleteServerContext()
 */
typedef struct SceNpMatching2DeleteServerContextRequest {
	SceNpMatching2ServerId serverId;
} SceNpMatching2DeleteServerContextRequest;

/*
 * sceNpMatching2GetServerInfo()
 */
typedef struct SceNpMatching2GetServerInfoRequest {
	SceNpMatching2ServerId serverId;
} SceNpMatching2GetServerInfoRequest;

typedef struct SceNpMatching2GetServerInfoResponse {
	SceNpMatching2Server server;
} SceNpMatching2GetServerInfoResponse;

/*
 * sceNpMatching2GetWorldInfoList()
 */
typedef struct SceNpMatching2GetWorldInfoListRequest {
	SceNpMatching2ServerId serverId;
} SceNpMatching2GetWorldInfoListRequest;

typedef struct SceNpMatching2GetWorldInfoListResponse {
	SceNpMatching2World *world;
	unsigned int worldNum;
} SceNpMatching2GetWorldInfoListResponse;

/*
 * sceNpMatching2SetUserInfo()
 */
typedef struct SceNpMatching2SetUserInfoRequest{
	SceNpMatching2ServerId serverId;
	uint8_t padding[2];
	SceNpMatching2BinAttr *userBinAttr;
	unsigned int userBinAttrNum;
} SceNpMatching2SetUserInfoRequest;

/*
 * sceNpMatching2GetUserInfoList()
 */

typedef struct SceNpMatching2GetUserInfoListRequest {
	SceNpMatching2ServerId serverId;
	uint8_t padding[2];
	SceNpId *npId;
	unsigned int npIdNum;
	SceNpMatching2AttributeId *attrId;
	unsigned int attrIdNum;
	int option;
} SceNpMatching2GetUserInfoListRequest;

typedef struct SceNpMatching2GetUserInfoListResponse {
	SceNpMatching2UserInfo *userInfo;
	unsigned int userInfoNum;
} SceNpMatching2GetUserInfoListResponse;

/*
 * sceNpMatching2GetRoomMemberDataExternalList()
 */
typedef struct SceNpMatching2GetRoomMemberDataExternalListRequest {
	SceNpMatching2RoomId roomId;
} SceNpMatching2GetRoomMemberDataExternalListRequest;

typedef struct SceNpMatching2GetRoomMemberDataExternalListResponse {
	SceNpMatching2RoomMemberDataExternal *roomMemberDataExternal;
	unsigned int roomMemberDataExternalNum;
} SceNpMatching2GetRoomMemberDataExternalListResponse;

/*
 * sceNpMatching2SetRoomDataExternal()
 */
typedef struct SceNpMatching2SetRoomDataExternalRequest {
	SceNpMatching2RoomId roomId;
	SceNpMatching2IntAttr *roomSearchableIntAttrExternal;
	unsigned int roomSearchableIntAttrExternalNum;
	SceNpMatching2BinAttr *roomSearchableBinAttrExternal;
	unsigned int roomSearchableBinAttrExternalNum;
	SceNpMatching2BinAttr *roomBinAttrExternal;
	unsigned int roomBinAttrExternalNum;
} SceNpMatching2SetRoomDataExternalRequest;

/*
 * sceNpMatching2GetRoomDataExternalList()
 */

typedef struct SceNpMatching2GetRoomDataExternalListRequest {
	SceNpMatching2RoomId *roomId;
	unsigned int roomIdNum;
	const SceNpMatching2AttributeId *attrId;
	unsigned int attrIdNum;
} SceNpMatching2GetRoomDataExternalListRequest;

typedef struct SceNpMatching2GetRoomDataExternalListResponse {
	SceNpMatching2RoomDataExternal *roomDataExternal;
	unsigned int roomDataExternalNum;
} SceNpMatching2GetRoomDataExternalListResponse;

/*
 * sceNpMatching2CreateJoinRoom()
 */

/*J ルームパスワードスロットマスクにスロット番号をを追加する */



/*J シグナリングオプションパラメータ */
typedef uint8_t SceNpMatching2SignalingType;



typedef uint8_t SceNpMatching2SignalingFlag;

typedef struct SceNpMatching2SignalingOptParam {
	SceNpMatching2SignalingType type;
	SceNpMatching2SignalingFlag flag;
	SceNpMatching2RoomMemberId hubMemberId;
	uint8_t reserved2[4];
} SceNpMatching2SignalingOptParam;

typedef struct SceNpMatching2CreateJoinRoomRequest {
	SceNpMatching2WorldId  worldId;
	uint8_t padding1[4];
	SceNpMatching2LobbyId  lobbyId;
	/*J ルーム作成パラメータ */
	unsigned int           maxSlot;
	SceNpMatching2FlagAttr flagAttr;
	SceNpMatching2BinAttr *roomBinAttrInternal;
	unsigned int           roomBinAttrInternalNum;
	SceNpMatching2IntAttr *roomSearchableIntAttrExternal;
	unsigned int           roomSearchableIntAttrExternalNum;
	SceNpMatching2BinAttr *roomSearchableBinAttrExternal;
	unsigned int           roomSearchableBinAttrExternalNum;
	SceNpMatching2BinAttr *roomBinAttrExternal;
	unsigned int           roomBinAttrExternalNum;
	SceNpMatching2SessionPassword      *roomPassword;
	SceNpMatching2RoomGroupConfig      *groupConfig;
	unsigned int                        groupConfigNum;	
	SceNpMatching2RoomPasswordSlotMask *passwordSlotMask;
	SceNpId      *allowedUser;
	unsigned int  allowedUserNum;
	SceNpId      *blockedUser;
	unsigned int  blockedUserNum;
	/*J ルーム参加パラメータ */
	SceNpMatching2GroupLabel *joinRoomGroupLabel;
	SceNpMatching2BinAttr    *roomMemberBinAttrInternal;
	unsigned int              roomMemberBinAttrInternalNum;
	SceNpMatching2TeamId      teamId;
	uint8_t padding2[3];
	/*J シグナリングパラメータ */
	SceNpMatching2SignalingOptParam *sigOptParam;
	uint8_t padding3[4];
} SceNpMatching2CreateJoinRoomRequest;

typedef struct SceNpMatching2CreateJoinRoomResponse {
	SceNpMatching2RoomDataInternal *roomDataInternal;
} SceNpMatching2CreateJoinRoomResponse;

/*
 * sceNpMatching2JoinRoom()
 */
typedef struct SceNpMatching2JoinRoomRequest {
	SceNpMatching2RoomId             roomId;
	SceNpMatching2SessionPassword   *roomPassword;
	SceNpMatching2GroupLabel        *joinRoomGroupLabel;	
	SceNpMatching2BinAttr           *roomMemberBinAttrInternal;
	unsigned int                     roomMemberBinAttrInternalNum;
	SceNpMatching2PresenceOptionData optData;
	SceNpMatching2TeamId             teamId;
	uint8_t padding[3];
} SceNpMatching2JoinRoomRequest;

/*
 * sceNpMatching2JoinProhibitiveRoom()
 */
typedef struct SceNpMatching2JoinProhibitiveRoomRequest {
	SceNpMatching2JoinRoomRequest    joinParam;
	SceNpId                         *blockedUser;
	unsigned int                     blockedUserNum;
} SceNpMatching2JoinProhibitiveRoomRequest;

typedef struct SceNpMatching2JoinRoomResponse {
	SceNpMatching2RoomDataInternal *roomDataInternal;
} SceNpMatching2JoinRoomResponse;

/*
 * sceNpMatching2LeaveRoom()
 */
typedef struct SceNpMatching2LeaveRoomRequest {
	SceNpMatching2RoomId roomId;
	SceNpMatching2PresenceOptionData optData;
	uint8_t padding[4];
} SceNpMatching2LeaveRoomRequest;

/*
 * sceNpMatching2GrantRoomOwner()
 */
typedef struct SceNpMatching2GrantRoomOwnerRequest {
	SceNpMatching2RoomId roomId;
	SceNpMatching2RoomMemberId newOwner;
	uint8_t padding[2];
	SceNpMatching2PresenceOptionData optData;
} SceNpMatching2GrantRoomOwnerRequest;

/*
 * sceNpMatching2KickoutRoomMember()
 */
typedef struct SceNpMatching2KickoutRoomMemberRequest {
	SceNpMatching2RoomId roomId;
	SceNpMatching2RoomMemberId target;
	SceNpMatching2BlockKickFlag blockKickFlag;
	uint8_t padding[1];
	SceNpMatching2PresenceOptionData optData;
} SceNpMatching2KickoutRoomMemberRequest;

/*
 * sceNpMatching2SearchRoom()
 */
typedef struct SceNpMatching2SearchRoomRequest {
	int option;
	SceNpMatching2WorldId          worldId;	
	SceNpMatching2LobbyId          lobbyId;
	SceNpMatching2RangeFilter      rangeFilter;
	SceNpMatching2FlagAttr         flagFilter;
	SceNpMatching2FlagAttr         flagAttr;
	SceNpMatching2IntSearchFilter *intFilter;
	unsigned int                   intFilterNum;
	SceNpMatching2BinSearchFilter *binFilter;
	unsigned int                   binFilterNum;
	SceNpMatching2AttributeId     *attrId;
	unsigned int                   attrIdNum;
} SceNpMatching2SearchRoomRequest;

typedef struct SceNpMatching2SearchRoomResponse {
	SceNpMatching2Range range;
	SceNpMatching2RoomDataExternal *roomDataExternal;
} SceNpMatching2SearchRoomResponse;

/*
 * sceNpMatching2SendRoomMessage()
 */
typedef struct SceNpMatching2SendRoomMessageRequest {
	SceNpMatching2RoomId roomId;
	SceNpMatching2CastType castType;
	uint8_t padding[3];
	SceNpMatching2RoomMessageDestination dst;
	const void *msg;
	size_t msgLen;
	int option;
} SceNpMatching2SendRoomMessageRequest;

/*
 * sceNpMatching2SendRoomChatMessage()
 */
typedef struct SceNpMatching2SendRoomChatMessageRequest {
	SceNpMatching2RoomId roomId;
	SceNpMatching2CastType castType;
	uint8_t padding[3];
	SceNpMatching2RoomMessageDestination dst;
	const void *msg;
	size_t msgLen;
	int option;
} SceNpMatching2SendRoomChatMessageRequest;

typedef struct SceNpMatching2SendRoomChatMessageResponse {
	bool filtered;
} SceNpMatching2SendRoomChatMessageResponse;

/*
 * sceNpMatching2SetRoomDataInternal()
 */
typedef struct SceNpMatching2SetRoomDataInternalRequest {
	SceNpMatching2RoomId roomId;
	SceNpMatching2FlagAttr flagFilter;
	SceNpMatching2FlagAttr flagAttr;
	SceNpMatching2BinAttr *roomBinAttrInternal;
	unsigned int           roomBinAttrInternalNum;
	SceNpMatching2RoomGroupPasswordConfig *passwordConfig;
	unsigned int passwordConfigNum;
	SceNpMatching2RoomPasswordSlotMask *passwordSlotMask;
	SceNpMatching2RoomMemberId *ownerPrivilegeRank;
	unsigned int ownerPrivilegeRankNum;
	uint8_t padding[4];
} SceNpMatching2SetRoomDataInternalRequest;

/*
 * sceNpMatching2GetRoomDataInternal()
 */
typedef struct SceNpMatching2GetRoomDataInternalRequest {
	SceNpMatching2RoomId roomId;
	const SceNpMatching2AttributeId *attrId;
	unsigned int attrIdNum;
} SceNpMatching2GetRoomDataInternalRequest;

typedef struct SceNpMatching2GetRoomDataInternalResponse {
	SceNpMatching2RoomDataInternal *roomDataInternal;
} SceNpMatching2GetRoomDataInternalResponse;

/*
 * sceNpMatching2SetRoomMemberDataInternal()
 */
typedef struct SceNpMatching2SetRoomMemberDataInternalRequest {
	SceNpMatching2RoomId       roomId;
	SceNpMatching2RoomMemberId memberId;
	SceNpMatching2TeamId       teamId;
	uint8_t padding[5];
	SceNpMatching2FlagAttr     flagFilter;
	SceNpMatching2FlagAttr     flagAttr;	
	SceNpMatching2BinAttr     *roomMemberBinAttrInternal;
	unsigned int               roomMemberBinAttrInternalNum;
} SceNpMatching2SetRoomMemberDataInternalRequest;

/*
 * sceNpMatching2GetRoomMemberDataInternal()
 */
typedef struct SceNpMatching2GetRoomMemberDataInternalRequest {
	SceNpMatching2RoomId roomId;
	SceNpMatching2RoomMemberId memberId;
	uint8_t padding[6];
	const SceNpMatching2AttributeId *attrId;
	unsigned int attrIdNum;
} SceNpMatching2GetRoomMemberDataInternalRequest;

typedef struct SceNpMatching2GetRoomMemberDataInternalResponse {
	SceNpMatching2RoomMemberDataInternal *roomMemberDataInternal;
} SceNpMatching2GetRoomMemberDataInternalResponse;

/*
 * sceNpMatching2SetSignalingOptParam()
 */
typedef struct SceNpMatching2SetSignalingOptParamRequest {
	SceNpMatching2RoomId roomId;
	SceNpMatching2SignalingOptParam sigOptParam;
} SceNpMatching2SetSignalingOptParamRequest;

/*
 * sceNpMatching2GetLobbyInfoList()
 */
typedef struct SceNpMatching2GetLobbyInfoListRequest {
	SceNpMatching2WorldId      worldId;
	SceNpMatching2RangeFilter  rangeFilter;
	SceNpMatching2AttributeId *attrId;
	unsigned int attrIdNum;
} SceNpMatching2GetLobbyInfoListRequest;

typedef struct SceNpMatching2GetLobbyInfoListResponse {
	SceNpMatching2Range range;
	SceNpMatching2LobbyDataExternal *lobbyDataExternal;
} SceNpMatching2GetLobbyInfoListResponse;

/*
 * sceNpMatching2JoinLobby()
 */
typedef struct SceNpMatching2JoinLobbyRequest {
	SceNpMatching2LobbyId            lobbyId;
	SceNpMatching2JoinedSessionInfo *joinedSessionInfo;
	unsigned int joinedSessionInfoNum;
	SceNpMatching2BinAttr           *lobbyMemberBinAttrInternal;
	unsigned int                     lobbyMemberBinAttrInternalNum;
	SceNpMatching2PresenceOptionData optData;
	uint8_t padding[4];
} SceNpMatching2JoinLobbyRequest;

typedef struct SceNpMatching2JoinLobbyResponse {
	SceNpMatching2LobbyDataInternal *lobbyDataInternal;
} SceNpMatching2JoinLobbyResponse;

/*
 * sceNpMatching2LeaveLobby()
 */
typedef struct SceNpMatching2LeaveLobbyRequest {
	SceNpMatching2LobbyId lobbyId;
	SceNpMatching2PresenceOptionData optData;
	uint8_t padding[4];
} SceNpMatching2LeaveLobbyRequest;

/*
 * sceNpMatching2SetLobbyMemberDataInternal()
 */
typedef struct SceNpMatching2SetLobbyMemberDataInternalRequest {
	SceNpMatching2LobbyId       lobbyId;
	SceNpMatching2LobbyMemberId memberId;
	uint8_t padding1[2];
	SceNpMatching2FlagAttr      flagFilter;	/*J 未使用 */
	SceNpMatching2FlagAttr      flagAttr;	/*J 未使用 */
	SceNpMatching2JoinedSessionInfo *joinedSessionInfo;
	unsigned int joinedSessionInfoNum;
	SceNpMatching2BinAttr      *lobbyMemberBinAttrInternal;
	unsigned int                lobbyMemberBinAttrInternalNum;
	uint8_t padding2[4];
} SceNpMatching2SetLobbyMemberDataInternalRequest;

/*
 * sceNpMatching2GetLobbyMemberDataInternal()
 */
typedef struct SceNpMatching2GetLobbyMemberDataInternalRequest {
	SceNpMatching2LobbyId lobbyId;
	SceNpMatching2LobbyMemberId memberId;
	uint8_t padding[6];
	const SceNpMatching2AttributeId *attrId;
	unsigned int attrIdNum;
} SceNpMatching2GetLobbyMemberDataInternalRequest;

typedef struct SceNpMatching2GetLobbyMemberDataInternalResponse {
	SceNpMatching2LobbyMemberDataInternal *lobbyMemberDataInternal;
} SceNpMatching2GetLobbyMemberDataInternalResponse;




/*
 * sceNpMatching2GetLobbyMemberDataInternalList()
 */
typedef struct SceNpMatching2GetLobbyMemberDataInternalListRequest {
	SceNpMatching2LobbyId lobbyId;
	SceNpMatching2LobbyMemberId* memberId;
	unsigned int memberIdNum;
	const SceNpMatching2AttributeId *attrId;
	unsigned int attrIdNum;
	bool extendedData;
	uint8_t padding[7];
} SceNpMatching2GetLobbyMemberDataInternalListRequest;

typedef struct SceNpMatching2GetLobbyMemberDataInternalListResponse {
	SceNpMatching2LobbyMemberDataInternal *lobbyMemberDataInternal;
	unsigned int lobbyMemberDataInternalNum;
} SceNpMatching2GetLobbyMemberDataInternalListResponse;

/*
 * sceNpMatching2SendLobbyChatMessage()
 */
typedef struct SceNpMatching2SendLobbyChatMessageRequest {
	SceNpMatching2LobbyId lobbyId;
	SceNpMatching2CastType castType;
	uint8_t padding[3];
	SceNpMatching2LobbyMessageDestination dst;
	const void *msg;
	size_t msgLen;
	int option;
} SceNpMatching2SendLobbyChatMessageRequest;

typedef struct SceNpMatching2SendLobbyChatMessageResponse {
	bool filtered;
} SceNpMatching2SendLobbyChatMessageResponse;

/*
 * sceNpMatching2SendLobbyInvitation()
 */
typedef struct SceNpMatching2SendLobbyInvitationRequest {
	SceNpMatching2LobbyId lobbyId;
	SceNpMatching2CastType castType;
	uint8_t padding[3];
	SceNpMatching2LobbyMessageDestination dst;
	SceNpMatching2InvitationData invitationData;
	int option;
} SceNpMatching2SendLobbyInvitationRequest;

/*
 * sceNpMatching2SignalingGetPingInfo()
 */
typedef struct SceNpMatching2SignalingGetPingInfoRequest {
	SceNpMatching2RoomId roomId;
	uint8_t reserved[16];
} SceNpMatching2SignalingGetPingInfoRequest;
	
typedef struct SceNpMatching2SignalingGetPingInfoResponse {
	SceNpMatching2ServerId serverId;
	uint8_t padding1[2];
	SceNpMatching2WorldId worldId;
	SceNpMatching2RoomId roomId;
	uint32_t rtt;
	uint8_t reserved[20];
} SceNpMatching2SignalingGetPingInfoResponse;

/*J
 *******************************************************************************
 * ルームイベントコールバックで通知される構造体
 *******************************************************************************
 */

/*
 * SCE_NP_MATCHING2_ROOM_EVENT_MemberJoined
 * SCE_NP_MATCHING2_ROOM_EVENT_MemberLeft
 */
typedef struct SceNpMatching2RoomMemberUpdateInfo {
	SceNpMatching2RoomMemberDataInternal *roomMemberDataInternal;
	SceNpMatching2EventCause eventCause;
	uint8_t padding[3];
	SceNpMatching2PresenceOptionData optData;
} SceNpMatching2RoomMemberUpdateInfo;

/*
 * SCE_NP_MATCHING2_ROOM_EVENT_RoomOwnerChanged
 */
typedef struct SceNpMatching2RoomOwnerUpdateInfo {
	SceNpMatching2RoomMemberId prevOwner;
	SceNpMatching2RoomMemberId newOwner;
	SceNpMatching2EventCause eventCause;
	uint8_t padding[3];
	SceNpMatching2SessionPassword *roomPassword;
	SceNpMatching2PresenceOptionData optData;
} SceNpMatching2RoomOwnerUpdateInfo;

/*
 * SCE_NP_MATCHING2_ROOM_EVENT_Kickedout
 * SCE_NP_MATCHING2_ROOM_EVENT_RoomDestroyed
 */
typedef struct SceNpMatching2RoomUpdateInfo {
	SceNpMatching2EventCause eventCause;
	uint8_t padding[3];
	int errorCode;
	SceNpMatching2PresenceOptionData optData;
} SceNpMatching2RoomUpdateInfo;

/*
 * SCE_NP_MATCHING2_ROOM_EVENT_UpdatedRoomDataInternal
 */
typedef struct SceNpMatching2RoomDataInternalUpdateInfo {
	SceNpMatching2RoomDataInternal      *newRoomDataInternal;
	SceNpMatching2FlagAttr              *newFlagAttr;
	SceNpMatching2FlagAttr              *prevFlagAttr;
	SceNpMatching2RoomPasswordSlotMask  *newRoomPasswordSlotMask;
	SceNpMatching2RoomPasswordSlotMask  *prevRoomPasswordSlotMask;
	SceNpMatching2RoomGroup            **newRoomGroup;
	unsigned int                         newRoomGroupNum;
	SceNpMatching2RoomBinAttrInternal  **newRoomBinAttrInternal;
	unsigned int                         newRoomBinAttrInternalNum;
} SceNpMatching2RoomDataInternalUpdateInfo;

/*
 * SCE_NP_MATCHING2_ROOM_EVENT_UpdatedRoomMemberDataInternal
 */
typedef struct SceNpMatching2RoomMemberDataInternalUpdateInfo {
	SceNpMatching2RoomMemberDataInternal     *newRoomMemberDataInternal;
	SceNpMatching2FlagAttr                   *newFlagAttr;
	SceNpMatching2FlagAttr                   *prevFlagAttr;
	SceNpMatching2TeamId                     *newTeamId;
	SceNpMatching2RoomMemberBinAttrInternal **newRoomMemberBinAttrInternal;
	unsigned int                              newRoomMemberBinAttrInternalNum;
} SceNpMatching2RoomMemberDataInternalUpdateInfo;

/*
 * SCE_NP_MATCHING2_ROOM_EVENT_UpdatedSignalingOptParam
 */
typedef struct SceNpMatching2SignalingOptParamUpdateInfo {
	SceNpMatching2SignalingOptParam newSignalingOptParam;
} SceNpMatching2SignalingOptParamUpdateInfo;

/*J
 *******************************************************************************
 * ルームメッセージコールバックで通知される構造体
 *******************************************************************************
 */

/*
 * SCE_NP_MATCHING2_ROOM_EVENT_ChatMessage
 * SCE_NP_MATCHING2_ROOM_EVENT_Message
 */
typedef struct SceNpMatching2RoomMessageInfo {
	bool filtered;
	SceNpMatching2CastType castType;
	uint8_t padding[2];
	SceNpMatching2RoomMessageDestination *dst;
	SceNpUserInfo2 *srcMember;
	const void *msg;
	size_t msgLen;	
} SceNpMatching2RoomMessageInfo;

/*J
 *******************************************************************************
 * ロビーイベントコールバックで通知される構造体
 *******************************************************************************
 */

/*
 * SCE_NP_MATCHING2_LOBBY_EVENT_MemberJoined
 * SCE_NP_MATCHING2_LOBBY_EVENT_MemberLeft
 */
typedef struct SceNpMatching2LobbyMemberUpdateInfo {
	SceNpMatching2LobbyMemberDataInternal *lobbyMemberDataInternal;
	SceNpMatching2EventCause eventCause;
	uint8_t padding[3];
	SceNpMatching2PresenceOptionData optData;
} SceNpMatching2LobbyMemberUpdateInfo;

/*
 * SCE_NP_MATCHING2_LOBBY_EVENT_LobbyDestroyed
 */
typedef struct SceNpMatching2LobbyUpdateInfo {
	SceNpMatching2EventCause eventCause;
	uint8_t padding[3];
	int errorCode;
} SceNpMatching2LobbyUpdateInfo;

/*
 * SCE_NP_MATCHING2_LOBBY_EVENT_UpdatedLobbyMemberDataInternal
 */
typedef struct SceNpMatching2LobbyMemberDataInternalUpdateInfo {
	SceNpMatching2LobbyMemberId memberId;
	uint8_t padding[2];
	SceNpId npId;
	SceNpMatching2FlagAttr                    flagFilter;
	SceNpMatching2FlagAttr                    newFlagAttr;
	SceNpMatching2JoinedSessionInfo          *newJoinedSessionInfo;
	unsigned int                              newJoinedSessionInfoNum;
	SceNpMatching2LobbyMemberBinAttrInternal *newLobbyMemberBinAttrInternal;
	unsigned int                              newLobbyMemberBinAttrInternalNum;
} SceNpMatching2LobbyMemberDataInternalUpdateInfo;

/*J
 *******************************************************************************
 * ロビーメッセージコールバックで通知される構造体
 *******************************************************************************
 */

/*
 * SCE_NP_MATCHING2_LOBBY_EVENT_ChatMessage
 */
typedef struct SceNpMatching2LobbyMessageInfo {
	bool filtered;
	SceNpMatching2CastType castType;
	uint8_t padding[2];
	SceNpMatching2LobbyMessageDestination *dst;
	SceNpUserInfo2 *srcMember;
	const void *msg;
	size_t msgLen;
} SceNpMatching2LobbyMessageInfo;

/*
 * SCE_NP_MATCHING2_LOBBY_EVENT_Invitation
 */
typedef struct SceNpMatching2LobbyInvitationInfo {
	SceNpMatching2CastType castType;
	uint8_t padding[3];
	SceNpMatching2LobbyMessageDestination *dst;
	SceNpUserInfo2 *srcMember;
	SceNpMatching2InvitationData invitationData;
} SceNpMatching2LobbyInvitationInfo;

/*J
 *******************************************************************************
 * API 宣言
 *******************************************************************************
 */
int
sceNpMatching2Init(
	size_t stackSize,
	int priority
	);

int
sceNpMatching2Term(
	void
	);

int
sceNpMatching2Init2(
	size_t stackSize,
	int priority,
	SceNpMatching2UtilityInitParam *param
	);

int
sceNpMatching2Term2(
	void
	);

int
sceNpMatching2GetEventData(
	SceNpMatching2ContextId ctxId,
	SceNpMatching2EventKey  eventKey,
	void   *buf,
	size_t  bufLen
	);

int
sceNpMatching2ClearEventData(
	SceNpMatching2ContextId ctxId,
	SceNpMatching2EventKey  eventKey
	);

int
sceNpMatching2CreateContext(
	const SceNpId *npId,
	const SceNpCommunicationId *commId,
	const SceNpCommunicationPassphrase *passPhrase,
	SceNpMatching2ContextId *ctxId,
	int option
	);

int
sceNpMatching2DestroyContext(
	SceNpMatching2ContextId ctxId
	);

int
sceNpMatching2ContextStart(
	SceNpMatching2ContextId ctxId
	);

int
sceNpMatching2ContextStartAsync(
	SceNpMatching2ContextId ctxId,
	uint32_t timeout
	);

int
sceNpMatching2AbortContextStart(
	SceNpMatching2ContextId ctxId
	);

int
sceNpMatching2ContextStop(
	SceNpMatching2ContextId ctxId
	);

int
sceNpMatching2SetDefaultRequestOptParam(
	SceNpMatching2ContextId ctxId,
	const SceNpMatching2RequestOptParam *optParam
	);

int
sceNpMatching2RegisterRoomEventCallback(
	SceNpMatching2ContextId ctxId,
	SceNpMatching2RoomEventCallback cbFunc,
	void *cbFuncArg
	);

int
sceNpMatching2RegisterRoomMessageCallback(
	SceNpMatching2ContextId ctxId,
	SceNpMatching2RoomMessageCallback cbFunc,
	void *cbFuncArg
	);

int
sceNpMatching2RegisterLobbyEventCallback(
	SceNpMatching2ContextId ctxId,
	SceNpMatching2LobbyEventCallback cbFunc,
	void *cbFuncArg
	);

int
sceNpMatching2RegisterLobbyMessageCallback(
	SceNpMatching2ContextId ctxId,
	SceNpMatching2LobbyMessageCallback cbFunc,
	void *cbFuncArg
	);

int
sceNpMatching2RegisterSignalingCallback(
	SceNpMatching2ContextId ctxId,
	SceNpMatching2SignalingCallback cbFunc,
	void *cbFuncArg
	);

int
sceNpMatching2RegisterContextCallback(
	SceNpMatching2ContextId ctxId,
	SceNpMatching2ContextCallback cbFunc,
	void *cbFuncArg
	);

int
sceNpMatching2GetClanLobbyId(
	SceNpMatching2ContextId ctxId,
	SceNpClanId clanId,
	SceNpMatching2LobbyId *lobbyId
	);

int
sceNpMatching2AbortRequest(
	SceNpMatching2ContextId ctxId,
	SceNpMatching2RequestId reqId
	);

int
sceNpMatching2GetMemoryInfo(
	SceNpMatching2MemoryInfo *memInfo
	);

int
sceNpMatching2GetCbQueueInfo(
	SceNpMatching2ContextId ctxId,
	SceNpMatching2CbQueueInfo *queueInfo
	);

int
sceNpMatching2GetServerIdListLocal(
	SceNpMatching2ContextId ctxId,
	SceNpMatching2ServerId *serverId,
	uint32_t serverIdNum
	);

int
sceNpMatching2GetServerInfo(
	SceNpMatching2ContextId ctxId,
	const SceNpMatching2GetServerInfoRequest *reqParam,
	const SceNpMatching2RequestOptParam *optParam,
	SceNpMatching2RequestId *assignedReqId
	);

int
sceNpMatching2CreateServerContext(
	SceNpMatching2ContextId ctxId,
	const SceNpMatching2CreateServerContextRequest *reqParam,
	const SceNpMatching2RequestOptParam *optParam,
	SceNpMatching2RequestId *assignedReqId
	);

int
sceNpMatching2DeleteServerContext(
	SceNpMatching2ContextId ctxId,
	const SceNpMatching2DeleteServerContextRequest *reqParam,
	const SceNpMatching2RequestOptParam *optParam,
	SceNpMatching2RequestId *assignedReqId
	);

int
sceNpMatching2GetWorldInfoList(
	SceNpMatching2ContextId ctxId,
	const SceNpMatching2GetWorldInfoListRequest *reqParam,
	const SceNpMatching2RequestOptParam *optParam,
	SceNpMatching2RequestId *assignedReqId
	);

int
sceNpMatching2SetUserInfo(
	SceNpMatching2ContextId ctxId,
	const SceNpMatching2SetUserInfoRequest *reqParam,
	const SceNpMatching2RequestOptParam *optParam,
	SceNpMatching2RequestId *assignedReqId
	);

int
sceNpMatching2GetUserInfoList(
	SceNpMatching2ContextId ctxId,
	const SceNpMatching2GetUserInfoListRequest *reqParam,
	const SceNpMatching2RequestOptParam *optParam,
	SceNpMatching2RequestId *assignedReqId
	);

int
sceNpMatching2CreateJoinRoom(
	SceNpMatching2ContextId ctxId,
	const SceNpMatching2CreateJoinRoomRequest *reqParam,
	const SceNpMatching2RequestOptParam *optParam,
	SceNpMatching2RequestId *assignedReqId
	);

int
sceNpMatching2SearchRoom(
	SceNpMatching2ContextId ctxId,
	const SceNpMatching2SearchRoomRequest *reqParam,
	const SceNpMatching2RequestOptParam *optParam,
	SceNpMatching2RequestId *assignedReqId
	);

int
sceNpMatching2GetRoomSlotInfoLocal(
	SceNpMatching2ContextId ctxId,
	const SceNpMatching2RoomId roomId,
	SceNpMatching2RoomSlotInfo *roomSlotInfo
	);

int
sceNpMatching2JoinRoom(
	SceNpMatching2ContextId ctxId,
	const SceNpMatching2JoinRoomRequest *reqParam,
	const SceNpMatching2RequestOptParam *optParam,
	SceNpMatching2RequestId *assignedReqId
	);

int
sceNpMatching2JoinProhibitiveRoom(
	SceNpMatching2ContextId ctxId,
	const SceNpMatching2JoinProhibitiveRoomRequest *reqParam,
	const SceNpMatching2RequestOptParam *optParam,
	SceNpMatching2RequestId *assignedReqId
	);

int
sceNpMatching2LeaveRoom(
	SceNpMatching2ContextId ctxId,
	const SceNpMatching2LeaveRoomRequest *reqParam,
	const SceNpMatching2RequestOptParam *optParam,
	SceNpMatching2RequestId *assignedReqId
	);

int
sceNpMatching2GetRoomDataInternal(
	SceNpMatching2ContextId ctxId,
	const SceNpMatching2GetRoomDataInternalRequest *reqParam,
	const SceNpMatching2RequestOptParam *optParam,
	SceNpMatching2RequestId *assignedReqId
	);

int
sceNpMatching2SetRoomDataInternal(
	SceNpMatching2ContextId ctxId,
	const SceNpMatching2SetRoomDataInternalRequest *reqParam,
	const SceNpMatching2RequestOptParam *optParam,
	SceNpMatching2RequestId *assignedReqId
	);

int
sceNpMatching2SetSignalingOptParam(
	SceNpMatching2ContextId ctxId,
	const SceNpMatching2SetSignalingOptParamRequest *reqParam,
	const SceNpMatching2RequestOptParam *optParam,
	SceNpMatching2RequestId *assignedReqId
	);

int
sceNpMatching2GetRoomPasswordLocal(
	SceNpMatching2ContextId ctxId,
	SceNpMatching2RoomId roomId,
	bool *withPassword,
	SceNpMatching2SessionPassword *roomPassword
	);

int
sceNpMatching2GetLobbyMemberIdListLocal(
	SceNpMatching2ContextId ctxId,
	SceNpMatching2LobbyId lobbyId,
	SceNpMatching2LobbyMemberId *memberId,
	uint32_t memberIdNum,
	SceNpMatching2LobbyMemberId *me
	);

int
sceNpMatching2GetSignalingOptParamLocal(
	SceNpMatching2ContextId ctxId,
	SceNpMatching2RoomId roomId,
	SceNpMatching2SignalingOptParam *signalingOptParam
	);

int
sceNpMatching2GetRoomDataExternalList(
	SceNpMatching2ContextId ctxId,
	const SceNpMatching2GetRoomDataExternalListRequest *reqParam,
	const SceNpMatching2RequestOptParam *optParam,
	SceNpMatching2RequestId *assignedReqId
	);

int
sceNpMatching2SetRoomDataExternal(
	SceNpMatching2ContextId ctxId,
	const SceNpMatching2SetRoomDataExternalRequest *reqParam,
	const SceNpMatching2RequestOptParam *optParam,
	SceNpMatching2RequestId *assignedReqId
	);

int
sceNpMatching2GetRoomMemberDataInternal(
	SceNpMatching2ContextId ctxId,
	const SceNpMatching2GetRoomMemberDataInternalRequest *reqParam,
	const SceNpMatching2RequestOptParam *optParam,
	SceNpMatching2RequestId *assignedReqId
	);

int
sceNpMatching2SetRoomMemberDataInternal(
	SceNpMatching2ContextId ctxId,
	const SceNpMatching2SetRoomMemberDataInternalRequest *reqParam,
	const SceNpMatching2RequestOptParam *optParam,
	SceNpMatching2RequestId *assignedReqId
	);

int
sceNpMatching2GetRoomMemberIdListLocal(
	SceNpMatching2ContextId ctxId,
	SceNpMatching2RoomId roomId,
	int sortMethod,
	SceNpMatching2RoomMemberId *memberId,
	uint32_t memberIdNum
	);

int
sceNpMatching2GetRoomMemberDataInternalLocal(
	SceNpMatching2ContextId ctxId,
	SceNpMatching2RoomId roomId,
	SceNpMatching2RoomMemberId memberId,
	SceNpMatching2AttributeId *attrId,
	uint32_t attrIdNum,
	SceNpMatching2RoomMemberDataInternal *member,
	char   *buf,
	size_t  bufLen
	);

int
sceNpMatching2GetRoomMemberDataExternalList(
	SceNpMatching2ContextId ctxId,
	const SceNpMatching2GetRoomMemberDataExternalListRequest *reqParam,
	const SceNpMatching2RequestOptParam *optParam,
	SceNpMatching2RequestId *assignedReqId
	);

int
sceNpMatching2KickoutRoomMember(
	SceNpMatching2ContextId ctxId,
	const SceNpMatching2KickoutRoomMemberRequest *reqParam,
	const SceNpMatching2RequestOptParam *optParam,
	SceNpMatching2RequestId *assignedReqId
	);

int
sceNpMatching2GrantRoomOwner(
	SceNpMatching2ContextId ctxId,
	const SceNpMatching2GrantRoomOwnerRequest *reqParam,
	const SceNpMatching2RequestOptParam *optParam,
	SceNpMatching2RequestId *assignedReqId
	);

int
sceNpMatching2SendRoomChatMessage(
	SceNpMatching2ContextId ctxId,
	const SceNpMatching2SendRoomChatMessageRequest *reqParam,
	const SceNpMatching2RequestOptParam *optParam,
	SceNpMatching2RequestId *assignedReqId
	);

int
sceNpMatching2SendRoomMessage(
	SceNpMatching2ContextId ctxId,
	const SceNpMatching2SendRoomMessageRequest *reqParam,
	const SceNpMatching2RequestOptParam *optParam,
	SceNpMatching2RequestId *assignedReqId
	);

int
sceNpMatching2GetLobbyInfoList(
	SceNpMatching2ContextId ctxId,
	const SceNpMatching2GetLobbyInfoListRequest *reqParam,
	const SceNpMatching2RequestOptParam *optParam,
	SceNpMatching2RequestId *assignedReqId
	);

int
sceNpMatching2JoinLobby(
	SceNpMatching2ContextId ctxId,
	const SceNpMatching2JoinLobbyRequest *reqParam,
	const SceNpMatching2RequestOptParam *optParam,
	SceNpMatching2RequestId *assignedReqId
	);

int
sceNpMatching2LeaveLobby(
	SceNpMatching2ContextId ctxId,
	const SceNpMatching2LeaveLobbyRequest *reqParam,
	const SceNpMatching2RequestOptParam *optParam,
	SceNpMatching2RequestId *assignedReqId
	);

int
sceNpMatching2SetLobbyMemberDataInternal(
	SceNpMatching2ContextId ctxId,
	const SceNpMatching2SetLobbyMemberDataInternalRequest *reqParam,
	const SceNpMatching2RequestOptParam *optParam,
	SceNpMatching2RequestId *assignedReqId
	);

int
sceNpMatching2GetLobbyMemberDataInternal(
	SceNpMatching2ContextId ctxId,
	const SceNpMatching2GetLobbyMemberDataInternalRequest *reqParam,
	const SceNpMatching2RequestOptParam *optParam,
	SceNpMatching2RequestId *assignedReqId
	);

int
sceNpMatching2GetLobbyMemberDataInternalList(
	SceNpMatching2ContextId ctxId,
	const SceNpMatching2GetLobbyMemberDataInternalListRequest *reqParam,
	const SceNpMatching2RequestOptParam *optParam,
	SceNpMatching2RequestId *assignedReqId
	);

int
sceNpMatching2SendLobbyChatMessage(
	SceNpMatching2ContextId ctxId,
	const SceNpMatching2SendLobbyChatMessageRequest *reqParam,
	const SceNpMatching2RequestOptParam *optParam,
	SceNpMatching2RequestId *assignedReqId
	);

int
sceNpMatching2SendLobbyInvitation(
	SceNpMatching2ContextId ctxId,
	const SceNpMatching2SendLobbyInvitationRequest *reqParam,
	const SceNpMatching2RequestOptParam *optParam,
	SceNpMatching2RequestId *assignedReqId
	);

int
sceNpMatching2SignalingGetPingInfo(
	SceNpMatching2ContextId ctxId,
	const SceNpMatching2SignalingGetPingInfoRequest *reqParam,
	const SceNpMatching2RequestOptParam *optParam,
	SceNpMatching2RequestId *assignedReqId
	);

int
sceNpMatching2SignalingGetConnectionStatus(
	SceNpMatching2ContextId ctxId,
	SceNpMatching2RoomId roomId,
	SceNpMatching2RoomMemberId memberId,
	int *connStatus,
	struct in_addr *peerAddr,
	in_port_t *peerPort
	);

int
sceNpMatching2SignalingGetConnectionInfo(
	SceNpMatching2ContextId ctxId,
	SceNpMatching2RoomId roomId,
	SceNpMatching2RoomMemberId memberId,
	int code,
	SceNpSignalingConnectionInfo *connInfo
	);

int
sceNpMatching2SignalingSetCtxOpt(
	SceNpMatching2ContextId ctxId,
	int optname,
	int optval
	);

int
sceNpMatching2SignalingGetCtxOpt(
	SceNpMatching2ContextId ctxId,
	int optname,
	int *optval
	);

/* nat staus */





typedef struct SceNpMatching2SignalingNetInfo {
	size_t size;
	struct in_addr localAddr;
	struct in_addr mappedAddr;
	int natStatus;
} SceNpMatching2SignalingNetInfo;

/*
 * Np Signaling NetInfo API
 */

int
sceNpMatching2SignalingGetLocalNetInfo(
	SceNpMatching2SignalingNetInfo *netinfo
	);

int
sceNpMatching2SignalingGetPeerNetInfo(
	SceNpMatching2ContextId ctxId,
	SceNpMatching2RoomId roomId,
	SceNpMatching2RoomMemberId memberId,
	SceNpMatching2SignalingRequestId *reqId
	);

int
sceNpMatching2SignalingCancelPeerNetInfo(
	SceNpMatching2ContextId ctxId,
	SceNpMatching2SignalingRequestId reqId
	);

int
sceNpMatching2SignalingGetPeerNetInfoResult(
	SceNpMatching2ContextId ctxId,
	SceNpMatching2SignalingRequestId reqId,
	SceNpMatching2SignalingNetInfo *netinfo
	);


}


# 35 "C:/usr/local/cell\\target\\ppu\\include/np.h" 3

# 1 "C:/usr/local/cell\\target\\ppu\\include/np/tustorage.h" 3
/*   SCE CONFIDENTIAL
PlayStation(R)3 Programmer Tool Runtime Library 475.001
*   Copyright (C) 2014 Sony Computer Entertainment Inc.
*   All Rights Reserved.
*/













extern "C" {


typedef	int32_t		SceNpTusSlotId;
typedef SceNpOnlineId SceNpTusVirtualUserId;

typedef struct SceNpTusSetDataOptParam{
	size_t size;
	CellRtcTick *isLastChangedDate;
	SceNpId *isLastChangedAuthorId;
} SceNpTusSetDataOptParam;

typedef struct SceNpTusAddAndGetVariableOptParam{
	size_t size;
	CellRtcTick *isLastChangedDate;
	SceNpId *isLastChangedAuthorId;
} SceNpTusAddAndGetVariableOptParam;

typedef struct SceNpTusTryAndSetVariableOptParam{
	size_t size;
	CellRtcTick *isLastChangedDate;
	SceNpId *isLastChangedAuthorId;
	int64_t *compareValue;
} SceNpTusTryAndSetVariableOptParam;

typedef	struct SceNpTusVariable{
	SceNpId ownerId;
	int32_t hasData;
	CellRtcTick lastChangedDate;
	uint8_t pad[4];
	SceNpId lastChangedAuthorId;
	int64_t variable;
	int64_t oldVariable;
	uint8_t reserved[16];
} SceNpTusVariable;

typedef	struct SceNpTusDataInfo{
	size_t infoSize;
	uint8_t pad[4];
	uint8_t data[384];
} SceNpTusDataInfo;

typedef	struct SceNpTusDataStatus{
	SceNpId ownerId;
	int32_t hasData;
	CellRtcTick lastChangedDate;
	SceNpId lastChangedAuthorId;
	void *data;
	size_t dataSize;
	uint8_t pad[4];
	SceNpTusDataInfo info;
} SceNpTusDataStatus;

typedef enum {
	SCE_NP_TUS_OPETYPE_EQUAL = 1,
	SCE_NP_TUS_OPETYPE_NOT_EQUAL,
	SCE_NP_TUS_OPETYPE_GREATER_THAN,
	SCE_NP_TUS_OPETYPE_GREATER_OR_EQUAL,
	SCE_NP_TUS_OPETYPE_LESS_THAN,
	SCE_NP_TUS_OPETYPE_LESS_OR_EQUAL
}SceNpTusOeratorType;

typedef enum {
	SCE_NP_TUS_VARIABLE_SORTTYPE_DESCENDING_DATE=1,
	SCE_NP_TUS_VARIABLE_SORTTYPE_ASCENDING_DATE,
	SCE_NP_TUS_VARIABLE_SORTTYPE_DESCENDING_VALUE,
	SCE_NP_TUS_VARIABLE_SORTTYPE_ASCENDING_VALUE
} SceNpTusVariableSortType;

typedef enum {
	SCE_NP_TUS_DATASTATUS_SORTTYPE_DESCENDING_DATE=1,
	SCE_NP_TUS_DATASTATUS_SORTTYPE_ASCENDING_DATE
} SceNpTusDataStatusSortType;

int32_t sceNpTusInit(int32_t prio);
int32_t sceNpTusTerm(void);

int32_t sceNpTusCreateTitleCtx(
	const SceNpCommunicationId *communicationId,
	const SceNpCommunicationPassphrase *passphrase,
	const SceNpId *selfNpId
);

int sceNpTusDestroyTitleCtx(
	int32_t titleCtxId
);

int sceNpTusCreateTransactionCtx(
	int32_t titleCtxId
);

int sceNpTusDestroyTransactionCtx (
	int32_t transId
);

int sceNpTusSetTimeout (
	int32_t ctxId,
	usecond_t timeout
);

int sceNpTusAbortTransaction(
	int32_t transId
);

int sceNpTusWaitAsync (
	int32_t transId,
	int32_t *result
);
int sceNpTusPollAsync (
	int32_t transId,
	int32_t *result
);

int sceNpTusSetMultiSlotVariable (
	int32_t	transId,
	const SceNpId *targetNpId,
	const SceNpTusSlotId slotIdArray[],
	const int64_t variableArray[],
	int32_t arrayNum,
	void *option
);

int sceNpTusSetMultiSlotVariableVUser (
	int32_t	transId,
	const SceNpTusVirtualUserId *targetVirtualUserId,
	const SceNpTusSlotId slotIdArray[],
	const int64_t variableArray[],
	int32_t arrayNum,
	void *option
);

int sceNpTusSetMultiSlotVariableAsync (
	int32_t	transId,
	const SceNpId *targetNpId,
	const SceNpTusSlotId slotIdArray[],
	const int64_t variableArray[],
	int32_t arrayNum,
	void *option
);

int sceNpTusSetMultiSlotVariableVUserAsync (
	int32_t	transId,
	const SceNpTusVirtualUserId *targetVirtualUserId,
	const SceNpTusSlotId slotIdArray[],
	const int64_t variableArray[],
	int32_t arrayNum,
	void *option
);

int sceNpTusGetMultiSlotVariable (
	int32_t	transId,
	const SceNpId *targetNpId,
	const SceNpTusSlotId slotIdArray[],
	SceNpTusVariable variableArray[],
	size_t variableArraySize,
	int32_t arrayNum,
	void *option
);

int sceNpTusGetMultiSlotVariableVUser (
	int32_t	transId,
	const SceNpTusVirtualUserId *targetVirtualUserId,
	const SceNpTusSlotId slotIdArray[],
	SceNpTusVariable variableArray[],
	size_t variableArraySize,
	int32_t arrayNum,
	void *option
);

int sceNpTusGetMultiSlotVariableAsync (
	int32_t	transId,
	const SceNpId *targetNpId,
	const SceNpTusSlotId slotIdArray[],
	SceNpTusVariable variableArray[],
	size_t variableArraySize,
	int32_t arrayNum,
	void *option
);

int sceNpTusGetMultiSlotVariableVUserAsync (
	int32_t	transId,
	const SceNpTusVirtualUserId *targetVirtualUserId,
	const SceNpTusSlotId slotIdArray[],
	SceNpTusVariable variableArray[],
	size_t variableArraySize,
	int32_t arrayNum,
	void *option
);

int sceNpTusGetMultiUserVariable (
	int32_t	transId,
	const SceNpId targetNpIdArray[],
	SceNpTusSlotId slotId,
	SceNpTusVariable variableArray[],
	size_t variableArraySize,
	int32_t arrayNum,
	void *option
);

int sceNpTusGetFriendsVariable (
	int transId,
	SceNpTusSlotId slotId,
	int includeSelf,
	int sortType,
	SceNpTusVariable variableArray[],
	size_t variableArraySize,
	int arrayNum,
	void *option
);

int sceNpTusGetFriendsVariableAsync (
	int transId,
	SceNpTusSlotId slotId,
	int includeSelf,
	int sortType,
	SceNpTusVariable variableArray[],
	size_t variableArraySize,
	int arrayNum,
	void *option
);

int sceNpTusGetMultiUserVariableVUser (
	int32_t	transId,
	const SceNpTusVirtualUserId targetVirtualUserIdArray[],
	SceNpTusSlotId slotId,
	SceNpTusVariable variableArray[],
	size_t variableArraySize,
	int32_t arrayNum,
	void *option
);

int sceNpTusGetMultiUserVariableAsync (
	int32_t	transId,
	const SceNpId targetNpIdArray[],
	SceNpTusSlotId slotId,
	SceNpTusVariable variableArray[],
	size_t variableArraySize,
	int32_t arrayNum,
	void *option
);

int sceNpTusGetMultiUserVariableVUserAsync (
	int32_t	transId,
	const SceNpTusVirtualUserId targetVirtualUserIdArray[],
	SceNpTusSlotId slotId,
	SceNpTusVariable variableArray[],
	size_t variableArraySize,
	int32_t arrayNum,
	void *option
);

int sceNpTusAddAndGetVariable (
	int32_t	transId,
	const SceNpId *targetNpId,
	SceNpTusSlotId slotId,
	int64_t inVariable,
	SceNpTusVariable *outVariable,
	size_t outVariableSize,
	SceNpTusAddAndGetVariableOptParam *option
);

int sceNpTusAddAndGetVariableVUser (
	int32_t	transId,
	const SceNpTusVirtualUserId *targetVirtualUserId,
	SceNpTusSlotId slotId,
	int64_t inVariable,
	SceNpTusVariable *outVariable,
	size_t outVariableSize,
	SceNpTusAddAndGetVariableOptParam *option
);

int sceNpTusAddAndGetVariableAsync (
	int32_t	transId,
	const SceNpId *targetNpId,
	SceNpTusSlotId slotId,
	int64_t inVariable,
	SceNpTusVariable *outVariable,
	size_t outVariableSize,
	SceNpTusAddAndGetVariableOptParam *option
);

int sceNpTusAddAndGetVariableVUserAsync (
	int32_t	transId,
	const SceNpTusVirtualUserId *targetVirtualUserId,
	SceNpTusSlotId slotId,
	int64_t inVariable,
	SceNpTusVariable *outVariable,
	size_t outVariableSize,
	SceNpTusAddAndGetVariableOptParam *option
);

int sceNpTusTryAndSetVariable (
	int32_t	transId,
	const SceNpId *targetNpId,
	SceNpTusSlotId slotId,
	int32_t opeType,
	int64_t variable,
	SceNpTusVariable *resultVariable,
	size_t	resultVariableSize,
	SceNpTusTryAndSetVariableOptParam *option
);

int sceNpTusTryAndSetVariableVUser (
	int32_t	transId,
	const SceNpTusVirtualUserId *targetVirtualUserId,
	SceNpTusSlotId slotId,
	int32_t opeType,
	int64_t variable,
	SceNpTusVariable *resultVariable,
	size_t	resultVariableSize,
	SceNpTusTryAndSetVariableOptParam *option
);

int sceNpTusTryAndSetVariableAsync (
	int32_t	transId,
	const SceNpId *targetNpId,
	SceNpTusSlotId slotId,
	int32_t opeType,
	int64_t variable,
	SceNpTusVariable *resultVariable,
	size_t	resultVariableSize,
	SceNpTusTryAndSetVariableOptParam *option
);

int sceNpTusTryAndSetVariableVUserAsync (
	int32_t	transId,
	const SceNpTusVirtualUserId *targetVirtualUserId,
	SceNpTusSlotId slotId,
	int32_t opeType,
	int64_t variable,
	SceNpTusVariable *resultVariable,
	size_t	resultVariableSize,
	SceNpTusTryAndSetVariableOptParam *option
);

int sceNpTusDeleteMultiSlotVariable (
	int32_t	transId,
	const SceNpId *targetNpId,
	const SceNpTusSlotId slotIdArray[],
	int32_t arrayNum,
	void *option
);

int sceNpTusDeleteMultiSlotVariableVUser (
	int32_t	transId,
	const SceNpTusVirtualUserId *targetVirtualUserId,
	const SceNpTusSlotId slotIdArray[],
	int32_t arrayNum,
	void *option
);

int sceNpTusDeleteMultiSlotVariableAsync (
	int32_t	transId,
	const SceNpId *targetNpId,
	const SceNpTusSlotId slotIdArray[],
	int32_t arrayNum,
	void *option
);

int sceNpTusDeleteMultiSlotVariableVUserAsync (
	int32_t	transId,
	const SceNpTusVirtualUserId *targetVirtualUserId,
	const SceNpTusSlotId slotIdArray[],
	int32_t arrayNum,
	void *option
);

int sceNpTusSetData (
	int32_t	transId,
	const SceNpId *targetNpId,
	SceNpTusSlotId slotId,
	size_t totalSize,
	size_t sendSize,
	const void *data,
	const SceNpTusDataInfo *info,
	size_t infoStructSize,
	SceNpTusSetDataOptParam *option
);

int sceNpTusSetDataVUser (
	int32_t	transId,
	const SceNpTusVirtualUserId *targetVirtualUserId,
	SceNpTusSlotId slotId,
	size_t totalSize,
	size_t sendSize,
	const void *data,
	const SceNpTusDataInfo *info,
	size_t infoStructSize,
	SceNpTusSetDataOptParam *option
);

int sceNpTusSetDataAsync (
	int32_t	transId,
	const SceNpId *targetNpId,
	SceNpTusSlotId slotId,
	size_t totalSize,
	size_t sendSize,
	const void *data,
	const SceNpTusDataInfo *info,
	size_t infoStructSize,
	SceNpTusSetDataOptParam *option
);

int sceNpTusSetDataVUserAsync (
	int32_t	transId,
	const SceNpTusVirtualUserId *targetVirtualUserId,
	SceNpTusSlotId slotId,
	size_t totalSize,
	size_t sendSize,
	const void *data,
	const SceNpTusDataInfo *info,
	size_t infoStructSize,
	SceNpTusSetDataOptParam *option
);

int sceNpTusGetData (
	int32_t	transId,
	const SceNpId *targetNpId,
	SceNpTusSlotId slotId,
	SceNpTusDataStatus *dataStatus,
	size_t dataStatusSize,
	void *data,
	size_t recvSize,
	void *option
);

int sceNpTusGetDataVUser (
	int32_t	transId,
	const SceNpTusVirtualUserId *targetVirtualUserId,
	SceNpTusSlotId slotId,
	SceNpTusDataStatus *dataStatus,
	size_t dataStatusSize,
	void *data,
	size_t recvSize,
	void *option
);

int sceNpTusGetDataAsync (
	int32_t	transId,
	const SceNpId *targetNpId,
	SceNpTusSlotId slotId,
	SceNpTusDataStatus *dataStatus,
	size_t dataStatusSize,
	void *data,
	size_t recvSize,
	void *option
);

int sceNpTusGetDataVUserAsync (
	int32_t	transId,
	const SceNpTusVirtualUserId *targetVirtualUserId,
	SceNpTusSlotId slotId,
	SceNpTusDataStatus *dataStatus,
	size_t dataStatusSize,
	void *data,
	size_t recvSize,
	void *option
);

int sceNpTusGetMultiSlotDataStatus (
	int32_t	transId,
	const SceNpId *targetNpId,
	const SceNpTusSlotId slotIdArray[],
	SceNpTusDataStatus statusArray[],
	size_t statusArraySize,
	int32_t arrayNum,
	void *option
);

int sceNpTusGetMultiSlotDataStatusVUser (
	int32_t	transId,
	const SceNpTusVirtualUserId *targetVirtualUserId,
	const SceNpTusSlotId slotIdArray[],
	SceNpTusDataStatus statusArray[],
	size_t statusArraySize,
	int32_t arrayNum,
	void *option
);

int sceNpTusGetMultiSlotDataStatusAsync (
	int32_t	transId,
	const SceNpId *targetNpId,
	const SceNpTusSlotId slotIdArray[],
	SceNpTusDataStatus statusArray[],
	size_t statusArraySize,
	int32_t arrayNum,
	void *option
);

int sceNpTusGetMultiSlotDataStatusVUserAsync (
	int32_t	transId,
	const SceNpTusVirtualUserId *targetVirtualUserId,
	const SceNpTusSlotId slotIdArray[],
	SceNpTusDataStatus statusArray[],
	size_t statusArraySize,
	int32_t arrayNum,
	void *option
);

int sceNpTusGetMultiUserDataStatus (
	int32_t	transId,
	const SceNpId targetNpIdArray[],
	SceNpTusSlotId slotId,
	SceNpTusDataStatus statusArray[],
	size_t statusArraySize,
	int32_t arrayNum,
	void *option
);

int sceNpTusGetMultiUserDataStatusVUser (
	int32_t	transId,
	const SceNpTusVirtualUserId targetVirtualUserIdArray[],
	SceNpTusSlotId slotId,
	SceNpTusDataStatus statusArray[],
	size_t statusArraySize,
	int32_t arrayNum,
	void *option
);

int sceNpTusGetMultiUserDataStatusAsync (
	int32_t	transId,
	const SceNpId targetNpIdArray[],
	SceNpTusSlotId slotId,
	SceNpTusDataStatus statusArray[],
	size_t statusArraySize,
	int32_t arrayNum,
	void *option
);

int sceNpTusGetMultiUserDataStatusVUserAsync (
	int32_t	transId,
	const SceNpTusVirtualUserId targetVirtualUserIdArray[],
	SceNpTusSlotId slotId,
	SceNpTusDataStatus statusArray[],
	size_t statusArraySize,
	int32_t arrayNum,
	void *option
);

int sceNpTusGetFriendsDataStatus (
	int transId,
	SceNpTusSlotId slotId,
	int includeSelf,
	int sortType,
	SceNpTusDataStatus statusArray[],
	size_t statusArraySize,
	int arrayNum,
	void *option
);

int sceNpTusGetFriendsDataStatusAsync (
	int transId,
	SceNpTusSlotId slotId,
	int includeSelf,
	int sortType,
	SceNpTusDataStatus statusArray[],
	size_t statusArraySize,
	int arrayNum,
	void *option
);

int sceNpTusDeleteMultiSlotData (
	int32_t	transId,
	const SceNpId *targetNpId,
	const SceNpTusSlotId slotIdArray[],
	int32_t arrayNum,
	void *option
);

int sceNpTusDeleteMultiSlotDataVUser (
	int32_t	transId,
	const SceNpTusVirtualUserId *targetVirtualUserId,
	const SceNpTusSlotId slotIdArray[],
	int32_t arrayNum,
	void *option
);

int sceNpTusDeleteMultiSlotDataAsync (
	int32_t	transId,
	const SceNpId *targetNpId,
	const SceNpTusSlotId slotIdArray[],
	int32_t arrayNum,
	void *option
);

int sceNpTusDeleteMultiSlotDataVUserAsync (
	int32_t	transId,
	const SceNpTusVirtualUserId *targetVirtualUserId,
	const SceNpTusSlotId slotIdArray[],
	int32_t arrayNum,
	void *option
);

/* TSS */





typedef int32_t SceNpTssSlotId;


typedef enum{
	SCE_NP_TSS_IFTYPE_IF_MODIFIED_SINCE,
	SCE_NP_TSS_IFTYPE_IF_RANGE
} SceNpTssIfType;

typedef struct SceNpTssIfModifiedSinceParam{
	int32_t ifType;
	uint8_t padding[4];
	CellRtcTick lastModified;
} SceNpTssIfModifiedSinceParam;

typedef struct SceNpTssGetDataOptParam{
	size_t size;
	uint64_t *offset;
	uint64_t *lastByte;
	SceNpTssIfModifiedSinceParam *ifParam;
} SceNpTssGetDataOptParam;

typedef enum {
	SCE_NP_TSS_STATUS_TYPE_OK,
	SCE_NP_TSS_STATUS_TYPE_PARTIAL,
	SCE_NP_TSS_STATUS_TYPE_NOT_MODIFIED
} SceNpTssStatusCodeType;

typedef struct SceNpTssDataStatus{
	CellRtcTick lastModified;
	int32_t statusCodeType;
	size_t contentLength;
} SceNpTssDataStatus;
int sceNpTssGetData (
	int32_t transId,
	SceNpTssSlotId slotId,
	SceNpTssDataStatus *dataStatus,
	size_t dataStatusSize,
	void *data,
	size_t recvSize,
	SceNpTssGetDataOptParam *option
);
int sceNpTssGetDataAsync(
	int32_t reqId,
	SceNpTssSlotId slotId,
	SceNpTssDataStatus *dataStatus,
	size_t dataStatusSize,
	void *data,
	size_t recvSize,
	SceNpTssGetDataOptParam *option
);





}


# 37 "C:/usr/local/cell\\target\\ppu\\include/np.h" 3

# 1 "C:/usr/local/cell\\target\\ppu\\include/np/trophy.h" 3
/*  SCE CONFIDENTIAL                                      */
/*  PlayStation(R)3 Programmer Tool Runtime Library 475.001 */
/*  Copyright (C) 2008 Sony Computer Entertainment Inc.   */
/*  All Rights Reserved.                                  */




extern "C" {


/* type */






/* status */














/* sizes */









/* options */




/* trophy flag array */
# 56 "C:/usr/local/cell\\target\\ppu\\include/np/trophy.h" 3

# 75 "C:/usr/local/cell\\target\\ppu\\include/np/trophy.h" 3

typedef uint32_t SceNpTrophyFlagMask;

typedef struct SceNpTrophyFlagArray {
	SceNpTrophyFlagMask flag_bits[(128) >> (5)];
} SceNpTrophyFlagArray;

typedef int32_t SceNpTrophyId;
typedef uint32_t SceNpTrophyContext;
typedef uint32_t SceNpTrophyHandle;
typedef uint32_t SceNpTrophyStatus;
typedef uint32_t SceNpTrophyGrade;

typedef struct SceNpTrophyGameDetails {
	size_t numTrophies;
	size_t numPlatinum;
	size_t numGold;
	size_t numSilver;
	size_t numBronze;
	char title[(128)];
	char description[(1024)];
	uint8_t reserved[4];
} SceNpTrophyGameDetails;

typedef struct SceNpTrophyGameData {
	size_t unlockedTrophies;
	size_t unlockedPlatinum;
	size_t unlockedGold;
	size_t unlockedSilver;
	size_t unlockedBronze;
} SceNpTrophyGameData;

typedef struct SceNpTrophyDetails {
	SceNpTrophyId trophyId;
	SceNpTrophyGrade trophyGrade;
	char name[(128)];
	char description[(1024)];
	bool hidden;
	uint8_t reserved[3];
} SceNpTrophyDetails;

typedef struct SceNpTrophyData {
	CellRtcTick timestamp;
	SceNpTrophyId trophyId;
	bool unlocked;
	uint8_t reserved[3];
} SceNpTrophyData;

typedef int (*SceNpTrophyStatusCallback)(
	SceNpTrophyContext context,
	SceNpTrophyStatus status,
	int completed,
	int total,
	void *arg
	);

/* library functions */
int sceNpTrophyInit(
	void *pool,
	size_t poolSize,
	sys_memory_container_t containerId,
	uint64_t options
	);

int sceNpTrophyTerm(
	void
	);

int sceNpTrophyCreateHandle(
	SceNpTrophyHandle *handle
	);

int sceNpTrophyDestroyHandle(
	SceNpTrophyHandle handle
	);

int sceNpTrophyAbortHandle(
	SceNpTrophyHandle handle
	);

int sceNpTrophyCreateContext(
	SceNpTrophyContext *context,
	const SceNpCommunicationId *commId,
	const SceNpCommunicationSignature *commSign,
	uint64_t options
	);

int sceNpTrophyGetRequiredDiskSpace(
	SceNpTrophyContext context,
	SceNpTrophyHandle handle,
	uint64_t *reqspace,
	uint64_t options
	);

int sceNpTrophyRegisterContext(
	SceNpTrophyContext context,
	SceNpTrophyHandle handle,
	SceNpTrophyStatusCallback statusCb,
	void *arg,
	uint64_t options
	);

int sceNpTrophyDestroyContext(
	SceNpTrophyContext context
	);

int sceNpTrophyGetGameInfo(
	SceNpTrophyContext context,
	SceNpTrophyHandle handle,
	SceNpTrophyGameDetails *details,
	SceNpTrophyGameData *data
	);

int sceNpTrophyGetTrophyUnlockState(
	SceNpTrophyContext context,
	SceNpTrophyHandle handle,
	SceNpTrophyFlagArray *flags,
	size_t *count
	);

int sceNpTrophyGetTrophyInfo(
	SceNpTrophyContext context,
	SceNpTrophyHandle handle,
	SceNpTrophyId trophyId,
	SceNpTrophyDetails *details,
	SceNpTrophyData *data
	);

int sceNpTrophyGetGameIcon(
	SceNpTrophyContext context,
	SceNpTrophyHandle handle,
	void *buffer,
	size_t *size
	);

int sceNpTrophyGetTrophyIcon(
	SceNpTrophyContext context,
	SceNpTrophyHandle handle,
	SceNpTrophyId trophyId,
	void *buffer,
	size_t *size
	);

int sceNpTrophySetSoundLevel(
	SceNpTrophyContext context,
	SceNpTrophyHandle handle,
	uint32_t level,
	uint64_t options
	);

int sceNpTrophyUnlockTrophy(
	SceNpTrophyContext context,
	SceNpTrophyHandle handle,
	SceNpTrophyId trophyId,
	SceNpTrophyId *platinumId
	);

int sceNpTrophyGetGameProgress(
	SceNpTrophyContext context,
	SceNpTrophyHandle handle,
	int32_t *percentage
	);


}


# 39 "C:/usr/local/cell\\target\\ppu\\include/np.h" 3

# 1 "C:/usr/local/cell\\target\\ppu\\include/np/profile.h" 3
/*  SCE CONFIDENTIAL                                      */
/*  PlayStation(R)3 Programmer Tool Runtime Library 475.001 */
/*  Copyright (C) 2009 Sony Computer Entertainment Inc.   */
/*  All Rights Reserved.                                  */




extern "C" {


typedef int (*SceNpProfileResultHandler)(
	int result,
	void *arg
	);

int sceNpProfileCallGui(
	const SceNpId *npid,
	SceNpProfileResultHandler handler,
	void *userArg,
	uint64_t options
	);

int sceNpProfileAbortGui(
	void
	);


}


# 41 "C:/usr/local/cell\\target\\ppu\\include/np.h" 3

# 1 "C:/usr/local/cell\\target\\ppu\\include/np/custom_menu.h" 3
/*  SCE CONFIDENTIAL                                      */
/*  PlayStation(R)3 Programmer Tool Runtime Library 475.001 */
/*  Copyright (C) 2008 Sony Computer Entertainment Inc.   */
/*  All Rights Reserved.                                  */




extern "C" {







/* custom menu index array */
# 24 "C:/usr/local/cell\\target\\ppu\\include/np/custom_menu.h" 3

# 43 "C:/usr/local/cell\\target\\ppu\\include/np/custom_menu.h" 3

typedef uint32_t SceNpCustomMenuIndexMask;

typedef struct SceNpCustomMenuIndexArray {
	SceNpCustomMenuIndexMask index_bits[(64) >> (5)];
} SceNpCustomMenuIndexArray;

# 57 "C:/usr/local/cell\\target\\ppu\\include/np/custom_menu.h" 3





typedef uint32_t SceNpCustomMenuActionMask;
typedef uint32_t SceNpCustomMenuSelectedType;

typedef struct SceNpCustomMenuAction {
	uint32_t options;
	const char *name;
	SceNpCustomMenuActionMask mask;
} SceNpCustomMenuAction;

typedef struct SceNpCustomMenu {
	uint64_t options;
	SceNpCustomMenuAction *actions;
	size_t numActions;
} SceNpCustomMenu;

typedef struct SceNpCustomMenuActionExceptions {
	uint32_t options;
	SceNpId npid;
	SceNpCustomMenuIndexArray actions;
	uint8_t reserved[4];
} SceNpCustomMenuActionExceptions;

typedef int (*SceNpCustomMenuEventHandler)(
	int retCode,
	size_t index,
	const SceNpId *npid,
	SceNpCustomMenuSelectedType type,
	void *arg
	);

int sceNpCustomMenuRegisterActions(
	const SceNpCustomMenu *menu,
	SceNpCustomMenuEventHandler handler,
	void *userArg,
	uint64_t options
	);

int sceNpCustomMenuActionSetActivation(
	const SceNpCustomMenuIndexArray *array,
	uint64_t options
	);

int sceNpCustomMenuRegisterExceptionList(
	const SceNpCustomMenuActionExceptions *items,
	size_t numItems,
	uint64_t options
	);


}


# 43 "C:/usr/local/cell\\target\\ppu\\include/np.h" 3

# 1 "C:/usr/local/cell\\target\\ppu\\include/np/auth_oauth.h" 3
/* SCE CONFIDENTIAL
 PlayStation(R)3 Programmer Tool Runtime Library 475.001
 *
 *      Copyright (C) 2014 Sony Computer Entertainment Inc.
 *                        All Rights Reserved.
 *
 */



# 1 "C:/usr/local/cell\\target\\ppu\\include/stdio.h" 3
/* SCE CONFIDENTIAL
PlayStation(R)3 Programmer Tool Runtime Library 475.001
* Copyright (C) 2007 Sony Computer Entertainment Inc. 
* All Rights Reserved.
*/
/* stdio.h standard header */
# 260 "C:/usr/local/cell\\target\\ppu\\include/stdio.h" 3

# 293 "C:/usr/local/cell\\target\\ppu\\include/stdio.h" 3

/*
 * Copyright (c) 1992-2003 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
V4.02:0216 */
# 12 "C:/usr/local/cell\\target\\ppu\\include/np/auth_oauth.h" 3


extern "C" {



/* NP Client ID */

typedef struct SceNpClientId {
	char id[128 + 1];
	uint8_t padding[7];
} SceNpClientId;

/* NP Authorization Code */

typedef struct SceNpAuthorizationCode {
	char code[128 + 1];
	uint8_t padding[7];
} SceNpAuthorizationCode;


typedef struct SceNpAuthGetAuthorizationCodeParameter {
	size_t size;
	const SceNpClientId *pClientId;
	const char *pScope;
} SceNpAuthGetAuthorizationCodeParameter;

typedef int SceNpAuthOAuthRequestId;





int sceNpAuthOAuthInit(void);
int sceNpAuthOAuthTerm(void);

SceNpAuthOAuthRequestId
sceNpAuthCreateOAuthRequest(
    void
	);

int
sceNpAuthDeleteOAuthRequest(
    SceNpAuthOAuthRequestId reqId
	);

int
sceNpAuthAbortOAuthRequest(
    SceNpAuthOAuthRequestId reqId
    );

int
sceNpAuthGetAuthorizationCode(
    SceNpAuthOAuthRequestId reqId,
	const SceNpAuthGetAuthorizationCodeParameter *param,
	SceNpAuthorizationCode *authCode,
	int *issuerId
    );


}


# 45 "C:/usr/local/cell\\target\\ppu\\include/np.h" 3

# 1 "C:/usr/local/cell\\target\\ppu\\include/np/error.h" 3
/*  SCE CONFIDENTIAL									  */
/*  PlayStation(R)3 Programmer Tool Runtime Library 475.001 */
/*  Copyright (C) 2014 Sony Computer Entertainment Inc.   */
/*  All Rights Reserved.								  */




extern "C" {


/* NP Authentication Error (client runtime errors) */
# 20 "C:/usr/local/cell\\target\\ppu\\include/np/error.h" 3

/* community client library error (0x8002a100 - 0x8002a1ff)*/
/* library has already been initialized */

/* the library has not yet been initialized */

/* tried to malloc, but got NULL (no memory) */

/*J 指定した引数の値がNULL(必須の引数がNULLで指定された) */

/*J TitleIDが設定されていない. (URLの情報が足りない) */

/*J クライアントはlogin transactionを実行していない. */

/*J 作成されるオブジェクトが多すぎる. */

/*J トランザクションの最中に、クライアントまたはトランザクションを削除しようとした.(obsolete) */

/*J トランザクションはアボートされた */

/*J 指定したリソースは一つも存在しない. */

/*J サーバからのレスポンスが不正 */

/*J サーバからのレスポンスボディのサイズが大きすぎる. */

/*J HTTPプロトコルレイヤでサーバと通信失敗. (403や404などが返ってきている) */

/*J サーバレスポンスの署名が不正 */

/*J タイムアウトした(libhttpレイヤのタイムアウトも返ることに注意) */

/*J 指定したトランザクションを作成するための引数が足りない. */

/*J 指定したTypeは存在しない. */

/*J 指定したIDは存在しない. */

/*J 指定したオンラインIDのクライアントは存在しない. */

/*J 指定したチケットのサイズが0 */

/*J 指定したオンラインIDで既にクライアントは作成されている. */


/*J 指定した引数のバッファのサイズが足りない. */

/*J 指定したトランザクションタイプが不正. */

/*J 指定したトランザクションは既に完了している */

/*J 指定したトランザクションは完了していない */

/*J 別のトランザクションは行えない */

/*J 構造体のサイズが不正 */

/*J 指定されたNPIDの数が多すぎる */

/*J 指定されたRANGEが長すぎる */

/*J 指定されたuploaderの使用領域が不正 */

/*J 指定されたSLOTIDの数が多すぎる */

/* obsolete (replaced by SCE_NP_COMMUNITY_ERROR_INVALID_ONLINE_ID) */



/* NP Authentication Error (server returned errors) */
# 124 "C:/usr/local/cell\\target\\ppu\\include/np/error.h" 3

/* NP Core Server Error */
# 132 "C:/usr/local/cell\\target\\ppu\\include/np/error.h" 3

/* community server error (0x8002a400 - 0x8002a4ff) */
# 210 "C:/usr/local/cell\\target\\ppu\\include/np/error.h" 3


/* Unspecified Error */



/* NP Core Error */
# 226 "C:/usr/local/cell\\target\\ppu\\include/np/error.h" 3

# 236 "C:/usr/local/cell\\target\\ppu\\include/np/error.h" 3

# 283 "C:/usr/local/cell\\target\\ppu\\include/np/error.h" 3

# 376 "C:/usr/local/cell\\target\\ppu\\include/np/error.h" 3


/* NP Core DNS Error */








/* NP Basic Error */
# 418 "C:/usr/local/cell\\target\\ppu\\include/np/error.h" 3






/* NP Matching Error */
# 476 "C:/usr/local/cell\\target\\ppu\\include/np/error.h" 3

# 492 "C:/usr/local/cell\\target\\ppu\\include/np/error.h" 3

/* NP Signaling Error */
# 518 "C:/usr/local/cell\\target\\ppu\\include/np/error.h" 3
/* obsolete */


/* NP Manager Error */
# 546 "C:/usr/local/cell\\target\\ppu\\include/np/error.h" 3

/* NP Utility Error */
# 564 "C:/usr/local/cell\\target\\ppu\\include/np/error.h" 3

/* NP Friendlist Error */
# 576 "C:/usr/local/cell\\target\\ppu\\include/np/error.h" 3

/* NP Profile Error */
# 588 "C:/usr/local/cell\\target\\ppu\\include/np/error.h" 3

/* NP Commerce Error */
# 621 "C:/usr/local/cell\\target\\ppu\\include/np/error.h" 3

# 632 "C:/usr/local/cell\\target\\ppu\\include/np/error.h" 3

# 642 "C:/usr/local/cell\\target\\ppu\\include/np/error.h" 3

# 651 "C:/usr/local/cell\\target\\ppu\\include/np/error.h" 3

# 659 "C:/usr/local/cell\\target\\ppu\\include/np/error.h" 3

# 667 "C:/usr/local/cell\\target\\ppu\\include/np/error.h" 3

/* NP DRM error */
# 689 "C:/usr/local/cell\\target\\ppu\\include/np/error.h" 3

# 701 "C:/usr/local/cell\\target\\ppu\\include/np/error.h" 3

/* NP Matching2 error */
# 766 "C:/usr/local/cell\\target\\ppu\\include/np/error.h" 3

/* Matching2 Resolver errors */
# 778 "C:/usr/local/cell\\target\\ppu\\include/np/error.h" 3

/* NP Matching2 Server error */
# 827 "C:/usr/local/cell\\target\\ppu\\include/np/error.h" 3

/* Np Clans Error */
# 846 "C:/usr/local/cell\\target\\ppu\\include/np/error.h" 3

/* Np Clans Server Error */
# 883 "C:/usr/local/cell\\target\\ppu\\include/np/error.h" 3

/* NP Commerce2 system utility error (0x80024000 - 0x800240ff) */


/* NP Commerce2 error (0x80023000 - 0x800230ff) */
# 917 "C:/usr/local/cell\\target\\ppu\\include/np/error.h" 3



/* NP Commerce2 server error (0x80023100 - 0x800231ff) */
# 935 "C:/usr/local/cell\\target\\ppu\\include/np/error.h" 3

/* Np Trophy Errors */
# 984 "C:/usr/local/cell\\target\\ppu\\include/np/error.h" 3

/* NP Custom Menu Error */
# 999 "C:/usr/local/cell\\target\\ppu\\include/np/error.h" 3

/*J NP SNS エラー(一般的なエラー) */
/*J 不明なエラー */

/*J NPサインインしていない(sceNpSnsFbStreamPublish()はNPサインイン必要) */

/*J 不正な引数 (意図しないnullポインタなどを渡された) */

/*J メモリ不足 */

/*J ゲームが終了中 */


/*J NP SNS FB エラー(sceNpSnsFb関数の使い方やFacebookの設定状態に関わるエラー) */
/*J 初期済みである (sceNpSnsFbInit()から返ることがある) */

/*J 初期化されてない (sceNpSnsFbTerm()から帰ることがある) */

/*J ハンドルを使用しすぎている */

/*J 不明なハンドル */

/*J アボートされた */

/*J アボート済みの操作を再アボートした */

/*J 設定が無効になっている */

/*J Facebookサーバがエラーを返した */

/*J スロットルが閉じられている */

/*J 操作間隔違反 */

/*J スロットルが未ロード */




/* NP Auth OAuth error */
# 1056 "C:/usr/local/cell\\target\\ppu\\include/np/error.h" 3



# 1069 "C:/usr/local/cell\\target\\ppu\\include/np/error.h" 3



/* for compatibility */



}


# 47 "C:/usr/local/cell\\target\\ppu\\include/np.h" 3

# 53 "C:\\Users\\USER\\Documents\\Visual Studio 2013\\Projects\\mp3_plugin_PS3\\mp3_plugin_PS3\\main.cpp"
# 1 "C:/usr/local/cell\\target\\ppu\\include/net\\if_dl.h" 3
/*   SCE CONFIDENTIAL                                       */
/*   PlayStation(R)3 Programmer Tool Runtime Library 475.001 */
/*   Copyright (C) 2009 Sony Computer Entertainment Inc.    */
/*   All Rights Reserved.                                   */







extern "C" {


struct sockaddr_dl {
	unsigned char sdl_len;
	sa_family_t sdl_family;
	unsigned short sdl_index;
	unsigned char sdl_type;
	unsigned char sdl_nlen;
	unsigned char sdl_alen;
	unsigned char sdl_slen;
	char sdl_data[12];
};


}




# 54 "C:\\Users\\USER\\Documents\\Visual Studio 2013\\Projects\\mp3_plugin_PS3\\mp3_plugin_PS3\\main.cpp"
# 1 "C:/usr/local/cell\\target\\ppu\\include/netdb.h" 3
/*   SCE CONFIDENTIAL                                       */
/*   PlayStation(R)3 Programmer Tool Runtime Library 475.001 */
/*   Copyright (C) 2009 Sony Computer Entertainment Inc.    */
/*   All Rights Reserved.                                   */







extern "C" {


int *_sys_net_h_errno_loc(void);	/* for multi-thread */



struct hostent {
	char *h_name;
	char **h_aliases;
	int h_addrtype;
	int h_length;
	char **h_addr_list;

};

/* error codes of gethostbyname() and gethostbyaddr() */
# 36 "C:/usr/local/cell\\target\\ppu\\include/netdb.h" 3


struct hostent *gethostbyaddr(const char *addr,
	socklen_t len,
	int type);

struct hostent *gethostbyname(const char *name);


}




# 56 "C:\\Users\\USER\\Documents\\Visual Studio 2013\\Projects\\mp3_plugin_PS3\\mp3_plugin_PS3\\main.cpp"
# 1 "C:/usr/local/cell\\target\\ppu\\include/netex/net.h" 3
/*   SCE CONFIDENTIAL                                       */
/*   PlayStation(R)3 Programmer Tool Runtime Library 475.001 */
/*   Copyright (C) 2009 Sony Computer Entertainment Inc.    */
/*   All Rights Reserved.                                   */





extern "C" {


typedef long long sys_net_thread_id_t;

typedef struct sys_net_initialize_parameter {
	void *memory;
	int memory_size;
	int flags;
} sys_net_initialize_parameter_t;

typedef struct sys_net_test_param_ops {
	unsigned short drop_rate;	/* 0-100 % (1%) */
	unsigned short drop_duration;	/* 0-8000 ms (1ms) */
	unsigned short pass_duration;	/* 0-8000 ms (1ms) */
	unsigned short delay_time;	/* 0-8000 ms (1ms) */
	unsigned short delay_jitter;	/* 0-delay_time ms (1ms) */
	unsigned short order_rate;	/* 0-100 % (1%) */
	unsigned short order_delay_time;	/* 0-8000 ms (1ms) */
	unsigned short duplication_rate;	/* 0-100 % (1%) */
	unsigned int bps_limit;	/* 0, 1024-1G bps (1bps) */
	unsigned short lower_size_limit;	/* 0-upper_size_limit bytes */
	unsigned short upper_size_limit;	/* lower_size_limit-1500 */
	unsigned long long policy_pattern;	/* 0-31: game, 32-63: system */
	unsigned short policy_flags[64];	/* each policy */
	unsigned char reserved[64];
} sys_net_test_param_ops_t;	/* sizeof(sys_net_test_param_ops_t) = 224 */

typedef struct sys_net_test_param {
	unsigned short version;	/* specified by user (IN) */
	unsigned short option_number;	/* 0 or 1-n (IN) */
	unsigned short current_version;	/* current version (OUT) */
	unsigned short result;	/* result (OUT) */
	unsigned int flags;	/* (IN) */
	unsigned int reserved2;
	sys_net_test_param_ops_t send;	/* (IN) */
	sys_net_test_param_ops_t recv;	/* (IN) */
	unsigned int seed;
	unsigned char reserved[44];
} sys_net_test_param_t;	/* sizeof(sys_net_test_param_t) = 512 */

# 59 "C:/usr/local/cell\\target\\ppu\\include/netex/net.h" 3

int sys_net_initialize_network_ex(sys_net_initialize_parameter_t *param);
int sys_net_finalize_network(void);

int sys_net_abort_socket(int sockfd, int flags);
int sys_net_abort_resolver(sys_net_thread_id_t tid, int flags);

int sys_net_open_dump(int len, int flags);
int sys_net_read_dump(int id, void *buf, int len, int *pflags);
int sys_net_close_dump(int id, int *pflags);

int sys_net_set_resolver_configurations(int retrans, int retry, int flags);

int sys_net_free_thread_context(sys_net_thread_id_t tid, int flags);

int sys_net_show_ifconfig(void);
int sys_net_show_nameserver(void);
int sys_net_show_route(void);

int sys_net_set_netemu_test_param(sys_net_test_param_t *param);
int sys_net_get_netemu_test_param(sys_net_test_param_t *param);

/* flags for sys_net_initialize_parameter_t */


/* flags for sys_net_abort_{resolver,socket} */


/* flags for sys_net_{open,read,close}_dump */






/* flags for sys_net_free_thread_context */





}




# 57 "C:\\Users\\USER\\Documents\\Visual Studio 2013\\Projects\\mp3_plugin_PS3\\mp3_plugin_PS3\\main.cpp"
# 1 "C:/usr/local/cell\\target\\ppu\\include/netex/errno.h" 3
/*   SCE CONFIDENTIAL                                       */
/*   PlayStation(R)3 Programmer Tool Runtime Library 475.001 */
/*   Copyright (C) 2006 Sony Computer Entertainment Inc.    */
/*   All Rights Reserved.                                   */







extern "C" {


/*
	CELL_ERROR_FACILITY_SYSTEM_SERVICE 0x001
	libnet : 0x8001_0201 - 0x8001_02ff
*/




/* CELL error */
/* ERR: SYS_NET_MAKE_ERROR(0x0201) */

/* ERR: SYS_NET_MAKE_ERROR(0x0202) */

/* ERR: SYS_NET_MAKE_ERROR(0x0203) */

/* ERR: SYS_NET_MAKE_ERROR(0x0204) */

/* ERR: SYS_NET_MAKE_ERROR(0x0205) */

/* ERR: SYS_NET_MAKE_ERROR(0x0206) */

/* ERR: SYS_NET_MAKE_ERROR(0x0207) */

/* ERR: SYS_NET_MAKE_ERROR(0x0208) */

/* ERR: SYS_NET_MAKE_ERROR(0x0209) */

/* ERR: SYS_NET_MAKE_ERROR(0x020a) */

/* ERR: SYS_NET_MAKE_ERROR(0x020b) */

/* ERR: SYS_NET_MAKE_ERROR(0x020c) */

/* ERR: SYS_NET_MAKE_ERROR(0x020d) */

/* ERR: SYS_NET_MAKE_ERROR(0x020e) */

/* ERR: SYS_NET_MAKE_ERROR(0x020f) */

/* ERR: SYS_NET_MAKE_ERROR(0x0210) */

/* ERR: SYS_NET_MAKE_ERROR(0x0211) */

/* ERR: SYS_NET_MAKE_ERROR(0x0212) */

/* ERR: SYS_NET_MAKE_ERROR(0x0213) */

/* ERR: SYS_NET_MAKE_ERROR(0x0214) */

/* ERR: SYS_NET_MAKE_ERROR(0x0215) */

/* ERR: SYS_NET_MAKE_ERROR(0x0216) */

/* ERR: SYS_NET_MAKE_ERROR(0x0217) */

/* ERR: SYS_NET_MAKE_ERROR(0x0218) */

/* ERR: SYS_NET_MAKE_ERROR(0x0219) */

/* ERR: SYS_NET_MAKE_ERROR(0x021a) */

/* ERR: SYS_NET_MAKE_ERROR(0x021b) */

/* ERR: SYS_NET_MAKE_ERROR(0x021c) */

/* ERR: SYS_NET_MAKE_ERROR(0x021d) */

/* ERR: SYS_NET_MAKE_ERROR(0x021e) */

/* ERR: SYS_NET_MAKE_ERROR(0x021f) */

/* ERR: SYS_NET_MAKE_ERROR(0x0220) */

/* ERR: SYS_NET_MAKE_ERROR(0x0221) */

/* ERR: SYS_NET_MAKE_ERROR(0x0222) */

/* ERR: SYS_NET_MAKE_ERROR(0x0223) */


/* ERR: SYS_NET_MAKE_ERROR(0x0224) */

/* ERR: SYS_NET_MAKE_ERROR(0x0225) */

/* ERR: SYS_NET_MAKE_ERROR(0x0226) */

/* ERR: SYS_NET_MAKE_ERROR(0x0227) */

/* ERR: SYS_NET_MAKE_ERROR(0x0228) */

/* ERR: SYS_NET_MAKE_ERROR(0x0229) */

/* ERR: SYS_NET_MAKE_ERROR(0x022a) */

/* ERR: SYS_NET_MAKE_ERROR(0x022b) */

/* ERR: SYS_NET_MAKE_ERROR(0x022c) */

/* ERR: SYS_NET_MAKE_ERROR(0x022d) */

/* ERR: SYS_NET_MAKE_ERROR(0x022e) */

/* ERR: SYS_NET_MAKE_ERROR(0x022f) */

/* ERR: SYS_NET_MAKE_ERROR(0x0230) */

/* ERR: SYS_NET_MAKE_ERROR(0x0231) */

/* ERR: SYS_NET_MAKE_ERROR(0x0232) */

/* ERR: SYS_NET_MAKE_ERROR(0x0233) */

/* ERR: SYS_NET_MAKE_ERROR(0x0234) */

/* ERR: SYS_NET_MAKE_ERROR(0x0235) */

/* ERR: SYS_NET_MAKE_ERROR(0x0236) */

/* ERR: SYS_NET_MAKE_ERROR(0x0237) */

/* ERR: SYS_NET_MAKE_ERROR(0x0238) */

/* ERR: SYS_NET_MAKE_ERROR(0x0239) */

/* ERR: SYS_NET_MAKE_ERROR(0x023a) */

/* ERR: SYS_NET_MAKE_ERROR(0x023b) */

/* ERR: SYS_NET_MAKE_ERROR(0x023c) */

/* ERR: SYS_NET_MAKE_ERROR(0x023d) */

/* ERR: SYS_NET_MAKE_ERROR(0x023e) */

/* ERR: SYS_NET_MAKE_ERROR(0x023f) */

/* ERR: SYS_NET_MAKE_ERROR(0x0240) */

/* ERR: SYS_NET_MAKE_ERROR(0x0241) */

/* ERR: SYS_NET_MAKE_ERROR(0x0242) */

/* ERR: SYS_NET_MAKE_ERROR(0x0243) */

/* ERR: SYS_NET_MAKE_ERROR(0x0244) */

/* ERR: SYS_NET_MAKE_ERROR(0x0245) */

/* ERR: SYS_NET_MAKE_ERROR(0x0246) */

/* ERR: SYS_NET_MAKE_ERROR(0x0247) */

/* ERR: SYS_NET_MAKE_ERROR(0x0248) */

/* ERR: SYS_NET_MAKE_ERROR(0x0249) */

/* ERR: SYS_NET_MAKE_ERROR(0x024a) */

/* ERR: SYS_NET_MAKE_ERROR(0x024b) */

/* ERR: SYS_NET_MAKE_ERROR(0x024c) */

/* ERR: SYS_NET_MAKE_ERROR(0x024d) */

/* ERR: SYS_NET_MAKE_ERROR(0x024e) */

/* ERR: SYS_NET_MAKE_ERROR(0x024f) */

/* ERR: SYS_NET_MAKE_ERROR(0x0250) */

/* ERR: SYS_NET_MAKE_ERROR(0x0251) */

/* ERR: SYS_NET_MAKE_ERROR(0x0252) */

/* ERR: SYS_NET_MAKE_ERROR(0x0253) */

/* ERR: SYS_NET_MAKE_ERROR(0x0254) */

/* ERR: SYS_NET_MAKE_ERROR(0x0255) */

/* ERR: SYS_NET_MAKE_ERROR(0x0256) */

/* ERR: SYS_NET_MAKE_ERROR(0x0257) */

/* ERR: SYS_NET_MAKE_ERROR(0x0258) */

/* ERR: SYS_NET_MAKE_ERROR(0x0259) */

/* ERR: SYS_NET_MAKE_ERROR(0x025a) */

/* ERR: SYS_NET_MAKE_ERROR(0x025b) */

/* ERR: SYS_NET_MAKE_ERROR(0x025c) */


/* sys_net_errno */
# 305 "C:/usr/local/cell\\target\\ppu\\include/netex/errno.h" 3

int *_sys_net_errno_loc(void);




}




# 58 "C:\\Users\\USER\\Documents\\Visual Studio 2013\\Projects\\mp3_plugin_PS3\\mp3_plugin_PS3\\main.cpp"
# 1 "C:/usr/local/cell\\target\\ppu\\include/netex/libnetctl.h" 3
/* SCE CONFIDENTIAL
 PlayStation(R)3 Programmer Tool Runtime Library 475.001
 *
 *      Copyright (C) 2008 Sony Computer Entertainment Inc.
 *                        All Rights Reserved.
 *
 */







/* 0x80130100 - 0x8013011f: libnetctl */

	/* Library module is not initialized. */

	/* Not Terminated */

	/* there is no space for new handler */

	/* specified ID is not found */

	/* specified ID is invalid */

	/* specified code is invalid */

	/* specified addr is invalid */

	/* Not connected */

	/* Not available */

	/* specified type is invalid */

	/* specified size is invalid */

/* 0x80130180 - 0x8013019f: libnetctl NetStart dialog */

	/* Internet Connection is disabled */

	/* does not have IP addr */

	/* do not have NP account */

	/* reserved for internal use */

	/* reserved for internal use */

	/* Ethernet cable is not connected */


	/* dialog is closed by user */

	/* dialog is aborted by API */

/* network error code which comes from libnetctl handler */
/* WLAN error */

	/* Deauthed/Disassociated from AP */

	/* WPA key information exchaning has been timed out */

	/* StatusCode of Association Response means Assoc failed */

	/* Access Point is disappered. */

/* PPPoE error */

	/* Init error. */

	/* Can't get PADO. */

	/* Can't get PADS. */

	/* PADT received. */

	/* Service name error. */

	/* AC system error. */

	/* Generic error. */

	/* Authentication error. */

	/* Network error. */

	/* Terminate error. */

/* DHCP error */

	/* Lease time expired. */


extern "C" {


/* state */





/* event */
# 113 "C:/usr/local/cell\\target\\ppu\\include/netex/libnetctl.h" 3

/* info code */
# 141 "C:/usr/local/cell\\target\\ppu\\include/netex/libnetctl.h" 3

/* device */



/* link_type */
# 154 "C:/usr/local/cell\\target\\ppu\\include/netex/libnetctl.h" 3

/* link */



/* wlan_security */
# 168 "C:/usr/local/cell\\target\\ppu\\include/netex/libnetctl.h" 3

/* 8021x_type */



/* ip_config */




/* http_proxy_config */



/* upnp_config */



# 195 "C:/usr/local/cell\\target\\ppu\\include/netex/libnetctl.h" 3

struct CellNetCtlEtherAddr {
	uint8_t data[6];
	uint8_t padding[2];
};

struct CellNetCtlSSID {
	uint8_t data[32];
	uint8_t term;
	uint8_t padding[3];
};

union CellNetCtlInfo {
	uint32_t device;
	struct CellNetCtlEtherAddr ether_addr;
	uint32_t mtu;
	uint32_t link;
	uint32_t link_type;
	struct CellNetCtlEtherAddr bssid;
	struct CellNetCtlSSID ssid;
	uint32_t wlan_security;
	uint32_t auth_8021x_type;
	char auth_8021x_auth_name[(127 + 1)];
	uint8_t rssi;
	uint8_t channel;
	uint32_t ip_config;
	char dhcp_hostname[(255 + 1)];
	char pppoe_auth_name[(127 + 1)];
	char ip_address[16];
	char netmask[16];
	char default_route[16];
	char primary_dns[16];
	char secondary_dns[16];
	uint32_t http_proxy_config;
	char http_proxy_server[(255 + 1)];
	uint16_t http_proxy_port;
	uint32_t upnp_config;
};

struct CellNetCtlNatInfo {
	size_t size;
	int upnp_status;
	int stun_status;
	int nat_type;
	struct in_addr mapped_addr;
};

/* upnp status */



/* stun staus */



/* nat type */




struct CellNetCtlNetStartDialogParam {
	size_t size;
	int type;
	uint32_t cid;
};
/* type */




struct CellNetCtlNetStartDialogResult {
	size_t size;
	int result;
};

/* status for sysutil callback */




int
cellNetCtlInit(
	void
	);

void
cellNetCtlTerm(
	void
	);

int
cellNetCtlGetInfo(
	int code,
	union CellNetCtlInfo *info
	);

int
cellNetCtlGetState(
	int *state
	);

typedef void (*cellNetCtlHandler)(
		int prev_state,
		int new_state,
		int event,
		int error_code,
		void *arg
		);

int
cellNetCtlAddHandler(
	cellNetCtlHandler handler,
	void *arg,
	int *hid
	);

int
cellNetCtlDelHandler(
	int hid
	);

int
cellNetCtlGetNatInfo(
	struct CellNetCtlNatInfo *natinfo
	);

int
cellNetCtlNetStartDialogLoadAsync(
	const struct CellNetCtlNetStartDialogParam *param
	);

int
cellNetCtlNetStartDialogAbortAsync(
	void
	);

int
cellNetCtlNetStartDialogUnloadAsync(
	struct CellNetCtlNetStartDialogResult *result
	);


}


# 59 "C:\\Users\\USER\\Documents\\Visual Studio 2013\\Projects\\mp3_plugin_PS3\\mp3_plugin_PS3\\main.cpp"
# 1 "C:/usr/local/cell\\target\\ppu\\include/arpa/inet.h" 3
/*   SCE CONFIDENTIAL                                       */
/*   PlayStation(R)3 Programmer Tool Runtime Library 475.001 */
/*   Copyright (C) 2009 Sony Computer Entertainment Inc.    */
/*   All Rights Reserved.                                   */







extern "C" {


in_addr_t inet_addr(const char *cp);
struct in_addr inet_makeaddr(in_addr_t net, in_addr_t lna);
in_addr_t inet_netof(struct in_addr in);
in_addr_t inet_lnaof(struct in_addr in);
in_addr_t inet_network(const char *cp);
char *inet_ntoa(struct in_addr in);
int inet_aton(const char *cp, struct in_addr *addr);
const char *inet_ntop(int af, const void *src, char *dst,
	socklen_t size);
int inet_pton(int af, const char *src, void *dst);


}




# 60 "C:\\Users\\USER\\Documents\\Visual Studio 2013\\Projects\\mp3_plugin_PS3\\mp3_plugin_PS3\\main.cpp"


# 1 "C:\\Users\\USER\\Documents\\Visual Studio 2013\\Projects\\mp3_plugin_PS3\\mp3_plugin_PS3\\enums.h"
enum eInput
{
	INPUT_NEXT_CAMERA,
	INPUT_SPRINT,
	INPUT_JUMP,
	INPUT_ENTER,
	INPUT_ATTACK,
	INPUT_ATTACK2,
	INPUT_AIM,
	INPUT_LOOK_BEHIND,
	INPUT_NEXT_WEAPON,
	INPUT_PREV_WEAPON,
	INPUT_MOVE_LEFT,
	INPUT_MOVE_RIGHT,
	INPUT_MOVE_UP,
	INPUT_MOVE_DOWN,
	INPUT_LOOK_LEFT,
	INPUT_LOOK_RIGHT,
	INPUT_LOOK_UP,
	INPUT_LOOK_DOWN,
	INPUT_DUCK,
	INPUT_PAYNE_KILLER,
	INPUT_TOGGLE_ATTACHMENT,
	INPUT_LETHAL_GRENADE,
	INPUT_PICKUP,
	INPUT_SNIPER_ZOOM_IN,
	INPUT_SNIPER_ZOOM_OUT,
	INPUT_SNIPER_ZOOM_IN_ALTERNATE,
	INPUT_SNIPER_ZOOM_OUT_ALTERNATE,
	INPUT_COVER,
	INPUT_RELOAD,
	INPUT_BULLET_TIME,
	INPUT_ACTION,
	INPUT_DROP_WEAPON,
	INPUT_MELEE_ATTACK_HIGH,
	INPUT_MELEE_ATTACK_MID,
	INPUT_MELEE_ATTACK_LOW,
	INPUT_MELEE_KICK,
	INPUT_MELEE_BLOCK,
	INPUT_MELEE_ATTACK4,
	INPUT_MP_ACTION,
	INPUT_SCOREBOARD,
	INPUT_VEH_MOVE_LEFT,
	INPUT_VEH_MOVE_RIGHT,
	INPUT_VEH_MOVE_UP,
	INPUT_VEH_MOVE_DOWN,
	INPUT_VEH_GUN_LEFT,
	INPUT_VEH_GUN_RIGHT,
	INPUT_VEH_GUN_UP,
	INPUT_VEH_GUN_DOWN,
	INPUT_VEH_ATTACK,
	INPUT_VEH_ATTACK2,
	INPUT_VEH_ACCELERATE,
	INPUT_VEH_BRAKE,
	INPUT_VEH_HEADLIGHT,
	INPUT_VEH_EXIT,
	INPUT_VEH_HANDBRAKE,
	INPUT_VEH_HANDBRAKE_ALT,
	INPUT_VEH_HOTWIRE_LEFT,
	INPUT_VEH_HOTWIRE_RIGHT,
	INPUT_VEH_LOOK_LEFT,
	INPUT_VEH_LOOK_RIGHT,
	INPUT_VEH_LOOK_BEHIND,
	INPUT_VEH_CIN_CAM,
	INPUT_VEH_NEXT_RADIO,
	INPUT_VEH_PREV_RADIO,
	INPUT_VEH_HORN,
	INPUT_VEH_FLY_THROTTLE_UP,
	INPUT_VEH_FLY_THROTTLE_DOWN,
	INPUT_VEH_FLY_YAW_LEFT,
	INPUT_VEH_FLY_YAW_RIGHT,
	INPUT_FRONTEND_DOWN,
	INPUT_FRONTEND_UP,
	INPUT_FRONTEND_LEFT,
	INPUT_FRONTEND_RIGHT,
	INPUT_FRONTEND_RDOWN,
	INPUT_FRONTEND_RUP,
	INPUT_FRONTEND_RLEFT,
	INPUT_FRONTEND_RRIGHT,
	INPUT_FRONTEND_AXIS_X,
	INPUT_FRONTEND_AXIS_Y,
	INPUT_FRONTEND_RIGHT_AXIS_X,
	INPUT_FRONTEND_RIGHT_AXIS_Y,
	INPUT_FRONTEND_PAUSE,
	INPUT_FRONTEND_ACCEPT,
	INPUT_FRONTEND_CANCEL,
	INPUT_FRONTEND_X,
	INPUT_FRONTEND_Y,
	INPUT_FRONTEND_LB,
	INPUT_FRONTEND_RB,
	INPUT_FRONTEND_LT,
	INPUT_FRONTEND_RT,
	INPUT_FRONTEND_LAUNCHGAME,
	INPUT_FRONTEND_ATTRACT,
	INPUT_FRONTEND_SOCIALCLUB,
	INPUT_FRONTEND_VENDETTA,
	INPUT_FRONTEND_RESPAWN,
	INPUT_FRONTEND_SUICIDE,
	INPUT_FRONTEND_SELECT,
	INPUT_BCAMERA_SLOW,
	INPUT_FRONTEND_WAGER,
	INPUT_FRONTEND_HIDETUTORIAL,
	INPUT_TEXTCHAT_ALL,
	INPUT_TEXTCHAT_TEAM,
	INPUT_FRONTEND_PUSHTOTALK,
	INPUT_MOUSE_UD,
	INPUT_MOUSE_LR,
	INPUT_MOUSE_WHEEL_UP,
	INPUT_MOUSE_WHEEL_DOWN,
	INPUT_WEAPON_LEFT,
	INPUT_WEAPON_RIGHT,
	INPUT_WEAPON_DUAL,
	INPUT_WEAPON_TWOHAND,
	INPUT_VAULT,
	INPUT_ROLLDODGE,
	INPUT_QUICKTHROW,
	INPUT_BCAMERA_SKIP,
	INPUT_WEAPON_GRENADE,
	NUM_EINPUT
};

enum eHudColor
{
	HUD_COLOUR_PURE_WHITE,
	HUD_COLOUR_WHITE,
	HUD_COLOUR_BLACK,
	HUD_COLOUR_GREY,
	HUD_COLOUR_RED,
	HUD_COLOUR_REDLIGHT,
	HUD_COLOUR_REDDARK,
	HUD_COLOUR_BLUE,
	HUD_COLOUR_BLUELIGHT,
	HUD_COLOUR_BLUEDARK,
	HUD_COLOUR_YELLOW,
	HUD_COLOUR_YELLOWLIGHT,
	HUD_COLOUR_YELLOWDARK,
	HUD_COLOUR_ORANGE,
	HUD_COLOUR_ORANGELIGHT,
	HUD_COLOUR_ORANGEDARK,
	HUD_COLOUR_GREEN,
	HUD_COLOUR_GREENLIGHT,
	HUD_COLOUR_GREENDARK,
	HUD_COLOUR_PURPLE,
	HUD_COLOUR_PURPLELIGHT,
	HUD_COLOUR_PURPLEDARK,
	HUD_COLOUR_PINK,
	HUD_COLOUR_RADAR_HEALTH,
	HUD_COLOUR_RADAR_ARMOUR,
	HUD_COLOUR_RADAR_DAMAGE,
	HUD_COLOUR_NET_PLAYER1,
	HUD_COLOUR_NET_PLAYER2,
	HUD_COLOUR_NET_PLAYER3,
	HUD_COLOUR_NET_PLAYER4,
	HUD_COLOUR_NET_PLAYER5,
	HUD_COLOUR_NET_PLAYER6,
	HUD_COLOUR_NET_PLAYER7,
	HUD_COLOUR_NET_PLAYER8,
	HUD_COLOUR_NET_PLAYER9,
	HUD_COLOUR_NET_PLAYER10,
	HUD_COLOUR_NET_PLAYER11,
	HUD_COLOUR_NET_PLAYER12,
	HUD_COLOUR_NET_PLAYER13,
	HUD_COLOUR_NET_PLAYER14,
	HUD_COLOUR_NET_PLAYER15,
	HUD_COLOUR_NET_PLAYER16,
	HUD_COLOUR_SIMPLEBLIP_DEFAULT,
	HUD_COLOUR_MENU_BLUE,
	HUD_COLOUR_MENU_GREY_LIGHT,
	HUD_COLOUR_MENU_BLUE_EXTRA_DARK,
	HUD_COLOUR_MENU_YELLOW,
	HUD_COLOUR_MENU_YELLOW_DARK,
	HUD_COLOUR_MENU_GREEN,
	HUD_COLOUR_MENU_GREY,
	HUD_COLOUR_MENU_GREY_DARK,
	HUD_COLOUR_MENU_HIGHLIGHT,
	HUD_COLOUR_MENU_STANDARD,
	HUD_COLOUR_MENU_DIMMED,
	HUD_COLOUR_MENU_EXTRA_DIMMED,
	HUD_COLOUR_BRIEF_TITLE,
	HUD_COLOUR_MID_GREY_MP,
	HUD_COLOUR_INTERNAL_GREY
};

enum eFontStyle
{
	FONT_GOTHAM,
	FONT_FUTURA_BOLD,
	FONT_TRADE_GOTHIC,
	FONT_PRISON_PRESS,
	FONT_SLATE_ITALIC,
	FONT_CLAN_TAG,
	FONT_FUTURA_SMALL,
	FONT_ITALIC_SMALL,
	FONT_EXTRA1,
	FONT_EXTRA2
};

enum eExplosionTag
{
	EXP_TAG_DONTCARE = -1,
	EXP_TAG_GRENADE,
	EXP_TAG_MOLOTOV,
	EXP_TAG_ROCKET,
	EXP_TAG_HI_OCTANE,
	EXP_TAG_CAR,
	EXP_TAG_PLANE,
	EXP_TAG_PETROL_PUMP,
	EXP_TAG_BIKE,
	EXP_TAG_DIR_STEAM,
	EXP_TAG_DIR_FLAME,
	EXP_TAG_DIR_WATER_HYDRANT,
	EXP_TAG_DIR_GAS_CANISTER,
	EXP_TAG_BOAT,
	EXP_TAG_SHIP_DESTROY,
	EXP_TAG_FIRE_EXTINGUISHER,
	EXP_TAG_PHANTOM_FORCE,
	EXP_TAG_TRUCK,
	EXP_TAG_SMOKE_GRENADE,
	EXP_TAG_TEAR_GAS_GRENADE,
	EXP_TAG_FLASH_GRENADE,
	EXP_TAG_GRENADE_SMALL,
	EXP_TAG_JERRY_CAN,
	EXP_TAG_CHAMPAGNE,
	EXP_TAG_HE_AMMO,
	EXP_TAG_LAUNCHER_ROTARY,
	EXP_TAG_LAUNCHER_G,
	EXP_TAG_BOOBY_TRAP,
	EXP_TAG_EPISODIC_1,
	EXP_TAG_EPISODIC_2,
	EXP_TAG_EPISODIC_3,
	EXP_TAG_EPISODIC_4,
	EXP_TAG_EPISODIC_5,
	EXP_TAG_EPISODIC_6,
	EXP_TAG_EPISODIC_7,
	EXP_TAG_EPISODIC_8,
	EXP_TAG_EPISODIC_9,
	EXP_TAG_EPISODIC_10,
	EXP_TAG_SMOKE_GRENADE_INF,
	EXP_TAG_TEAR_GAS_GRENADE_INF,
	EXP_TAG_ROCKET_LAW,
	NUM_EEXPLOSIONTAG
};

// incomplete
enum eGameKey
{
	GameKey_F4 = 62,
	GameKey_F5 = 63,
	GameKey_F6 = 64,
	GameKey_Backspace = 56,
	GameKey_ESC = 1,
	GameKey_Spacebar = 57,
	GameKey_Numpad8 = 72,
	GameKey_Numpad4 = 75,
	GameKey_Numpad5 = 76,
	GameKey_Numpad6 = 77,
	GameKey_Numpad2 = 80,
	GameKey_Numpad0 = 82,
	GameKey_W = 17,
	GameKey_A = 30,
	GameKey_S = 31,
	GameKey_D = 32,
	GameKey_F = 33,
	GameKey_G = 34,
	GameKey_H = 35,
	GameKey_J = 36
};

enum eWeaponHash
{
	VEHICLE_WEAPON_CAVEIRAO_GUN = 0xB65738AB,
	VEHICLE_WEAPON_CAVEIRAO_VAR_GUN = 0x304117CA,
	VEHICLE_WEAPON_DUNE = 0x3AD4DB0C,
	VEHICLE_WEAPON_HIND_GUN = 0x0B949C08,
	VEHICLE_WEAPON_HIND_ROCKET = 0x723A51FD,
	VEHICLE_WEAPON_TANK = 0x73F7C04B,
	WEAPON_AMMO_BAG = 0x7C93B3E8,
	WEAPON_BEANBAG_LAUNCHER = 0x09B0AD0E,
	WEAPON_BLEEDOUT = 0xDF196FAB,
	WEAPON_BOOBYTRAP = 0x34D69CE0,
	WEAPON_C4 = 0xC17121D1,
	WEAPON_C4_DETONATOR = 0x6EE35348,
	WEAPON_CATTLE_PROD = 0xAB0E51CB,
	WEAPON_CRUSH = 0xFAA1EFE1,
	WEAPON_DROWNING = 0xFF58C4FB,
	WEAPON_DROWNING_IN_VEHICLE = 0x736F5990,
	WEAPON_EXPLOSION = 0x2024F4E8,
	WEAPON_FALL = 0xCDC174B0,
	WEAPON_GRENADE_LAUNCHER = 0x9D1D9087,
	WEAPON_GRENADE_LAUNCHER_BECKER = 0x376F53CF,
	WEAPON_GRENADE_LAUNCHER_FINALE = 0x3469116F,
	WEAPON_GRENADE_LAUNCHER_G9 = 0xBCDFAD96,
	WEAPON_HIT_BY_WATER_CANNON = 0xCC34325E,
	WEAPON_LAW = 0x16821557,
	WEAPON_MG_21E = 0x130E6DFC,
	WEAPON_MG_RPD = 0xF964263C,
	WEAPON_MONEY_BAG = 0xE8CE6938,
	WEAPON_MP_BAG = 0x6FCCD38B,
	WEAPON_NIGHT_STICK = 0xAE2805B3,
	WEAPON_PEPPER_SPRAY = 0xE937867A,
	WEAPON_PISTOL_38 = 0x183AA38D,
	WEAPON_PISTOL_BROWNING = 0x3FC7AB50,
	WEAPON_PISTOL_BROWNING_SILENCED = 0x983108FA,
	WEAPON_PISTOL_COLT1911 = 0xCC9B512F,
	WEAPON_PISTOL_DEAGLE = 0x1B38D183,
	WEAPON_PISTOL_GLOCK18 = 0xA8AF8476,
	WEAPON_PISTOL_PT92 = 0x040DE373,
	WEAPON_PISTOL_PT92_BOTTLE = 0x30630AFA,
	WEAPON_PISTOL_TAURUS608 = 0xDB7A2147,
	WEAPON_RAMMED_BY_CAR = 0x07FC7D7A,
	WEAPON_RIFLE_97LC = 0xC393F0CC,
	WEAPON_RIFLE_AK47 = 0xBFF084B9,
	WEAPON_RIFLE_AK47_UNDERBARREL_GRENADE = 0x72FA1AFF,
	WEAPON_RIFLE_FAL = 0x4DFE88CD,
	WEAPON_RIFLE_FAL_RUBBER = 0x321B9F40,
	WEAPON_RIFLE_G36K = 0x036DE6A2,
	WEAPON_RIFLE_GALIL = 0x637285D0,
	WEAPON_RIFLE_IA2 = 0x191BD85A,
	WEAPON_RIFLE_L1A1 = 0x955D6BCE,
	WEAPON_RIFLE_L1A1_GRENADE = 0xCB6868CC,
	WEAPON_RIFLE_M4 = 0x3DF2B633,
	WEAPON_RIFLE_RUG30 = 0x2B351E15,
	WEAPON_RIFLE_RUG30_HELI = 0x151DD2A7,
	WEAPON_RIFLE_TAR = 0xEF71421B,
	WEAPON_RIOT_SHIELD = 0xBE5ADF7C,
	WEAPON_RPG = 0xB1CA77B1,
	WEAPON_RUN_OVER_BY_CAR = 0xA36D413E,
	WEAPON_SHOTGUN = 0xC7C74268,
	WEAPON_SHOTGUN_BENELLIM3 = 0x19E69EBD,
	WEAPON_SHOTGUN_DOUBLEBARREL = 0x6DFA071B,
	WEAPON_SHOTGUN_HAMMERHEAD = 0x3A48FFC7,
	WEAPON_SHOTGUN_MOSSBERG590 = 0xF5F785A7,
	WEAPON_SHOTGUN_SPAS12 = 0xE4385D4E,
	WEAPON_SHOTGUN_SPAS15 = 0xF4F9FED1,
	WEAPON_SHOTGUN_WINCHESTERSX3 = 0x1EA4D45D,
	WEAPON_SMG_FAMAEMT40 = 0x75146205,
	WEAPON_SMG_MAC10 = 0xD6CA055B,
	WEAPON_SMG_MP5 = 0x5818A173,
	WEAPON_SMG_MP5_UNDERBARREL_GRENADE = 0x0AAFC6C1,
	WEAPON_SMG_PM12 = 0xAC4A0D35,
	WEAPON_SMG_SKORPION = 0x11D207F8,
	WEAPON_SMG_UZI = 0x4731AEA4,
	WEAPON_SNIPER_ENFORCER = 0x404F1B1F,
	WEAPON_SNIPER_M24 = 0x5D1319A8,
	WEAPON_SNIPER_M82 = 0x48F8EAEC,
	WEAPON_SNIPER_SG1 = 0x00A27A53,
	WEAPON_SPEARGUN = 0x45546DDC,
	WEAPON_STINGER = 0x687652CE,
	WEAPON_STUN_GUN = 0x73C97D3E,
	WEAPON_TASER = 0xCF161C27,
	WEAPON_THROWN_BOUNCING_BETTY = 0x7F689A91,
	WEAPON_THROWN_FLASH = 0xB5028882,
	WEAPON_THROWN_GRENADE = 0xE973717C,
	WEAPON_THROWN_GRENADE_SCRIPT = 0x89FA998C,
	WEAPON_THROWN_GRENADE_SMALL = 0xADDAB164,
	WEAPON_THROWN_INCENDIARY = 0x5C231F7E,
	WEAPON_THROWN_INCENDIARY_FAST = 0x2BD4C4B3,
	WEAPON_THROWN_INCENDIARY_MP = 0x169E41B2,
	WEAPON_THROWN_SMOKE = 0x89957454,
	WEAPON_THROWN_TEAR_GAS = 0x9EE23BF3,
	WEAPON_THROWN_TEAR_GAS_INF = 0xF5886E06,
	WEAPON_THROWN_TIN_CAN = 0x8726D0D5,
	WEAPON_THROWN_TRIPWIRE = 0xF9577253,
	WEAPON_TRAM_TEAR_GAS = 0xAA29BB37,
	WEAPON_UNARMED = 0xA2719263,
	WEAPON_XMG_21E = 0x1976AC16,
	WEAPON_XPISTOL_DUMMY = 0x08F91428,
	WEAPON_XRIFLE_97LC = 0x76CA3168,
	WEAPON_XRIFLE_RUG30 = 0x957A0FCC,
	WEAPON_XRPG = 0x3BB059C6,
	WEAPON_XSMG_MAC10 = 0x43787C65,
	WEAPON_XSMG_PM12 = 0xFB6E25BB,
	WEAPON_XSNIPER_DUMMY = 0x844C25A9
};

enum eWeaponGuntype
{
	GUNTYPE_UNKNOWN = -1,
	GUNTYPE_PISTOL,
	GUNTYPE_RIFLE,
	GUNTYPE_SNIPER,
	GUNTYPE_SHOTGUN,
	GUNTYPE_MACHINEGUN,
	GUNTYPE_ROCKET,
	GUNTYPE_DLC_1,
	GUNTYPE_DLC_2,
	GUNTYPE_DLC_3,
	GUNTYPE_DLC_4,
	GUNTYPE_DLC_5,
	NUM_EWEAPONGUNTYPE
};

enum eWeaponAttachmentType
{
	WEAPON_ATTACHMENT_CLIP,
	WEAPON_ATTACHMENT_TRIGGER,
	WEAPON_ATTACHMENT_HAMMER,
	WEAPON_ATTACHMENT_DIAL,
	WEAPON_ATTACHMENT_SLIDE,
	WEAPON_ATTACHMENT_FIRE_MODE_SELECTOR,
	WEAPON_ATTACHMENT_HIGH_CAPACITY_CLIP,
	WEAPON_ATTACHMENT_GRENADE_PIN,
	WEAPON_ATTACHMENT_SUPPRESSOR,
	WEAPON_ATTACHMENT_COMPENSATOR,
	WEAPON_ATTACHMENT_BIPOD,
	WEAPON_ATTACHMENT_SNIPER_SCOPE,
	WEAPON_ATTACHMENT_RED_DOT_SCOPE,
	WEAPON_ATTACHMENT_LASER_SIGHT,
	WEAPON_ATTACHMENT_FLASHLIGHT,
	WEAPON_ATTACHMENT_SECONDARY_MODE,
	WEAPON_ATTACHMENT_HE_AMMO,
	WEAPON_ATTACHMENT_AP_AMMO,
	WEAPON_ATTACHMENT_FLECHETTE_AMMO,
	WEAPON_ATTACHMENT_INCENDIARY_AMMO,
	WEAPON_ATTACHMENT_GAS_BLOCK,
	WEAPON_ATTACHMENT_GAS_SYSTEMS,
	WEAPON_ATTACHMENT_BARREL_UPGRADES,
	WEAPON_ATTACHMENT_MAG_GUIDE,
	WEAPON_ATTACHMENT_GOLD,
	WEAPON_ATTACHMENT_CHROME,
	NUM_EWEAPONATTACHMENTTYPE
};

enum eFiringPattern
{
	FIRING_PATTERN_BURST_FIRE = 0xD6FF6D61,
	FIRING_PATTERN_CAV_BURST_LONG_DELAY = 0x068A43EC,
	FIRING_PATTERN_CAV_BURST_MEDIUM_DELAY = 0x0C45E645,
	FIRING_PATTERN_CAV_BURST_SHORT_DELAY = 0x3570643F,
	FIRING_PATTERN_CAV_RANDOM_LONG_DELAY = 0xF09207CF,
	FIRING_PATTERN_CAV_RANDOM_MEDIUM_DELAY = 0xB481D183,
	FIRING_PATTERN_CAV_RANDOM_SHORT_DELAY = 0x72CEF834,
	FIRING_PATTERN_CAV_STEADY_COUPLE = 0xBAF4A766,
	FIRING_PATTERN_CAV_STEADY_FEW = 0xB5D82462,
	FIRING_PATTERN_CAV_STEADY_SINGLE = 0x96F345B0,
	FIRING_PATTERN_DELAY_FIRE_BY_ONE_SEC = 0x7A845691,
	FIRING_PATTERN_DOUBLE_TAP = 0x55B52C8F,
	FIRING_PATTERN_FULL_AUTO = 0xC6EE6B4C,
	FIRING_PATTERN_GRENADE_LAUNCHER_HIGH = 0x6FA25AC2,
	FIRING_PATTERN_GRENADE_LAUNCHER_LOW = 0x526939C0,
	FIRING_PATTERN_GRENADE_LAUNCHER_MEDIUM = 0x90C25741,
	FIRING_PATTERN_NONE = 0xC7DE6F6C,
	FIRING_PATTERN_ONE_BURST = 0xC1C586D2,
	FIRING_PATTERN_PISTOL_COVER = 0xD3AAFC91,
	FIRING_PATTERN_PISTOL_GLOCK18_COVER = 0x6B821B73,
	FIRING_PATTERN_PISTOL_GLOCK18_HIGH = 0xA7604890,
	FIRING_PATTERN_PISTOL_GLOCK18_LOW = 0x09B0F0C5,
	FIRING_PATTERN_PISTOL_GLOCK18_MEDIUM = 0x76A77708,
	FIRING_PATTERN_PISTOL_GLOCK18_SUPPRESS = 0x3B7B5916,
	FIRING_PATTERN_PISTOL_GLOCK18_UNLOAD = 0x4F63AFB0,
	FIRING_PATTERN_PISTOL_HEAVY_COVER = 0x887E5B47,
	FIRING_PATTERN_PISTOL_HEAVY_HIGH = 0x83058007,
	FIRING_PATTERN_PISTOL_HEAVY_LOW = 0x00F9EB1D,
	FIRING_PATTERN_PISTOL_HEAVY_MEDIUM = 0x0F5AED39,
	FIRING_PATTERN_PISTOL_HEAVY_SUPPRESS = 0x00566724,
	FIRING_PATTERN_PISTOL_HEAVY_UNLOAD = 0xC5F5ED60,
	FIRING_PATTERN_PISTOL_HIGH = 0xABDF3EF4,
	FIRING_PATTERN_PISTOL_LOW = 0xA7BC38D9,
	FIRING_PATTERN_PISTOL_MEDIUM = 0x3C02AAB1,
	FIRING_PATTERN_PISTOL_SUPPRESS = 0x3AFDAFAF,
	FIRING_PATTERN_PISTOL_UNLOAD = 0x67068AA9,
	FIRING_PATTERN_RIFLE_AK47_COVER = 0xCEE2959D,
	FIRING_PATTERN_RIFLE_AK47_HIGH = 0x25F554C3,
	FIRING_PATTERN_RIFLE_AK47_LOW = 0xBB78D00E,
	FIRING_PATTERN_RIFLE_AK47_MEDIUM = 0xD797CCB5,
	FIRING_PATTERN_RIFLE_AK47_SUPPRESS = 0xFBF76C40,
	FIRING_PATTERN_RIFLE_AK47_UNLOAD = 0x677CB69E,
	FIRING_PATTERN_RIFLE_COVER = 0x96BFE07D,
	FIRING_PATTERN_RIFLE_FAL_COVER = 0x64977D79,
	FIRING_PATTERN_RIFLE_FAL_HIGH = 0xD6C9BB8C,
	FIRING_PATTERN_RIFLE_FAL_LOW = 0xB33B2434,
	FIRING_PATTERN_RIFLE_FAL_MEDIUM = 0x363BDDC8,
	FIRING_PATTERN_RIFLE_FAL_SUPPRESS = 0xA8F89029,
	FIRING_PATTERN_RIFLE_FAL_UNLOAD = 0x4FC88FA6,
	FIRING_PATTERN_RIFLE_G36K_COVER = 0x3828CE33,
	FIRING_PATTERN_RIFLE_G36K_HIGH = 0x20F8B82B,
	FIRING_PATTERN_RIFLE_G36K_LOW = 0xBFAA1B15,
	FIRING_PATTERN_RIFLE_G36K_MEDIUM = 0x0E415DE5,
	FIRING_PATTERN_RIFLE_G36K_SUPPRESS = 0x1508F085,
	FIRING_PATTERN_RIFLE_G36K_UNLOAD = 0x23D0D855,
	FIRING_PATTERN_RIFLE_HIGH = 0x5061B8BE,
	FIRING_PATTERN_RIFLE_LOW = 0xF4B8A25F,
	FIRING_PATTERN_RIFLE_MEDIUM = 0x076DCCC2,
	FIRING_PATTERN_RIFLE_MG_21E_COVER = 0x98462B59,
	FIRING_PATTERN_RIFLE_MG_21E_HIGH = 0x44F2C297,
	FIRING_PATTERN_RIFLE_MG_21E_LOW = 0x5020D5FE,
	FIRING_PATTERN_RIFLE_MG_21E_MEDIUM = 0x656B46AC,
	FIRING_PATTERN_RIFLE_MG_21E_SUPPRESS = 0x627B0871,
	FIRING_PATTERN_RIFLE_MG_21E_UNLOAD = 0xB69EA381,
	FIRING_PATTERN_RIFLE_RUG30_COVER = 0xE6F7AC04,
	FIRING_PATTERN_RIFLE_RUG30_HIGH = 0x0AC80960,
	FIRING_PATTERN_RIFLE_RUG30_LOW = 0xA6C2FE8A,
	FIRING_PATTERN_RIFLE_RUG30_MEDIUM = 0x1C8E17CA,
	FIRING_PATTERN_RIFLE_RUG30_SUPPRESS = 0xE1562C61,
	FIRING_PATTERN_RIFLE_RUG30_UNLOAD = 0x1F9F3753,
	FIRING_PATTERN_RIFLE_SUPPRESS = 0x27F4CD3A,
	FIRING_PATTERN_RIFLE_UNLOAD = 0xDA9A4C36,
	FIRING_PATTERN_SCRIPT_HIGH = 0xF0B711FF,
	FIRING_PATTERN_SCRIPT_LOW = 0xE17EB299,
	FIRING_PATTERN_SCRIPT_MEDIUM = 0x73094D94,
	FIRING_PATTERN_SEMI_AUTO = 0xE7B10400,
	FIRING_PATTERN_SHOTGUN = 0xAB96C0D0,
	FIRING_PATTERN_SHOTGUN_BENELLIM3_COVER = 0x3E5797ED,
	FIRING_PATTERN_SHOTGUN_BENELLIM3_HIGH = 0xD8C33ABF,
	FIRING_PATTERN_SHOTGUN_BENELLIM3_LOW = 0xE1B27500,
	FIRING_PATTERN_SHOTGUN_BENELLIM3_MEDIUM = 0xB55C9460,
	FIRING_PATTERN_SHOTGUN_BENELLIM3_SUPPRESS = 0xBF3CF934,
	FIRING_PATTERN_SHOTGUN_BENELLIM3_UNLOAD = 0x807D939A,
	FIRING_PATTERN_SHOTGUN_COVER = 0xC11604F5,
	FIRING_PATTERN_SHOTGUN_DOUBLEBARREL_COVER = 0xA9A6EA49,
	FIRING_PATTERN_SHOTGUN_DOUBLEBARREL_HIGH = 0x9DE310C8,
	FIRING_PATTERN_SHOTGUN_DOUBLEBARREL_LOW = 0x2FB4233A,
	FIRING_PATTERN_SHOTGUN_DOUBLEBARREL_MEDIUM = 0x2EDCDB7A,
	FIRING_PATTERN_SHOTGUN_DOUBLEBARREL_SUPPRESS = 0xB3ABEFAA,
	FIRING_PATTERN_SHOTGUN_DOUBLEBARREL_UNLOAD = 0x7F1DC7C2,
	FIRING_PATTERN_SHOTGUN_HIGH = 0x8D243AB0,
	FIRING_PATTERN_SHOTGUN_LOW = 0x05A72BFA,
	FIRING_PATTERN_SHOTGUN_MEDIUM = 0x9F498AA8,
	FIRING_PATTERN_SHOTGUN_SPAS15_COVER = 0xE3F3C0F3,
	FIRING_PATTERN_SHOTGUN_SPAS15_HIGH = 0xF75CF4D7,
	FIRING_PATTERN_SHOTGUN_SPAS15_LOW = 0x1321B1C1,
	FIRING_PATTERN_SHOTGUN_SPAS15_MEDIUM = 0x64E3AF1C,
	FIRING_PATTERN_SHOTGUN_SPAS15_SUPPRESS = 0x26347969,
	FIRING_PATTERN_SHOTGUN_SPAS15_UNLOAD = 0xA4E2AE6D,
	FIRING_PATTERN_SHOTGUN_SUPPRESS = 0x4D9739FD,
	FIRING_PATTERN_SHOTGUN_UNLOAD = 0x3E7D58B7,
	FIRING_PATTERN_SHOTGUN_WINCHESTERSX3_COVER = 0xF94879EC,
	FIRING_PATTERN_SHOTGUN_WINCHESTERSX3_HIGH = 0xE58F8171,
	FIRING_PATTERN_SHOTGUN_WINCHESTERSX3_LOW = 0x92069FF3,
	FIRING_PATTERN_SHOTGUN_WINCHESTERSX3_MEDIUM = 0x81D4C3EC,
	FIRING_PATTERN_SHOTGUN_WINCHESTERSX3_SUPPRESS = 0x07E3003C,
	FIRING_PATTERN_SHOTGUN_WINCHESTERSX3_UNLOAD = 0xCBD01043,
	FIRING_PATTERN_SINGLE_SHOT = 0x5D60E4E0,
	FIRING_PATTERN_SMG_COVER = 0x37C20B16,
	FIRING_PATTERN_SMG_HIGH = 0xF96FBEED,
	FIRING_PATTERN_SMG_LOW = 0x911E4FA5,
	FIRING_PATTERN_SMG_MEDIUM = 0x024ED4C1,
	FIRING_PATTERN_SMG_SUPPRESS = 0xE68186E6,
	FIRING_PATTERN_SMG_UNLOAD = 0xB0D7D985,
	FIRING_PATTERN_SNIPER = 0x3899A833,
	FIRING_PATTERN_SNIPER_COVER = 0xAB84D669,
	FIRING_PATTERN_SNIPER_HIGH = 0x0BEE5307,
	FIRING_PATTERN_SNIPER_LOW = 0x4A360CE0,
	FIRING_PATTERN_SNIPER_MEDIUM = 0xAB5C1EA9,
	FIRING_PATTERN_SNIPER_SUPPRESS = 0xAEE88289,
	FIRING_PATTERN_SNIPER_UNLOAD = 0xF13D4210,
	FIRING_PATTERN_THREE_ROUND_BURST = 0xA51FC9CF
};

enum ePedComponent
{
	PED_COMPONENT_HEAD,
	PED_COMPONENT_HAIR,
	PED_COMPONENT_UPPR,
	PED_COMPONENT_LOWR,
	PED_COMPONENT_SUSE,
	PED_COMPONENT_HAND,
	PED_COMPONENT_FEET,
	PED_COMPONENT_JACK,
	PED_COMPONENT_SUS2,
	PED_COMPONENT_TEEF,
	PED_COMPONENT_ACCS,
	PED_COMPONENT_TASK,
	PED_COMPONENT_DECL,
	NUM_EPEDCOMPONENT
};

enum ePedProp
{
	PED_PROP_HEAD,
	PED_PROP_HELM,
	PED_PROP_EYES,
	PED_PROP_EARS,
	PED_PROP_MOUTH,
	PED_PROP_LHAND,
	PED_PROP_RHAND,
	PED_PROP_LWRIST,
	PED_PROP_RWRIST,
	PED_PROP_HIP,
	PED_PROP_LFOOT,
	PED_PROP_RFOOT,
	PED_PROP_LPROP,
	PED_PROP_RPROP,
	PED_PROP_LFINGER,
	PED_PROP_RFINGER,
	NUM_EPEDPROP
};

enum ePedBone
{
	ROOT = 0x0000,
	PELVIS = 0xC018,
	SPINE = 0x3A8D,
	SPINE1 = 0x0C9B,
	SPINE2 = 0x0C9C,
	SPINE3 = 0x0C9D,
	NECK = 0xE168,
	HEAD = 0xFFD0,
	NECKROLL = 0xFFFF,
	R_CLAVICLE = 0xA1AD,
	R_UPPERARM = 0xA9A0,
	R_FOREARM = 0x3CC6,
	R_HAND = 0x34BE,
	R_FINGER0 = 0xD714,
	R_FINGER01 = 0x4663,
	R_FINGER02 = 0x4664,
	R_FINGER1 = 0xD715,
	R_FINGER11 = 0x4633,
	R_FINGER12 = 0x4634,
	R_FINGER2 = 0xD716,
	R_FINGER21 = 0x4643,
	R_FINGER22 = 0x4644,
	R_FINGER3 = 0xD717,
	R_FINGER31 = 0x4613,
	R_FINGER32 = 0x4614,
	R_FINGER4 = 0xD718,
	R_FINGER41 = 0x4623,
	R_FINGER42 = 0x4624,
	R_FORETWIST = 0x2AF6,
	R_FORETWIST1 = 0x2AF7,
	R_UPPPERARMROLL = 0x5D07,
	R_ARMROLL = 0xA4F7,
	L_CLAVICLE = 0xC1AD,
	L_UPPERARM = 0x89A0,
	L_FOREARM = 0x3AC6,
	L_HAND = 0x62DE,
	L_FINGER0 = 0xD514,
	L_FINGER01 = 0x2663,
	L_FINGER02 = 0x2664,
	L_FINGER1 = 0xD515,
	L_FINGER11 = 0x2633,
	L_FINGER12 = 0x2634,
	L_FINGER2 = 0xD516,
	L_FINGER21 = 0x2643,
	L_FINGER22 = 0x2644,
	L_FINGER3 = 0xD517,
	L_FINGER31 = 0x2613,
	L_FINGER32 = 0x2614,
	L_FINGER4 = 0xD518,
	L_FINGER41 = 0x2623,
	L_FINGER42 = 0x2624,
	L_FORETWIST = 0x5916,
	L_FORETWIST1 = 0x5917,
	L_UPPPERARMROLL = 0x5C67,
	L_ARMROLL = 0x9AF7,
	L_THIGH = 0xA555,
	L_CALF = 0x1431,
	L_FOOT = 0xD4FE,
	L_TOE = 0xB1C9,
	L_CALFROLL = 0xCAE3,
	R_THIGH = 0xBF02,
	R_CALF = 0xE4A0,
	R_FOOT = 0xA6DE,
	R_TOE = 0x83A9,
	R_CALFROLL = 0xD389,
	RB_L_THIGHROLL = 0xFFFF,
	RB_R_THIGHROLL = 0xFFFF,
	RB_L_BUMROLL = 0xFFFF,
	RB_R_BUMROLL = 0xFFFF,
	PH_L_HAND = 0xFFFF,
	PH_R_HAND = 0xFFFF,
	L_PROPR_PROPFB_FACIAL_ROOT = 0xEE89,
	FB_JAW_C = 0xC069,
	FB_CHIN_C = 0x988B,
	FB_LOWERLIP_R = 0xDF11,
	FB_LOWERLIP_L = 0x6676,
	FB_TONGUE_A = 0x1E17,
	FB_TONGUE_B = 0x1DB1,
	FB_LOWERLIP_C = 0xF745,
	FB_FOREHEAD_C = 0xF746,
	FB_UPPERCHEEKOUTER_R = 0x1DA8,
	FB_EYEBROW_B_R = 0x25DF,
	FB_NOSTRIL_L = 0x2104,
	FB_NOSTRIL_R = 0x2194,
	FB_EYEBROW_B_L = 0x07DF,
	FB_EYEBROW_A_L = 0x0765,
	FB_EYEPIVOT_L = 0x21AE,
	FB_UPPEREYELID_L = 0x22AE,
	FB_LOWEREYELID_L = 0x0F13,
	FB_EYEBROW_A_R = 0xDAAB,
	FB_EYEPIVOT_R = 0x3C5A,
	FB_UPPEREYELID_R = 0x2294,
	FB_LOWEREYELID_R = 0x0F59,
	FB_UPPERCHEEKOUTER_L = 0xDA91,
	FB_UPPERLIP_R = 0x3C40,
	FB_UPPERLIP_L = 0x213E,
	FB_LIPCORNER_R = 0x6AB6,
	FB_LIPCORNER_L = 0x6B30,
	FB_LOWERCHEEK_R = 0x71FA,
	FB_LOWERCHEEK_L = 0x71F4,
	FB_EAR_R = 0x62E3,
	FB_EAR_L = 0x631D,
	FB_EYEBROW_C_L = 0xD2EB,
	FB_EYEBROW_C_R = 0xD2E5,
	FB_UPPERLIP = 0x14AE,
	FB_UPPERCHEEKINNER_L = 0x1494,
	FB_UPPERCHEEKINNER_R = 0x6B27,
	FB_R_NASAL = 0xEE31,
	FB_L_NASAL = 0xEDD7,
	FB_R_UPPERLIP = 0xFFFF,
	FB_ADAMSAPPLE = 0xFFFF,
	FB_POINTFB_C_JAW = 0xFFFF,
	FB_POINTFB_R_LIPLOWER = 0xFFFF,
	FB_POINTFB_L_LIPLOWER = 0xFFFF,
	FB_POINTFB_L_LIPUPPER = 0xFFFF,
	FB_POINTFB_R_LIPUPPER = 0xFFFF,
	EXTRA_1 = 0xFFFF,
	EXTRA_2 = 0xFFFF,
	CAMERA = 0xFFFF,
	L_RECOIL = 0xFFFF,
	R_RECOIL = 0x31D9,
	CAMERA_OFFSET = 0xB0CD,
	ROOT_OFFSET = 0xB093,
	BONEMASK_ALL = 0xD546,
	BONEMASK_UPPERONLY = 0x5FA8,
	BONEMASK_SPINEONLY = 0xFFFF
};

enum eHandType
{
	HAND_R,
	HAND_L,
	NUM_EHANDTYPE
};

enum eHolsterType
{
	HOLSTER_PISTOL_R,
	HOLSTER_PISTOL_L,
	HOLSTER_RIFLE,
	HOLSTER_MP_BAG,
	HOLSTER_SHIELD,
	HOLSTER_GRENADE,
	HOLSTER_SPECIAL,
	NUM_EHOLSTERTYPE
};

enum eEmotionState
{
	ES_INVALID,
	ES_ALERT,
	ES_ANGRY,
	ES_RELAXED,
	ES_RELAXED_EXTREME,
	ES_SAD,
	ES_SCARED,
	ES_SCARED_EXTREME,
	ES_CALM,
	ES_AGITATED,
	NUM_EEMOTIONSTATE
};

enum ePedHash
{
	a_ufe_sold_a = 0x3CC33E33,
	a_ufe_sold_b = 0x777BB39B,
	a_ufe_sold_d = 0x8FEFE483,
	a_ufe_sold_e = 0x7DFE40A0,
	alph_club = 0xE8459C03,
	amb_man_avg = 0x647FFDD9,
	andr_suit = 0x023449FC,
	andr_uc = 0x7752E610,
	armo_suit = 0x7469FF18,
	armo_unif = 0x5B1D196A,
	armo_unif_1 = 0x94B1E690,
	armo_unif_fkd_up = 0x3FA66A2E,
	bach_unif = 0xD2A43031,
	bar_girl_f_avg = 0x6F275C01,
	bar_tend_fat = 0x6E7681CC,
	bope_stf_mus = 0xF257E429,
	bope_stf_mus_1 = 0x4DA074F4,
	c_busd_driv_f = 0x068B65AD,
	c_f1_os_anos = 0xD9DA0B59,
	c_rt_party_f = 0x96F833ED,
	c_rt_party_fc = 0x8B25F9F2,
	c_rt_party_m = 0x9D7BC0C4,
	c_rt_party_mc = 0x974632BE,
	c_rt_phw_f = 0xB61D55C5,
	c_rt_staff_m = 0x50B88EDA,
	c_rtpl_ded = 0xD9443D37,
	clau_club = 0x94006A9E,
	clau_club_ded = 0x62E493E9,
	clau_club_low = 0x696821D7,
	crazy_man = 0x0B1939E1,
	dr_arth_doc = 0xD9AAE8BD,
	f_ap_civ_z = 0x36E16FC4,
	f_f1_misc_a = 0x6770560F,
	f_f1_misc_b = 0x7631F392,
	f_f1_misc_b_jp = 0xC20EAD0E,
	f_f1_misc_c = 0x12D92CE2,
	f_f1_misc_x = 0x97F53714,
	f_f1_misc_z = 0x32D0ECC9,
	f_f2_misc_a = 0x2E0E3CDE,
	f_f2_misc_b1 = 0xB7037583,
	f_f2_misc_b = 0x0FC70050,
	f_hotl_pris_a = 0x67DA8068,
	f_nc_misc_b = 0xC6787CBF,
	f_nc_misc_c = 0x6C1B4806,
	f_nc_patr_a1 = 0x480629D9,
	f_nc_patr_a = 0x5710E643,
	f_nc_patr_b = 0x9DFCF41A,
	f_nc_patr_b_low = 0x4F459BD8,
	f_pa_misc_a = 0x37870CC0,
	f_pa_misc_b = 0x6562E877,
	f_pa_misc_b_d = 0x6FCB504B,
	f_pa_misc_c = 0xE271E29F,
	f_pa_misc_d = 0xD1E8418C,
	f_pan_front = 0xE576B323,
	f_pp_civ_a = 0x8927AE8E,
	f_ufe_rcpt_a = 0x2D435209,
	fabi_club = 0x52819A6E,
	fabi_club_low = 0xF780F0F9,
	fabi_docks = 0x6B3CB30B,
	fabi_fav_1 = 0x4CAB0E25,
	fabi_roof = 0x94B4AE79,
	fav1_sc_bart = 0x05036E61,
	fav2_old_lady = 0x833228C3,
	fav_dj_fat = 0xC91DEA81,
	fav_fw_kid = 0xF4AE9A7D,
	fav_max_kid = 0x063B6224,
	fav_mc_avg = 0x436BDBAC,
	fave_resi_avg = 0xCF5B0D8A,
	fave_resi_thn = 0x2E2B3D02,
	fb_daph_dead = 0x9A049F0C,
	fb_daph_yaht = 0xED3C92F7,
	fb_de_marc = 0x88B27802,
	fb_pass_ny = 0x78AE7267,
	fb_tony_d = 0xD684FE2B,
	fun1_civ_ward_fat = 0x53FF125E,
	g_cs_bag_avg = 0x8567820F,
	g_cs_dock_a = 0xFB79F7A4,
	g_cs_dock_b = 0x2FFFE0AF,
	g_cs_dock_c = 0x2738CF21,
	g_cs_dock_d = 0x5C5BB966,
	g_cs_dock_e2 = 0xB72CD16A,
	g_cs_dock_e = 0x41BF842E,
	g_cs_dock_f = 0x7EF4FE98,
	g_cs_k_avg = 0x8076B4AF,
	g_cs_k_elva_pr = 0x24E709DD,
	g_cs_k_elvb_pr = 0x311DB8E2,
	g_cs_k_m_mus = 0xFF799C1D,
	g_cs_k_mony_pb = 0x64B92973,
	g_cs_k_mus = 0xCACB6525,
	g_cs_k_sold_hl = 0x10A222C0,
	g_cs_k_sold_pb = 0xE5A5D5C4,
	g_cs_k_sold_pr = 0x811C8CAF,
	g_cs_k_sold_sr = 0x9A47B989,
	g_cs_kidn_a = 0xBCE3E9CD,
	g_cs_kidn_aw = 0xDE7DEC70,
	g_cs_kidn_b = 0xCEBC8D7E,
	g_cs_kidn_c = 0x986620D2,
	g_cs_ncck = 0xBB3C5F60,
	g_cs_ncsm_a1 = 0x87BA0520,
	g_cs_ncsm_a = 0x3512AFED,
	g_cs_ncsm_b1 = 0xBC0D5D02,
	g_cs_ncsm_b1l = 0x58138E3A,
	g_cs_ncsm_b = 0x234C0C60,
	g_cs_ncsm_c1 = 0x4FAA1269,
	g_cs_ncsm_c2 = 0x143E9B97,
	g_cs_ncsm_c = 0x8D9DE102,
	g_cs_ncsm_d1 = 0x69F4C82A,
	g_cs_ncsm_d = 0x7FE4458F,
	g_cs_ncsm_e1 = 0xB1D454FC,
	g_cs_ncsm_e = 0xCC10DDE7,
	g_cs_rail_a = 0x0545E708,
	g_cs_rail_ax = 0x18DFEE7C,
	g_cs_slip_a = 0xBCCB4CC2,
	g_cs_slip_b = 0xEE072F39,
	g_cs_sold_b = 0x0ECDE116,
	g_cs_sold_d = 0x357FAE79,
	g_cs_sold_f = 0xD7D27320,
	g_cs_sold_x = 0x169BF07E,
	g_cs_uc_avg = 0x5520F584,
	g_cs_uc_nm_lt_mus = 0x403E87B2,
	g_fav_mug_avg = 0x747C0FF5,
	g_ny_c_drive_a = 0x11FFAF4A,
	g_ny_c_gdig_a = 0xE2E838B8,
	g_ny_c_gren = 0x04A8BE70,
	g_ny_c_gunp_c = 0xAB7D127F,
	g_ny_c_snip_a = 0x1DD0AA97,
	g_ny_c_sold_a = 0x61D69F3C,
	g_ny_c_sold_b = 0x6FFA3B83,
	g_ny_c_sold_c = 0xBE645856,
	g_ny_c_sold_d = 0x949A04C2,
	g_ny_c_sold_e = 0xA5B0A6EF,
	g_ny_c_sold_f = 0xF37DC288,
	g_ny_c_sold_g = 0x09CBEF24,
	g_ny_c_sold_h = 0xD7E10B4F,
	g_ny_c_thug_a = 0xB555B8E8,
	g_ny_c_thug_b = 0xC317D46C,
	g_ny_d_dead_a = 0x9FDF7CAE,
	g_ny_g_barp_a = 0xC7182B98,
	g_ny_t_blow_up = 0xA6E674C1,
	g_ny_t_sold_a = 0xD81D091D,
	g_ny_t_sold_b = 0x1F4A9777,
	g_ny_t_sold_bb = 0x2FD5DCBF,
	g_ny_t_sold_c = 0x2D0B32F8,
	g_ny_t_sold_d = 0x0DEB74B9,
	g_ny_t_sold_e = 0x9B971012,
	g_ny_t_sold_f = 0xF1D5BC8E,
	g_ny_t_thug_a = 0x7BFF23CE,
	g_ny_t_thug_b = 0xA8917CF2,
	g_ny_t_thug_c = 0x9657D87F,
	g_pp_pris_a = 0x4691468F,
	g_pp_riot_a = 0xAFE5A5B1,
	g_pp_riot_b = 0x1C4C7E7D,
	g_pp_riot_c1 = 0x577CE382,
	g_pp_riot_c = 0x9C2EFE44,
	g_pp_riot_d = 0x6A7E1AE3,
	g_pp_riot_e = 0x78DC379F,
	giov_bus = 0xB8368028,
	giov_club = 0x1FA0704D,
	giov_club_b = 0x075B3C0D,
	giov_club_c = 0xD5C858E8,
	giov_club_low = 0xCD1A8CAB,
	giov_fav = 0xD6B199EA,
	giov_fav_low = 0xCDEDEED3,
	h_crac_sold_a = 0x2D6FBD3A,
	h_crac_sold_b = 0x4922F498,
	h_crac_sold_c = 0x37595105,
	k_f1_misc_a = 0xFF7E9CB1,
	k_f1_misc_b = 0x0E1739DE,
	m7_pmc_01_avg = 0x678BB0DA,
	m_ap_civ_b = 0x2634C958,
	m_ap_civ_br = 0x00070C62,
	m_ap_emp_a = 0x499762B5,
	m_ap_sec_a = 0xC30EA5A6,
	m_crac_snip_avg = 0x5B9FB4F7,
	m_crac_sold_a = 0x5CAC7F10,
	m_crac_sold_avg = 0x3ECB6593,
	m_crac_sold_b = 0x13566C55,
	m_crac_sold_bb = 0x5327FA16,
	m_crac_sold_c = 0xDE1401D1,
	m_crac_sold_d = 0xB8F9379C,
	m_crac_sold_ded = 0xDE0D1140,
	m_crac_sold_e = 0x02B0CB0A,
	m_crac_sold_jy = 0x783D4DA8,
	m_crac_sold_of = 0x9D950A1E,
	m_crac_sold_sr = 0xDECC8CCC,
	m_crac_sold_tt = 0x00DC588F,
	m_crac_sold_z2 = 0x675E99C7,
	m_crac_sold_z = 0x60248600,
	m_crac_w_sold_avg = 0xEB80AFBE,
	m_f1_gcs_a = 0x3A079D89,
	m_f1_gcs_b = 0x72438E00,
	m_f1_gcs_c = 0x808A2A8D,
	m_f1_hood_a = 0xC40A8021,
	m_f1_hood_b = 0x2E81D512,
	m_f1_hood_c = 0x409CF948,
	m_f1_hood_d = 0x0AF00DEF,
	m_f1_hood_e = 0x1D423293,
	m_f1_misc_a = 0x1CC99D8C,
	m_f1_misc_b1 = 0x79EDD358,
	m_f1_misc_b2 = 0x8C3577E7,
	m_f1_misc_c = 0x516A86D1,
	m_f1_misc_d1 = 0x2ECF4CE0,
	m_f1_misc_d2 = 0x1C78A833,
	m_f1_misc_d3 = 0x4B5705EF,
	m_f1_misc_d = 0x64A1AD3F,
	m_f1_misc_e = 0x3592CF1A,
	m_f1_misc_f = 0x475EF2B2,
	m_f1_misc_fw = 0x3DD4E8D7,
	m_f1_misc_fx = 0x2B07C33D,
	m_f1_misc_g = 0xCBB7FB6A,
	m_f1_misc_h1 = 0xAB842FC8,
	m_f1_misc_h = 0x9DE91FCD,
	m_f1_misc_i = 0x6EC9C18F,
	m_f1_misc_ia = 0x533C7BDE,
	m_f1_misc_ib = 0x44EEDF43,
	m_f1_misc_x = 0x815566A2,
	m_f1_misc_y = 0x539F0B36,
	m_f2_gcs_a = 0x2C5E05FE,
	m_f2_gcs_b = 0x1DFEE944,
	m_f2_gcs_d = 0x82BE32BD,
	m_f2_gcs_e = 0x74779630,
	m_f2_gcs_h = 0xC412B569,
	m_f2_gcs_i = 0xB4D016E4,
	m_f2_gcs_y1 = 0xA821D519,
	m_f2_gcs_y = 0xE8187D80,
	m_f2_gcs_z = 0xB5B598BB,
	m_f2_mcp_a1 = 0x041B7B35,
	m_f2_mcp_a = 0xC4A3820C,
	m_f2_misc_a = 0xD6BC8CE5,
	m_f2_misc_b = 0x98CA10E9,
	m_f2_ufe_b = 0x8FCE4DB7,
	m_f2_ufe_c = 0x10F9CFF8,
	m_f2_ufe_e = 0xF46E16E1,
	m_f2_ufe_f1 = 0xCFFD857C,
	m_f2_ufe_f = 0xE62FFA65,
	m_f2_ufe_g = 0x77D71D79,
	m_f2_ufe_h = 0x8A1841FB,
	m_f2_ufe_i = 0xBAF3239C,
	m_hotl_pris_a = 0xF35733E7,
	m_nc_civs_a = 0x81D59E87,
	m_nc_civs_b = 0x4C0A32E9,
	m_nc_civs_c = 0x9D60559C,
	m_nc_hall_a = 0x5E18289A,
	m_nc_pack_a1 = 0xA716E1B3,
	m_nc_patr_a = 0xC04A7BC1,
	m_nc_patr_b = 0x8D6C1605,
	m_nc_patr_b_low = 0xC694E647,
	m_nc_staf_a = 0xE247009D,
	m_nc_staf_b = 0x10EF5DED,
	m_nc_staf_c = 0x41353E78,
	m_pa_dead_a = 0x9D61F8FE,
	m_pa_dead_z = 0xD2466262,
	m_pa_misc_a = 0x5EC7F821,
	m_pa_misc_b = 0x51855D9C,
	m_pa_rebl_a = 0x46DE1075,
	m_pa_rebl_b = 0x5D213CFB,
	m_pa_rebl_b_d = 0x9393517E,
	m_pa_rebl_c = 0xD0A52401,
	m_pa_rebl_d = 0xA08DC3D3,
	m_pa_rebl_d_1 = 0xFB3968FA,
	m_pa_rebl_d_2 = 0xE189359A,
	m_pa_rebl_e_1 = 0x31FB0CE7,
	m_pa_rebl_e_2 = 0x3FA9A844,
	m_pa_rebl_f = 0x83F80AA8,
	m_pa_rzip_a = 0x49CA4819,
	m_pan_front = 0x38281580,
	m_pp_misc_a = 0xB2E4395B,
	marc_casu = 0x3DD7B2BC,
	marc_casu_low = 0x4F3BABA7,
	marc_fav2 = 0xEAC1C7A6,
	marc_fav = 0xE8C726E9,
	marc_fav_low = 0xC934A675,
	marc_form = 0xE1457BFC,
	marc_suit = 0xEF6602EB,
	marc_yaht = 0xB1BBA014,
	maxpayne_mirrored = 0x5796EE80,
	milo_unif = 0xABA5597B,
	nevs_unif = 0x6DEDC74B,
	offi_tech_avg = 0x885031CC,
	offi_tech_ded = 0x46D98458,
	p_rt_secg_m = 0x234592CF,
	p_ufe_sold_a1 = 0xC8FE8AA7,
	p_ufe_sold_a2 = 0x2F365715,
	p_ufe_sold_a = 0xD8AA4513,
	p_ufe_sold_b1 = 0x4ED6909D,
	p_ufe_sold_b = 0xE716E1EC,
	p_ufe_sold_c = 0xD8D34561,
	p_ufe_sold_d = 0xE653E062,
	p_ufe_sold_e = 0xBCFD8DB6,
	p_ufe_sold_f = 0xCABF2939,
	p_ufe_sold_g = 0xA131D61F,
	p_ufe_sold_x = 0x203D5400,
	pass_club_h = 0xF34B0E8E,
	pass_comb = 0xC01AE62E,
	pass_dock = 0x890BEDB2,
	pass_heli_pilo = 0x4B0ABAAA,
	pass_ny_h = 0xE4FB5BF9,
	pass_ny_w = 0xDA59C6BA,
	pass_roof = 0x37DD7F36,
	pass_suit = 0x04B2BBB8,
	pass_yaht = 0xCE4A4D28,
	r_crac_heavy_g = 0x24E58F54,
	r_spp_sold_a = 0xE4D54E4F,
	r_ufe_sold_a = 0x292EBD5C,
	rcpt_f_avg = 0x5BE3F7B1,
	rodr_form = 0x6C3805F4,
	rodr_form_dead = 0x90E800C1,
	rodr_suit = 0x4BF6B715,
	secr_f_avg = 0x245EDE9A,
	sero_club = 0xBF544563,
	sero_club_low = 0xF1CFD4A3,
	sero_unif_1 = 0x281A0CD2,
	sero_unif_2 = 0x55B5E809,
	sero_unif_3 = 0x048345A5,
	sext_dave = 0x251CA0F7,
	sext_dave_pp = 0x6C2E931D,
	superlod = 0xAE4B15D6,
	uppr_pty_f_avg = 0xEEF6B616,
	vict_crash = 0xD85BA5B1,
	vict_form = 0xDC1B5517,
	vict_police = 0x5276B8FC,
	vict_suit = 0xF87AA0CE,
	wlsn_spp_noj = 0x756AD77E,
	wlsn_spp_unif = 0xE16AEB67,
	wlsn_undr_1a = 0x71FC09BA
};

enum eLobbyOption
{
	LOBBY_OPT_LOCATION,
	LOBBY_OPT_DURATION,
	LOBBY_OPT_TEAM,
	LOBBY_OPT_HEALTH,
	LOBBY_OPT_LOCKON,
	LOBBY_OPT_BT_FRIENDLY_TRANSMIT,
	LOBBY_OPT_DEBUG_BLIPS,
	LOBBY_OPT_LMS_LIVES,
	LOBBY_OPT_PEDS,
	LOBBY_OPT_BLIPS,
	LOBBY_OPT_NAME,
	LOBBY_OPT_RETICULE,
	LOBBY_OPT_TEAMCHAT,
	LOBBY_OPT_SPAWNDIST,
	LOBBY_OPT_SPAWNTIME,
	LOBBY_OPT_TIMEOFDAY,
	LOBBY_OPT_WEATHER,
	LOBBY_OPT_INFO,
	LOBBY_OPT_SHOOT_DODGE_MODE,
	LOBBY_OPT_JIP_ALLOWED,
	LOBBY_OPT_WINNING_COND,
	LOBBY_OPT_NONETWORKSTART,
	LOBBY_OPT_FALLING_DAMAGE,
	LOBBY_OPT_SILHOUETTE,
	LOBBY_OPT_GW_GAMEMODE,
	LOBBY_OPT_MO_SPECOP,
	LOBBY_OPT_MO_SPECPW,
	LOBBY_OPT_MO_RANKRES,
	LOBBY_OPT_MO_NUMPLYR,
	LOBBY_OPT_MO_DIFFICULTY,
	LOBBY_OPT_GWLASTSTAND,
	LOBBY_OPT_MPDISPDEBUG,
	LOBBY_OPT_DM_VARIANT,
	LOBBY_OPT_ROUNDS_LIMIT,
	LOBBY_OPT_GW_SMALLSERVERSHUTDOWN,
	LOBBY_OPT_GW_FORCESETUP,
	LOBBY_OPT_NAME_TAGS,
	LOBBY_OPT_MP_BOT,
	LOBBY_OPT_MO_DMWSOAK,
	LOBBY_OPT_MP_RESIZEMAP,
	LOBBY_OPT_GW_ROUND1,
	LOBBY_OPT_GW_ROUND2,
	LOBBY_OPT_GW_ROUND3,
	LOBBY_OPT_GW_ROUND4,
	LOBBY_OPT_GW_ROUND5,
	LOBBY_OPT_SOCIALCLUB,
	LOBBY_OPT_XP_BONUSMULTIPLIER,
	LOBBY_OPT_BURSTSALLOWED,
	LOBBY_OPT_PK_PRIMARY,
	LOBBY_OPT_PK_SECONDARY,
	NUM_ELOBBYOPTION
};

enum eNmMessage
{
	nm000_stopAllBehaviours,
	nm001,
	nm002_start,
	nm003_activePose,
	nm004,
	nm005_mask,
	nm006_incomingTransforms,
	nm007,
	nm008_bodyRelax,
	nm009,
	nm010_relaxation,
	nm011_mask,
	nm012_holdPose,
	nm013_damping,
	nm014_configureBalance,
	nm015,
	nm016_stepHeight,
	nm017_legsApartRestep,
	nm018_legsTogetherRestep,
	nm019_taperKneeStrength,
	nm020_legStiffness,
	nm021_leftLegSwingDamping,
	nm022_rightLegSwingDamping,
	nm023_balanceAbortThreshold,
	nm024_giveUpHeight,
	nm025_stepClampScale,
	nm026_stepClampScaleVariance,
	nm027_predictionTime,
	nm028_predictionTimeVariance,
	nm029_maxSteps,
	nm030_fallType,
	nm031_fallMult,
	nm032_fallReduceGravityComp,
	nm033_maxBalanceTime,
	nm034_stableLinSpeedThresh,
	nm035_stableRotSpeedThresh,
	nm036_balanceIndefinitely,
	nm037_rampHipPitchOnFail,
	nm038_movingFloor,
	nm039_airborneStep,
	nm040_useComDirTurnVelThresh,
	nm041_minKneeAngle,
	nm042_flatterSwingFeet,
	nm043_flatterStaticFeet,
	nm044_leanAgainstVelocity,
	nm045_stepDecisionThreshold,
	nm046_stepIfInSupport,
	nm047_alwaysStepWithFarthest,
	nm048_standUp,
	nm049_giveUpHeightEnd,
	nm050_balanceAbortThresholdEnd,
	nm051_giveUpRampDuration,
	nm052_leanToAbort,
	nm053_configureBalanceReset,
	nm054,
	nm055_defineAttachedObject,
	nm056,
	nm057_partIndex,
	nm058_worldPos,
	nm059_objectMass,
	nm060_setStiffness,
	nm061,
	nm062_mask,
	nm063_bodyStiffness,
	nm064_damping,
	nm065_bodyRollUp,
	nm066,
	nm067_mask,
	nm068_stiffness,
	nm069_legPush,
	nm070_armReachAmount,
	nm071_useArmToSlowDown,
	nm072_asymmetricalLegs,
	nm073_bodyWrithe,
	nm074,
	nm075_armStiffness,
	nm076_legStiffness,
	nm077_backStiffness,
	nm078_legPeriod,
	nm079_armPeriod,
	nm080_backPeriod,
	nm081_legDamping,
	nm082_armDamping,
	nm083_backDamping,
	nm084_legAmplitude,
	nm085_armAmplitude,
	nm086_backAmplitude,
	nm087_kneeAmplitude,
	nm088_elbowAmplitude,
	nm089_mask,
	nm090_rollOverFlag,
	nm091_armsWindmillAdaptive,
	nm092,
	nm093_armStiffness,
	nm094_bodyStiffness,
	nm095_period,
	nm096_amplitude,
	nm097_phase,
	nm098_leftElbowAngle,
	nm099_rightElbowAngle,
	nm100_armDirection,
	nm101_disableOnImpact,
	nm102_setBackAngles,
	nm103_useAngMom,
	nm104_bendLeftElbow,
	nm105_bendRightElbow,
	nm106_mask,
	nm107_pedalLegs,
	nm108,
	nm109_backPedal,
	nm110_legStiffness,
	nm111_pedalLeftLeg,
	nm112_pedalRightLeg,
	nm113_radius,
	nm114_angularSpeed,
	nm115_pedalOffset,
	nm116_speedAsymmetry,
	nm117_adaptivePedal4Dragging,
	nm118_angSpeedMultiplier4Dragging,
	nm119_radiusVariance,
	nm120_legAngleVariance,
	nm121_centreForwards,
	nm122_centreUp,
	nm123_centreOut,
	nm124_dragReduction,
	nm125_hula,
	nm126_bodyBalance,
	nm127_balance,
	nm128_armStiffness,
	nm129_armDamping,
	nm130_elbow,
	nm131_shoulder,
	nm132_useHeadLook,
	nm133_headLookPos,
	nm134_headLookInstanceIndex,
	nm135_somersaultAngle,
	nm136_somersaultAngleThreshold,
	nm137_sideSomersaultAngle,
	nm138_sideSomersaultAngleThreshold,
	nm139_returningToBalanceArmsOut,
	nm140_armsOutOnPush,
	nm141_armsOutStraightenElbows,
	nm142_armsOutMinLean2,
	nm143_angVelMultiplier,
	nm144_angVelThreshold,
	nm145_armsOutOnPushMultiplier,
	nm146_armsOutOnPushTimeout,
	nm147_useBodyTurn,
	nm148_elbowAngleOnContact,
	nm149_bendElbowsTime,
	nm150_bendElbowsGait,
	nm151_headLookAtVelProb,
	nm152_turnOffProb,
	nm153_turn2VelProb,
	nm154_turnAwayProb,
	nm155_turnLeftProb,
	nm156_turnRightProb,
	nm157_turn2TargetProb,
	nm158_leanInDirection,
	nm159,
	nm160_dir,
	nm161_leanAmount,
	nm162_applyAsForce,
	nm163_leanToPosition,
	nm164,
	nm165_pos,
	nm166_leanAmount,
	nm167_applyAsForce,
	nm168_leanTowardsObject,
	nm169,
	nm170_offset,
	nm171_leanAmount,
	nm172_instanceIndex,
	nm173_applyAsForce,
	nm174_forceLeanInDirection,
	nm175,
	nm176_dir,
	nm177_leanAmount,
	nm178_forceLeanToPosition,
	nm179,
	nm180_pos,
	nm181_leanAmount,
	nm182_forceLeanTowardsObject,
	nm183,
	nm184_offset,
	nm185_leanAmount,
	nm186_instanceIndex,
	nm187_braceForImpact,
	nm188_brace,
	nm189_pos,
	nm190_look,
	nm191_instanceIndex,
	nm192_braceDistance,
	nm193_reachAbsorbtionTime,
	nm194_targetPredictionTime,
	nm195_bodyStiffness,
	nm196_grabDontLetGo,
	nm197_grabStrength,
	nm198_grabDistance,
	nm199_grabReachAngle,
	nm200_grabHoldTimer,
	nm201_legStiffness,
	nm202_upperBodyFlinch,
	nm203,
	nm204_pos,
	nm205_leftHanded,
	nm206_rightHanded,
	nm207_handDistanceVertical,
	nm208_handDistanceLeftRight,
	nm209_handDistanceFrontBack,
	nm210_bodyStiffness,
	nm211_bodyDamping,
	nm212_backBendAmount,
	nm213_useLeftArm,
	nm214_useRightArm,
	nm215_noiseScale,
	nm216_newHit,
	nm217_turnTowards,
	nm218_protectHeadToggle,
	nm219_headLookAwayFromTarget,
	nm220_crushReaction,
	nm221,
	nm222_obstacleID,
	nm223_obstacleMass,
	nm224_obstacleVel,
	nm225_obstaclePos,
	nm226_flinchMode,
	nm227_useInjuries,
	nm228_stiffness,
	nm229_damping,
	nm230_mask,
	nm231_grab,
	nm232_rightArmGrab,
	nm233_bodyStiffness,
	nm234_grabStrength,
	nm235_pos1,
	nm236_pos2,
	nm237_pos3,
	nm238_pos4,
	nm239_normalL,
	nm240_normalR,
	nm241_linegrab,
	nm242_surfaceGrab,
	nm243_justbrace,
	nm244_tryToPullUp,
	nm245_useLeft,
	nm246_useRight,
	nm247_instanceIndex,
	nm248_dontLetGo,
	nm249_grabDist,
	nm250_reachAngle,
	nm251_oneSideReachAngle,
	nm252_pullUpStrengthLeft,
	nm253_pullUpStrengthRight,
	nm254_pullUpTime,
	nm255_grabHoldMaxTimer,
	nm256_instancePartIndex,
	nm257,
	nm258_leftArmGrab,
	nm259_catchFall,
	nm260_catchFall,
	nm261_legsStiffness,
	nm262_armsStiffness,
	nm263_torsoStiffness,
	nm264_backwardsMinArmOffset,
	nm265_forwardMaxArmOffset,
	nm266_zAxisSpinReduction,
	nm267_useHeadLook,
	nm268_shot,
	nm269_shot,
	nm270_bodyStiffness,
	nm271_neckStiffness,
	nm272_neckDamping,
	nm273_bodyPart,
	nm274_crouching,
	nm275_reachForWound,
	nm276_fling,
	nm277_chickenArms,
	nm278_pointGun,
	nm279_brace,
	nm280_antiSpinAmount,
	nm281_antiSpinTime,
	nm282_grabHoldTime,
	nm283_maxSteps,
	nm284_loosenessAmount,
	nm285_minArmsLooseness,
	nm286_minLegsLooseness,
	nm287_stableHandsAndNeck,
	nm288_useHeadLook,
	nm289_hitPoint,
	nm290_bulletVel,
	nm291_normal,
	nm292_headLook,
	nm293_timeBeforeReachForWound,
	nm294_timeBeforeCollapseWoundLeg,
	nm295_kMultOnLoose,
	nm296_kMult4Legs,
	nm297_alwaysResetLooseness,
	nm298_spineDamping,
	nm299_cpainSmooth2Time,
	nm300_cpainDuration,
	nm301_cpainMag,
	nm302_cpainTwistMag,
	nm303_cpainSmooth2Zero,
	nm304_armsHoldTime,
	nm305_armsPoseTime,
	nm306_armsBlendMotion,
	nm307_legLiftTime,
	nm308_legLiftStiffness,
	nm309_legLiftDamping,
	nm310_useCatchFallOnFall,
	nm311_bulletProofVest,
	nm312_allowInjuredLeg,
	nm313_allowInjuredLegReach,
	nm314_allowInjuredArm,
	nm315_injuredArmReactTime,
	nm316_snap,
	nm317_snapMag,
	nm318_snapDirectionRandomness,
	nm319_snapLeftArm,
	nm320_snapRightArm,
	nm321_snapLeftLeg,
	nm322_snapRightLeg,
	nm323_snapSpine,
	nm324_snapNeck,
	nm325_snapPhasedLegs,
	nm326_snapHipType,
	nm327_snapUseBulletDir,
	nm328_unSnapInterval,
	nm329_unSnapRatio,
	nm330_snapUseTorques,
	nm331_melee,
	nm332_initialWeaknessZeroDuration,
	nm333_initialWeaknessRampDuration,
	nm334_shotShockSpin,
	nm335_addShockSpin,
	nm336_randomizeShockSpinDirection,
	nm337_alwaysAddShockSpin,
	nm338_shockSpinMin,
	nm339_shockSpinMax,
	nm340_shockSpinLiftForceMult,
	nm341_shockSpinDecayMult,
	nm342_shockSpinScalePerComponent,
	nm343_shotFallToKnees,
	nm344_fallToKnees,
	nm345_ftkBalanceTime,
	nm346_ftkAlwaysChangeFall,
	nm347_ftkHelperForce,
	nm348_ftkHelperForceOnSpine,
	nm349_ftkLeanHelp,
	nm350_ftkSpineBend,
	nm351_ftkStiffSpine,
	nm352_ftkImpactLooseness,
	nm353_ftkImpactLoosenessTime,
	nm354_ftkOnKneesArmType,
	nm355_ftkReleaseReachForWound,
	nm356_ftkReleasePointGun,
	nm357_shotConfigureArms,
	nm358_brace,
	nm359_alwaysReachTime,
	nm360_useArmsWindmill,
	nm361_AWSpeedMult,
	nm362_AWRadiusMult,
	nm363_AWStiffnessAdd,
	nm364_forceLeftReachForWound,
	nm365_forceRightReachForWound,
	nm366_reachForWoundWithGun,
	nm367_allowTwoHandedReach,
	nm368_shotFromBehind,
	nm369_shotFromBehind,
	nm370_sfbSpineAmount,
	nm371_sfbNeckAmount,
	nm372_sfbHipAmount,
	nm373_sfbKneeAmount,
	nm374_sfbPeriod,
	nm375_sfbForceBalancePeriod,
	nm376_sfbArmsOnset,
	nm377_sfbKneesOnset,
	nm378_sfbNoiseGain,
	nm379_shotInGuts,
	nm380_shotInGuts,
	nm381_sigSpineAmount,
	nm382_sigNeckAmount,
	nm383_sigHipAmount,
	nm384_sigKneeAmount,
	nm385_sigPeriod,
	nm386_sigForceBalancePeriod,
	nm387_sigKneesOnset,
	nm388_shotHeadLook,
	nm389_useHeadLook,
	nm390_headLook,
	nm391_headLookAtWoundMinTimer,
	nm392_headLookAtWoundMaxTimer,
	nm393_headLookAtHeadPosMaxTimer,
	nm394_headLookAtHeadPosMinTimer,
	nm395_shotRelax,
	nm396_relaxPeriodUpper,
	nm397_relaxPeriodLower,
	nm398_splitBody,
	nm399_configureBullets,
	nm400_impulseSpreadOverParts,
	nm401_impulseLeakageStrengthScaled,
	nm402_impulsePeriod,
	nm403_impulseDelay,
	nm404_impulseReductionPerShot,
	nm405_impulseMinimumStrength,
	nm406_impulseRecoveryPerTick,
	nm407_impulseTorqueScale,
	nm408_torqueMode,
	nm409_torqueSpinMode,
	nm410_torqueFilterMode,
	nm411_torqueAlwaysSpine3,
	nm412_torqueDelay,
	nm413_torquePeriod,
	nm414_torqueGain,
	nm415_torqueCutoff,
	nm416_torqueReductionPerTick,
	nm417_liftGain,
	nm418_counterImpulseDelay,
	nm419_counterImpulseMag,
	nm420_counterAfterMagReached,
	nm421_doCounterImpulse,
	nm422_counterImpulse2Hips,
	nm423_impulseAirMult,
	nm424_impulseAirMultStart,
	nm425_impulseAirMax,
	nm426_impulseAirApplyAbove,
	nm427_impulseAirOn,
	nm428_loosenessFix,
	nm429_armScale,
	nm430_staggerFall,
	nm431_armStiffness,
	nm432_armDamping,
	nm433_spineDamping,
	nm434_spineStiffness,
	nm435_armStiffnessStart,
	nm436_armDampingStart,
	nm437_spineDampingStart,
	nm438_spineStiffnessStart,
	nm439_timeAtStartValues,
	nm440_rampTimeFromStartValues,
	nm441_staggerStepProb,
	nm442_stepsTillStartEnd,
	nm443_timeStartEnd,
	nm444_rampTimeToEndValues,
	nm445_lowerBodyStiffness,
	nm446_lowerBodyStiffnessEnd,
	nm447_predictionTime,
	nm448_perStepReduction1,
	nm449_leanInDirRate,
	nm450_leanInDirMax,
	nm451_hipBendMult,
	nm452_spineBendMult,
	nm453_useHeadLook,
	nm454_headLookPos,
	nm455_headLookInstanceIndex,
	nm456_headLookAtVelProb,
	nm457_turnOffProb,
	nm458_turn2TargetProb,
	nm459_turn2VelProb,
	nm460_turnAwayProb,
	nm461_turnLeftProb,
	nm462_turnRightProb,
	nm463_useBodyTurn,
	nm464_upperBodyReaction,
	nm465_rdsForceMag,
	nm466_rdsStiffnessDecayTime,
	nm467_mask,
	nm468_parent,
	nm469_headLook,
	nm470,
	nm471_damping,
	nm472_stiffness,
	nm473_instanceIndex,
	nm474_vel,
	nm475_pos,
	nm476_alwaysLook,
	nm477_alwaysEyesHorizontal,
	nm478_highFall,
	nm479_highFall,
	nm480_bodyStiffness,
	nm481_bodydamping,
	nm482_pdStrength,
	nm483_crashOrLandCutOff,
	nm484_catchfalltime,
	nm485_armsUp,
	nm486_legRadius,
	nm487_legAngSpeed,
	nm488_armPeriod,
	nm489_armAmplitude,
	nm490_fowardRoll,
	nm491_aimAngleBase,
	nm492_sideD,
	nm493_fowardOffsetOfLegIK,
	nm494_fowardVelRotation,
	nm495_orientateBodyToFallDirection,
	nm496_useZeroPose,
	nm497_ignoreWorldCollisions,
	nm498_footVelCompScale,
	nm499_fowardVelCutOff,
	nm500_legL,
	nm501_catchFallCutOff,
	nm502_legStrength,
	nm503_stayUpright,
	nm504,
	nm505_useForces,
	nm506_useTorques,
	nm507_velocityBased,
	nm508_torqueOnlyInAir,
	nm509_forceStrength,
	nm510_forceDamping,
	nm511_forceFeetMult,
	nm512_forceSpine3Share,
	nm513_forceLeanReduction,
	nm514_forceInAirShare,
	nm515_forceMin,
	nm516_forceMax,
	nm517_forceSaturationVel,
	nm518_forceThresholdVel,
	nm519_torqueStrength,
	nm520_torqueDamping,
	nm521_torqueSaturationVel,
	nm522_torqueThresholdVel,
	nm523_supportPosition,
	nm524_noSupportForceMult,
	nm525_rollDownStairs,
	nm526_rollDownStairs,
	nm527_stiffness,
	nm528_damping,
	nm529_forcemag,
	nm530_asymmetry,
	nm531_m_useArmToSlowDown,
	nm532_useZeroPose,
	nm533_spinWhenInAir,
	nm534_m_legPush,
	nm535_armReachLength,
	nm536_m_armReachAmount,
	nm537_tryToAvoidHeadbuttingGround,
	nm538_useCustomRollDir,
	nm539_customRollDir,
	nm540_stiffnessDecayTime,
	nm541_stiffnessDecayTarget,
	nm542_asymmetricalLegs,
	nm543_zAxisSpinReduction,
	nm544_targetLinearVelocityDecayTime,
	nm545_targetLinearVelocity,
	nm546_onlyApplyHelperForces,
	nm547_useVelocityOfObjectBelow,
	nm548_useRelativeVelocity,
	nm549_applyFoetalToLegs,
	nm550_movementLegsInFoetalPosition,
	nm551_maxAngVelAroundFrontwardAxis,
	nm552_minAngVel,
	nm553_applyNewRollingCheatingTorques,
	nm554_maxAngVel,
	nm555_magOfTorqueToRoll,
	nm556_applyHelPerTorqueToAlign,
	nm557_delayToAlignBody,
	nm558_magOfTorqueToAlign,
	nm559_airborneReduction,
	nm560_fallOverWall,
	nm561_fallOverWall,
	nm562_bodyStiffness,
	nm563_damping,
	nm564_magOfForce,
	nm565_maxDistanceFromPelToHitPoint,
	nm566_maxForceDist,
	nm567_stepExclusionZone,
	nm568_minLegHeight,
	nm569_bodyTwist,
	nm570_fallOverWallEndA,
	nm571_fallOverWallEndB,
	nm572_forceAngleAbort,
	nm573_forceTimeOut,
	nm574_moveArms,
	nm575_moveLegs,
	nm576_bendSpine,
	nm577_angleDirWithWallNormal,
	nm578_leaningAngleThreshold,
	nm579_maxAngVel,
	nm580_adaptForcesToLowWall,
	nm581_maxWallHeight,
	nm582_distanceToSendSuccessMessage,
	nm583_useArmIK,
	nm584_reachDistanceFromHitPoint,
	nm585_minReachDistanceFromHitPoint,
	nm586_angleTotallyBack,
	nm587_pointArm,
	nm588,
	nm589_target,
	nm590_twist,
	nm591_armStraightness,
	nm592_useLeftArm,
	nm593_armStiffness,
	nm594_armDamping,
	nm595_instanceIndex,
	nm596_pointSwingLimit,
	nm597_useZeroPoseWhenNotPointing,
	nm598_pointGun,
	nm599_pointGun,
	nm600_leftHandTarget,
	nm601_leftHandTargetIndex,
	nm602_leftHandParentEffector,
	nm603_leftHandParentOffset,
	nm604_rightHandTarget,
	nm605_rightHandTargetIndex,
	nm606_rightHandParentEffector,
	nm607_rightHandParentOffset,
	nm608_leadTarget,
	nm609_secondaryHandOffset,
	nm610_primaryHandWeaponDistance,
	nm611_armStiffness,
	nm612_armDamping,
	nm613_useHelperTorques,
	nm614_useHelperForces,
	nm615_useHelperTorquesSupport,
	nm616_useHelperForcesSupport,
	nm617_maxAngle,
	nm618_clavicleBlend,
	nm619_elbowAttitude,
	nm620_useIncomingTransforms,
	nm621_useConstraint,
	nm622_alwaysConstrain,
	nm623_makeConstraintDistance,
	nm624_weaponMask,
	nm625_leftHandWeaponIndex,
	nm626_rightHandWeaponIndex,
	nm627_stabilizeRifleStock,
	nm628_oriStiff,
	nm629_oriDamp,
	nm630_posStiff,
	nm631_posDamp,
	nm632_extraTilt,
	nm633_fireWeaponRelaxTime,
	nm634_fireWeaponRelaxAmount,
	nm635_fireWeaponRelaxDistance,
	nm636_gravityOpposition,
	nm637_constrainRifle,
	nm638_enableRight,
	nm639_enableLeft,
	nm640_disableArmCollision,
	nm641_poseArmWhenNotInUse,
	nm642_timeWarpActive,
	nm643_timeWarpStrengthScale,
	nm644_errorThreshold,
	nm645_rifleConstraintMinDistance,
	nm646_constraintMinDistance,
	nm647_usePistolIK,
	nm648_useSpineTwist,
	nm649_useTurnToTarget,
	nm650_useHeadLook,
	nm651_alwaysSupport,
	nm652_twoHandedPistols,
	nm653_allowShotLooseness,
	nm654_parent,
	nm655_exagHeightThreshold,
	nm656_exagDuration,
	nm657_exagMag,
	nm658_exagTwistMag,
	nm659_exagSmooth2Zero,
	nm660_exagZeroTime,
	nm661_shootDodge,
	nm662_ShootDodge,
	nm663_state,
	nm664_endCollisionReaction,
	nm665_headDamping,
	nm666_headStiffness,
	nm667_trunkDamping,
	nm668_trunkStiffness,
	nm669_legDamping,
	nm670_legStiffness,
	nm671_legStiffnessMin,
	nm672_legTaper,
	nm673_aimingArmStiffness,
	nm674_aimingArmDamping,
	nm675_notAimingArmStiffness,
	nm676_notAimingArmStiffnessMin,
	nm677_notAimingArmDamping,
	nm678_notAimingArmTaper,
	nm679_wristMuscleStiffness,
	nm680_rightArmTarget,
	nm681_leftArmTarget,
	nm682_collisionPoint,
	nm683_collisionNormal,
	nm684_collisionObjectVelocity,
	nm685_collisionTime,
	nm686_collisionTimeThreshold,
	nm687_collisionAccelThreshold,
	nm688_collisionVelThreshold,
	nm689_collisionIndex,
	nm690_useHeadLook,
	nm691_usePointGun,
	nm692_endDesiredImpactOrientation,
	nm693_predictedTimeToEndImpact,
	nm694_legGroundCollisionTime,
	nm695_legGroundCollisionHipLean1,
	nm696_legGroundCollisionKneeAngle,
	nm697_legGroundCollisionKneeStiffness,
	nm698_armAnimTask,
	nm699_leftArmAnimTaskParent,
	nm700_rightArmAnimTaskParent,
	nm701_oriStiff,
	nm702_oriDamp,
	nm703_oriSplit,
	nm704_velSmooth,
	nm705_stickyRootStiff,
	nm706_stickyRootDamp,
	nm707_stickyRootThresh,
	nm708_groundInstance,
	nm709_recoilRelaxAmount,
	nm710_recoilRelaxTime,
	nm711_pointGunUseConstraint,
	nm712_pointGunElbowAttitude,
	nm713_pointGunOriStiff,
	nm714_pointGunOriDamp,
	nm715_pointGunPosStiff,
	nm716_pointGunPosDamp,
	nm717_pointGunClavicleBlend,
	nm718_pointGunConstrainRifle,
	nm719_pointGunErrorThreshold,
	nm720_pointGunRifleConstraintMinDistance,
	nm721_pointGunConstraintMinDistance,
	nm722_pointGunGravityOpposition,
	nm723_bodyWritheArmStiffness,
	nm724_bodyWritheBackStiffness,
	nm725_bodyWritheLegStiffness,
	nm726_bodyWritheArmDamping,
	nm727_bodyWritheBackDamping,
	nm728_bodyWritheLegDamping,
	nm729_bodyWritheArmPeriod,
	nm730_bodyWritheBackPeriod,
	nm731_bodyWritheLegPeriod,
	nm732_bodyWritheMask,
	nm733_bodyWritheArmAmplitude,
	nm734_bodyWritheBackAmplitude,
	nm735_bodyWritheLegAmplitude,
	nm736_bodyWritheElbowAmplitude,
	nm737_bodyWritheKneeAmplitude,
	nm738_bodyWritheRollOverFlag,
	nm739_bodyWritheBlendArms,
	nm740_bodyWritheBlendBack,
	nm741_bodyWritheBlendLegs,
	nm742_bodyWritheApplyStiffness,
	nm743_legNoiseScale,
	nm744_breathingScale,
	nm745_timeWarpActive,
	nm746_reversingDirection,
	nm747_timeWarpStrengthScale,
	nm748_groundVelocity,
	nm749_frictionScale,
	nm750_restitutionScale,
	nm751_spineBlend,
	nm752_tuneWeaponMass,
	nm753_hardKey,
	nm754_hardKeyMask,
	nm755_hardKeyMaxDeviation,
	nm756_reOrientTime,
	nm757_reOrientScale,
	nm758_runtimeLimitsMargin,
	nm759_supportedHeightThreshold,
	nm760_disableRifleCollision,
	nm761_disableArmCollision,
	nm762_braceTime,
	nm763_remote,
	nm764_localFeedback,
	nm765_lastManStanding,
	nm766_target,
	nm767_stiffness,
	nm768_damping,
	nm769_recovery,
	nm770_part,
	nm771_timeWarpActive,
	nm772_timeWarpStrengthScale,
	nm773_scalePitch,
	nm774_dragScale,
	nm775_dragTime,
	nm776_groundIndex,
	nm777_animPose,
	nm778,
	nm779_muscleStiffness,
	nm780_stiffness,
	nm781_damping,
	nm782_effectorMask,
	nm783_overideHeadlook,
	nm784_overidePointArm,
	nm785_overidePointGun,
	nm786_useGravityCompensation,
	nm787_teeter,
	nm788_teeter,
	nm789_edgeLeft,
	nm790_edgeRight,
	nm791_useExclusionZone,
	nm792_balancerCollisionsReaction,
	nm793_numStepsTillSlump,
	nm794_stable2SlumpTime,
	nm795_exclusionZone,
	nm796_footFrictionMultStart,
	nm797_footFrictionMultRate,
	nm798_backFrictionMultStart,
	nm799_backFrictionMultRate,
	nm800_impactLegStiffReduction,
	nm801_slumpMode,
	nm802_slumpLegStiffReduction,
	nm803_slumpLegStiffRate,
	nm804_reactTime,
	nm805_glanceSpinTime,
	nm806_glanceSpinMag,
	nm807_glanceSpinDecayMult,
	nm808_ignoreColWithIndex,
	nm809_ignoreColMassBelow,
	nm810_ignoreColVolumeBelow,
	nm811_fallOverWallDrape,
	nm812_fallOverHighWalls,
	nm813_fallOverMagOfForce,
	nm814_bouyancy,
	nm815_surfacePoint,
	nm816_surfaceNormal,
	nm817_bouyancy,
	nm818_chestBouyancy,
	nm819_damping,
	nm820_righting,
	nm821_rightingStrength,
	nm822_rightingTime,
	nm823_configureLimits,
	nm824_mask,
	nm825_enable,
	nm826_toDesired,
	nm827_restore,
	nm828_toCurAnimation,
	nm829_index,
	nm830_lean1,
	nm831_lean2,
	nm832_twist,
	nm833_margin,
	nm834_nmstring_end
};
# 63 "C:\\Users\\USER\\Documents\\Visual Studio 2013\\Projects\\mp3_plugin_PS3\\mp3_plugin_PS3\\main.cpp"
# 1 "C:\\Users\\USER\\Documents\\Visual Studio 2013\\Projects\\mp3_plugin_PS3\\mp3_plugin_PS3\\utils.h"
extern "C" int _sys_printf(const char *fmt, ...);


extern "C" int _sys_snprintf(char *buffer, size_t len, const char *fmt, ...);


extern "C" int _sys_sprintf(char *buffer, const char *fmt, ...);


extern "C" int _sys_vprintf(const char *format, va_list arg);


extern "C" int _sys_vsnprintf(char* buffer, std::size_t buf_size, const char* format, va_list arg);


extern "C" int _sys_vsprintf(char *s, const char *format, va_list arg);


extern "C" void *_sys_malloc(size_t size);


extern "C" void _sys_free(void *ptr);


extern "C" void *_sys_memalign(size_t boundary, size_t size);


extern "C" void *_sys_memchr(const void *s, int c, size_t n);


extern "C" int _sys_memcmp(const void * s1, const void * s2, size_t n);


extern "C" void *_sys_memcpy(void *dest, const void *src, size_t n);


extern "C" void *_sys_memset(void *m, int c, size_t n);


extern "C" void *_sys_memmove(void *str1, const void *str2, size_t n);


extern "C" char *_sys_strcat(char *dest, const char *src);


extern "C" char *_sys_strchr(const char *s, int c);


extern "C" int _sys_strcmp(const char * s1, const char * s2);


extern "C" char *_sys_strcpy(char *dest, const char *src);


extern "C" size_t _sys_strlen(const char *str);


extern "C" int _sys_strncasecmp(const char *s1, const char *s2, size_t n);


extern "C" char *_sys_strncat(char *dest, const char *src, size_t n);


extern "C" int _sys_strncmp(const char * s1, const char * s2, size_t n);


extern "C" char *_sys_strncpy(char *dest, const char *src, size_t n);


extern "C" char *_sys_strrchr(const char *s, int c);


extern "C" int _sys_tolower(int c);


extern "C" int _sys_toupper(int c);







































struct opd_s
{
	uint32_t sub;
	uint32_t toc;
};

opd_s ParseAddr(uint32_t sub)
{
	opd_s opd;
	opd.sub = sub;
	opd.toc = 0x1234235;
	_sys_printf("opd_s.sub = 0x%X | opd_s.toc = 0x%X\n", opd.sub, opd.toc);
	return opd;
}
template <typename T>
T(*call(unsigned int address))(...)
{
	T(*func)(...) = (T(*)(...))&ParseAddr(address);
	return func;
}


# 64 "C:\\Users\\USER\\Documents\\Visual Studio 2013\\Projects\\mp3_plugin_PS3\\mp3_plugin_PS3\\main.cpp"
# 1 "C:\\Users\\USER\\Documents\\Visual Studio 2013\\Projects\\mp3_plugin_PS3\\mp3_plugin_PS3\\natives.h"



typedef int Entity;
typedef int Ped;
typedef int Vehicle;
typedef int Cam;
typedef int Group;
typedef int Pickup;
typedef int Object;
typedef int Weapon;
typedef int Blip;
typedef int Camera;
typedef int ScrHandle;
typedef int FireId;
typedef int Rope;
typedef int Interior;
typedef int BOOL;

typedef unsigned int Player;
typedef unsigned long Hash;
typedef unsigned long Void;
typedef unsigned long Any;

struct Request_s
{
	int index;
	int unk;
};

typedef struct Vector3
{
	float x, y, z;
} Vector3;

































































struct nativeHashTable // todo: find proper native table
{
	unsigned int nativeHash;
	unsigned int nativeFunction;
};


unsigned int native_table_address = 0;
unsigned int native_table_modulator = 0;
unsigned int* g_Natives;


#pragma pack(push, 1)
class NativeContext
{
public:
	NativeContext();
	~NativeContext();
	template<typename T>
	inline void nativePush(T Value)
	{
		if (sizeof(T) <= 4)
		{
			*(T*)&m_pArgs[m_nArgCount] = Value;
			m_nArgCount++;
		}
	}
	inline void nativePush(std::string Value)
	{
		nativePush(Value.c_str());
	}
	inline void nativePush(Vector3 Value)
	{
		nativePush(Value.x);
		nativePush(Value.y);
		nativePush(Value.z);
	}
	template<typename R>
	inline R nativeResult()
	{
		R* Result;

		Result = (R*)&m_pReturn[m_uiReadCount];

		m_uiReadCount += sizeof(R);
		if ((sizeof(R) % 4) != 0)
			m_uiReadCount += 4 - (sizeof(R) % 4);

		return *(R*)Result;
	}



	int *			m_CurrentThread;
	int *			m_pReturn;
	unsigned int	m_nArgCount;
	int *			m_pArgs;
	unsigned int	m_uiReadCount;
};
#pragma pack(pop)

NativeContext::NativeContext()
{
	m_nArgCount = 0;
	m_uiReadCount = 0;
	m_pArgs = (int*)_sys_malloc(32 * sizeof(unsigned int));
	m_pReturn = m_pArgs;
}

NativeContext::~NativeContext()
{
	if (m_pReturn)
	{
		_sys_free((void*)m_pReturn);
	}
}







unsigned int GetNativeAddressFromHash(unsigned int hash)
{
	unsigned int modulator = *(unsigned int*)native_table_modulator;

	int index = hash % modulator;
	unsigned int hashTableAddress = *(unsigned int *)g_Natives;
	unsigned int temp_native_hash = hash;

	while (modulator != 0)
	{
		nativeHashTable table = *(nativeHashTable *)(hashTableAddress + 8 * index);
		if (table.nativeHash == hash)
		{
			if (table.nativeFunction != 0 && table.nativeFunction != 0xCDCDCDCD)
			{
				return table.nativeFunction;
			}
		}

		temp_native_hash = (temp_native_hash >> 1) + 1;
		index = (temp_native_hash + index) % modulator;
	}

	return 0;
}
unsigned int GetNativeAddress(char* name)
{
	if (_sys_strlen(name) > 0)
	{
		return GetNativeAddressFromHash(call<unsigned int>(0x0E75894)(name));
	}

	return 0;
}
template <typename R>
inline R nativeCall(unsigned int hash, NativeContext* context)
{
	unsigned int modulator = *(unsigned int*)native_table_modulator;

	int index = hash % modulator;
	unsigned int hashTableAddress = *(unsigned int *)g_Natives;
	unsigned int temp_native_hash = hash;

	while (modulator != 0)
	{
		nativeHashTable table = *(nativeHashTable *)(hashTableAddress + 8 * index);
		if (table.nativeHash == hash)
		{
			if (table.nativeFunction != 0 && table.nativeFunction != 0xCDCDCDCD)
			{
				((void(*)(NativeContext*))table.nativeFunction)(context);
				return context->nativeResult<R>();
			}
		}

		temp_native_hash = (temp_native_hash >> 1) + 1;
		index = (temp_native_hash + index) % modulator;
	}
}
BOOL nativeHook(unsigned int hash, unsigned new_func)
{
	unsigned int modulator = *(unsigned int*)native_table_modulator;

	int index = hash % modulator;
	unsigned int hashTableAddress = *(unsigned int *)g_Natives;
	unsigned int temp_native_hash = hash;

	while (modulator != 0)
	{
		nativeHashTable table = *(nativeHashTable *)(hashTableAddress + 8 * index);
		if (table.nativeHash == hash)
		{
			if (table.nativeFunction != 0 && table.nativeFunction != 0xCDCDCDCD)
			{
				*(unsigned int *)(hashTableAddress + 8 * index + 4) = new_func;
				return 1;
			}
		}

		temp_native_hash = (temp_native_hash >> 1) + 1;
		index = (temp_native_hash + index) % modulator;
	}

	return 0;
}










template <typename R>
static inline R invoke(unsigned int hash)
{
	NativeContext cxt;
	return nativeCall<R>(hash, &cxt);
}

template <typename R, typename T1>
static inline R invoke(unsigned int hash, T1 P1)
{
	NativeContext cxt;

	cxt.nativePush(P1);

	return nativeCall<R>(hash, &cxt);
}

template <typename R, typename T1, typename T2>
static inline R invoke(unsigned int hash, T1 P1, T2 P2)
{
	NativeContext cxt;

	cxt.nativePush(P1);
	cxt.nativePush(P2);

	return nativeCall<R>(hash, &cxt);
}

template <typename R, typename T1, typename T2, typename T3>
static inline R invoke(unsigned int hash, T1 P1, T2 P2, T3 P3)
{
	NativeContext cxt;

	cxt.nativePush(P1);
	cxt.nativePush(P2);
	cxt.nativePush(P3);

	return nativeCall<R>(hash, &cxt);
}

template <typename R, typename T1, typename T2, typename T3, typename T4>
static inline R invoke(unsigned int hash, T1 P1, T2 P2, T3 P3, T4 P4)
{
	NativeContext cxt;

	cxt.nativePush(P1);
	cxt.nativePush(P2);
	cxt.nativePush(P3);
	cxt.nativePush(P4);

	return nativeCall<R>(hash, &cxt);
}

template <typename R, typename T1, typename T2, typename T3, typename T4, typename T5>
static inline R invoke(unsigned int hash, T1 P1, T2 P2, T3 P3, T4 P4, T5 P5)
{
	NativeContext cxt;

	cxt.nativePush(P1);
	cxt.nativePush(P2);
	cxt.nativePush(P3);
	cxt.nativePush(P4);
	cxt.nativePush(P5);

	return nativeCall<R>(hash, &cxt);
}

template <typename R, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6>
static inline R invoke(unsigned int hash, T1 P1, T2 P2, T3 P3, T4 P4, T5 P5, T6 P6)
{
	NativeContext cxt;

	cxt.nativePush(P1);
	cxt.nativePush(P2);
	cxt.nativePush(P3);
	cxt.nativePush(P4);
	cxt.nativePush(P5);
	cxt.nativePush(P6);

	return nativeCall<R>(hash, &cxt);
}

template <typename R, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7>
static inline R invoke(unsigned int hash, T1 P1, T2 P2, T3 P3, T4 P4, T5 P5, T6 P6, T7 P7)
{
	NativeContext cxt;

	cxt.nativePush(P1);
	cxt.nativePush(P2);
	cxt.nativePush(P3);
	cxt.nativePush(P4);
	cxt.nativePush(P5);
	cxt.nativePush(P6);
	cxt.nativePush(P7);

	return nativeCall<R>(hash, &cxt);
}

template <typename R, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8>
static inline R invoke(unsigned int hash, T1 P1, T2 P2, T3 P3, T4 P4, T5 P5, T6 P6, T7 P7, T8 P8)
{
	NativeContext cxt;

	cxt.nativePush(P1);
	cxt.nativePush(P2);
	cxt.nativePush(P3);
	cxt.nativePush(P4);
	cxt.nativePush(P5);
	cxt.nativePush(P6);
	cxt.nativePush(P7);
	cxt.nativePush(P8);

	return nativeCall<R>(hash, &cxt);
}

template <typename R, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9>
static inline R invoke(unsigned int hash, T1 P1, T2 P2, T3 P3, T4 P4, T5 P5, T6 P6, T7 P7, T8 P8, T9 P9)
{
	NativeContext cxt;

	cxt.nativePush(P1);
	cxt.nativePush(P2);
	cxt.nativePush(P3);
	cxt.nativePush(P4);
	cxt.nativePush(P5);
	cxt.nativePush(P6);
	cxt.nativePush(P7);
	cxt.nativePush(P8);
	cxt.nativePush(P9);

	return nativeCall<R>(hash, &cxt);
}

template <typename R, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10>
static inline R invoke(unsigned int hash, T1 P1, T2 P2, T3 P3, T4 P4, T5 P5, T6 P6, T7 P7, T8 P8, T9 P9, T10 P10)
{
	NativeContext cxt;

	cxt.nativePush(P1);
	cxt.nativePush(P2);
	cxt.nativePush(P3);
	cxt.nativePush(P4);
	cxt.nativePush(P5);
	cxt.nativePush(P6);
	cxt.nativePush(P7);
	cxt.nativePush(P8);
	cxt.nativePush(P9);
	cxt.nativePush(P10);

	return nativeCall<R>(hash, &cxt);
}

template <typename R, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11>
static inline R invoke(unsigned int hash, T1 P1, T2 P2, T3 P3, T4 P4, T5 P5, T6 P6, T7 P7, T8 P8, T9 P9, T10 P10, T11 P11)
{
	NativeContext cxt;

	cxt.nativePush(P1);
	cxt.nativePush(P2);
	cxt.nativePush(P3);
	cxt.nativePush(P4);
	cxt.nativePush(P5);
	cxt.nativePush(P6);
	cxt.nativePush(P7);
	cxt.nativePush(P8);
	cxt.nativePush(P9);
	cxt.nativePush(P10);
	cxt.nativePush(P11);

	return nativeCall<R>(hash, &cxt);
}

template <typename R, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12>
static inline R invoke(unsigned int hash, T1 P1, T2 P2, T3 P3, T4 P4, T5 P5, T6 P6, T7 P7, T8 P8, T9 P9, T10 P10, T11 P11, T12 P12)
{
	NativeContext cxt;

	cxt.nativePush(P1);
	cxt.nativePush(P2);
	cxt.nativePush(P3);
	cxt.nativePush(P4);
	cxt.nativePush(P5);
	cxt.nativePush(P6);
	cxt.nativePush(P7);
	cxt.nativePush(P8);
	cxt.nativePush(P9);
	cxt.nativePush(P10);
	cxt.nativePush(P11);
	cxt.nativePush(P12);

	return nativeCall<R>(hash, &cxt);
}

template <typename R, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13>
static inline R invoke(unsigned int hash, T1 P1, T2 P2, T3 P3, T4 P4, T5 P5, T6 P6, T7 P7, T8 P8, T9 P9, T10 P10, T11 P11, T12 P12, T13 P13)
{
	NativeContext cxt;

	cxt.nativePush(P1);
	cxt.nativePush(P2);
	cxt.nativePush(P3);
	cxt.nativePush(P4);
	cxt.nativePush(P5);
	cxt.nativePush(P6);
	cxt.nativePush(P7);
	cxt.nativePush(P8);
	cxt.nativePush(P9);
	cxt.nativePush(P10);
	cxt.nativePush(P11);
	cxt.nativePush(P12);
	cxt.nativePush(P13);

	return nativeCall<R>(hash, &cxt);
}

template <typename R, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14>
static inline R invoke(unsigned int hash, T1 P1, T2 P2, T3 P3, T4 P4, T5 P5, T6 P6, T7 P7, T8 P8, T9 P9, T10 P10, T11 P11, T12 P12, T13 P13, T14 P14)
{
	NativeContext cxt;

	cxt.nativePush(P1);
	cxt.nativePush(P2);
	cxt.nativePush(P3);
	cxt.nativePush(P4);
	cxt.nativePush(P5);
	cxt.nativePush(P6);
	cxt.nativePush(P7);
	cxt.nativePush(P8);
	cxt.nativePush(P9);
	cxt.nativePush(P10);
	cxt.nativePush(P11);
	cxt.nativePush(P12);
	cxt.nativePush(P13);
	cxt.nativePush(P14);

	return nativeCall<R>(hash, &cxt);
}

template <typename R, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15>
static inline R invoke(unsigned int hash, T1 P1, T2 P2, T3 P3, T4 P4, T5 P5, T6 P6, T7 P7, T8 P8, T9 P9, T10 P10, T11 P11, T12 P12, T13 P13, T14 P14, T15 P15)
{
	NativeContext cxt;

	cxt.nativePush(P1);
	cxt.nativePush(P2);
	cxt.nativePush(P3);
	cxt.nativePush(P4);
	cxt.nativePush(P5);
	cxt.nativePush(P6);
	cxt.nativePush(P7);
	cxt.nativePush(P8);
	cxt.nativePush(P9);
	cxt.nativePush(P10);
	cxt.nativePush(P11);
	cxt.nativePush(P12);
	cxt.nativePush(P13);
	cxt.nativePush(P14);
	cxt.nativePush(P15);

	return nativeCall<R>(hash, &cxt);
}

template <typename R, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16>
static inline R invoke(unsigned int hash, T1 P1, T2 P2, T3 P3, T4 P4, T5 P5, T6 P6, T7 P7, T8 P8, T9 P9, T10 P10, T11 P11, T12 P12, T13 P13, T14 P14, T15 P15, T16 P16)
{
	NativeContext cxt;

	cxt.nativePush(P1);
	cxt.nativePush(P2);
	cxt.nativePush(P3);
	cxt.nativePush(P4);
	cxt.nativePush(P5);
	cxt.nativePush(P6);
	cxt.nativePush(P7);
	cxt.nativePush(P8);
	cxt.nativePush(P9);
	cxt.nativePush(P10);
	cxt.nativePush(P11);
	cxt.nativePush(P12);
	cxt.nativePush(P13);
	cxt.nativePush(P14);
	cxt.nativePush(P15);
	cxt.nativePush(P16);

	return nativeCall<R>(hash, &cxt);
}

template <typename R, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17>
static inline R invoke(unsigned int hash, T1 P1, T2 P2, T3 P3, T4 P4, T5 P5, T6 P6, T7 P7, T8 P8, T9 P9, T10 P10, T11 P11, T12 P12, T13 P13, T14 P14, T15 P15, T16 P16, T17 P17)
{
	NativeContext cxt;

	cxt.nativePush(P1);
	cxt.nativePush(P2);
	cxt.nativePush(P3);
	cxt.nativePush(P4);
	cxt.nativePush(P5);
	cxt.nativePush(P6);
	cxt.nativePush(P7);
	cxt.nativePush(P8);
	cxt.nativePush(P9);
	cxt.nativePush(P10);
	cxt.nativePush(P11);
	cxt.nativePush(P12);
	cxt.nativePush(P13);
	cxt.nativePush(P14);
	cxt.nativePush(P15);
	cxt.nativePush(P16);
	cxt.nativePush(P17);

	return nativeCall<R>(hash, &cxt);
}

template <typename R, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17, typename T18>
static inline R invoke(unsigned int hash, T1 P1, T2 P2, T3 P3, T4 P4, T5 P5, T6 P6, T7 P7, T8 P8, T9 P9, T10 P10, T11 P11, T12 P12, T13 P13, T14 P14, T15 P15, T16 P16, T17 P17, T18 P18)
{
	NativeContext cxt;

	cxt.nativePush(P1);
	cxt.nativePush(P2);
	cxt.nativePush(P3);
	cxt.nativePush(P4);
	cxt.nativePush(P5);
	cxt.nativePush(P6);
	cxt.nativePush(P7);
	cxt.nativePush(P8);
	cxt.nativePush(P9);
	cxt.nativePush(P10);
	cxt.nativePush(P11);
	cxt.nativePush(P12);
	cxt.nativePush(P13);
	cxt.nativePush(P14);
	cxt.nativePush(P15);
	cxt.nativePush(P16);
	cxt.nativePush(P17);
	cxt.nativePush(P18);

	return nativeCall<R>(hash, &cxt);
}

template <typename R, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17, typename T18, typename T19>
static inline R invoke(unsigned int hash, T1 P1, T2 P2, T3 P3, T4 P4, T5 P5, T6 P6, T7 P7, T8 P8, T9 P9, T10 P10, T11 P11, T12 P12, T13 P13, T14 P14, T15 P15, T16 P16, T17 P17, T18 P18, T19 P19)
{
	NativeContext cxt;

	cxt.nativePush(P1);
	cxt.nativePush(P2);
	cxt.nativePush(P3);
	cxt.nativePush(P4);
	cxt.nativePush(P5);
	cxt.nativePush(P6);
	cxt.nativePush(P7);
	cxt.nativePush(P8);
	cxt.nativePush(P9);
	cxt.nativePush(P10);
	cxt.nativePush(P11);
	cxt.nativePush(P12);
	cxt.nativePush(P13);
	cxt.nativePush(P14);
	cxt.nativePush(P15);
	cxt.nativePush(P16);
	cxt.nativePush(P17);
	cxt.nativePush(P18);
	cxt.nativePush(P19);

	return nativeCall<R>(hash, &cxt);
}

template <typename R, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17, typename T18, typename T19, typename T20>
static inline R invoke(unsigned int hash, T1 P1, T2 P2, T3 P3, T4 P4, T5 P5, T6 P6, T7 P7, T8 P8, T9 P9, T10 P10, T11 P11, T12 P12, T13 P13, T14 P14, T15 P15, T16 P16, T17 P17, T18 P18, T19 P19, T20 P20)
{
	NativeContext cxt;

	cxt.nativePush(P1);
	cxt.nativePush(P2);
	cxt.nativePush(P3);
	cxt.nativePush(P4);
	cxt.nativePush(P5);
	cxt.nativePush(P6);
	cxt.nativePush(P7);
	cxt.nativePush(P8);
	cxt.nativePush(P9);
	cxt.nativePush(P10);
	cxt.nativePush(P11);
	cxt.nativePush(P12);
	cxt.nativePush(P13);
	cxt.nativePush(P14);
	cxt.nativePush(P15);
	cxt.nativePush(P16);
	cxt.nativePush(P17);
	cxt.nativePush(P18);
	cxt.nativePush(P19);
	cxt.nativePush(P20);

	return nativeCall<R>(hash, &cxt);
}

template <typename R, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17, typename T18, typename T19, typename T20, typename T21>
static inline R invoke(unsigned int hash, T1 P1, T2 P2, T3 P3, T4 P4, T5 P5, T6 P6, T7 P7, T8 P8, T9 P9, T10 P10, T11 P11, T12 P12, T13 P13, T14 P14, T15 P15, T16 P16, T17 P17, T18 P18, T19 P19, T20 P20, T21 P21)
{
	NativeContext cxt;

	cxt.nativePush(P1);
	cxt.nativePush(P2);
	cxt.nativePush(P3);
	cxt.nativePush(P4);
	cxt.nativePush(P5);
	cxt.nativePush(P6);
	cxt.nativePush(P7);
	cxt.nativePush(P8);
	cxt.nativePush(P9);
	cxt.nativePush(P10);
	cxt.nativePush(P11);
	cxt.nativePush(P12);
	cxt.nativePush(P13);
	cxt.nativePush(P14);
	cxt.nativePush(P15);
	cxt.nativePush(P16);
	cxt.nativePush(P17);
	cxt.nativePush(P18);
	cxt.nativePush(P19);
	cxt.nativePush(P20);
	cxt.nativePush(P21);

	return nativeCall<R>(hash, &cxt);
}

template <typename R, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17, typename T18, typename T19, typename T20, typename T21, typename T22>
static inline R invoke(unsigned int hash, T1 P1, T2 P2, T3 P3, T4 P4, T5 P5, T6 P6, T7 P7, T8 P8, T9 P9, T10 P10, T11 P11, T12 P12, T13 P13, T14 P14, T15 P15, T16 P16, T17 P17, T18 P18, T19 P19, T20 P20, T21 P21, T22 P22)
{
	NativeContext cxt;

	cxt.nativePush(P1);
	cxt.nativePush(P2);
	cxt.nativePush(P3);
	cxt.nativePush(P4);
	cxt.nativePush(P5);
	cxt.nativePush(P6);
	cxt.nativePush(P7);
	cxt.nativePush(P8);
	cxt.nativePush(P9);
	cxt.nativePush(P10);
	cxt.nativePush(P11);
	cxt.nativePush(P12);
	cxt.nativePush(P13);
	cxt.nativePush(P14);
	cxt.nativePush(P15);
	cxt.nativePush(P16);
	cxt.nativePush(P17);
	cxt.nativePush(P18);
	cxt.nativePush(P19);
	cxt.nativePush(P20);
	cxt.nativePush(P21);
	cxt.nativePush(P22);

	return nativeCall<R>(hash, &cxt);
}

template <typename R, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17, typename T18, typename T19, typename T20, typename T21, typename T22, typename T23>
static inline R invoke(unsigned int hash, T1 P1, T2 P2, T3 P3, T4 P4, T5 P5, T6 P6, T7 P7, T8 P8, T9 P9, T10 P10, T11 P11, T12 P12, T13 P13, T14 P14, T15 P15, T16 P16, T17 P17, T18 P18, T19 P19, T20 P20, T21 P21, T22 P22, T23 P23)
{
	NativeContext cxt;

	cxt.nativePush(P1);
	cxt.nativePush(P2);
	cxt.nativePush(P3);
	cxt.nativePush(P4);
	cxt.nativePush(P5);
	cxt.nativePush(P6);
	cxt.nativePush(P7);
	cxt.nativePush(P8);
	cxt.nativePush(P9);
	cxt.nativePush(P10);
	cxt.nativePush(P11);
	cxt.nativePush(P12);
	cxt.nativePush(P13);
	cxt.nativePush(P14);
	cxt.nativePush(P15);
	cxt.nativePush(P16);
	cxt.nativePush(P17);
	cxt.nativePush(P18);
	cxt.nativePush(P19);
	cxt.nativePush(P20);
	cxt.nativePush(P21);
	cxt.nativePush(P22);
	cxt.nativePush(P23);

	return nativeCall<R>(hash, &cxt);
}

template <typename R, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17, typename T18, typename T19, typename T20, typename T21, typename T22, typename T23, typename T24>
static inline R invoke(unsigned int hash, T1 P1, T2 P2, T3 P3, T4 P4, T5 P5, T6 P6, T7 P7, T8 P8, T9 P9, T10 P10, T11 P11, T12 P12, T13 P13, T14 P14, T15 P15, T16 P16, T17 P17, T18 P18, T19 P19, T20 P20, T21 P21, T22 P22, T23 P23, T24 P24)
{
	NativeContext cxt;

	cxt.nativePush(P1);
	cxt.nativePush(P2);
	cxt.nativePush(P3);
	cxt.nativePush(P4);
	cxt.nativePush(P5);
	cxt.nativePush(P6);
	cxt.nativePush(P7);
	cxt.nativePush(P8);
	cxt.nativePush(P9);
	cxt.nativePush(P10);
	cxt.nativePush(P11);
	cxt.nativePush(P12);
	cxt.nativePush(P13);
	cxt.nativePush(P14);
	cxt.nativePush(P15);
	cxt.nativePush(P16);
	cxt.nativePush(P17);
	cxt.nativePush(P18);
	cxt.nativePush(P19);
	cxt.nativePush(P20);
	cxt.nativePush(P21);
	cxt.nativePush(P22);
	cxt.nativePush(P23);
	cxt.nativePush(P24);

	return nativeCall<R>(hash, &cxt);
}

template <typename R, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9, typename T10, typename T11, typename T12, typename T13, typename T14, typename T15, typename T16, typename T17, typename T18, typename T19, typename T20, typename T21, typename T22, typename T23, typename T24, typename T25>
static inline R invoke(unsigned int hash, T1 P1, T2 P2, T3 P3, T4 P4, T5 P5, T6 P6, T7 P7, T8 P8, T9 P9, T10 P10, T11 P11, T12 P12, T13 P13, T14 P14, T15 P15, T16 P16, T17 P17, T18 P18, T19 P19, T20 P20, T21 P21, T22 P22, T23 P23, T24 P24, T25 P25)
{
	NativeContext cxt;

	cxt.nativePush(P1);
	cxt.nativePush(P2);
	cxt.nativePush(P3);
	cxt.nativePush(P4);
	cxt.nativePush(P5);
	cxt.nativePush(P6);
	cxt.nativePush(P7);
	cxt.nativePush(P8);
	cxt.nativePush(P9);
	cxt.nativePush(P10);
	cxt.nativePush(P11);
	cxt.nativePush(P12);
	cxt.nativePush(P13);
	cxt.nativePush(P14);
	cxt.nativePush(P15);
	cxt.nativePush(P16);
	cxt.nativePush(P17);
	cxt.nativePush(P18);
	cxt.nativePush(P19);
	cxt.nativePush(P20);
	cxt.nativePush(P21);
	cxt.nativePush(P22);
	cxt.nativePush(P23);
	cxt.nativePush(P24);
	cxt.nativePush(P25);

	return nativeCall<R>(hash, &cxt);
}














































namespace SYSTEM
{
	static int TIMERA() { return invoke<int>(0x45C8C188); }
	static int TIMERB() { return invoke<int>(0x330A9C0C); }
	static int TIMERSYSTEM() { return invoke<int>(0x845A1774); }
	static void SETTIMERA(int value) { invoke<Void>(0x35785333, value); }
	static void SETTIMERB(int value) { invoke<Void>(0x27C1B7C6, value); } // unused
	static void SETTIMERSYSTEM(int value) { invoke<Void>(0x12542514, value); } // unused
	static float TIMESTEP() { return invoke<float>(0x50597EE2); }
	static float TIMESTEPUNWARPED() { return invoke<float>(0x99B02B53); } // unused
	static void WAIT(int ms) { invoke<Void>(0x7715C03B, ms); }
	static void WAITUNWARPED(int ms) { invoke<Void>(0x01185F9B, ms); } // unused
	static void WAITUNPAUSED(int ms) { invoke<Void>(0x7C496803, ms); } // unused
	static void PRINTSTRING(char* str) { invoke<Void>(0xECF8EB5F, str); }
	static void PRINTFLOAT(float value) { invoke<Void>(0xD48B90B6, value); }
	static void PRINTFLOAT2(Any p0, Any p1, float value) { invoke<Void>(0x3983593A, p0, p1, value); } // unused
	static void PRINTINT(int value) { invoke<Void>(0x63651F03, value); }
	static void PRINTINT2(int value, Any p1) { invoke<Void>(0x83B2E331, value, p1); } // unused
	static void PRINTNL() { invoke<Void>(0x868997DA); }
	static void PRINTVECTOR(float x, float y, float z) { invoke<Void>(0x085F31FB, x, y, z); }
	static void BREAKPOINT() { invoke<Void>(0xEFEAFB91); } // unused
	static float SIN(float value) { return invoke<float>(0xBF987F58, value); }
	static float COS(float value) { return invoke<float>(0x00238FE9, value); }
	static float SQRT(float value) { return invoke<float>(0x145C7701, value); }
	static float POW(float base, float exponent) { return invoke<float>(0x85D134F8, base, exponent); } // unused
	static float EXP(float value) { return invoke<float>(0xE2313450, value); } // unused
	static float VMAG(float x, float y, float z) { return invoke<float>(0x1FCF1ECD, x, y, z); }
	static float VMAG2(float x, float y, float z) { return invoke<float>(0xE796E629, x, y, z); }
	static float VDIST(float x1, float y1, float z1, float x2, float y2, float z2) { return invoke<float>(0x3C08ECB7, x1, y1, z1, x2, y2, z2); }
	static float VDIST2(float x1, float y1, float z1, float x2, float y2, float z2) { return invoke<float>(0xC85DEF1F, x1, y1, z1, x2, y2, z2); }
	static int SHIFT_LEFT(int value, int bitShift) { return invoke<int>(0x314CC6CD, value, bitShift); } // unused
	static int SHIFT_RIGHT(int value, int bitShift) { return invoke<int>(0x352633CA, value, bitShift); } // unused
	static int START_NEW_SCRIPT(char* scriptName, int stackSize) { return invoke<int>(0x3F166D0E, scriptName, stackSize); }
	static int START_NEW_SCRIPT_WITH_ARGS(char* scriptName, Any* args, int argCount, int stackSize) { return invoke<int>(0x4A2100E4, scriptName, args, argCount, stackSize); } // unused
	static int START_NEW_SCRIPT_TYPED(char* scriptName, int stackSize, int unk) { return invoke<int>(0x9EE416E7, scriptName, stackSize, unk); }
	static int START_NEW_SCRIPT_TYPED_WITH_ARGS(char* scriptName, Any* args, int argCount, int stackSize, int unk) { return invoke<int>(0x50A1D455, scriptName, args, argCount, stackSize, unk); } // unused
	static int FLOOR(float value) { return invoke<int>(0x32E9BE04, value); }
	static int CEIL(float value) { return invoke<int>(0xD536A1DF, value); }
	static int ROUND(float value) { return invoke<int>(0x323B0E24, value); }
	static float TO_FLOAT(int value) { return invoke<float>(0x67116627, value); }
	static void SNAPSHOT_GLOBALS() { invoke<Void>(0x5A25520E); } // unused
	static void CLEAR_TEXT_LABEL(char* textLabel) { invoke<Void>(0xA66AAE8F, textLabel); } // unused
}

namespace AICOMBATACTION
{
	static void CREATE_AICOMBATACTION_COVERENTER(char* p0, char* p1, char* p2) { invoke<Void>(0xB1F504D9, p0, p1, p2); } // unused
}

namespace AUDIO
{
	static int CREATE_NEW_SCRIPTED_CONVERSATION(int p0) { return invoke<int>(0xB2BC25F8, p0); }
	static void SET_CONVERSATION_CHECK_HASH(int index, Hash hash) { invoke<Void>(0x0937CE9E, index, hash); }
	static void ADD_LINE_TO_CONVERSATION(int index, int p1, char* p2, char* p3, int p4, int p5, int p6, BOOL p7, BOOL p8) { invoke<Void>(0x96CD0513, index, p1, p2, p3, p4, p5, p6, p7, p8); }
	static void ADD_PED_TO_CONVERSATION(int index, int speakerConversationIndex, Ped ped, char* p3) { invoke<Void>(0xF8D5EB86, index, speakerConversationIndex, ped, p3); } // unused
	static void ADD_PED_TO_CONVERSATION_ENUM(int index, int speakerConversationIndex, Ped ped, Hash p3) { invoke<Void>(0x53CF1845, index, speakerConversationIndex, ped, p3); }
	static Any START_SCRIPTED_CONVERSATION() { return invoke<Any>(0x07E4CB1E); } // unused
	static void START_SCRIPT_CONVERSATION(int index, BOOL p1, BOOL p2) { invoke<Void>(0xE5DE7D9D, index, p1, p2); }
	static Any IS_SCRIPTED_CONVERSATION_ONGOING(Any p0) { return invoke<Any>(0xCB8FD96F, p0); }
	static Any GET_CURRENT_SCRIPTED_CONVERSATION_LINE() { return invoke<Any>(0x9620E41F); } // unused
	static Any PAUSE_SCRIPTED_CONVERSATION() { return invoke<Any>(0xE2C9C6F8); } // unused
	static Any STOP_SCRIPTED_CONVERSATION(Any p0, Any p1, Any p2) { return invoke<Any>(0xAB77DA7D, p0, p1, p2); }
	static void STOP_ALL_SCRIPTED_CONVERSATIONS(Any p0) { invoke<Void>(0xCBE79A01, p0); }
	static Any PRIVATE_SKIP_TO_NEXT_SCRIPTED_CONVERSATION_LINE() { return invoke<Any>(0xB528AEA6); } // unused
	static Any GET_CHECK_HASH_FROM_CONVERSATION_ID(Any p0) { return invoke<Any>(0x312BFBAB, p0); }
	static Any GET_SPEECH_FOR_EMERGENCY_SERVICE_CALL() { return invoke<Any>(0xEDE519D6); } // unused
	static Any PLAY_AUDIO_EVENT() { return invoke<Any>(0x4B31CE89); } // unused
	static void PLAY_AUDIO_EVENT_FROM_PED(Any p0, Any p1) { invoke<Void>(0x1AB792DA, p0, p1); }
	static Any PLAY_AUDIO_EVENT_FROM_VEHICLE() { return invoke<Any>(0x0B7DC5C8); } // unused
	static void PLAY_AUDIO_EVENT_FROM_OBJECT(Any p0, Any p1) { invoke<Void>(0x0C5DB6A5, p0, p1); }
	static void PLAY_COMPANION_DEATH_GUNSHOT(Ped ped) { invoke<Void>(0x52AEE5E6, ped); } // unused
	static BOOL IS_SCRIPT_AUDIO_BANK_LOADED(char* name, BOOL p1) { return invoke<BOOL>(0x8CCF6840, name, p1); }
	static BOOL LOAD_SCRIPT_AUDIO_BANK(char* name) { return invoke<BOOL>(0xF0346449, name); }
	static BOOL REQUEST_SCRIPT_AUDIO_BANK(char* name) { return invoke<BOOL>(0x21322887, name); }
	static void RELEASE_SCRIPT_AUDIO_BANK() { invoke<Void>(0x22F865E5); }
	static void RELEASE_NAMED_SCRIPT_AUDIO_BANK(char* name) { invoke<Void>(0x16707ABC, name); }
	static int GET_SOUND_ID() { return invoke<int>(0x6AE0AD56); }
	static void RELEASE_SOUND_ID(int soundId) { invoke<Void>(0x9C080899, soundId); }
	static void PLAY_SOUND(int soundId, char* soundName) { invoke<Void>(0xB6E1917F, soundId, soundName); } // unused
	static void PLAY_SOUND_FRONTEND(int soundId, char* soundName) { invoke<Void>(0x2E458F74, soundId, soundName); }
	static void PLAY_SOUND_FROM_PED(int soundId, char* soundName, Ped ped) { invoke<Void>(0x1D6D6AC3, soundId, soundName, ped); }
	static void PLAY_SOUND_FROM_VEHICLE(int soundId, char* soundName, Vehicle vehicle) { invoke<Void>(0x8A5F9685, soundId, soundName, vehicle); }
	static void PLAY_SOUND_FROM_COORD(int soundId, char* soundName, float x, float y, float z) { invoke<Void>(0xCAD3E2D5, soundId, soundName, x, y, z); }
	static void PLAY_FIRE_SOUND_FROM_COORD(int soundId, float x, float y, float z) { invoke<Void>(0x2EFD64B3, soundId, x, y, z); } // unused
	static void PLAY_SOUND_FROM_OBJECT(int soundId, char* soundName, Object object) { invoke<Void>(0x6A515A49, soundId, soundName, object); }
	static void STOP_SOUND(int soundId, BOOL p1) { invoke<Void>(0xCD7F4030, soundId, p1); }
	static void SET_VARIABLE_ON_SOUND(int soundId, char* variableName, float value) { invoke<Void>(0x606EE5FA, soundId, variableName, value); }
	static BOOL HAS_SOUND_FINISHED(int soundId) { return invoke<BOOL>(0xE85AEC2E, soundId); }
	static void AUDIO_RESET_PED_DEAD_SPEECH_FLAG(Ped ped) { invoke<Void>(0x15256E0C, ped); }
	static void SCREAM(Ped ped) { invoke<Void>(0xD1956683, ped); } // unused
	static void PLAY_PED_AMBIENT_SPEECH(Ped ped, char* speech, BOOL p2, BOOL p3, int p4, BOOL p5, int p6) { invoke<Void>(0xB4EB114E, ped, speech, p2, p3, p4, p5, p6); }
	static void PLAY_PED_AMBIENT_SPEECH_WITH_VOICE(Ped ped, char* speech, char* voice, BOOL p3, BOOL p4, int p5, BOOL p6, int p7) { invoke<Void>(0xA3E3390C, ped, speech, voice, p3, p4, p5, p6, p7); } // unused
	static void PRELOAD_ANNOUNCER_SPEECH(char* name, BOOL p1) { invoke<Void>(0x92DE336C, name, p1); }
	static void PLAY_PRELOADED_ANNOUNCER_SPEECH() { invoke<Void>(0x2B508AA3); }
	static void PLAY_PRELOADED_SPEECH(Ped ped) { invoke<Void>(0xC7F2260A, ped); } // unused
	static void PLAY_RELIEF_SIGH(Ped ped) { invoke<Void>(0x622C486D, ped); } // unused
	static void SET_AMBIENT_VOICE_NAME(Ped ped, char* voiceName, float p2) { invoke<Void>(0xBD2EA1A1, ped, voiceName, p2); } // unused
	static void SET_PED_VOICE_FULL(Ped ped) { invoke<Void>(0x7A7C24DD, ped); } // unused
	static void SET_VOICE_ID_FROM_HEAD_COMPONENT(Ped ped, int unused1, BOOL unused2) { invoke<Void>(0x84EDB1B8, ped, unused1, unused2); } // unused
	static void STOP_CURRENT_PLAYING_AMBIENT_SPEECH(Ped ped) { invoke<Void>(0xBB8E64BF, ped); }
	static BOOL IS_AMBIENT_SPEECH_PLAYING(Ped ped) { return invoke<BOOL>(0x1972E8AA, ped); } // unused
	static BOOL IS_SCRIPTED_SPEECH_PLAYING(Ped ped) { return invoke<BOOL>(0x2C653904, ped); }
	static BOOL IS_ANY_SPEECH_PLAYING(Ped ped) { return invoke<BOOL>(0x2B74A6D6, ped); }
	static BOOL IS_MONOLOGUE_PLAYING() { return invoke<BOOL>(0xF6006ECB); }
	static int TIME_SINCE_LAST_MONOLOGUE() { return invoke<int>(0x4B91ACE8); }
	static void PLAY_PED_AUDIO_EVENT_ANIM(Ped ped, char* p1) { invoke<Void>(0x2CDC0A7A, ped, p1); } // unused
	static void PLAY_END_CREDITS_MUSIC(BOOL play) { invoke<Void>(0x8E88B3CC, play); }
	static int GET_CUTSCENE_AUDIO_TIME_MS() { return invoke<int>(0xCA56C61D); }
	static void STOP_CUTSCENE_AUDIO() { invoke<Void>(0x55461BE6); }
	static void SET_GAMEWORLD_AUDIO_MUTE(BOOL toggle) { invoke<Void>(0xFAC2EDD0, toggle); }
	static void _SET_UNK_AUDIO_MUTE(BOOL toggle) { invoke<Void>(0x9F3090EF, toggle); } // unused
	static void SILENCE_VEHICLE(Vehicle vehicle, BOOL toggle) { invoke<Void>(0xA7250DE3, vehicle, toggle); }
	static Any SET_TRAIN_AUDIO_ROLLOFF() { return invoke<Any>(0x56F2F2E9); } // unused
	static Any SET_HELI_AUDIO_MAX_OCCLUSION() { return invoke<Any>(0x57125C3F); } // unused
	static Any SET_COLLISION_AUDIO_DISABLED() { return invoke<Any>(0xB8DD4243); } // unused
	static Any GET_SCRIPT_STREAM_STATE(Any p0, Any p1) { return invoke<Any>(0xE2F9A12A, p0, p1); }
	static Any LOAD_SCRIPT_STREAM(Any p0, Any p1) { return invoke<Any>(0xB99CBFB5, p0, p1); }
	static Any REQUEST_SCRIPT_STREAM(Any p0, Any p1) { return invoke<Any>(0xD5782CC7, p0, p1); }
	static Any CLEAR_SCRIPT_STREAM_REQUESTS() { return invoke<Any>(0x108F237A); } // unused
	static void PLAY_SCRIPT_STREAM_FROM_PED(Any p0, Any p1) { invoke<Void>(0xD774E920, p0, p1); }
	static void PLAY_SCRIPT_STREAM_FROM_OBJECT(Any p0, Any p1) { invoke<Void>(0x53558097, p0, p1); }
	static void PLAY_SCRIPT_STREAM_FROM_VEHICLE(Any p0, Any p1) { invoke<Void>(0x23B01838, p0, p1); }
	static void PLAY_SCRIPT_STREAM_FROM_COORD(Any p0, Any p1, Any p2, Any p3) { invoke<Void>(0x3C976ECC, p0, p1, p2, p3); }
	static void PLAY_SCRIPT_STREAM_FRONTEND(Any p0) { invoke<Void>(0xFE8558E8, p0); }
	static void PLAY_SCRIPT_STREAM_FRONTEND_INT(Any p0, Any p1) { invoke<Void>(0x73CB1718, p0, p1); }
	static void STOP_SCRIPT_STREAM(Any p0) { invoke<Void>(0xD6CA123C, p0); }
	static void ENABLE_PED_PAIN(Ped ped, BOOL toggle) { invoke<Void>(0xB2AE469E, ped, toggle); }
	static void STOP_PED_SPEAKING(Ped ped, BOOL toggle) { invoke<Void>(0xFF92B49D, ped, toggle); }
	static BOOL IS_AMBIENT_SPEECH_DISABLED(Ped ped) { return invoke<BOOL>(0x109D1F89, ped); } // unused
	static Any AUDIO_SET_PLAYER_PAIN_NAME() { return invoke<Any>(0xE8A10A1A); } // unused
	static Any AUDIO_SET_SIDEKICK_PAIN_NAME() { return invoke<Any>(0x7C64FB16); } // unused
	static void SET_SIREN_WITH_NO_DRIVER(Vehicle vehicle, BOOL toggle) { invoke<Void>(0x77182D58, vehicle, toggle); } // unused
	static BOOL IS_GAME_IN_CONTROL_OF_MUSIC() { return invoke<BOOL>(0x7643170D); } // unused
	static void SET_END_CREDITS_FADE_ACTIVE(BOOL toggle) { invoke<Void>(0xB8408EB9, toggle); } // unused
	static int AUD_GET_ANIM_MARKER_LEVEL() { return invoke<int>(0x8A44F752); }
	static void ENABLE_AMBIENT_ZONE(char* zoneName, BOOL toggle) { invoke<Void>(0xD20ABC53, zoneName, toggle); }
	static void ENABLE_WALLA_ZONE(char* zoneName, BOOL toggle) { invoke<Void>(0x41CBE852, zoneName, toggle); }
	static void ENABLE_STATIC_EMITTER(char* emitterName, BOOL toggle) { invoke<Void>(0x3A1AB545, emitterName, toggle); }
	static void SET_STATIC_EMITTER_VOLUME(char* emitterName, float volume) { invoke<Void>(0xFDF95AA4, emitterName, volume); }
	static void CHANGE_STATIC_EMITTER_SOUND(char* emitterName, char* soundName) { invoke<Void>(0x05788865, emitterName, soundName); } // unused
	static void ENABLE_AMBIENT_STREAM(char* streamName, BOOL toggle) { invoke<Void>(0xBBE7F424, streamName, toggle); }
	static Any CHANGE_AMBIENT_STREAM_SOUND() { return invoke<Any>(0xAAA16BCB); } // unused
	static void SET_FADE_MUTE_OVERRIDE(Any p0) { invoke<Void>(0x0A31CE81, p0); }
	static Any SET_LOBBY_MUTE_OVERRIDE() { return invoke<Any>(0x35BA6682); } // unused
	static void ENABLE_AUDIO_MISSION_FLAG(int p0, BOOL toggle) { invoke<Void>(0x5B1A1397, p0, toggle); }
	static void AUD_SET_IS_POWER_ON(BOOL toggle) { invoke<Void>(0xAB429BE9, toggle); }
	static void TRIGGER_THUNDER(float p0, BOOL p1) { invoke<Void>(0x57360FB9, p0, p1); }
	static void TRIGGER_LIGHTNING(BOOL p0) { invoke<Void>(0xB53EE377, p0); }
	static void PLAY_MUSIC(char* musicName, int p1) { invoke<Void>(0x28C17DAF, musicName, p1); } // unused
	static void STOP_MUSIC() { invoke<Void>(0x84A658A1); } // unused
	static void ENABLE_AUDIO_MIX_LAYER(int p0, BOOL p1, float p2, int p3) { invoke<Void>(0xE9DB6185, p0, p1, p2, p3); }
	static void TRIGGER_EXPLOSION_AUDIO_MIX_LAYER(Any p0, Any p1, Any p2, Any p3) { invoke<Void>(0xDA1CBE98, p0, p1, p2, p3); }
	static void TRIGGER_EXPLOSION_AUDIO_FROM_PED(Any p0, Any p1) { invoke<Void>(0x7A936A56, p0, p1); }
	static Any TRIGGER_EXPLOSION_AUDIO_FROM_OBJECT() { return invoke<Any>(0xD4807989); } // unused
	static void TRIGGER_EXPLOSION_AUDIO_FROM_COORDS(Any p0, Any p1, Any p2, Any p3) { invoke<Void>(0x02C7F4F0, p0, p1, p2, p3); }
	static void MUTE_EXPLOSIONS() { invoke<Void>(0x325CC231); } // unused
	static void UNMUTE_EXPLOSIONS() { invoke<Void>(0x72A9758E); } // unused
	static void ENABLE_HEARTBEAT_RUMBLE(BOOL toggle) { invoke<Void>(0x0B6FC8F5, toggle); }
	static void ENABLE_TINNITUS(BOOL toggle) { invoke<Void>(0xBB3BD914, toggle); }
	static void ENABLE_MPM(BOOL toggle) { invoke<Void>(0x1A8BD82F, toggle); }
	static void SET_DEATH_STATE_ACTIVE(BOOL toggle) { invoke<Void>(0xD4CE933A, toggle); } // unused
	static void AUDIO_ENABLE_HEALTH_MIX(BOOL toggle) { invoke<Void>(0xA7D06400, toggle); }
	static void AUDIO_ENABLE_FE_MUSIC(BOOL toggle) { invoke<Void>(0x2F7AFED9, toggle); }
	static void SET_PED_HAS_SPECIAL_GUN_SOUND(Ped ped, BOOL toggle) { invoke<Void>(0x24A0BE24, ped, toggle); }
	static void SET_PED_IS_HUMAN_SHIELD(Ped ped, BOOL toggle) { invoke<Void>(0x697C85BD, ped, toggle); }
	static void AUDIO_IGNORE_NEXT_WARP_TRANSITION_SOUND() { invoke<Void>(0xA9CC919C); }
	static Any LOAD_BULLET_CAM_BANK() { return invoke<Any>(0xCE805879); } // unused
	static void AUDIO_MUSIC_FORCE_TRACK(Any p0, Any p1, Any p2, Any p3, Any p4, Any p5, Any p6, Any p7) { invoke<Void>(0xA2A356A7, p0, p1, p2, p3, p4, p5, p6, p7); }
	static Any AUDIO_MUSIC_FORCE_TRACK_HASH() { return invoke<Any>(0x6CEFA97A); } // unused
	static void AUDIO_MUSIC_SET_MOOD(char* p0, char* p1, float p2, int p3, int p4) { invoke<Void>(0x633B8905, p0, p1, p2, p3, p4); }
	static Any AUDIO_MUSIC_ONE_SHOT() { return invoke<Any>(0x714DA5BB); } // unused
	static Any AUDIO_MUSIC_PLAY_PREPARED() { return invoke<Any>(0x7CC2738F); } // unused
	static void AUDIO_MUSIC_ADJUST_VOLUME(Any p0) { invoke<Void>(0xA34A3F55, p0); }
	static Any AUDIO_MUSIC_IS_PREPARED() { return invoke<Any>(0xBF316157); } // unused
	static Any AUDIO_MUSIC_SET_STATE() { return invoke<Any>(0x789C753C); } // unused
	static Any AUDIO_MUSIC_RELEASE_CONTROL() { return invoke<Any>(0xA3A2984E); } // unused
	static void AUDIO_MUSIC_SUSPEND(int p0) { invoke<Void>(0x56E3D235, p0); }
	static Any AUDIO_MUSIC_RESUME() { return invoke<Any>(0x5F48A85B); } // unused
	static BOOL AUDIO_IS_MUSIC_PLAYING() { return invoke<BOOL>(0x84435231); }
	static BOOL AUDIO_IS_SCRIPTED_MUSIC_PLAYING() { return invoke<BOOL>(0x86E995D1); }
	static Any AUDIO_IS_FRONTEND_MUSIC_PLAYING() { return invoke<Any>(0x9EC502D6); } // unused
	static Any AUDIO_MUSIC_SET_SUSPENSE_ALLOWED() { return invoke<Any>(0xE0DE16BD); } // unused
	static Any AUDIO_MUSIC_PLAY_UNSCRIPTED_NOW() { return invoke<Any>(0xE2A37056); } // unused
	static Any AUDIO_MUSIC_GET_MS_UNTIL_AUDIO_SYNC() { return invoke<Any>(0x02CBEC97); } // unused
	static Any AUDIO_MUSIC_IS_AUDIO_SYNC_NOW() { return invoke<Any>(0xED9CA16F); } // unused
	static Any AUDIO_MUSIC_CLEAR_AUDIO_SYNC_VARIABLES() { return invoke<Any>(0xE73CA44B); } // unused
	static Any AUDIO_MUSIC_IS_MARKER_IN_RANGE() { return invoke<Any>(0xAAB5C232); } // unused
	static Any AUDIO_IS_CUTSCENE_PLAYING() { return invoke<Any>(0xE026C62E); } // unused
	static Any AUDIO_MUSIC_REQUEST_ONESHOT(Any p0, Any p1) { return invoke<Any>(0x607773A0, p0, p1); }
	static Any AUDIO_MUSIC_PRELOAD_ONESHOT(Any p0, Any p1) { return invoke<Any>(0x404A0AE6, p0, p1); }
	static void AUDIO_MUSIC_PLAY_ONESHOT() { invoke<Void>(0x8229B903); }
	static void AUDIO_MUSIC_STOP_ONESHOT() { invoke<Void>(0xD92E534F); }
	static Any AUDIO_MUSIC_IS_ONESHOT_PREPARED(Any p0) { return invoke<Any>(0x0CF2727F, p0); }
	static void AUDIO_SET_PED_FOOTSTEPS_ON(Any p0) { invoke<Void>(0x17FEF7EA, p0); }
	static Any AUDIO_SET_SINGLE_PED_FOOTSTEPS_ON() { return invoke<Any>(0x0B15ADFA); } // unused
	static void AUDIO_SET_PED_FOOTSTEPS_VOLUME(Any p0, Any p1) { invoke<Void>(0x85DA7899, p0, p1); }
	static Any AUDIO_SET_PED_FOOTSTEPS_ROLLOFF() { return invoke<Any>(0xB125E896); } // unused
	static Any AUDIO_DISABLE_WADING_SOUNDS() { return invoke<Any>(0x6A9FF2B8); } // unused
	static void AUDIO_ENABLE_TV_MOVIE(BOOL toggle) { invoke<Void>(0x63979E44, toggle); }
	static void AUDIO_SET_PED_HAS_MP_BURST_GROUNDED(Any p0, Any p1) { invoke<Void>(0x4FF98558, p0, p1); }
	static Any AUDIO_SET_BREATHING_STATUS() { return invoke<Any>(0x22A622F1); } // unused
	static Any AUDIO_CHANGE_PORTAL_SETTINGS() { return invoke<Any>(0xD0DF16AD); } // unused
	static void AUD_ENABLE_PRE_BINK_SHUTDOWN(Any p0) { invoke<Void>(0xC3BDC70F, p0); }
	static Any AUDIO_LOAD_METADATA() { return invoke<Any>(0xE8424B87); } // unused
	static Any AUDIO_UNLOAD_METADATA() { return invoke<Any>(0xD1A72EA2); } // unused
	static Any AUDIO_LOAD_SPEECH_DATA() { return invoke<Any>(0x94C4FDB5); } // unused
	static Any AUDIO_LOAD_BANK() { return invoke<Any>(0x0F418A70); } // unused
	static Any AUDIO_MAKE_SLOT_STATIC() { return invoke<Any>(0x943F7EB0); } // unused
	static void PLAY_DLC_SOUND_FRONTEND(int soundId, char* soundName, char* categoryName) { invoke<Void>(0xBDE849F7, soundId, soundName, categoryName); } // unused
}

namespace CAM
{
	static void RENDER_SCRIPT_CAMS(BOOL render, BOOL ease, int easeTime, BOOL p3) { invoke<Void>(0x74337969, render, ease, easeTime, p3); }
	static Cam CREATE_CAM(char* camName, BOOL p1) { return invoke<Cam>(0xE9BF2A7D, camName, p1); }
	static Cam CREATE_CAM_WITH_PARAMS(char* camName, float posX, float posY, float posZ, float rotX, float rotY, float rotZ, float fieldOfView, BOOL p8) { return invoke<Cam>(0x23B02F15, camName, posX, posY, posZ, rotX, rotY, rotZ, fieldOfView, p8); }
	static void DESTROY_CAM(Cam cam) { invoke<Void>(0xC39302BD, cam); }
	static void DESTROY_ALL_CAMS() { invoke<Void>(0x10C151CE); }
	static BOOL DOES_CAM_EXIST(Cam cam) { return invoke<BOOL>(0x1EF89DC0, cam); }
	static void SET_CAM_ACTIVE(Cam cam, BOOL toggle) { invoke<Void>(0x064659C2, cam, toggle); }
	static BOOL IS_CAM_ACTIVE(Cam cam) { return invoke<BOOL>(0x4B58F177, cam); }
	static BOOL IS_CAM_RENDERING(Cam cam) { return invoke<BOOL>(0x6EC6B5B2, cam); } // unused
	static Cam GET_RENDERING_CAM() { return invoke<Cam>(0x0FCF4DF1); }
	static Vector3 GET_CAM_COORD(Cam cam) { return invoke<Vector3>(0x7C40F09C, cam); }
	static Vector3 GET_CAM_ROT(Cam cam) { return invoke<Vector3>(0xDAC84C9F, cam); }
	static float GET_CAM_FOV(Cam cam) { return invoke<float>(0xD6E9FCF5, cam); } // unused
	static float GET_CAM_NEAR_CLIP(Cam cam) { return invoke<float>(0xCFCD35EE, cam); } // unused
	static float GET_CAM_FAR_CLIP(Cam cam) { return invoke<float>(0x09F119B8, cam); } // unused
	static float GET_CAM_NEAR_DOF(Cam cam) { return invoke<float>(0x3F627534, cam); } // unused
	static float GET_CAM_FAR_DOF(Cam cam) { return invoke<float>(0x98C5CCE9, cam); } // unused
	static float GET_CAM_DOF_STRENGTH(Cam cam) { return invoke<float>(0x64E6B290, cam); } // unused
	static float GET_CAM_MOTION_BLUR_STRENGTH(Cam cam) { return invoke<float>(0x54EA722E, cam); } // unused
	static void SET_CAM_PARAMS(Cam cam, float posX, float posY, float posZ, float rotX, float rotY, float rotZ, float fieldOfView, int p8, int p9, int p10) { invoke<Void>(0x2167CEBF, cam, posX, posY, posZ, rotX, rotY, rotZ, fieldOfView, p8, p9, p10); }
	static void SET_CAM_COORD(Cam cam, float x, float y, float z) { invoke<Void>(0x7A8053AF, cam, x, y, z); }
	static void SET_CAM_ROT(Cam cam, float rotX, float rotY, float rotZ) { invoke<Void>(0xEE38B3C1, cam, rotX, rotY, rotZ); }
	static void SET_CAM_FOV(Cam cam, float fov) { invoke<Void>(0xD3D5D74F, cam, fov); }
	static void SET_CAM_NEAR_CLIP(Cam cam, float nearClip) { invoke<Void>(0x46DB13B1, cam, nearClip); } // unused
	static void SET_CAM_FAR_CLIP(Cam cam, float farClip) { invoke<Void>(0x0D23E381, cam, farClip); } // unused
	static void SET_CAM_NEAR_DOF(Cam cam, float p1, float p2) { invoke<Void>(0xF28254DF, cam, p1, p2); } // unused
	static void SET_CAM_FAR_DOF(Cam cam, float p1, float p2) { invoke<Void>(0x58515E8E, cam, p1, p2); }
	static void SET_CAM_DOF_STRENGTH(Cam cam, float strength) { invoke<Void>(0x3CC4EB3F, cam, strength); }
	static void SET_CAM_MOTION_BLUR_STRENGTH(Cam cam, float strength) { invoke<Void>(0xFD6E0D67, cam, strength); } // unused
	static void SET_CAM_VIEW_MODE(int mode) { invoke<Void>(0xADC5A34E, mode); }
	static int GET_CAM_VIEW_MODE() { return invoke<int>(0x5A502ADD); }
	static void ATTACH_CAM_TO_PED(Cam cam, Ped ped, float offsetX, float offsetY, float offsetZ, BOOL heading) { invoke<Void>(0xAFE56AF8, cam, ped, offsetX, offsetY, offsetZ, heading); }
	static void ATTACH_CAM_TO_VEHICLE(Cam cam, Vehicle vehicle, float offsetX, float offsetY, float offsetZ, BOOL heading) { invoke<Void>(0x8D33A0B5, cam, vehicle, offsetX, offsetY, offsetZ, heading); }
	static void ATTACH_CAM_TO_OBJECT(Cam cam, Object object, float offsetX, float offsetY, float offsetZ, BOOL heading) { invoke<Void>(0xD8AD0661, cam, object, offsetX, offsetY, offsetZ, heading); } // unused
	static void DETACH_CAM(Cam cam) { invoke<Void>(0xF4FBF14A, cam); }
	static void SET_CAM_INHERIT_ROLL_OBJECT(Cam cam, Object object) { invoke<Void>(0x32453696, cam, object); } // unused
	static void SET_CAM_INHERIT_ROLL_VEHICLE(Cam cam, Vehicle vehicle) { invoke<Void>(0xE4BD5342, cam, vehicle); } // unused
	static void POINT_CAM_AT_COORD(Cam cam, float x, float y, float z) { invoke<Void>(0x914BC21A, cam, x, y, z); }
	static void POINT_CAM_AT_PED(Cam cam, Ped ped, float offsetX, float offsetY, float offsetZ, BOOL p5) { invoke<Void>(0x81BC4966, cam, ped, offsetX, offsetY, offsetZ, p5); }
	static void POINT_CAM_AT_VEHICLE(Cam cam, Vehicle vehicle, float offsetX, float offsetY, float offsetZ, BOOL p5) { invoke<Void>(0x06DE50BF, cam, vehicle, offsetX, offsetY, offsetZ, p5); }
	static void POINT_CAM_AT_OBJECT(Cam cam, Object object, float offsetX, float offsetY, float offsetZ, BOOL p5) { invoke<Void>(0xC2B50105, cam, object, offsetX, offsetY, offsetZ, p5); } // unused
	static void STOP_CAM_POINTING(Cam cam) { invoke<Void>(0x5435F6A5, cam); }
	static Cam GET_DEBUG_CAM() { return invoke<Cam>(0x76A50592); }
	static void ADD_CAM_SPLINE_NODE(Cam cam, float x, float y, float z, float xRot, float yRot, float zRot, int length) { invoke<Void>(0xAD3C7EAA, cam, x, y, z, xRot, yRot, zRot, length); } // unused
	static void SET_CAM_ACTIVE_WITH_INTERP(Cam camTo, Cam camFrom, int duration, int easeLocation, int easeRotation) { invoke<Void>(0x7983E7F0, camTo, camFrom, duration, easeLocation, easeRotation); }
	static BOOL IS_CAM_INTERPOLATING(Cam cam) { return invoke<BOOL>(0x7159CB5D, cam); } // unused
	static void SHAKE_CAM(Cam cam, char* shakeName, float amplitude) { invoke<Void>(0x1D4211B0, cam, shakeName, amplitude); }
	static BOOL IS_CAM_SHAKING(Cam cam) { return invoke<BOOL>(0x0961FD9B, cam); }
	static void SET_CAM_SHAKE_AMPLITUDE(Cam cam, float amplitude) { invoke<Void>(0x60FF6382, cam, amplitude); } // unused
	static void STOP_CAM_SHAKING(Cam cam, BOOL p1) { invoke<Void>(0x40D0EB87, cam, p1); }
	static void SET_HANDYCAM_SHAKE(Cam cam, BOOL p1, BOOL p2, int p3, float p4, float p5, float p6, float p7, float p8, float p9, int p10) { invoke<Void>(0xC64D1A59, cam, p1, p2, p3, p4, p5, p6, p7, p8, p9, p10); } // unused
	static BOOL IS_SCREEN_FADED_OUT() { return invoke<BOOL>(0x9CAA05FA); }
	static BOOL IS_SCREEN_FADED_IN() { return invoke<BOOL>(0x4F37276D); }
	static BOOL IS_SCREEN_FADING_OUT() { return invoke<BOOL>(0x79275A57); }
	static BOOL IS_SCREEN_FADING_IN() { return invoke<BOOL>(0xC7C82800); }
	static void DO_SCREEN_FADE_IN(int duration) { invoke<Void>(0x66C1BDEE, duration); }
	static void DO_SCREEN_FADE_OUT(int duration) { invoke<Void>(0x89D01805, duration); }
	static void SET_WIDESCREEN_BORDERS(BOOL toggle, int p1) { invoke<Void>(0x1A75DC9A, toggle, p1); }
	static BOOL ARE_WIDESCREEN_BORDERS_ACTIVE() { return invoke<BOOL>(0x4E26746C); } // unused
	static Vector3 GET_GAMEPLAY_CAM_COORD() { return invoke<Vector3>(0x9388CF79); }
	static Vector3 GET_GAMEPLAY_CAM_ROT() { return invoke<Vector3>(0x13A010B5); }
	static float GET_GAMEPLAY_CAM_FOV() { return invoke<float>(0x4D6B3BFA); }
	static float GET_GAMEPLAY_CAM_RELATIVE_HEADING() { return invoke<float>(0xCAF839C2); }
	static void SET_GAMEPLAY_CAM_RELATIVE_HEADING(float p0, float p1, BOOL p2) { invoke<Void>(0x20C6217C, p0, p1, p2); }
	static float GET_GAMEPLAY_CAM_RELATIVE_PITCH() { return invoke<float>(0xFC5A4946); }
	static void SET_GAMEPLAY_CAM_RELATIVE_PITCH(float p0, float p1, BOOL p2) { invoke<Void>(0x6381B963, p0, p1, p2); }
	static void SHAKE_GAMEPLAY_CAM(char* shakeName, float intensity) { invoke<Void>(0xF2EFE660, shakeName, intensity); }
	static BOOL IS_GAMEPLAY_CAM_SHAKING(char* shakeName) { return invoke<BOOL>(0x3457D681, shakeName); }
	static void SET_GAMEPLAY_CAM_SHAKE_AMPLITUDE(Any p0, Any p1) { invoke<Void>(0x9219D44A, p0, p1); }
	static void STOP_GAMEPLAY_CAM_SHAKING(Any p0, Any p1) { invoke<Void>(0xFD569E4E, p0, p1); }
	static BOOL IS_SPHERE_VISIBLE(float x, float y, float z, float radius, BOOL p4) { return invoke<BOOL>(0xDD1329E2, x, y, z, radius, p4); }
	static BOOL IS_FOLLOW_PED_CAM_ACTIVE() { return invoke<BOOL>(0x9F9E856C); } // unused
	static int GET_FOLLOW_PED_CAM_ZOOM_LEVEL() { return invoke<int>(0x57583DF1); } // unused
	static void SET_FOLLOW_PED_CAM_ZOOM_LEVEL(int zoomLevel) { invoke<Void>(0x9E686DC1, zoomLevel); } // unused
	static BOOL IS_FOLLOW_VEHICLE_CAM_ACTIVE() { return invoke<BOOL>(0x8DD49B77); } // unused
	static int GET_FOLLOW_VEHICLE_CAM_ZOOM_LEVEL() { return invoke<int>(0x8CD67DE3); } // unused
	static void SET_FOLLOW_VEHICLE_CAM_ZOOM_LEVEL(int zoomLevel) { invoke<Void>(0x8F55EBBE, zoomLevel); } // unused
	static BOOL IS_AIM_CAM_ACTIVE() { return invoke<BOOL>(0xC24B4F6F); }
	static int GET_AIM_CAM_ZOOL_LEVEL() { return invoke<int>(0x8850B945); } // unused
	static void SET_AIM_CAM_ZOOM_LEVEL(int zoomLevel) { invoke<Void>(0x134C2026, zoomLevel); }
	static void SET_CAMERA_OVERRIDE(char* camName, char* camName2, BOOL p2, BOOL p3, BOOL p4) { invoke<Void>(0xF02D8E72, camName, camName2, p2, p3, p4); }
	static Any SET_GAMEPLAY_COORD_HINT() { return invoke<Any>(0xF27483C9); } // unused
	static Any SET_GAMEPLAY_PED_HINT() { return invoke<Any>(0x7C27343E); } // unused
	static Any SET_GAMEPLAY_VEHICLE_HINT() { return invoke<Any>(0x2C9A11D8); } // unused
	static Any SET_GAMEPLAY_OBJECT_HINT() { return invoke<Any>(0x2ED5E2F8); } // unused
	static Any SET_GAMEPLAY_HINT_FOV() { return invoke<Any>(0x96FD173B); } // unused
	static Any SET_GAMEPLAY_HINT_RELATIVE_PITCH() { return invoke<Any>(0x7D04320E); } // unused
	static BOOL IS_GAMEPLAY_HINT_ACTIVE() { return invoke<BOOL>(0xAD8DA205); } // unused
	static void STOP_GAMEPLAY_HINT() { invoke<Void>(0x1BC28B7B); } // unused
	static void SET_CINEMATIC_BUTTON_ACTIVE(BOOL toggle) { invoke<Void>(0x3FBC5D00, toggle); } // unused
	static BOOL IS_BULLET_CAMERA_ACTIVE() { return invoke<BOOL>(0xB5B03846); }
	static BOOL IS_BULLET_CAMERA_SCENE_ACTIVE(Cam cam) { return invoke<BOOL>(0x05D6EAC4, cam); }
	static BOOL IS_BULLET_CAMERA_RUNNING(BOOL p0) { return invoke<BOOL>(0xC0B3AD61, p0); }
	static Any SETUP_BULLET_CAMERA_SCENE(Any p0, Any p1, Any p2, Any p3, Any p4, Any p5, Any p6, Any p7, Any p8, Any p9, Any p10, Any p11, Any p12, Any p13, Any p14, Any p15, Any p16, Any p17, Any p18, Any p19, Any p20, Any p21) { return invoke<Any>(0x536FD4DA, p0, p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14, p15, p16, p17, p18, p19, p20, p21); }
	static void SETUP_BULLET_CAMERA_ANIM_SCENE(Any p0, Any p1, Any p2) { invoke<Void>(0xC527E29F, p0, p1, p2); }
	static Any RESET_BULLET_CAMERA_TIMEWARP_SCALE() { return invoke<Any>(0x69EE7ED4); } // unused
	static Any GET_BULLET_CAMERA_SCENE_START(Any p0) { return invoke<Any>(0xF7334085, p0); }
	static void SET_BULLET_CAMERA_VICTIM(Any p0, Any p1) { invoke<Void>(0xFB6C221F, p0, p1); }
	static void SET_BULLET_CAMERA_VEHICLE(Any p0, Any p1) { invoke<Void>(0x9754F23E, p0, p1); }
	static void SET_BULLET_CAMERA_TRACKER(Any p0) { invoke<Void>(0x0B09B233, p0); }
	static Any SET_BULLET_CAMERA_OBJECT_TRACKER() { return invoke<Any>(0x4E75A262); } // unused
	static Any SET_BULLET_CAMERA_TRACKED_PED() { return invoke<Any>(0x450D1234); } // unused
	static Any GET_BULLET_CAMERA_MARKER(Any p0) { return invoke<Any>(0xFE343BB0, p0); }
	static void BULLET_CAMERA_TRACK_UNTIL_GROUNDED(BOOL toggle) { invoke<Void>(0xF32B2C96, toggle); }
	static void BULLET_CAMERA_ALLOW_TRACK_BULLET(BOOL toggle) { invoke<Void>(0x5754CF87, toggle); }
	static void BULLET_CAMERA_PRELOAD_TEXT_BINK(char* p0, BOOL p1) { invoke<Void>(0x8CD8006E, p0, p1); }
	static void SET_PED_BULLET_CAMERA_ON_NEXT_HIT(Ped ped) { invoke<Void>(0xF43737FB, ped); } // unused
	static void ALLOW_BULLET_CAMERA_TO_GAMEPLAY(BOOL p0, BOOL p1) { invoke<Void>(0x2BB2C58F, p0, p1); }
	static BOOL IS_BULLET_CAMERA_TO_GAMEPLAY_ALLOWED() { return invoke<BOOL>(0x60EBB1EB); }
	static int GET_PRESET_DURATION(char* presetName) { return invoke<int>(0xB61080D1, presetName); }
	static BOOL SET_PRESET_TEXT(char* presetName, int p1, int p2, char* p3) { return invoke<BOOL>(0x58439F1A, presetName, p1, p2, p3); }
	static BOOL SET_PRESET_TEXTVIDEO(char* presetName, int p1, int p2, char* p3) { return invoke<BOOL>(0x292E48B3, presetName, p1, p2, p3); } // unused
	static BOOL SET_PRESET_TEXT_TIMING(char* presetName, int p1, int p2, int p3, float p4, int p5, float p6, int p7, float p8, int p9, float p10, int p11, float p12, int p13, float p14) { return invoke<BOOL>(0xCA682A7E, presetName, p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14); } // unused
	static void SET_BCAM_STR_HELPER_TRACK_PLAYER(BOOL toggle) { invoke<Void>(0x809B977E, toggle); }
	static void SET_PORTAL_TRACK_DEATH_CAMERA(BOOL toggle) { invoke<Void>(0x5B1065AF, toggle); }
	static void ALLOW_BULLET_CAMERA_SLOWDOWN(BOOL toggle) { invoke<Void>(0xC6AB9205, toggle); }
	static void TERMINATE_GAME_BULLET_CAMERA() { invoke<Void>(0xEE7F2F5D); }
	static void START_PANEL_WIPE(int p0, int p1) { invoke<Void>(0x45E78975, p0, p1); }
	static void ENABLE_BULLET_CAMERA_WIPE(BOOL toggle) { invoke<Void>(0xDCCD38E5, toggle); }
	static BOOL IS_BULLET_CAMERA_WIPE_ENABLED() { return invoke<BOOL>(0x7E5F8C2D); }
	static BOOL IS_BULLET_CAMERA_WIPE_STOPPED() { return invoke<BOOL>(0xB271F669); }
	static void RESUME_BULLET_CAMERA_WIPE() { invoke<Void>(0xACF3AD1F); }
	static void RESUME_BULLET_CAMERA_WIPE_ON_FADEIN() { invoke<Void>(0xC038C512); }
	static void FORCE_CUSTOM_WIPE_BULLET_CAMERA(BOOL toggle) { invoke<Void>(0xDC58C1A2, toggle); }
	static void FORCE_QUICK_DEATH_CAMERAS(BOOL toggle) { invoke<Void>(0x60BBBAAD, toggle); }
	static void ALLOW_BULLET_CAMERA_CHEAT(BOOL toggle) { invoke<Void>(0x3A19D0D1, toggle); }
	static void PLAY_KILLSTRIP_LOCAL(Ped ped1, Ped ped2) { invoke<Void>(0x492BDFA1, ped1, ped2); } // unused
	static void FREEZE_CURRENT_PANEL() { invoke<Void>(0xABE10E99); }
	static void SET_CAM_SIDE_LEFT(BOOL toggle) { invoke<Void>(0xC14844A8, toggle); }
	static void SET_CAM_FORCE_LEFT_SIDE(BOOL toggle) { invoke<Void>(0xFD6D5D1D, toggle); }
	static void OVERRIDE_WARP_MODIFIER(BOOL toggle, float modifier) { invoke<Void>(0x6637FAB8, toggle, modifier); }
	static void SET_RAIL_RELATIVE_DIR(int index, float dir) { invoke<Void>(0x69B9D3A5, index, dir); }
	static void CAMERA_POINT_AT_GRENADE(BOOL toggle) { invoke<Void>(0x57EB9828, toggle); }
	static void CAMERA_POINT_AT_PED(Ped ped, int duration) { invoke<Void>(0x8B002BD2, ped, duration); }
	static void CAMERA_POINT_AT_VEHICLE(Vehicle vehicle, int duration) { invoke<Void>(0xC006BBFD, vehicle, duration); }
	static void CAMERA_POINT_AT_OBJECT(Object object, int duration) { invoke<Void>(0xFF7BF49E, object, duration); } // unused
	static void CAMERA_POINT_AT_COORD(float x, float y, float z, int duration) { invoke<Void>(0x5F3C6D7A, x, y, z, duration); }
	static void CAMERA_CLEAR_POINT_AT_TARGET() { invoke<Void>(0x09013E7F); }
	static Any CAMERA_IS_POINTING_AT_TARGET() { return invoke<Any>(0x6C7043F0); } // unused
	static void CAMERA_SNAP_POINT_AT_COORD(Any p0, Any p1, Any p2) { invoke<Void>(0x8025901F, p0, p1, p2); }
	static void CAMERA_CAN_TARGET_OBJECT(BOOL toggle, Object object) { invoke<Void>(0x484A10F1, toggle, object); }
	static void CAMERA_CAN_TARGET_VEHICLE(BOOL toggle, Vehicle vehicle) { invoke<Void>(0x49845055, toggle, vehicle); } // unused
	static void CAMERA_CAN_TARGET_TIRES(BOOL toggle) { invoke<Void>(0x13CBB1CD, toggle); }
	static void CAMERA_CAN_TARGET_PROJECTILES(BOOL toggle) { invoke<Void>(0xA931C3F2, toggle); }
	static void CAMERA_FIRST_PERSON_TRACK_RATE(float rate) { invoke<Void>(0xD9D54F5A, rate); }
	static void CAMERA_AIM_OVERRIDE(BOOL toggle) { invoke<Void>(0x8DA8FA57, toggle); }
	static void CAMERA_ENABLE_FIRST_TIME_AIM_LOCK(BOOL toggle) { invoke<Void>(0x8F5BB594, toggle); }
	static void CAMERA_USE_HANDY_CAM(BOOL p0, float p1, BOOL p2) { invoke<Void>(0x4AF9573A, p0, p1, p2); }
	static void CAMERA_ENABLE_SHOULDER_MODE(BOOL toggle) { invoke<Void>(0xD33A2B48, toggle); }
	static BOOL CAMERA_SETTINGS_IS_HARD_LOCK_ENABLED() { return invoke<BOOL>(0x1A2E23B0); }
	static void CAMERA_PLAY_ANIMATED(Any p0, Any p1, Any p2, Any p3, Any p4, Any p5, Any p6, Any p7, Any p8) { invoke<Void>(0x07481CC8, p0, p1, p2, p3, p4, p5, p6, p7, p8); }
	static void CAMERA_PLAY_ANIMATED_ATTACHED_VEHICLE(Any p0, Any p1, Any p2, Any p3, Any p4, Any p5, Any p6, Any p7, Any p8) { invoke<Void>(0x26C4B9FA, p0, p1, p2, p3, p4, p5, p6, p7, p8); }
	static void CAMERA_PLAY_ANIMATED_ATTACHED_VEHICLE_RELATIVE(Any p0, Any p1, Any p2, Any p3, Any p4) { invoke<Void>(0xAE338F48, p0, p1, p2, p3, p4); }
	static void CAMERA_PLAY_ANIMATED_ATTACHED_PED_RELATIVE(Any p0, Any p1, Any p2, Any p3, Any p4) { invoke<Void>(0xC6F70F9A, p0, p1, p2, p3, p4); }
	static void CAMERA_PLAY_ANIMATED_WITH_SRL(Any p0, Any p1, Any p2, Any p3, Any p4, Any p5, Any p6, Any p7, Any p8, Any p9) { invoke<Void>(0xAE16D609, p0, p1, p2, p3, p4, p5, p6, p7, p8, p9); }
	static Any CAMERA_ANIMATED_USE_DOF() { return invoke<Any>(0xFB7557B5); } // unused
	static void CAMERA_ANIMATED_STOP(Any p0, Any p1) { invoke<Void>(0x70990C57, p0, p1); }
	static Any CAMERA_ANIMATED_CURRENT_TIME() { return invoke<Any>(0x79AF1166); }
	static Any CAMERA_ANIMATED_LENGTH(Any p0, Any p1) { return invoke<Any>(0xA6DA5494, p0, p1); }
	static BOOL IS_ANIMATED_CAMERA_PLAYING() { return invoke<BOOL>(0x7FB6E861); }
	static Any CAMERA_ANIMATED_START_POSITION(Any p0, Any p1, Any p2) { return invoke<Any>(0xCA7616AE, p0, p1, p2); }
	static Any CAMERA_ANIMATED_START_HEADING(Any p0, Any p1, Any p2) { return invoke<Any>(0xA7596ABA, p0, p1, p2); }
	static Any CAMERA_ANIMATED_START_FOV(Any p0, Any p1, Any p2) { return invoke<Any>(0x083EC5A3, p0, p1, p2); }
	static void CAMERA_ANIMATED_RECORD_SRL() { invoke<Void>(0x0816DFBD); }
	static void CAMERA_SET_HIGH_COVER_LOCK_ON_ANGLE_LIMIT(float limit) { invoke<Void>(0x18B57920, limit); } // unused
	static void CAMERA_FREEZE_FRAME(BOOL p0, int p1, int p2, float p3) { invoke<Void>(0xDDFE747D, p0, p1, p2, p3); }
	static BOOL IS_CAMERA_AIMING_AT_ENEMY() { return invoke<BOOL>(0x7AD6405B); }
	static void SET_CAMERA_USE_COVER_FOR_AIMING(BOOL toggle) { invoke<Void>(0x8B40F1EA, toggle); }
	static void CAMERA_OVERRIDE_EFFECT_OBSTRUCTION(BOOL toggle) { invoke<Void>(0x24770C0D, toggle); } // unused
}

namespace ACTIONTREE
{
	static void SET_ACTTEST_ENABLED(char* name, BOOL toggle) { invoke<Void>(0xF652E42A, name, toggle); } // unused
	static void SET_ACTIONTREE_INFO(char* name, char* fileName, char* shortName) { invoke<Void>(0xED7221F0, name, fileName, shortName); }
	static void GET_ACTIONTREE_INFO(char* name, int bufferSize1, char* buffer1, int bufferSize2, char* buffer2) { invoke<Void>(0x302A2839, name, bufferSize1, buffer1, bufferSize2, buffer2); } // unused
}

namespace DEBUG
{
	static void SET_DEBUG_ACTIVE(BOOL toggle) { invoke<Void>(0x07852439, toggle); }
	static Any SET_DEBUG_TEXT_VISIBLE() { return invoke<Any>(0x50017383); } // unused
	static void SCRIPT_ASSERT(char* format, int argCount, ...)
	{
		NativeContext cxt;

		va_list _nativeVarArgsList; const int _nativeVarArgsCount = argCount * 2; ((_nativeVarArgsList) = __va_funcx (2, (char *) __builtin_addrof((_nativeVarArgsCount))));;
		cxt.nativePush(format);
		cxt.nativePush(argCount);
		for (int i = 0; i < _nativeVarArgsCount; i++) { cxt . nativePush((*((Any *) __va_funcx (3, (_nativeVarArgsList),((Any *) 0))))); };
		((void) 0);;

		nativeCall<Void>(0xD9BCCE95, &cxt);
	}
	static Any OPEN_DEBUG_FILE() { return invoke<Any>(0xA754055A); } // unused
	static Any CLOSE_DEBUG_FILE() { return invoke<Any>(0xAFDE128D); } // unused
	static Any SAVE_INT_TO_DEBUG_FILE() { return invoke<Any>(0x13F0037D); } // unused
	static Any SAVE_FLOAT_TO_DEBUG_FILE() { return invoke<Any>(0xAE315350); } // unused
	static Any SAVE_NEWLINE_TO_DEBUG_FILE() { return invoke<Any>(0x36383B18); } // unused
	static Any SAVE_STRING_TO_DEBUG_FILE() { return invoke<Any>(0x1BC43E17); } // unused
	static Any OPEN_NAMED_DEBUG_FILE() { return invoke<Any>(0xE817E336); } // unused
	static Any SAVE_INT_TO_NAMED_DEBUG_FILE() { return invoke<Any>(0xC59156BD); } // unused
	static Any SAVE_FLOAT_TO_NAMED_DEBUG_FILE() { return invoke<Any>(0x72E3DA94); } // unused
	static Any SAVE_STRING_TO_NAMED_DEBUG_FILE() { return invoke<Any>(0xD7B91218); } // unused
	static Any SAVE_NEWLINE_TO_NAMED_DEBUG_FILE() { return invoke<Any>(0xC41A4082); } // unused
	static Any CLEAR_NAMED_DEBUG_FILE() { return invoke<Any>(0xD62B95EB); } // unused
	static Any DEBUG_SET_SELECTED_PED() { return invoke<Any>(0x6F65ABB3); } // unused
	static void SET_CURRENT_WIDGET_GROUP(Any p0) { invoke<Void>(0xF1392227, p0); }
	static void CLEAR_CURRENT_WIDGET_GROUP(Any p0) { invoke<Void>(0x345CAE26, p0); }
	static void START_WIDGET_GROUP(char* p0) { invoke<Void>(0xA782BE62, p0); }
	static void STOP_WIDGET_GROUP() { invoke<Void>(0xB7E25D55); }
	static Any ADD_WIDGET_INT_SLIDER(Any p0, Any p1, Any p2, Any p3, Any p4) { return invoke<Any>(0xF6A6C926, p0, p1, p2, p3, p4); }
	static Any ADD_WIDGET_FLOAT_SLIDER(Any p0, Any p1, Any p2, Any p3, Any p4) { return invoke<Any>(0x67865135, p0, p1, p2, p3, p4); }
	static Any ADD_WIDGET_INT_READ_ONLY(Any p0, Any p1) { return invoke<Any>(0xB3F4D0DF, p0, p1); }
	static Any ADD_WIDGET_FLOAT_READ_ONLY(Any p0, Any p1) { return invoke<Any>(0xEF2D8DEA, p0, p1); }
	static Any ADD_WIDGET_BOOL(Any p0, Any p1) { return invoke<Any>(0xECBF5BB2, p0, p1); }
	static void ADD_WIDGET_STRING(char* string) { invoke<Void>(0xC541594C, string); }
	static void DELETE_WIDGET_GROUP(Any p0) { invoke<Void>(0xD215BACE, p0); }
	static void DELETE_WIDGET(Any p0) { invoke<Void>(0xB3CAB5FB, p0); }
	static Any DOES_WIDGET_GROUP_EXIST() { return invoke<Any>(0x2B1D2AF9); } // unused
	static void START_NEW_WIDGET_COMBO() { invoke<Void>(0x284A3C93); }
	static void ADD_TO_WIDGET_COMBO(Any p0) { invoke<Void>(0xE136E83E, p0); }
	static Any STOP_WIDGET_COMBO(Any p0, Any p1) { return invoke<Any>(0x4159C9A0, p0, p1); }
	static void GET_CONTENTS_OF_COMBO_WIDGET_SELECTION(Any p0, Any p1, Any p2) { invoke<Void>(0x96868B18, p0, p1, p2); }
	static int ADD_TEXT_WIDGET(char* p0) { return invoke<int>(0xE178AA0F, p0); }
	static void GET_CONTENTS_OF_TEXT_WIDGET(Any p0, Any p1, Any p2) { invoke<Void>(0x28BE9702, p0, p1, p2); }
	static void SET_CONTENTS_OF_TEXT_WIDGET(Any p0, Any p1) { invoke<Void>(0x74E6F8F5, p0, p1); }
	static Any GET_NETWORK_RESTART_NODE_DEBUG() { return invoke<Any>(0x9B999753); } // unused
	static Any PRINT_MISSION_DESCRIPTION() { return invoke<Any>(0x61668A58); } // unused
	static void GET_NAME_OF_SCRIPT_TO_AUTOMATICALLY_START(int bufferSize, char* buffer) { invoke<Void>(0x9183C7B7, bufferSize, buffer); } // unused
	static void PRINT_MEMORY_STATS() { invoke<Void>(0xD6F9C65D); }
	static void DISPLAYF(char* format, int argCount, ...)
	{
		NativeContext cxt;

		va_list _nativeVarArgsList; const int _nativeVarArgsCount = argCount * 2; ((_nativeVarArgsList) = __va_funcx (2, (char *) __builtin_addrof((_nativeVarArgsCount))));;
		cxt.nativePush(format);
		cxt.nativePush(argCount);
		for (int i = 0; i < _nativeVarArgsCount; i++) { cxt . nativePush((*((Any *) __va_funcx (3, (_nativeVarArgsList),((Any *) 0))))); };
		((void) 0);;

		nativeCall<Void>(0x5B03B710, &cxt);
	}
	static void ASSERTF(BOOL p0, char* format, int argCount, ...) // unused
	{
		NativeContext cxt;

		va_list _nativeVarArgsList; const int _nativeVarArgsCount = argCount * 2; ((_nativeVarArgsList) = __va_funcx (2, (char *) __builtin_addrof((_nativeVarArgsCount))));;
		cxt.nativePush(p0);
		cxt.nativePush(format);
		cxt.nativePush(argCount);
		for (int i = 0; i < _nativeVarArgsCount; i++) { cxt . nativePush((*((Any *) __va_funcx (3, (_nativeVarArgsList),((Any *) 0))))); };
		((void) 0);;

		nativeCall<Void>(0xA3D74DD5, &cxt);
	}
	static void SET_ENABLE_PED_PROCESS_INTELLIGENCE(BOOL toggle) { invoke<Void>(0x6700C96C, toggle); } // unused
	static Vector3 GET_POSITION_OF_LAST_MOUSECLICK() { return invoke<Vector3>(0x5EBC23BF); } // unused
	static void FORCE_OPEN_NETWORK() { invoke<Void>(0x9B6F9F04); }
	static void FORCE_CLOSE_NETWORK() { invoke<Void>(0xD63AEB80); }
}

namespace HUD
{
	static void SET_CHIQUITAS_ALWAYS_VISIBLE_ON_PLAYER(int p0, BOOL toggle) { invoke<Void>(0xCA7E5546, p0, toggle); } // unused
	static void SET_CHIQUITAS_ALWAYS_VISIBLE(BOOL toggle) { invoke<Void>(0x29132B80, toggle); } // unused
	static BOOL UI_SET(int index, int argCount, ...)
	{
		NativeContext cxt;

		va_list _nativeVarArgsList; const int _nativeVarArgsCount = argCount * 2; ((_nativeVarArgsList) = __va_funcx (2, (char *) __builtin_addrof((_nativeVarArgsCount))));;
		cxt.nativePush(index);
		cxt.nativePush(argCount);
		for (int i = 0; i < _nativeVarArgsCount; i++) { cxt . nativePush((*((Any *) __va_funcx (3, (_nativeVarArgsList),((Any *) 0))))); };
		((void) 0);;

		return nativeCall<BOOL>(0xA2A179B2, &cxt);
	}
	static BOOL UI_GET(int index, int argCount, ...)
	{
		NativeContext cxt;

		va_list _nativeVarArgsList; const int _nativeVarArgsCount = argCount * 2; ((_nativeVarArgsList) = __va_funcx (2, (char *) __builtin_addrof((_nativeVarArgsCount))));;
		cxt.nativePush(index);
		cxt.nativePush(argCount);
		for (int i = 0; i < _nativeVarArgsCount; i++) { cxt . nativePush((*((Any *) __va_funcx (3, (_nativeVarArgsList),((Any *) 0))))); };
		((void) 0);;

		return nativeCall<BOOL>(0x09608938, &cxt);
	}
	static BOOL UI_DOES_FRAME_EXIST_HASH(Hash frameHash) { return invoke<BOOL>(0x32852FD0, frameHash); }
	static BOOL UI_DOES_FRAME_EXIST_NAME(char* frameName) { return invoke<BOOL>(0x279B59AB, frameName); } // unused
	static void UI_SET_MP_BIG_NUMBER(int p0, int argCount, ...) // unused
	{
		NativeContext cxt;

		va_list _nativeVarArgsList; const int _nativeVarArgsCount = argCount * 2; ((_nativeVarArgsList) = __va_funcx (2, (char *) __builtin_addrof((_nativeVarArgsCount))));;
		cxt.nativePush(p0);
		cxt.nativePush(argCount);
		for (int i = 0; i < _nativeVarArgsCount; i++) { cxt . nativePush((*((Any *) __va_funcx (3, (_nativeVarArgsList),((Any *) 0))))); };
		((void) 0);;

		nativeCall<Void>(0xE903DA08, &cxt);
	}
	static int UI_GET_SELECTED_INDEX(int argCount, ...)
	{
		NativeContext cxt;

		va_list _nativeVarArgsList; const int _nativeVarArgsCount = argCount * 2; ((_nativeVarArgsList) = __va_funcx (2, (char *) __builtin_addrof((_nativeVarArgsCount))));;
		cxt.nativePush(argCount);
		for (int i = 0; i < _nativeVarArgsCount; i++) { cxt . nativePush((*((Any *) __va_funcx (3, (_nativeVarArgsList),((Any *) 0))))); };
		((void) 0);;

		return nativeCall<int>(0x8B63A008, &cxt);
	}
	static void UI_SET_WORLDCONTAINER_POS(float x, float y, float z, int argCount, ...) // unused
	{
		NativeContext cxt;

		va_list _nativeVarArgsList; const int _nativeVarArgsCount = argCount * 2; ((_nativeVarArgsList) = __va_funcx (2, (char *) __builtin_addrof((_nativeVarArgsCount))));;
		cxt.nativePush(x);
		cxt.nativePush(y);
		cxt.nativePush(z);
		cxt.nativePush(argCount);
		for (int i = 0; i < _nativeVarArgsCount; i++) { cxt . nativePush((*((Any *) __va_funcx (3, (_nativeVarArgsList),((Any *) 0))))); };
		((void) 0);;

		nativeCall<Void>(0x73F91E06, &cxt);
	}
	static void UI_ADD_MP_HITMARK(int p0, int p1) { invoke<Void>(0xDA1F284A, p0, p1); }
	static void UI_REMOVE_MP_HITMARKS() { invoke<Void>(0x04155A12); }
	static BOOL UI_LOAD_AFTER_ACTION_REPORT(char* name) { return invoke<BOOL>(0x2399616B, name); }
	static BOOL UI_SHOW_TOOLTIP(int p0, char* p1) { return invoke<BOOL>(0x6A99EF9C, p0, p1); }
	static void UI_CLEAR_TOOLTIP() { invoke<Void>(0xB6CA18C1); }
	static void UI_LOAD_MINIMAP_TXD(char* txdName) { invoke<Void>(0xBA0CC379, txdName); }
	static void HUD_SET_SCORETIMER(char* name, BOOL p1) { invoke<Void>(0xDA7B6C20, name, p1); }
	static void HUD_SCOREBOARD_SETGWNODE(Any p0, Any p1) { invoke<Void>(0xBBB66CB1, p0, p1); }
	static void HUD_SCOREBOARD_SETGW_TALLY_SCORES(Any p0) { invoke<Void>(0xB4D65DD8, p0); }
	static BOOL HUD_ARE_GANGWARS_ANIMS_COMPLETE() { return invoke<BOOL>(0x7C4C7D45); } // unused
	static void SETUP_HUD_SCOREBOARD(Any p0) { invoke<Void>(0xEE11C349, p0); }
	static void _0xEB2EC892(float p0, int p1) { invoke<Void>(0xEB2EC892, p0, p1); }
	static void _0x4F04780C(int p0) { invoke<Void>(0x4F04780C, p0); } // unused
	static void _0xA5B5413B(int p0, BOOL p1) { invoke<Void>(0xA5B5413B, p0, p1); }
	static BOOL _0x8FBEC493(int p0) { return invoke<BOOL>(0x8FBEC493, p0); } // unused
	static void _0xB2945C4B(int p0) { invoke<Void>(0xB2945C4B, p0); } // unused
	static void _0xD27DD5C7() { invoke<Void>(0xD27DD5C7); } // unused
	static void _0xABDF1C6D() { invoke<Void>(0xABDF1C6D); }
	static int _0xF81D2B60() { return invoke<int>(0xF81D2B60); }
	static void FORCE_SUBTITLES(BOOL toggle) { invoke<Void>(0x904213A2, toggle); } // unused
	static void PRINT(char* textLabel, int duration, int p2) { invoke<Void>(0x53C5F206, textLabel, duration, p2); } // unused
	static void PRINT_NOW(char* textLabel, int duration, int p2) { invoke<Void>(0x2C60BF8C, textLabel, duration, p2); } // unused
	static void CLEAR_PRINTS() { invoke<Void>(0x216CB1C5); }
	static void CLEAR_BRIEF() { invoke<Void>(0x9F75A929); } // unused
	static Any PRINT_WITH_NUMBER() { return invoke<Any>(0x9FBDDD94); } // unused
	static Any PRINT_WITH_NUMBER_NOW() { return invoke<Any>(0x7FFF2957); } // unused
	static Any PRINT_WITH_2_NUMBERS() { return invoke<Any>(0x1D5F8E7A); } // unused
	static Any PRINT_WITH_2_NUMBERS_NOW() { return invoke<Any>(0x4F62BE65); } // unused
	static Any PRINT_STRING_IN_STRING() { return invoke<Any>(0x31026991); } // unused
	static Any PRINT_STRING_IN_STRING_NOW() { return invoke<Any>(0x610BDA9E); } // unused
	static void PRINT_STRING_WITH_LITERAL_STRING(char* textLabel, char* literalString, int duration, int p3) { invoke<Void>(0x5BFD20CB, textLabel, literalString, duration, p3); }
	static void PRINT_STRING_WITH_LITERAL_STRING_NOW(char* textLabel, char* literalString, int duration, int p3) { invoke<Void>(0x40D7612D, textLabel, literalString, duration, p3); } // unused
	static Any CLEAR_THIS_PRINT() { return invoke<Any>(0x06878327); } // unused
	static Any CLEAR_SMALL_PRINTS() { return invoke<Any>(0xA869A238); } // unused
	static Any IS_THIS_PRINT_BEING_DISPLAYED() { return invoke<Any>(0xED8E2421); } // unused
	static void LOAD_ADDITIONAL_TEXT(char* gxt, int slot) { invoke<Void>(0xF133AED9, gxt, slot); }
	static void REQUEST_ADDITIONAL_TEXT(char* gxt, int slot) { invoke<Void>(0x9FA9175B, gxt, slot); }
	static BOOL HAS_ADDITIONAL_TEXT_LOADED(int slot) { return invoke<BOOL>(0xB0E56045, slot); } // unused
	static void CLEAR_ADDITIONAL_TEXT(int slot, BOOL p1) { invoke<Void>(0x518141E0, slot, p1); } // unused
	static BOOL IS_STREAMING_ADDITIONAL_TEXT(int slot) { return invoke<BOOL>(0xF079E4EB, slot); }
	static BOOL HAS_THIS_ADDITIONAL_TEXT_LOADED(char* gxt) { return invoke<BOOL>(0x80A52040, gxt); }
	static BOOL IS_MESSAGE_BEING_DISPLAYED() { return invoke<BOOL>(0x6A77FE8D); } // unused
	static BOOL DOES_TEXT_LABEL_EXIST(char* textLabel) { return invoke<BOOL>(0x6ECAE560, textLabel); }
	static int GET_LENGTH_OF_STRING_WITH_THIS_TEXT_LABEL(char* textLabel) { return invoke<int>(0xA4CA7BE5, textLabel); }
	static int GET_FIRST_INDEX_OF(char* str, char* substr) { return invoke<int>(0x893E3C02, str, substr); }
	static int GET_LENGTH_OF_LITERAL_STRING(char* literalString) { return invoke<int>(0x99379D55, literalString); } // unused
	static int GET_NTH_INTEGER_IN_STRING(char* textLabel, int n) { return invoke<int>(0x258DD91D, textLabel, n); }
	static BOOL IS_HUD_PREFERENCE_SWITCHED_ON() { return invoke<BOOL>(0xC3BC1B4F); }
	static BOOL IS_HUD_RETICULE_COMPLEX() { return invoke<BOOL>(0x9A99C9C7); } // unused
	static void SET_DISPLAY_FLAGS(int flags, BOOL set) { invoke<Void>(0xE55CCC60, flags, set); }
	static void DISPLAY_HUD(BOOL toggle) { invoke<Void>(0xD10E4E31, toggle); }
	static void SET_PAUSE_MENU_ACTIVE(BOOL toggle) { invoke<Void>(0x1DCD878E, toggle); } // unused
	static void ENABLE_PAUSE_MENU(BOOL toggle) { invoke<Void>(0x7441D0DD, toggle); } // unused
	static Any SET_ROUTE_FLASHES() { return invoke<Any>(0x93BD3E80); } // unused
	static Any SET_BLIP_ROUTE() { return invoke<Any>(0x3E160C90); } // unused
	static void ADD_NEXT_MESSAGE_TO_PREVIOUS_BRIEFS(BOOL toggle) { invoke<Void>(0xB58B25BD, toggle); } // unused
	static void SET_RADAR_ZOOM(int zoomLevel) { invoke<Void>(0x2A50D1A6, zoomLevel); } // unused
	static void GET_HUD_COLOUR(int hudColorIndex, int* r, int* g, int* b, int* a) { invoke<Void>(0x63F66A0B, hudColorIndex, r, g, b, a); }
	static void GET_CORRECTED_COLOUR(int r, int g, int b, int* correctedR, int* correctedG, int* correctedB) { invoke<Void>(0xDB5AC03E, r, g, b, correctedR, correctedG, correctedB); } // unused
	static void SET_FRONTEND_ACTIVE(BOOL toggle) { invoke<Void>(0x81E1AD32, toggle); } // unused
	static BOOL IS_PAUSE_MENU_ACTIVE() { return invoke<BOOL>(0xD3600591); }
	static void SET_NEXT_MULTIPLAYER_MESSAGE_TIMEOUT(Any p0, Any p1) { invoke<Void>(0xB1EF9817, p0, p1); }
	static Any SET_NEXT_TICKER_MESSAGE_BACKGROUND_COLOR() { return invoke<Any>(0x4BD59DD4); } // unused
	static void SET_MPITEMS_OVERHEAD_ICONS_ENABLED(BOOL p0, BOOL p1) { invoke<Void>(0x13672AC9, p0, p1); }
	static void INIT_TICKER_DATA(Any* data) { invoke<Void>(0xDF4E6CEB, data); }
	static void ADD_TICKER_MESSAGE(Any* data) { invoke<Void>(0x151A8CA9, data); }
	static void ADD_MULTIPLAYER_MESSAGE(char* message, BOOL belowTimer) { invoke<Void>(0xDFE98FBC, message, belowTimer); }
	static void CLEAR_TICKER_MESSAGES() { invoke<Void>(0xFACE788D); }
	static void CLEAR_CENTRAL_MESSAGES() { invoke<Void>(0x2BCCCD02); }
	static void CLEAR_DEATH_RECORDS() { invoke<Void>(0x58BB6879); }
	static Any REGISTER_INJURY() { return invoke<Any>(0x33B0E8E6); } // unused
	static Any GET_PREVIOUS_FONT_SETTINGS() { return invoke<Any>(0xA6BC3F4F); } // unused
	static Any GET_NUMBER_LINES_WITH_SUBSTRINGS() { return invoke<Any>(0xD172184D); } // unused
	static void DISPLAY_TEXT(float x, float y, char* text) { invoke<Void>(0xFC4541B5, x, y, text); } // unused
	static void SET_TEXT_SCALE(float p0, float p1) { invoke<Void>(0xB6E15B23, p0, p1); }
	static Any SET_TEXT_LINE_DISPLAY() { return invoke<Any>(0x5AE8AF79); } // unused
	static void SET_TEXT_COLOUR(int r, int g, int b, int a) { invoke<Void>(0xE54DD2C8, r, g, b, a); }
	static void SET_TEXT_JUSTIFY(BOOL toggle) { invoke<Void>(0xBC971139, toggle); }
	static void SET_TEXT_CENTRE(BOOL toggle) { invoke<Void>(0xE26D39A1, toggle); }
	static void SET_TEXT_TO_USE_TEXT_FILE_COLOURS(BOOL toggle) { invoke<Void>(0xB95E39DE, toggle); } // unused
	static void SET_TEXT_LINE_HEIGHT_MULT(float mult) { invoke<Void>(0x2F947549, mult); } // unused
	static void SET_TEXT_WRAP(float start, float end) { invoke<Void>(0x6F60AB54, start, end); }
	static void SET_TEXT_BACKGROUND(BOOL toggle) { invoke<Void>(0x14ADAD25, toggle); } // unused
	static void SET_TEXT_USE_UNDERSCORE(BOOL toggle) { invoke<Void>(0x95CD1881, toggle); } // unused
	static void SET_TEXT_PROPORTIONAL(BOOL toggle) { invoke<Void>(0xF49D8A08, toggle); } // unused
	static Any LOAD_TEXT_FONT() { return invoke<Any>(0x9A4F5026); } // unused
	static BOOL IS_TEXT_FONT_LOADED(int font) { return invoke<BOOL>(0xD82F8828, font); } // unused
	static void SET_TEXT_FONT(int font) { invoke<Void>(0x80BC530D, font); } // unused
	static void SET_TEXT_DRAW_BEFORE_FADE(BOOL toggle) { invoke<Void>(0x1B2BA35E, toggle); } // unused
	static void SET_TEXT_RIGHT_JUSTIFY(BOOL toggle) { invoke<Void>(0x45B60520, toggle); }
	static Any DISPLAY_TEXT_WITH_NUMBER() { return invoke<Any>(0xECE5A56D); } // unused
	static Any DISPLAY_TEXT_WITH_2_NUMBERS() { return invoke<Any>(0x6931FB7C); } // unused
	static Any DISPLAY_TEXT_WITH_3_NUMBERS() { return invoke<Any>(0x23EFF6DA); } // unused
	static void SET_TEXT_DROPSHADOW(int distance, int r, int g, int b, int a) { invoke<Void>(0xE6587517, distance, r, g, b, a); }
	static void DISPLAY_TEXT_WITH_FLOAT(float x, float y, char* textLabel, float value, int p4) { invoke<Void>(0x9B4D3A1C, x, y, textLabel, value, p4); } // unused
	static void DISPLAY_TEXT_WITH_LITERAL_STRING(float x, float y, char* textLabel, char* string) { invoke<Void>(0x247F4D85, x, y, textLabel, string); }
	static Any DISPLAY_TEXT_WITH_TWO_LITERAL_STRINGS() { return invoke<Any>(0x04DA9DF6); } // unused
	static Any DISPLAY_TEXT_WITH_STRING() { return invoke<Any>(0xB6BA7A8A); } // unused
	static Any DISPLAY_TEXT_WITH_TWO_STRINGS() { return invoke<Any>(0xB07C454C); } // unused
	static void SET_TEXT_EDGE(int p0, int r, int g, int b, int a) { invoke<Void>(0x3F1A5DAB, p0, r, g, b, a); }
	static void SET_TEXT_RENDER_ID(int renderId) { invoke<Void>(0xC5C3B7F3, renderId); }
	static int GET_SCRIPT_RENDERTARGET_RENDER_ID() { return invoke<int>(0xE7617459); }
	static void SET_SCRIPT_RENDERTARGET_SIZE_ID(int p0, int p1, int p2) { invoke<Void>(0x5155F6F8, p0, p1, p2); } // unused
	static void PRINT_HELP(char* textLabel) { invoke<Void>(0x6A762B4E, textLabel); } // unused
	static Any PRINT_HELP_WITH_NUMBER() { return invoke<Any>(0x215A5FCC); } // unused
	static void PRINT_HELP_WITH_STRING(char* p0, char* p1) { invoke<Void>(0x66735DD7, p0, p1); } // unused
	static Any PRINT_HELP_WITH_STRING_NO_SOUND() { return invoke<Any>(0x89A0FF88); } // unused
	static void CLEAR_HELP() { invoke<Void>(0xE6D85741); }
	static Any PRINT_HELP_FOREVER() { return invoke<Any>(0xB7AC63C3); } // unused
	static Any PRINT_HELP_FOREVER_WITH_NUMBER() { return invoke<Any>(0xADE2E873); } // unused
	static Any PRINT_HELP_FOREVER_WITH_STRING() { return invoke<Any>(0xDB159D05); } // unused
	static Any PRINT_HELP_FOREVER_WITH_STRING_NO_SOUND() { return invoke<Any>(0x63049363); } // unused
	static Any IS_HELP_MESSAGE_BEING_DISPLAYED() { return invoke<Any>(0xA65F262A); } // unused
	static Any SET_HELP_MESSAGE_BOX_SIZE() { return invoke<Any>(0x138D7BB9); } // unused
	static Any GET_HELP_MESSAGE_BOX_SIZE() { return invoke<Any>(0x3F552D6C); } // unused
	static Any IS_THIS_HELP_MESSAGE_BEING_DISPLAYED() { return invoke<Any>(0x792ECC8C); } // unused
	static Any IS_THIS_HELP_MESSAGE_WITH_NUMBER_BEING_DISPLAYED() { return invoke<Any>(0x7303D366); } // unused
	static Any IS_THIS_HELP_MESSAGE_WITH_STRING_BEING_DISPLAYED() { return invoke<Any>(0x8FDB39D4); } // unused
	static void DISPLAY_NON_MINIGAME_HELP_MESSAGES(BOOL toggle) { invoke<Void>(0xDBD36A26, toggle); } // unused
	static BOOL DOES_THIS_MINIGAME_SCRIPT_ALLOW_NON_MINIGAME_HELP_MESSAGES() { return invoke<BOOL>(0xE667A6D1); } // unused
	static Any ADD_TO_PREVIOUS_BRIEF() { return invoke<Any>(0xFE33CF4A); } // unused
	static Any ADD_TO_PREVIOUS_BRIEF_WITH_UNDERSCORE() { return invoke<Any>(0xB12B4573); } // unused
	static Blip GET_CENTRE_BLIP_ID() { return invoke<Blip>(0x45EDA627); }
	static Blip GET_NEXT_BLIP_INFO_ID(int sprite) { return invoke<Blip>(0x9356E92F, sprite); } // unused
	static Blip GET_FIRST_BLIP_INFO_ID(int sprite) { return invoke<Blip>(0x64C0273D, sprite); } // unused
	static Vector3 GET_BLIP_INFO_ID_COORD(Blip blip) { return invoke<Vector3>(0xB7374A66, blip); } // unused
	static int GET_BLIP_INFO_ID_DISPLAY(Blip blip) { return invoke<int>(0xD0FC19F4, blip); } // unused
	static int GET_BLIP_INFO_ID_TYPE(Blip blip) { return invoke<int>(0x501D7B4E, blip); } // unused
	static Vehicle GET_BLIP_INFO_ID_VEHICLE_INDEX(Blip blip) { return invoke<Vehicle>(0x6CB45104, blip); } // unused
	static Ped GET_BLIP_INFO_ID_PED_INDEX(Blip blip) { return invoke<Ped>(0x0DD57007, blip); } // unused
	static Object GET_BLIP_INFO_ID_OBJECT_INDEX(Blip blip) { return invoke<Object>(0x27AB7110, blip); } // unused
	static Pickup GET_BLIP_INFO_ID_PICKUP_INDEX(Blip blip) { return invoke<Pickup>(0x86913D37, blip); } // unused
	static Blip ADD_BLIP_FOR_GANG_TERRITORY(float x, float y, float z) { return invoke<Blip>(0x63EBC4FA, x, y, z); } // unused
	static Blip ADD_BLIP_FOR_VEHICLE(Vehicle vehicle) { return invoke<Blip>(0xA338238C, vehicle); } // unused
	static Blip ADD_BLIP_FOR_PED(Ped ped) { return invoke<Blip>(0x8A6ED1DF, ped); }
	static Blip ADD_BLIP_FOR_OBJECT(Object object) { return invoke<Blip>(0x0E5372EC, object); } // unused
	static Blip ADD_BLIP_FOR_PICKUP(Pickup pickup) { return invoke<Blip>(0x16693C3A, pickup); } // unused
	static Blip ADD_BLIP_FOR_COORD(float x, float y, float z) { return invoke<Blip>(0xC6F43D0E, x, y, z); }
	static Vector3 GET_BLIP_COORDS(Blip blip) { return invoke<Vector3>(0xEF6FF47B, blip); }
	static void SET_BLIP_COORDS(Blip blip, float x, float y, float z) { invoke<Void>(0x680A34D4, blip, x, y, z); }
	static Blip ADD_BLIP_FOR_CONTACT(float x, float y, float z) { return invoke<Blip>(0x6295B365, x, y, z); } // unused
	static void SET_BLIP_ROTATION(Blip blip, float rotation) { invoke<Void>(0x6B8F44FE, blip, rotation); }
	static void SHOW_BLIP_ROTATION(Blip blip, BOOL toggle) { invoke<Void>(0x17773F15, blip, toggle); }
	static void SET_BLIP_SPRITE(Blip blip, int sprite) { invoke<Void>(0x8DBBB0B9, blip, sprite); }
	static int GET_BLIP_SPRITE(Blip blip) { return invoke<int>(0x72FF2E73, blip); } // unused
	static void SET_BLIP_NAME_FROM_TEXT_FILE(Blip blip, char* gxt) { invoke<Void>(0xAC8A5461, blip, gxt); } // unused
	static void SET_BLIP_NAME_FROM_ASCII(Blip blip, char* name) { invoke<Void>(0x40279490, blip, name); }
	static void SET_BLIP_ALPHA(Blip blip, int alpha) { invoke<Void>(0xA791FCCD, blip, alpha); }
	static int GET_BLIP_ALPHA(Blip blip) { return invoke<int>(0x297AF6C8, blip); }
	static void SET_BLIP_COLOUR(Blip blip, int color) { invoke<Void>(0xBB3C5A41, blip, color); }
	static int GET_BLIP_COLOUR(Blip blip) { return invoke<int>(0xDD6A1E54, blip); } // unused
	static BOOL IS_BLIP_SHORT_RANGE(Blip blip) { return invoke<BOOL>(0x1226765A, blip); } // unused
	static void SET_BLIP_MARKER_LONG_DISTANCE(Blip blip, BOOL toggle) { invoke<Void>(0x0D0C1675, blip, toggle); } // unused
	static void SET_BLIP_FLASHES(Blip blip, BOOL toggle) { invoke<Void>(0xC0047F15, blip, toggle); }
	static void SET_BLIP_FLASHES_ALTERNATE(Blip blip, BOOL toggle) { invoke<Void>(0x1A81202B, blip, toggle); } // unused
	static void SET_BLIP_AS_SHORT_RANGE(Blip blip, BOOL toggle) { invoke<Void>(0x5C67725E, blip, toggle); } // unused
	static void SET_TERRITORY_BLIP_SCALE(Blip blip, float p1, float p2) { invoke<Void>(0xAB843007, blip, p1, p2); } // unused
	static void SET_BLIP_SCALE(Blip blip, float scale) { invoke<Void>(0x1E6EC434, blip, scale); }
	static void SET_BLIP_PRIORITY(Blip blip, int priority) { invoke<Void>(0xCE87DA6F, blip, priority); }
	static void SET_BLIP_DISPLAY(Blip blip, int display) { invoke<Void>(0x2B521F91, blip, display); }
	static void REMOVE_BLIP(Blip blip) { invoke<Void>(0xD8C3C1CD, blip); }
	static void REMOVE_ALL_SCRIPTED_BLIPS() { invoke<Void>(0x1C339C34); }
	static void SET_BLIP_AS_FRIENDLY(Blip blip, BOOL toggle) { invoke<Void>(0xF290CFD8, blip, toggle); } // unused
	static BOOL DOES_BLIP_EXIST(Blip blip) { return invoke<BOOL>(0xAE92DD96, blip); }
	static void SET_BLIP_DIM(Blip blip, int dim) { invoke<Void>(0x8AC07C0E, blip, dim); } // unused
	static void HIDE_LOADING_ON_FADE_THIS_FRAME() { invoke<Void>(0x35087963); } // unused
	static void SET_RADAR_AS_INTERIOR_THIS_FRAME() { invoke<Void>(0x6F2626E1); } // unused
	static void SET_WIDESCREEN_FORMAT(int format) { invoke<Void>(0xF016E08F, format); }
	static void DISPLAY_AREA_NAME(BOOL toggle) { invoke<Void>(0x489FDD41, toggle); } // unused
	static void DISPLAY_FRONTEND_MAP_BLIPS(BOOL toggle) { invoke<Void>(0x2C01BA1E, toggle); } // unused
	static void SET_MULTIPLAYER_HUD_TIME(char* time) { invoke<Void>(0x72F2B585, time); } // unused
	static void SET_MULTIPLAYER_HUD_CASH(int cash) { invoke<Void>(0xA8DB435E, cash); } // unused
	static void SET_MULTIPLAYER_HUD_SCORE_STATS(int p0, int p1) { invoke<Void>(0xA98EAAB3, p0, p1); } // unused
	static void HIDE_HELP_TEXT_THIS_FRAME() { invoke<Void>(0xF3807BED); } // unused
	static void DISPLAY_HELP_TEXT_THIS_FRAME(char* textLabel, BOOL p1) { invoke<Void>(0x18E3360A, textLabel, p1); } // unused
	static Any NETWORK_SET_RADIOHUD_IN_LOBBY_OFF() { return invoke<Any>(0x4FDBF664); } // unused
	static Hash GET_FRONTEND_STATE_NAME(int bufferSize, char* buffer) { return invoke<Hash>(0x4695E609, bufferSize, buffer); } // unused
	static void SET_PLAYER_ICON_COLOUR(int color) { invoke<Void>(0x1630B64C, color); } // unused
	static void SET_PICKUP_BLIP_SCALE(float scale) { invoke<Void>(0xD6A4F36B, scale); } // unused
	static void SET_PICKUP_BLIP_PRIORITY(int priority) { invoke<Void>(0x7E7DA662, priority); } // unused
	static void SET_PICKUP_BLIP_DISPLAY(int display) { invoke<Void>(0xC7410B80, display); } // unused
	static void SET_PICKUP_BLIP_COLOUR(int color) { invoke<Void>(0x8E3E6E45, color); } // unused
	static void SET_PICKUP_BLIP_SPRITE(int sprite) { invoke<Void>(0xEE28B6FE, sprite); } // unused
	static void SET_MPBAG_OVERHEAD_PARAMS(int p0, int p1, int p2, int p3, BOOL p4, BOOL p5, char* text) { invoke<Void>(0x1332298C, p0, p1, p2, p3, p4, p5, text); }
	static void SET_SPECIAL_MPITEM_BLIP_PARAMS(int p0, int p1, int p2, float p3, int p4, int p5, int p6) { invoke<Void>(0x90FD2B14, p0, p1, p2, p3, p4, p5, p6); }
	static void OVERRIDE_ALREADY_PRESENT_MPITEM_BLIPS_WITH_LAST_PARAMS() { invoke<Void>(0x45E585DF); }
	static void SET_INTERACTION_VOLUME_BLIP_PARAMS(int p0, int p1, int p2, float p3, int p4, int p5) { invoke<Void>(0xA90BA3FA, p0, p1, p2, p3, p4, p5); } // unused
	static Any CREATE_LOADOUT_SCREEN() { return invoke<Any>(0x0D6A8ACE); } // unused
	static Any DESTROY_LOADOUT_SCREEN() { return invoke<Any>(0x660F22FF); } // unused
	static Any ACTIVATE_LOADOUT_SCREEN() { return invoke<Any>(0xD3C74E5D); } // unused
	static void PLACE_LOADOUT_TO_INVENTORY() { invoke<Void>(0xA1EBA6BB); }
	static void PLACE_LOADOUT_ITEMS_TO_INVENTORY() { invoke<Void>(0x3EBE60EF); }
	static void SAVE_LOADOUT_TO_PROFILE() { invoke<Void>(0x0C1CD7E2); } // unused
	static BOOL LOADOUT_CHANGED_DURING_GAME() { return invoke<BOOL>(0xBE6FFEB1); }
	static void RESET_LOADOUT_CHANGED_DURING_GAME() { invoke<Void>(0xFE9542E3); }
	static void REPLENISH_LOADOUT_IN_INVENTORY() { invoke<Void>(0x2FA924B7); }
	static int GET_NUM_LOADOUT_SLOTS() { return invoke<int>(0xB197B3D2); }
	static BOOL IS_LOADOUT_SLOT_AVAILABLE(int slot) { return invoke<BOOL>(0xFA76A13A, slot); }
	static void GET_LOADOUT_SLOT_NAME(int bufferSize, char* buffer, int slot) { invoke<Void>(0x917F5D80, bufferSize, buffer, slot); }
	static int GET_CURRENT_LOADOUT_SLOT() { return invoke<int>(0x741531DA); }
	static void SET_CURRENT_LOADOUT_SLOT(int slot) { invoke<Void>(0xAD2DF9C0, slot); }
	static void ADD_BULLET_CAM_TEXT(char* text, float p1, float p2, int p3, int p4, float p5, float p6, int p7, int p8, int p9, float p10, float p11, float p12, float p13) { invoke<Void>(0x3A5A1CDB, text, p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13); } // unused
	static void CREATE_ANIMATED_TEXT(char* text, float x, float y) { invoke<Void>(0xDF9EC686, text, x, y); }
	static void SET_ANIMATED_TEXT_SCALE(float p0, float p1) { invoke<Void>(0xEF71D31B, p0, p1); }
	static void SET_ANIMATED_TEXT_COLOR(int r, int g, int b, int a) { invoke<Void>(0xA0AC3FD2, r, g, b, a); }
	static void SET_ANIMATED_TEXT_ANIMATIONS(Any p0, Any p1, float p2, float p3, Any p4, Any p5, Any p6, float p7, float p8) { invoke<Void>(0x71899FF8, p0, p1, p2, p3, p4, p5, p6, p7, p8); }
	static void SET_ANIMATED_TEXT_TWITCH(float p0, Any p1, Any p2) { invoke<Void>(0xA98C2A3D, p0, p1, p2); } // unused
	static void SET_ANIMATED_TEXT_JUSTIFY(int justifyType) { invoke<Void>(0x767DF0BA, justifyType); }
	static void DRAW_ANIMATED_TEXT() { invoke<Void>(0xF8C0BE3E); }
	static float GET_ANIMATED_TEXT_WIDTH() { return invoke<float>(0x8276E3F9); }
	static float GET_ANIMATED_TEXT_HEIGHT() { return invoke<float>(0x71223133); } // unused
	static void ENABLE_SNIPER_HUD(BOOL toggle) { invoke<Void>(0x8C6E1D09, toggle); } // unused
	static void SET_SNIPER_HUD_ALPHA(int alpha) { invoke<Void>(0x13A2A389, alpha); }
	static void HUD_SET_PLAYER_HEALTH_TEXTURE(char* textureName) { invoke<Void>(0x954FDCD0, textureName); }
	static void ENABLE_PLAYERHEALTH(BOOL toggle) { invoke<Void>(0x2ACBE7FA, toggle); }
	static void ENABLE_BULLETTIMEMETER(BOOL toggle) { invoke<Void>(0x5FA15459, toggle); }
	static void ENABLE_WEAPONPICKUP(BOOL toggle) { invoke<Void>(0x1C727DAA, toggle); }
	static void SET_USING_ALT_HEALTH(BOOL toggle) { invoke<Void>(0xB135037B, toggle); }
	static void SET_PLAYER_ALT_HEALTH(float health) { invoke<Void>(0x4DB0855A, health); }
	static void SET_PLAYER_ALT_MAX_HEALTH(float health) { invoke<Void>(0x638660F0, health); }
	static void ENABLE_EQUIPPEDWEAPON(BOOL toggle) { invoke<Void>(0x398E8CF1, toggle); }
	static void ENABLE_INVENTORY(BOOL toggle) { invoke<Void>(0x6B3C2DAC, toggle); }
	static void ENABLE_CROSSHAIR(BOOL toggle) { invoke<Void>(0x6C40B100, toggle); }
	static void ENABLE_AMMOPICKUP(BOOL toggle) { invoke<Void>(0x2077903F, toggle); }
	static void ENABLE_DEATHHELPERTEXT(BOOL p0, BOOL p1, int p2) { invoke<Void>(0xB7067496, p0, p1, p2); }
	static void ENABLE_GRENADE_WARNING(BOOL toggle) { invoke<Void>(0x2C61E2B5, toggle); } // unused
	static void ALLOW_BULLET_CAMERA_TUTORIAL_MSG(BOOL toggle) { invoke<Void>(0xB20B0BD2, toggle); }
	static void TOGGLE_SECONDARY_LIFE_BAR(BOOL toggle) { invoke<Void>(0x5BD64BF5, toggle); }
	static void SET_SECONDARY_LIFE_BAR_NAME(char* name) { invoke<Void>(0x6CB9CEA9, name); } // unused
	static void SET_SECONDARY_LIFE_BAR_PERCENT(float percent) { invoke<Void>(0x78474550, percent); }
	static float GET_SECONDARY_LIFE_BAR_PERCENT() { return invoke<float>(0x3FBDD93D); }
	static void SET_SECONDARY_LIFE_BAR_START_FLASH_PERCENT(float percent) { invoke<Void>(0xB8BD396B, percent); } // unused
	static void TOGGLE_SECONDARY_LIFE_BAR_FLASH(BOOL toggle) { invoke<Void>(0xE081A44C, toggle); } // unused
	static void SET_PROGRESS_BAR_VISIBLE(BOOL toggle) { invoke<Void>(0x7CA2A24F, toggle); }
	static void SET_PROGRESS_BAR_NAME(char* name) { invoke<Void>(0x07284689, name); }
	static void SET_PROGRESS_BAR_PERCENT(float percent) { invoke<Void>(0x5D681AB9, percent); }
	static float GET_PROGRESS_BAR_PERCENT() { return invoke<float>(0xA04FB35F); } // unused
	static void SET_PROGRESS_BAR_START_FLASH_PERCENT(float percent) { invoke<Void>(0x29FF4235, percent); } // unused
	static void SET_PROGRESS_BAR_FLASH(BOOL toggle) { invoke<Void>(0x7CCD409B, toggle); } // unused
	static void SET_PROGRESS_BAR_POSITION(float x, float y) { invoke<Void>(0x7933FBC4, x, y); }
	static void SET_PROGRESS_BAR_COLOURS(int color1, int color2) { invoke<Void>(0xE68944E3, color1, color2); }
	static void HUD_SET_CURRENT_STREAK(BOOL p0, char* p1, int p2, int p3, int p4) { invoke<Void>(0x296B0492, p0, p1, p2, p3, p4); }
	static BOOL UI_IS_TOOLTIP_SHOWING() { return invoke<BOOL>(0x71C43A04); }
	static BOOL ISTOASTANIMATING() { return invoke<BOOL>(0x23C45638); }
	static void SET_HUD_TIMER(int p0, int p1) { invoke<Void>(0x4E42A47B, p0, p1); }
	static void SET_INFO_TIMER(char* p0, int p1) { invoke<Void>(0x2402EFB6, p0, p1); }
	static void HUD_SCOREBOARD_SHOW(BOOL toggle) { invoke<Void>(0xF068DFC8, toggle); }
	static void HUD_SCOREBOARD_SORT_BY(char* p0) { invoke<Void>(0xB19BBC22, p0); }
	static void HUD_SCOREBOARD_SETPLAYERVALUES_TEAM(Any p0, Any p1) { invoke<Void>(0xFF4217BA, p0, p1); }
	static void HUD_SCOREBOARD_SETPLAYERVALUES_KILLDEATH(Any p0, Any p1, Any p2) { invoke<Void>(0x61D1AF52, p0, p1, p2); }
	static void HUD_SCOREBOARD_SETPLAYERVALUES_POINTS(Any p0, Any p1) { invoke<Void>(0xCAE15E7C, p0, p1); }
	static void HUD_SCOREBOARD_SETPLAYERVALUES_LIVES(Any p0, Any p1) { invoke<Void>(0xCA96230B, p0, p1); }
	static void HUD_SCOREBOARD_SETPLAYERVALUES_ASSISTS(Any p0, Any p1) { invoke<Void>(0x7F885408, p0, p1); }
	static Any HUD_SCOREBOARD_SETPLAYERVALUES_XP2() { return invoke<Any>(0x320884BF); } // unused
	static void HUD_SCOREBOARD_SETPLAYERVALUES_FAKE_DEAD(Any p0, Any p1) { invoke<Void>(0x64493D6D, p0, p1); }
	static void HUD_SCOREBOARD_SETPLAYERVALUES_FAKE_ALIVE(Any p0, Any p1) { invoke<Void>(0x96A91A36, p0, p1); }
	static void HUD_SCOREBOARD_SETPLAYERVALUES_VENDETTA(Any p0, Any p1) { invoke<Void>(0x0BAB504D, p0, p1); }
	static void HUD_SCOREBOARD_SETPLAYERVALUES_ROLE(Any p0, Any p1, Any p2) { invoke<Void>(0xBD05410B, p0, p1, p2); }
	static Any HUD_SCOREBOARD_RESETPLAYERXP() { return invoke<Any>(0xC5437B8F); } // unused
	static void HUD_SCOREBOARD_SETPLAYERBASEXP(Any p0, Any p1) { invoke<Void>(0x1742CD46, p0, p1); }
	static Any HUD_SCOREBOARD_RESETALLPLAYERXP() { return invoke<Any>(0x98AF4AB7); } // unused
	static Any HUD_SCOREBOARD_GETPLAYERPOSITION(Any p0) { return invoke<Any>(0x581C7D26, p0); }
	static Any HUD_SCOREBOARD_SETPROGRESS() { return invoke<Any>(0xA6F24CFB); } // unused
	static void HUD_SCOREBOARD_SETTEAMNAMES(char* teamName1, char* teamName2) { invoke<Void>(0x921D2407, teamName1, teamName2); }
	static void SET_SECONDARY_LIFE_BAR_COLOR(int color) { invoke<Void>(0xBBB82D30, color); } // unused
	static void SET_SECONDARY_LIFE_BACKGROUND_COLOR(int color) { invoke<Void>(0xC509E8EA, color); } // unused
	static void SET_SECONDARY_LIFE_TEXT_COLOR(int color) { invoke<Void>(0x8333ADD4, color); } // unused
	static void SET_SECONDARY_LIFE_BAR_COLOR32(int r, int g, int b) { invoke<Void>(0x502ECD4B, r, g, b); } // unused
	static void SET_SECONDARY_LIFE_BACKGROUND_COLOR32(int r, int g, int b) { invoke<Void>(0xE6330B74, r, g, b); } // unused
	static void SET_SECONDARY_LIFE_TEXT_COLOR32(int r, int g, int b) { invoke<Void>(0xADA42319, r, g, b); } // unused
	static void SET_SECONDARY_LIFE_ICON(char* iconName) { invoke<Void>(0x161011A3, iconName); } // unused
	static void SET_SECONDARY_LIFE_ICON_COLOR(int color) { invoke<Void>(0x441B42D0, color); } // unused
	static void SET_SECONDARY_LIFE_ICON_COLOR32(int r, int g, int b) { invoke<Void>(0x585032B9, r, g, b); } // unused
	static void ENABLE_HIT_DETECTION(BOOL toggle) { invoke<Void>(0xE476F1D1, toggle); }
	static void SET_KILL_EFFECT_NAME(char* name) { invoke<Void>(0xCB39A28D, name); }
	static void SET_INTERACTIONTEXT_VISIBLE(BOOL toggle) { invoke<Void>(0x20538A42, toggle); }
	static void FORCE_INTERACTIONTEXT_VISIBLE(BOOL toggle) { invoke<Void>(0xD69DFC56, toggle); } // unused
	static void SET_INTERACTIONTEXT_BUTTON(int button) { invoke<Void>(0xD2AC407F, button); }
	static void SET_INTERACTIONTEXT_TEXT(char* text) { invoke<Void>(0x4C2397BD, text); }
	static void SET_INTERACTIONTEXT_PULSE(BOOL toggle) { invoke<Void>(0x3825FF30, toggle); }
	static void SET_INTERACTIONTEXT_PULSE_PERIOD(float period) { invoke<Void>(0xFE5984FF, period); }
	static void SET_INTERACTIONTEXT_AVAILABLE(BOOL toggle) { invoke<Void>(0xDDCFB33F, toggle); }
	static void SET_INTERACTIONTEXT_BUTTON_VISIBLE(BOOL toggle) { invoke<Void>(0x120A3F51, toggle); }
	static void ENABLE_OVERHEAT_ICON(BOOL toggle, char* iconName) { invoke<Void>(0x085921A0, toggle, iconName); }
	static void SET_OVERHEAT_AMOUNT(float amount) { invoke<Void>(0x624A49AE, amount); }
	static void SET_CROSSHAIR_BLINK() { invoke<Void>(0x59868456); } // unused
	static void SET_CROSSHAIR_PULSE() { invoke<Void>(0xB5B648B0); }
	static void SET_SECONDARY_LIFE_SCALE(float p0, float p1) { invoke<Void>(0x5CE97A69); } // unused
	static void SET_SECONDARY_LIFE_BAR_ALPHA(int alpha) { invoke<Void>(0xB0139147, alpha); } // unused
	static void TOGGLE_DISPLAY_AMMO(BOOL toggle) { invoke<Void>(0x08807D97, toggle); }
	static void DRAW_BACKGROUND(int p0, int p1, int r, int g, int b, int a) { invoke<Void>(0x7B6E91AF, p0, p1, r, g, b, a); } // unused
	static void ENABLE_TUTORIAL_HUD(BOOL toggle) { invoke<Void>(0xC8B35409, toggle); } // unused
	static void ENABLE_CHECKPOINT_ICON() { invoke<Void>(0xAE5FF058); }
	static void ENABLE_DUAL_WIELD_IN_INVENTORY(BOOL toggle) { invoke<Void>(0x8625D99F, toggle); }
	static BOOL IS_SNIPER_SCOPE_VISIBLE() { return invoke<BOOL>(0xBC59557E); }
	static BOOL IS_SP_LEVEL_REPLAY() { return invoke<BOOL>(0x842386F7); } // unused
	static void FORCE_PAUSEMENU_OPEN() { invoke<Void>(0x495FD473); }
	static void SET_DISABLE_CUTSCENE_CROSSHAIRS(BOOL toggle) { invoke<Void>(0xEFB0A45E, toggle); }
	static void INIT_RINGICON_DATA(Any* ringicon) { invoke<Void>(0xE7B01199, ringicon); }
	static void SET_RINGICON_OBJECT(Object object, Any* ringicon) { invoke<Void>(0x8B6F801B, object, ringicon); }
	static void SET_RINGICON_PLAYER(Player player, Any* ringicon) { invoke<Void>(0x9506F619, player, ringicon); }
	static void SET_RINGICON_WORLD(float x, float y, float z, Any* ringicon) { invoke<Void>(0x32BE24DE, x, y, z, ringicon); }
	static void SET_RINGICON_OBJECT_PERCENT(Object object, float percent) { invoke<Void>(0x616D7ACC, object, percent); }
	static void SET_RINGICON_PLAYER_PERCENT(Player player, float percent) { invoke<Void>(0x473ADD6D, player, percent); } // unused
	static void SET_RINGICON_WORLD_PERCENT(float x, float y, float z, float percent) { invoke<Void>(0x5BF34139, x, y, z, percent); }
	static void CLEAR_RINGICON_OBJECT(Object object) { invoke<Void>(0x284B05F3, object); }
	static void CLEAR_RINGICON_PLAYER(Player player) { invoke<Void>(0x913B00BA, player); }
	static void CLEAR_RINGICON_WORLD(float x, float y, float z) { invoke<Void>(0x879CB1D1, x, y, z); }
	static void CLEAR_ALL_RINGICON_WORLD() { invoke<Void>(0xA87B2666); }
	static BOOL IS_MP_TUTORIAL_MESSAGES_SHOWN() { return invoke<BOOL>(0xF501D241); }
	static void UI_START_QTE_MINIGAME(float p0, float p1, float p2, int p3) { invoke<Void>(0x0A6F90D0, p0, p1, p2, p3); } // unused
	static void UI_STOP_QTE_MINIGAME() { invoke<Void>(0x478F8D91); } // unused
	static BOOL UI_IS_QTE_MINIGAME_FINISHED() { return invoke<BOOL>(0xC55DA3BB); } // unused
	static BOOL UI_IS_QTE_MINIGAME_IN_WINDOW() { return invoke<BOOL>(0xD6D05C65); } // unused
	static BOOL IS_QUIT_CONFIRMING() { return invoke<BOOL>(0xDBA589AE); }
	static BOOL UI_IS_QTE_MINIGAME_SUCCESS() { return invoke<BOOL>(0xF664AEA4); } // unused
	static BOOL UI_IS_QTE_MINIGAME_FAILURE() { return invoke<BOOL>(0xEFEEDC60); } // unused
	static void DISABLE_RESTART_CHECKPOINT(BOOL toggle) { invoke<Void>(0x558A8538, toggle); }
	static BOOL IS_RESTARTCHECKPOINT_DISABLED_BY_SCRIPT() { return invoke<BOOL>(0x6F67E592); } // unused
	static void FORCE_RED_RETICULE(BOOL toggle) { invoke<Void>(0x12F5C34E, toggle); }
	static BOOL IS_INTERACTIONTEXT_ONSCREEN() { return invoke<BOOL>(0x22C325FB); }
	static BOOL IS_INTERACTIONTEXT_AVAILABLE() { return invoke<BOOL>(0x419C48B7); }
	static void SET_END_OF_PART_ONE() { invoke<Void>(0x46890BC0); }
	static BOOL WAS_SINGLE_PLAYER_TITLE_SCREEN_ENTERED() { return invoke<BOOL>(0x3912FB64); }
	static void SET_SINGLE_PLAYER_TITLE_SCREEN_ENTRY_HANDLED() { invoke<Void>(0x9DF58C06); }
	static void SET_CONTROL_CONFIG_OPTION_DISABLED(BOOL toggle) { invoke<Void>(0xF569B90D, toggle); }
	static BOOL IS_WEAPON_PICKUP_VISIBLE() { return invoke<BOOL>(0xD7492EEB); }
	static BOOL _0x6E962B5B() { return invoke<BOOL>(0x6E962B5B); }
	static void _0xDDEFBB33(int loadoutSlot, char* buffer) { invoke<Void>(0xDDEFBB33, loadoutSlot, buffer); } // unused
	static Hash _0x5F5212D9(Hash weaponHash, char* buffer) { return invoke<Hash>(0x5F5212D9, weaponHash, buffer); } // unused
}

namespace MISC
{
	static void SET_RICH_PRESENCE(Any* p0) { invoke<Void>(0x7BDCBD45, p0); }
	static int GET_CURRENT_ARCADE_MODE() { return invoke<int>(0xD7FA564A); } // unused
	static int GET_CURRENT_LEVEL_START() { return invoke<int>(0xF1AAFA7B); } // unused
	static int GET_CURRENT_LEVEL_FINISH() { return invoke<int>(0x64C8F354); } // unused
	static BOOL IS_ARCADE_MODE_ACTIVE() { return invoke<BOOL>(0x93A9462E); }
	static BOOL IS_IN_SCORE_ATTACK_MODE() { return invoke<BOOL>(0x37A598E6); } // unused
	static BOOL IS_IN_NYMINUTE_MODE() { return invoke<BOOL>(0x62AE43CB); }
	static BOOL IS_IN_CPCHALLENGE_MODE() { return invoke<BOOL>(0xE43D4E47); } // unused
	static BOOL IS_IN_NYM_HARDCORE_MODE() { return invoke<BOOL>(0x45C22E47); } // unused
	static BOOL IS_IN_STORY_MODE() { return invoke<BOOL>(0x442DD86B); }
	static void DISPLAY_ARCADE_MODE_LEVEL_END(char* levelName) { invoke<Void>(0xD64ABCEF, levelName); }
	static void SET_HIGHEST_ARCADE_LEVEL_UNLOCKED(int levelId) { invoke<Void>(0xC6B59993, levelId); }
	static void UPDATE_ARCADE_CHECK_POINT(int p0) { invoke<Void>(0x131CE7C6, p0); }
	static void SET_SAFE_TO_KILL_PLAYER(BOOL toggle) { invoke<Void>(0x1328332A, toggle); }
	static BOOL IS_SAFE_TO_KILL_PLAYER() { return invoke<BOOL>(0x6702E169); } // unused
	static float GET_TIME_REMAINING() { return invoke<float>(0x85FA3578); }
	static void GET_CURRENT_LEVEL_NAME(int bufferSize, char* buffer) { invoke<Void>(0xD11807A3, bufferSize, buffer); } // unused
	static BOOL _0xA328A44A() { return invoke<BOOL>(0xA328A44A); } // unused
	static void _0xE36E2536(BOOL toggle) { invoke<Void>(0xE36E2536, toggle); } // unused
	static void _0x8A52A2C0(Ped ped, int p1, Any* p2) { invoke<Void>(0x8A52A2C0, ped, p1, p2); } // unused
	static int _GET_CHALLENGE_MODE_STREAK() { return invoke<int>(0xDBD7F6A3); } // unused
	static void _SET_CHALLENGE_MODE_STREAK(int amount) { invoke<Void>(0xFD53580A, amount); } // unused
	static float _GET_CHALLENGE_MODE_TIME_REMAINING() { return invoke<float>(0xD91473DB); } // unused
	static void _SET_CHALLENGE_MODE_TIME_REMAINING(float time) { invoke<Void>(0x493D0DA7, time); } // unused
	static int _0x8F052EB9() { return invoke<int>(0x8F052EB9); } // unused
	static int _0xE93ED57B() { return invoke<int>(0xE93ED57B); } // unused
	static int _0x1ED65D54(Hash hash) { return invoke<int>(0x1ED65D54, hash); } // unused
	static void _0xF8EE133C(int bufferSize, char* buffer, Hash hash) { invoke<Void>(0xF8EE133C, bufferSize, buffer); } // unused
	static int _GET_ARCADE_CHECKPOINT() { return invoke<int>(0x8F64EDF4); } // unused
	static void _0x10FBD916(Any p0, char* p1, Any p2, BOOL p3) { invoke<Void>(0x10FBD916, p0, p1, p2, p3); } // unused
	static void _0x0C63AC67(Any p0, Any p1, char* p2, Any p3, BOOL p4) { invoke<Void>(0x0C63AC67, p0, p1, p2, p3, p4); } // unused
	static void _0xB0F08CA2(BOOL toggle) { invoke<Void>(0xB0F08CA2, toggle); } // unused
	static void _0xE5B45011(BOOL p0) { invoke<Void>(0xE5B45011, p0); } // unused
	static void _0xC2B42F6A() { invoke<Void>(0xC2B42F6A); } // unused
	static BOOL _0x0751E6F3() { return invoke<BOOL>(0x0751E6F3); } // unused
	static void _0xF1C0396E(BOOL toggle) { invoke<Void>(0xF1C0396E, toggle); } // unused
	static BOOL _0x038569E0() { return invoke<BOOL>(0x038569E0); } // unused
	static void _0xF9ECFD89(BOOL toggle) { invoke<Void>(0xF9ECFD89, toggle); } // unused
	static void _0x6669E888(int p0) { invoke<Void>(0x6669E888, p0); } // unused
	static BOOL IS_GOLDEN_GUN_FINISHED(char* name) { return invoke<BOOL>(0xD92C7E81, name); } // unused
	static void FOUND_EXPLORATION_ITEM(char* name) { invoke<Void>(0x1E09BCAC, name); }
	static BOOL HAS_EXPLORATION_ITEM_BEEN_FOUND(char* name) { return invoke<BOOL>(0xE8E8D39B, name); }
	static void SET_RANDOM_SEED(int seed) { invoke<Void>(0xDB3FEB5C, seed); }
	static void SET_TIME_SCALE(float scale) { invoke<Void>(0xA7F84694, scale); } // unused
	static float GET_TIME_SCALE() { return invoke<float>(0x8CFD581F); } // unused
	static void SET_MISSION_FLAG(BOOL value) { invoke<Void>(0x57592D52, value); } // unused
	static BOOL GET_MISSION_FLAG() { return invoke<BOOL>(0x95115F97); } // unused
	static void SET_HIGHEST_DIFFICULTY_BEAT() { invoke<Void>(0x6196D0C8); }
	static void SET_WEATHER_TYPE_PERSIST(char* weatherType) { invoke<Void>(0xC6C04C75, weatherType); }
	static void SET_WEATHER_TRANSITION_IMMEDIATE(BOOL toggle) { invoke<Void>(0x8DE31F0B, toggle); }
	static void SET_WEATHER_TYPE_NOW_PERSIST(char* weatherType) { invoke<Void>(0xC869FE97, weatherType); }
	static void SET_RANDOM_WEATHER_TYPE() { invoke<Void>(0xE7AA1BC9); } // unused
	static void CLEAR_WEATHER_TYPE_PERSIST() { invoke<Void>(0x6AB757D8); }
	static void SET_WIND(float speed) { invoke<Void>(0xC6294698, speed); } // unused
	static void SET_WEATHER_TRANSITION_SPEED(float speed) { invoke<Void>(0x17EB71A7, speed); }
	static Any ADD_WIND_THERMAL() { return invoke<Any>(0xF355A848); } // unused
	static Any REMOVE_WIND_THERMAL() { return invoke<Any>(0xD1B522B6); } // unused
	static int GET_REAL_TIME() { return invoke<int>(0xCBB4CA94); }
	static int GET_GAME_TIMER() { return invoke<int>(0xA4EA0691); }
	static int GET_REAL_GAME_TIMER() { return invoke<int>(0x5FBEB0F6); }
	static float GET_FRAME_TIME() { return invoke<float>(0x96374262); }
	static float GET_REAL_FRAME_TIME() { return invoke<float>(0x04D12A84); }
	static int GET_GAME_IDLE_TIMER() { return invoke<int>(0x069FBFDC); }
	static void RESET_GAME_IDLE_TIMER() { invoke<Void>(0xB8B2853A); }
	static float GET_RANDOM_FLOAT_IN_RANGE(float min, float max) { return invoke<float>(0x0562C4D0, min, max); }
	static int GET_RANDOM_INT_IN_RANGE(int min, int max) { return invoke<int>(0x4051115B, min, max); }
	static BOOL GET_GROUND_Z_FOR_3D_COORD(float x, float y, float z, float* groundZ) { return invoke<BOOL>(0xA1BFD5E0, x, y, z, groundZ); }
	static float ASIN(float x) { return invoke<float>(0x998E5CAD, x); } // unused
	static float ACOS(float x) { return invoke<float>(0xF4038776, x); }
	static float TAN(float x) { return invoke<float>(0xD320CE5E, x); } // unused
	static float ATAN(float x) { return invoke<float>(0x7A03CC8E, x); } // unused
	static float ATAN2(float y, float x) { return invoke<float>(0x2508AC81, y, x); } // unused
	static BOOL IS_AREA_OCCUPIED(float x1, float y1, float z1, float x2, float y2, float z2, BOOL p6, BOOL p7, BOOL p8, BOOL p9, BOOL p10) { return invoke<BOOL>(0xC013972F, x1, y1, z1, x2, y2, z2, p6, p7, p8, p9, p10); } // unused
	static BOOL IS_POINT_OBSCURED_BY_A_MISSION_ENTITY(float x1, float y1, float z1, float x2, float y2, float z2) { return invoke<BOOL>(0xC161558D, x1, y1, z1, x2, y2, z2); } // unused
	static void CLEAR_AREA(float x, float y, float z, float radius, BOOL dontIgnoreProjectiles) { invoke<Void>(0x854E9AB8, x, y, z, radius, dontIgnoreProjectiles); }
	static void CLEAR_AREA_OF_VEHICLES(float x, float y, float z, float radius) { invoke<Void>(0x63320F3C, x, y, z, radius); } // unused
	static void CLEAR_ANGLED_AREA_OF_VEHICLES(float x1, float y1, float z1, float x2, float y2, float z2, float p6) { invoke<Void>(0xF11A3018, x1, y1, z1, x2, y2, z2, p6); } // unused
	static void CLEAR_AREA_OF_OBJECTS(float x, float y, float z, float radius) { invoke<Void>(0xBB720FE7, x, y, z, radius); }
	static void CLEAR_AREA_OF_PEDS(float x, float y, float z, float radius) { invoke<Void>(0x25BE7FA8, x, y, z, radius); } // unused
	static void CLEAR_AREA_OF_COPS(float x, float y, float z, float radius) { invoke<Void>(0x95C53824, x, y, z, radius); } // unused
	static void CLEAR_PROJECTILES() { invoke<Void>(0xDE0D76C3); }
	static void CLEAR_AREA_OF_FIRES_AND_EXPLOSIONS(float x, float y, float z, float radius) { invoke<Void>(0xAE40D6A1, x, y, z, radius); }
	static void SET_NETWORK_SETTINGS_MENU(BOOL p0) { invoke<Void>(0x21C7922C, p0); } // unused
	static void SET_CREDITS_ACTIVE(BOOL toggle) { invoke<Void>(0xEC2A0ECF, toggle); }
	static BOOL ARE_CREDITS_ACTIVE() { return invoke<BOOL>(0xD53CA5A2); }
	static void TERMINATE_ALL_SCRIPTS_WITH_THIS_NAME(char* name) { invoke<Void>(0x9F861FD4, name); } // unused
	static void TERMINATE_ALL_SCRIPTS_FOR_NETWORK_GAME() { invoke<Void>(0x51C902BD); } // unused
	static void NETWORK_SET_SCRIPT_IS_SAFE_FOR_NETWORK_GAME() { invoke<Void>(0x878486CE); } // unused
	static void NETWORK_REMOVE_OLD_BLIPS_FROM_CLEANUP_LIST() { invoke<Void>(0x069DD331); } // unused
	static void SET_SCRIPT_SHOULD_BE_SAVED() { invoke<Void>(0xC109699A); }
	static void SET_PLAYER_CONTROL_ON_IN_MISSION_CLEANUP(BOOL toggle) { invoke<Void>(0xE886E2C5, toggle); } // unused
	static BOOL SET_ONE_TIME_ONLY_COMMANDS_TO_RUN() { return invoke<BOOL>(0x840BD987); }
	static float GET_DISTANCE_BETWEEN_COORDS(float x1, float y1, float z1, float x2, float y2, float z2, BOOL useZ) { return invoke<float>(0xF698765E, x1, y1, z1, x2, y2, z2, useZ); }
	static float GET_ANGLE_BETWEEN_2D_VECTORS(float x1, float y1, float x2, float y2) { return invoke<float>(0xDBF75E58, x1, y1, x2, y2); }
	static float GET_HEADING_FROM_VECTOR_2D(float dx, float dy) { return invoke<float>(0xD209D52B, dx, dy); }
	static int GET_SAVEGAME_LEVEL() { return invoke<int>(0x6BCE5E43); }
	static int GET_LAST_LEVEL_PLAYED() { return invoke<int>(0x1209CA49); }
	static BOOL REQUEST_SAVE() { return invoke<BOOL>(0x681BE79F); }
	static BOOL REQUEST_LOAD() { return invoke<BOOL>(0x0E35F54A); } // unused
	static BOOL HAS_LOAD_JUST_OCCURRED() { return invoke<BOOL>(0x12F1F57B); }
	static BOOL HAS_SELECTED_RETRY_CHECKPOINT() { return invoke<BOOL>(0x64F307B9); }
	static BOOL ARE_UNIT_TESTS_RUNNING() { return invoke<BOOL>(0x4F4C7FA4); } // unused
	static Any BROADCAST_UNIT_TEST_MESSAGE() { return invoke<Any>(0x44E68F92); } // unused
	static float PROJECTED_DISTANCE(float p0, float p1, float p2, float p3, float p4, float p5, float p6, float p7, float p8) { return invoke<float>(0xEC0E7C49, p0, p1, p2, p3, p4, p5, p6, p7, p8); }
	static float GET_BEST_HEADING_IF_POSSIBLE(float p0, float p1, float p2, float p3, float p4, float p5, float p6, float p7, float p8, float p9) { return invoke<float>(0x7A1EF9BD, p0, p1, p2, p3, p4, p5, p6, p7, p8, p9); }
	static int GET_REQUESTED_LEVEL() { return invoke<int>(0xE4D2AEE3); } // unused
	static void SHOOT_SINGLE_BULLET_BETWEEN_COORDS(float x1, float y1, float z1, float x2, float y2, float z2, int damage, BOOL p7, Hash weaponHash, Ped ownerPed) { invoke<Void>(0xCB7415AC, x1, y1, z1, x2, y2, z2, damage, p7, weaponHash, ownerPed); }
	static void RESERVE_BULLETS(int amount) { invoke<Void>(0xA253D302, amount); }
	static void GET_MODEL_DIMENSIONS(Hash modelHash, Vector3* minimum, Vector3* maximum) { invoke<Void>(0x91ABB8E0, modelHash, minimum, maximum); } // unused
	static void SET_FAKE_WANTED_LEVEL(int wantedLevel) { invoke<Void>(0x85B1C9FA, wantedLevel); } // unused
	static BOOL IS_BIT_SET(int data, int bit) { return invoke<BOOL>(0x902E26AC, data, bit); }
	static void SET_BIT(int* data, int bit) { invoke<Void>(0x4EFE7E6B, data, bit); }
	static void CLEAR_BIT(int* data, int bit) { invoke<Void>(0x8BC9E618, data, bit); }
	static Hash GET_HASH_KEY(char* value) { return invoke<Hash>(0x98EFF6F1, value); }
	static void SET_MINIGAME_IN_PROGRESS(BOOL toggle) { invoke<Void>(0x348B9046, toggle); } // unused
	static BOOL IS_MINIGAME_IN_PROGRESS() { return invoke<BOOL>(0x53A95E13); } // unused
	static BOOL IS_THIS_A_MINIGAME_SCRIPT() { return invoke<BOOL>(0x7605EF6F); } // unused
	static BOOL IS_SNIPER_INVERTED() { return invoke<BOOL>(0x5C3BF51B); } // unused
	static BOOL IS_JAPANESE_GAME() { return invoke<BOOL>(0x4F2A77E3); }
	static int GET_CURRENT_LANGUAGE() { return invoke<int>(0x761BE00B); } // unused
	static int GET_GAME_DIFFICULTY() { return invoke<int>(0x337B7E30); }
	static int GET_LOWEST_USED_GAME_DIFFICULTY() { return invoke<int>(0xE04CBBD5); }
	static int GET_PROFILE_SETTING(Hash hash) { return invoke<int>(0xD374BEBC, hash); } // unused
	static BOOL SET_PROFILE_SETTING(Hash hash, int value) { return invoke<BOOL>(0xF6FA0CA6, hash, value); } // unused
	static float GET_STRING_WIDTH(char* textLabel) { return invoke<float>(0xBABDF3D6, textLabel); } // unused
	static float GET_STRING_WIDTH_WITH_NUMBER(char* textLabel, int number) { return invoke<float>(0xEAEB477D, textLabel, number); } // unused
	static float GET_STRING_WIDTH_WITH_STRING(char* textLabel, char* string) { return invoke<float>(0x048A2E6C, textLabel, string); } // unused
	static void GET_LOCALISED_STRING(int bufferSize, char* buffer, char* textLabel) { invoke<Void>(0xEDB3726D, bufferSize, buffer, textLabel); }
	static void SPLIT_LOCALISED_STRING(char* textLabel, int bufferSize1, char* buffer1, int bufferSize2, char* buffer2, int bufferSize3, char* buffer3, int bufferSize4, char* buffer4) { invoke<Void>(0xE6102DD1, textLabel, bufferSize1, buffer1, bufferSize2, buffer2, bufferSize3, buffer3, bufferSize4, buffer4); }
	static BOOL ARE_STRINGS_EQUAL(char* str1, char* str2) { return invoke<BOOL>(0x877C0BC5, str1, str2); }
	static int ABSI(int value) { return invoke<int>(0xB44677C5); }
	static float ABSF(float value) { return invoke<float>(0xAF6F6E0B); }
	static Any IS_SNIPER_BULLET_IN_AREA() { return invoke<Any>(0x0483715C); } // unused
	static Any IS_PROJECTILE_IN_AREA() { return invoke<Any>(0x78E1A557); } // unused
	static Any IS_PROJECTILE_TYPE_IN_AREA() { return invoke<Any>(0x2B73BCF6); } // unused
	static Any IS_BULLET_IN_AREA() { return invoke<Any>(0xB54F46CA); } // unused
	static Any IS_BULLET_IN_BOX() { return invoke<Any>(0xAB73ED26); } // unused
	static BOOL IS_XBOX360_VERSION() { return invoke<BOOL>(0x24005CC8); }
	static BOOL IS_GERMAN_VERSION() { return invoke<BOOL>(0xE023A0AD); }
	static BOOL IS_AUSSIE_VERSION() { return invoke<BOOL>(0x944BA1DC); } // unused
	static Any GET_OFFSET_FROM_INTERIOR_IN_WORLD_COORDS() { return invoke<Any>(0x7D8F26A1); } // unused
	static Any GET_INTERIOR_HEADING() { return invoke<Any>(0xFB56D1AC); } // unused
	static BOOL IS_STRING_NULL(char* str) { return invoke<BOOL>(0x8E71E00F, str); }
	static BOOL STRING_TO_INT(char* str, int* outInt) { return invoke<BOOL>(0x590A8160, str, outInt); }
	static Any SET_PHONE_HUD_ITEM() { return invoke<Any>(0x7FD60931); } // unused
	static void SET_OVERRIDE_NO_SPRINTING_ON_PHONE_IN_MULTIPLAYER(BOOL toggle) { invoke<Void>(0xE9FDDA54, toggle); } // unused
	static void SET_MESSAGES_WAITING(BOOL toggle) { invoke<Void>(0x15A9C493, toggle); } // unused
	static void SET_SLEEP_MODE_ACTIVE(BOOL toggle) { invoke<Void>(0x8AC848BA, toggle); } // unused
	static void SET_BITS_IN_RANGE(int* data, int rangeStart, int rangeEnd, int p3) { invoke<Void>(0x32094719, data, rangeStart, rangeEnd, p3); } // unused
	static int GET_BITS_IN_RANGE(int data, int rangeStart, int rangeEnd) { return invoke<int>(0xCA03A1E5, data, rangeStart, rangeEnd); }
	static BOOL IS_BULLET_TIME_ACTIVE(BOOL p0) { return invoke<BOOL>(0xCDC1B8A3, p0); }
	static void SET_GAME_PAUSED(BOOL toggle) { invoke<Void>(0x8230FF6C, toggle); }
	static void SET_THIS_SCRIPT_CAN_BE_PAUSED(BOOL toggle) { invoke<Void>(0xA0C3CE29, toggle); }
	static void SET_THIS_SCRIPT_CAN_REMOVE_BLIPS_CREATED_BY_ANY_SCRIPT(BOOL toggle) { invoke<Void>(0xD06F1720, toggle); } // unused
	static void CLEAR_NEWS_SCROLLBAR() { invoke<Void>(0xD70532E8); } // unused
	static void ADD_STRING_TO_NEWS_SCROLLBAR(char* str) { invoke<Void>(0x00DDFD22, str); } // unused
	static void SET_CHEAT_ACTIVE(int cheatId) { invoke<Void>(0x83D97A32, cheatId); } // unused
	static void OVERRIDE_FREEZE_FLAGS(BOOL toggle) { invoke<Void>(0x4B3DF87E, toggle); } // unused
	static void SET_GLOBAL_INSTANCE_PRIORITY(int priority) { invoke<Void>(0xEA330E59, priority); } // unused
	static void SET_DEFAULT_GLOBAL_INSTANCE_PRIORITY() { invoke<Void>(0x47280F2D); }
	static Any SET_XBOX_SCREEN_SAVER() { return invoke<Any>(0xD121D3DE); } // unused
	static void PROCESS_MISSION_DELETION_LIST() { invoke<Void>(0xA5CB6B1B); } // unused
	static BOOL IS_FRONTEND_FADING() { return invoke<BOOL>(0x8FF6232C); } // unused
	static BOOL IS_INTERIOR_SCENE() { return invoke<BOOL>(0x55226C13); } // unused
	static void POPULATE_NOW() { invoke<Void>(0x72C20700); } // unused
	static int GET_INDEX_OF_CURRENT_LEVEL() { return invoke<int>(0x6F203C6E); }
	static BOOL GET_NAME_OF_CURRENT_LEVEL(int bufferSize, char* buffer) { return invoke<BOOL>(0x4EFC439F, bufferSize, buffer); }
	static void SWITCH_TO_LEVEL(int index) { invoke<Void>(0xFA085695, index); }
	static void SWITCH_TO_LEVEL_NAME(char* name) { invoke<Void>(0xB0F99718, name); }
	static void RETURN_TO_TITLESCREEN(char* reasonTextLabel) { invoke<Void>(0xB52B5F2D, reasonTextLabel); }
	static void RETURN_TO_MP_LOBBY(char* reasonTextLabel) { invoke<Void>(0x782A6A92, reasonTextLabel); }
	static void REGISTER_PERSISTENT_GLOBAL_VARIABLES(Any* ptr, int count) { invoke<Void>(0x42830D95, ptr, count); } // unused
	static void GAMEPLAY_HELPER_BOX_CREATE(Any p0, Any p1, Any p2, Any p3, Any p4, Any p5, Any p6, Any p7) { invoke<Void>(0xC7341B47, p0, p1, p2, p3, p4, p5, p6, p7); }
	static void GAMEPLAY_HELPER_BOX_ANGLED_CREATE(Any p0, Any p1, Any p2, Any p3, Any p4, Any p5, Any p6, Any p7, Any p8, Any p9, Any p10, Any p11) { invoke<Void>(0x66CF72BB, p0, p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11); }
	static Any GAMEPLAY_HELPER_BOX_ANGLED_CREATE_VER2() { return invoke<Any>(0x8E89F378); } // unused
	static void GAMEPLAY_HELPER_BOX_DESTROY(Any p0) { invoke<Void>(0x27C9E914, p0); }
	static void GAMEPLAY_HELPER_BOX_SET_ENABLED(Any p0, Any p1) { invoke<Void>(0x75BF06F3, p0, p1); }
	static Vector3 GET_GAMEPLAY_HELPER_BOX_COORD(char* name) { return invoke<Vector3>(0xF0C17F9A, name); } // unused
	static Vector3 GET_GAMEPLAY_HELPER_VOLUME_COORD(char* name) { return invoke<Vector3>(0x2A9EA7D3, name); } // unused
	static void GAMEPLAY_HELPER_CYLINDER_CREATE(Any p0, Any p1, Any p2, Any p3, Any p4, Any p5, Any p6) { invoke<Void>(0x05E76389, p0, p1, p2, p3, p4, p5, p6); }
	static Any GET_GAMEPLAY_HELPER_CYLINDER_RADIUS() { return invoke<Any>(0x2F97E6C0); } // unused
	static Any SET_GAMEPLAY_HELPER_CYLINDER_RADIUS() { return invoke<Any>(0x4EBFD673); } // unused
	static Any GET_GAMEPLAY_HELPER_CYLINDER_HEIGHT() { return invoke<Any>(0xB5BE0139); } // unused
	static Any SET_GAMEPLAY_HELPER_CYLINDER_HEIGHT() { return invoke<Any>(0xB6B24984); } // unused
	static void GAMEPLAY_HELPER_VOLUME_DESTROY(Any p0) { invoke<Void>(0xD154D5DE, p0); }
	static Any GAMEPLAY_HELPER_VOLUME_SET_ENABLED() { return invoke<Any>(0xEAA23DE7); } // unused
	static Any GET_GAMEPLAY_HELPER_VOLUME_COORD() { return invoke<Any>(0x2A9EA7D3); } // unused
	static Any SET_GAMEPLAY_HELPER_VOLUME_COORD() { return invoke<Any>(0xAE3938DF); } // unused
	static void SET_INTERACTION_VOLUME_STATIC_VARIABLES(Any p0, Any p1, Any p2) { invoke<Void>(0x931C72B3, p0, p1, p2); }
	static void ATTACH_INTERACT_VOLUME_TO_PED(Any p0, Any p1, Any p2, Any p3, Any p4, Any p5, Any p6, Any p7, Any p8, Any p9, Any p10) { invoke<Void>(0x05167446, p0, p1, p2, p3, p4, p5, p6, p7, p8, p9, p10); }
	static void ATTACH_EXPLOSIVE_INTERACT_VOLUME_TO_PED(Any p0, Any p1, Any p2, Any p3, Any p4, Any p5, Any p6, Any p7, Any p8, Any p9, Any p10, Any p11, Any p12) { invoke<Void>(0x13BAF8E2, p0, p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12); }
	static void BOOBY_TRAP_ALL_CORPSE_VOLUMES(Any p0, Any p1) { invoke<Void>(0x3D89B3C3, p0, p1); }
	static void CREATE_COORD_INTERACTION_VOLUME(Any p0, Any p1, Any p2, Any p3, Any p4, Any p5, Any p6, Any p7, Any p8, Any p9, Any p10, Any p11, Any p12) { invoke<Void>(0xBBB2AA68, p0, p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12); }
	static void REMOVE_INTERACTION_VOLUME_IF_EXISTS(Any p0) { invoke<Void>(0x7254F372, p0); }
	static void REMOVE_ALL_INTERACTION_VOLUMES() { invoke<Void>(0x621AB3A0); }
	static Any IS_PLAYER_INTERACTING_WITH_VOLUME(Any p0, Any p1) { return invoke<Any>(0x424D60A3, p0, p1); }
	static Any IS_ANYONE_INTERACTING_WITH_VOLUME(Any p0) { return invoke<Any>(0x461C258F, p0); }
	static Any IS_LOCAL_PLAYER_READY_TO_INTERACT_WITH(Any p0) { return invoke<Any>(0x303F8C07, p0); }
	static Any GET_INTERACTION_VOLUME_POS(Any p0, Any p1) { return invoke<Any>(0xAE7B9E7D, p0, p1); }
	static int GET_CHECKPOINT_SELECTED() { return invoke<int>(0x2FA3742B); }
	static BOOL IS_ROBO_TESTING() { return invoke<BOOL>(0x0326798C); }
	static BOOL IS_PC_BUILD() { return invoke<BOOL>(0xE6A62D57); }
	static Vector3 VECTOR_ROTATE_AXIS(float x, float y, float z, float rotate, char* axis) { return invoke<Vector3>(0x649E57A6, x, y, z, rotate, axis); }
	static void RESET_LAST_MAN_STANDING() { invoke<Void>(0x3F47FAEA); }
	static void STRING_FORMAT(int bufferSize, char* buffer, char* formatOrTextLabel, int argCount, ...)
	{
		NativeContext cxt;

		va_list _nativeVarArgsList; const int _nativeVarArgsCount = argCount * 2; ((_nativeVarArgsList) = __va_funcx (2, (char *) __builtin_addrof((_nativeVarArgsCount))));;
		cxt.nativePush(bufferSize);
		cxt.nativePush(buffer);
		cxt.nativePush(formatOrTextLabel);
		cxt.nativePush(argCount);
		for (int i = 0; i < _nativeVarArgsCount; i++) { cxt . nativePush((*((Any *) __va_funcx (3, (_nativeVarArgsList),((Any *) 0))))); };
		((void) 0);;

		nativeCall<Void>(0x1EBBD64A, &cxt);
	}
	static void STRING_FORMAT_HASH(int bufferSize, char* buffer, Hash textLabelHash, int argCount, ...)
	{
		NativeContext cxt;

		va_list _nativeVarArgsList; const int _nativeVarArgsCount = argCount * 2; ((_nativeVarArgsList) = __va_funcx (2, (char *) __builtin_addrof((_nativeVarArgsCount))));;
		cxt.nativePush(bufferSize);
		cxt.nativePush(buffer);
		cxt.nativePush(textLabelHash);
		cxt.nativePush(argCount);
		for (int i = 0; i < _nativeVarArgsCount; i++) { cxt . nativePush((*((Any *) __va_funcx (3, (_nativeVarArgsList),((Any *) 0))))); };
		((void) 0);;

		nativeCall<Void>(0xA1091C07, &cxt);
	}
	static void STRING_APPEND(int bufferSize, char* buffer, char* formatOrTextLabel, int argCount, ...)
	{
		NativeContext cxt;

		va_list _nativeVarArgsList; const int _nativeVarArgsCount = argCount * 2; ((_nativeVarArgsList) = __va_funcx (2, (char *) __builtin_addrof((_nativeVarArgsCount))));;
		cxt.nativePush(bufferSize);
		cxt.nativePush(buffer);
		cxt.nativePush(formatOrTextLabel);
		cxt.nativePush(argCount);
		for (int i = 0; i < _nativeVarArgsCount; i++) { cxt . nativePush((*((Any *) __va_funcx (3, (_nativeVarArgsList),((Any *) 0))))); };
		((void) 0);;

		nativeCall<Void>(0xD00EC3B6, &cxt);
	}
	static void STRING_STORE(char* p0, char* p1) { invoke<Void>(0xC1389FB0, p0, p1); } // unused
	static void SET_KILL_HEIGHT(float height) { invoke<Void>(0x50D3FF0E, height); }
	static void MANOGAMETESTER_ENABLE() { invoke<Void>(0x25B894F2); }
	static void MANOGAMETESTER_DISABLE() { invoke<Void>(0x28CB5F76); }
	static BOOL MANOGAMETESTER_DUMP_NOW() { return invoke<BOOL>(0x409525B7); }
	static float GET_CURRENT_FPS() { return invoke<float>(0x7030FB99); }
	static BOOL IS_MAGDEMO() { return invoke<BOOL>(0x6A50485A); }
	static BOOL IS_AMED_ENABLED() { return invoke<BOOL>(0xEA4F2A84); } // unused
	static BOOL IS_SCRIPTEDFX_ENABLED() { return invoke<BOOL>(0x36B7B213); }
	static BOOL IS_COLLECTABLE_ENABLED() { return invoke<BOOL>(0x473FF184); }
	static BOOL IS_DEATH_PANEL_WIPE_ALLOWED() { return invoke<BOOL>(0xFA0FC3B6); }
	static void RESET_CHECKPOINT_ATTEMPTS() { invoke<Void>(0xD9591EC0); }
	static void INCREMENT_CHECKPOINT_ATTEMPT() { invoke<Void>(0xAF1C3055); }
	static void ADJUST_AMMO_ATTEMPTS() { invoke<Void>(0xF4BFDBAD); }
	static void ADJUST_PAIN_KILLERS_ATTEMPTS() { invoke<Void>(0x36620C4E); }
	static void DISABLE_FADE_BETWEEN_SP_LEVELS() { invoke<Void>(0xD2666E85); }
	static void HANDLE_CHECKPOINT_RESTART() { invoke<Void>(0x821221B4); }
	static void SET_ARCADEMODE_EVENT(int p0, Ped ped) { invoke<Void>(0xC56F72BA, p0, ped); }
	static BOOL IS_IN_SOUTHPAW_MODE() { return invoke<BOOL>(0x18D7934F); }
	static void SET_CASH_CLAN_DISCOUNT(float p0) { invoke<Void>(0x0C838CD2, p0); } // unused
	static BOOL IS_TICKER_ACTIVITY_LOW() { return invoke<BOOL>(0x238BCCB6); } // unused
	static BOOL IS_TICKER_ACTIVITY_HIGH() { return invoke<BOOL>(0x4BC91752); }
	static void STORE_FRONTEND_TIMECYCLE_SETTINGS() { invoke<Void>(0x9BDAB003); }
	static BOOL IS_RESTARTING_FE_FOR_NEW_GAME() { return invoke<BOOL>(0x7D3CB0CB); }
	static BOOL IS_NEW_GAME_REQUESTED() { return invoke<BOOL>(0xF994E7DC); }
	static void SET_NEW_GAME_READY() { invoke<Void>(0x467EAD5A); }
	static void FORCE_SKIP_ATTRACT_SCREEN(BOOL toggle) { invoke<Void>(0x87D28A29, toggle); }
	static BOOL IS_CUSTOM_PLAYER_VARIATION() { return invoke<BOOL>(0x2E325641); }
	static int GET_CUSTOM_PLAYER_VARIATION() { return invoke<int>(0x464688D7); }
	static void SAVE_STORY_DISC_SWAP(char* levelName) { invoke<Void>(0x96CBF1FE, levelName); }
	static Any _0x0E0BECD5() { return invoke<Any>(0x0E0BECD5); }
	static void _0x17988716(Any p0) { invoke<Void>(0x17988716, p0); }
	static void _0x9820E166(Any p0, Any p1, Any p2) { invoke<Void>(0x9820E166, p0, p1, p2); }
	static void _0x06CBF39A(Any p0, Any p1, Any p2, Any p3, Any p4, Any p5, Any p6, Any p7) { invoke<Void>(0x06CBF39A, p0, p1, p2, p3, p4, p5, p6, p7); }
	static void _0x26FA30EA(Any p0, Any p1) { invoke<Void>(0x26FA30EA, p0, p1); }
	static void _0x4E5ED973(Any p0, Any p1, Any p2, Any p3) { invoke<Void>(0x4E5ED973, p0, p1, p2, p3); }
	static Any _0xAA9D237A() { return invoke<Any>(0xAA9D237A); }
}

namespace PAD
{
	static BOOL IS_PICKUP_CONSUMED(int pickup) { return invoke<BOOL>(0x21F50584, pickup); } // unused
	static void SET_ACTION_CONSUMED(int action, BOOL toggle) { invoke<Void>(0x52FAFA2B, action, toggle); }
	static BOOL IS_ACTION_CONSUMED(int action) { return invoke<BOOL>(0x2253B4DA, action); } // unused
	static BOOL DOES_PAD_EXIST(int padIndex) { return invoke<BOOL>(0x435A85E0, padIndex); }
	static BOOL IS_BUTTON_PRESSED(int padIndex, int buttonId) { return invoke<BOOL>(0x7BCB3F15, padIndex, buttonId); }
	static BOOL IS_BUTTON_JUST_PRESSED(int padIndex, int buttonId) { return invoke<BOOL>(0x7FCD1FA1, padIndex, buttonId); }
	static BOOL IS_CONTROL_PRESSED(int padIndex, int controlId) { return invoke<BOOL>(0x517A4384, padIndex, controlId); }
	static BOOL IS_CONTROL_JUST_PRESSED(int padIndex, int controlId) { return invoke<BOOL>(0x4487F579, padIndex, controlId); }
	static void GET_POSITION_OF_ANALOGUE_STICKS(int padIndex, int* p1, int* p2, int* p3, int* p4) { invoke<Void>(0x12713A99, padIndex, p1, p2, p3, p4); }
	static BOOL IS_KEYBOARD_KEY_PRESSED(int key) { return invoke<BOOL>(0xA644ED03, key); } // unused
	static BOOL IS_KEYBOARD_KEY_JUST_PRESSED(int key) { return invoke<BOOL>(0xEAC23998, key); }
	static BOOL IS_GAME_KEYBOARD_KEY_PRESSED(int key) { return invoke<BOOL>(0x958135C3, key); } // unused
	static BOOL IS_GAME_KEYBOARD_KEY_JUST_PRESSED(int key) { return invoke<BOOL>(0x3FEEBF9C, key); } // unused
	static BOOL IS_MARKETING_KEYBOARD_KEY_JUST_PRESSED(int key) { return invoke<BOOL>(0xBA00B7F4, key); }
	static void SET_PAD_SHAKE(int padIndex, int duration, int frequency) { invoke<Void>(0x5D38BD2F, padIndex, duration, frequency); }
	static BOOL IS_LOOK_INVERTED() { return invoke<BOOL>(0x313434B2); } // unused
	static void SET_LOOK_INVERT(BOOL toggle) { invoke<Void>(0xC6A53617, toggle); } // unused
	static void SET_PLAYERPAD_SHAKES_WHEN_CONTROLLER_DISABLED(BOOL toggle) { invoke<Void>(0xA86BD91F, toggle); } // unused
	static Any GET_CURRENT_CONTROL_CONFIG() { return invoke<Any>(0xA9B6DA66); } // unused
	static BOOL GET_PAD_PITCH_ROLL(int padIndex, Any* p1, Any* p2) { return invoke<BOOL>(0x666EE1CB, padIndex, p1, p2); } // unused
	static BOOL HAS_RELOADED_WITH_MOTION_CONTROL(Any p0, Any* p1) { return invoke<BOOL>(0xE338B363, p0, p1); } // unused
	static Any SET_ALL_MOTION_CONTROL_PREFERENCES() { return invoke<Any>(0x94FF7903); } // unused
	static Any GET_MOTION_CONTROL_PREFERENCE() { return invoke<Any>(0xA4CA9C1C); } // unused
	static BOOL IS_USING_CONTROLLER() { return invoke<BOOL>(0x019064ED); }
	static void SET_LEFT_TRIGGER_HOLD_TIME(int time) { invoke<Void>(0xADE291A3, time); } // unused
	static void SET_RIGHT_TRIGGER_HOLD_TIME(int time) { invoke<Void>(0x0BD1F617, time); } // unused
}

namespace PED
{
	static Ped CREATE_PED(int pedType, Hash modelHash, float x, float y, float z, float heading, BOOL isNetwork, BOOL dontOwn) { return invoke<Ped>(0x0389EF71, pedType, modelHash, x, y, z, heading, isNetwork, dontOwn); }
	static void RELEASE_PED_ENTITY_SYNC_POINT(Ped ped) { invoke<Void>(0x60E94D19, ped); }
	static void CREATE_PED_CORPSE(Ped ped, Ped dummyPed) { invoke<Void>(0x48B657A1, ped, dummyPed); } // unused
	static void DELETE_PED_CORPSE(Ped ped) { invoke<Void>(0x85F66883, ped); }
	static void DELETE_ALL_PED_CORPSES() { invoke<Void>(0x632B0876); }
	static BOOL DOES_CORPSE_EXIST(Ped ped) { return invoke<BOOL>(0x109EAB3D, ped); }
	static Vector3 GET_CORPSE_COORDS(Ped ped) { return invoke<Vector3>(0x0AAA4C65, ped); }
	static void DELETE_PED(Ped* ped) { invoke<Void>(0x13EFB9A0, ped); }
	static Vector3 GET_PED_COORDS(Ped ped) { return invoke<Vector3>(0x9E3ED6AF, ped); }
	static void SET_PED_COORDS(Ped ped, float x, float y, float z, BOOL unk) { invoke<Void>(0x16BE1EC7, ped, x, y, z, unk); }
	static void SET_DEAD_PED_COORDS(Ped ped, float x, float y, float z) { invoke<Void>(0xBE678A36, ped, x, y, z); } // unused
	static void SET_PED_GORE(Ped ped, BOOL toggle) { invoke<Void>(0xDA25E662, ped, toggle); }
	static void SET_PED_GORE_FROM_PLAYER(Ped ped, BOOL toggle) { invoke<Void>(0x25A69B70, ped, toggle); }
	static void SET_PED_GORE_FROM_NPC(Ped ped, BOOL toggle) { invoke<Void>(0x6CBAB679, ped, toggle); }
	static void SET_PED_GORE_AS_ALLY(Ped ped) { invoke<Void>(0x5A64FA8B, ped); }
	static void SET_PED_GORE_AS_DEFAULT(Ped ped) { invoke<Void>(0xCBFA79EA, ped); } // unused
	static void RESET_PED_GORE(Ped ped) { invoke<Void>(0xA882A64A, ped); }
	static void SET_PED_BLOOD_SMEAR(Ped ped, int smear) { invoke<Void>(0xEA3D0C15, ped, smear); } // unused
	static void RESET_PED_BLOOD_SMEAR(Ped ped) { invoke<Void>(0x6CDF4A41, ped); } // unused
	static void SET_FORCE_PLAYER_GORE(BOOL toggle) { invoke<Void>(0x631DD85B, toggle); }
	static void TRANSFER_PED_BLOOD_HANDLE(Ped ped, Ped ped2) { invoke<Void>(0x1E3CF6F7, ped, ped2); }
	static void ADD_PED_CLONE(Ped ped, float x, float y, float z, float heading) { invoke<Void>(0x0201A0FC, ped, x, y, z, heading); } // unused
	static void RESET_PED_CLONES(Ped ped) { invoke<Void>(0x1E0C9CBE, ped); } // unused
	static BOOL IS_PED_IN_AREA(Ped ped, float x1, float y1, float z1, float x2, float y2, float z2, BOOL p7, int p8) { return invoke<BOOL>(0x1B4FD43E, ped, x1, y1, z1, x2, y2, z2, p7, p8); } // unused
	static BOOL IS_PED_IN_ANGLED_AREA(Ped ped, float x1, float y1, float z1, float x2, float y2, float z2, float angle, BOOL p8, int p9) { return invoke<BOOL>(0x67D32AF9, ped, x1, y1, z1, x2, y2, z2, angle, p8, p9); } // unused
	static BOOL IS_PED_AT_COORD(Ped ped, float x1, float y1, float z1, float x2, float y2, float z2, BOOL p7, int p8) { return invoke<BOOL>(0x2DCD8806, ped, x1, y1, z1, x2, y2, z2, p7, p8); }
	static BOOL IS_PED_AT_PED(Ped ped, Ped ped2, float p2, float p3, float p4, BOOL p5, int p6) { return invoke<BOOL>(0xCD0373CE, ped, ped2, p2, p3, p4, p5, p6); } // unused
	static BOOL IS_PED_AT_VEHICLE(Ped ped, Vehicle vehicle, float p2, float p3, float p4, BOOL p5, int p6) { return invoke<BOOL>(0xA9191096), ped, vehicle, p2, p3, p4, p5, p6; } // unused
	static BOOL IS_PED_AT_OBJECT(Ped ped, Object object, float p2, float p3, float p4, BOOL p5, int p6) { return invoke<BOOL>(0x7CE82D5F, ped, object, p2, p3, p4, p5, p6); } // unused
	static BOOL IS_PED_IN_VEHICLE(Ped ped, Vehicle vehicle) { return invoke<BOOL>(0x7DA6BC83, ped, vehicle); }
	static BOOL IS_PED_IN_MODEL(Ped ped, Hash modelHash) { return invoke<BOOL>(0xA6438D4B, ped, modelHash); } // unused
	static BOOL IS_PED_IN_ANY_VEHICLE(Ped ped) { return invoke<BOOL>(0x3B0171EE, ped); }
	static BOOL IS_PED_IN_CROSSHAIR_CONE(Ped ped, float p1, float p2) { return invoke<BOOL>(0x21C18EA9, ped, p1, p2); } // unused
	static BOOL CAN_PED_SEE_OTHER_PED(Ped ped, Ped ped2, float p2, float p3) { return invoke<BOOL>(0xFF36A652, ped, ped2, p2, p3); }
	static int GET_TIME_SINCE_PED_MADE_NOISE(Ped ped, int p1) { return invoke<int>(0x923C24E6, ped, p1); }
	static BOOL IS_PED_DEAD(Ped ped) { return invoke<BOOL>(0xF990EBB2, ped); }
	static BOOL IS_PED_INJURED(Ped ped) { return invoke<Any>(0x2530A087, ped); }
	static BOOL IS_PED_FATALLY_INJURED(Ped ped) { return invoke<BOOL>(0xBADA0093, ped); }
	static BOOL IS_PLAYER_BEING_ARRESTED() { return invoke<BOOL>(0x7F6A60D3); } // unused
	static Ped CREATE_PED_INSIDE_VEHICLE(Vehicle vehicle, int pedType, Hash modelHash, int seatIndex, char* p4, BOOL p5) { return invoke<Ped>(0x3000F092, vehicle, pedType, modelHash, seatIndex, p4, p5); }
	static BOOL IS_PED_IN_ZONE(Ped ped, char* zoneName) { return invoke<BOOL>(0x4EECB942, ped, zoneName); } // unused
	static float GET_PED_HEADING(Ped ped) { return invoke<float>(0xD8D707C6, ped); }
	static void SET_PED_HEADING(Ped ped, float heading) { invoke<Void>(0xE9288F19, ped, heading); }
	static Vector3 GET_PED_DIRECTION(Ped ped, int p1) { return invoke<Vector3>(0x6F0BCEAC, ped, p1); } // unused
	static void SET_FREEZE_PED_AIM(Ped ped, BOOL toggle) { invoke<Void>(0x4EA8E77C, ped, toggle); }
	static void SET_PED_DESIRED_HEADING(Ped ped, float heading) { invoke<Void>(0x961458F9, ped, heading); } // unused
	static BOOL IS_PED_FACING_PED(Ped ped, Ped ped2, float angle) { return invoke<BOOL>(0x0B775838, ped, ped2, angle); }
	static BOOL IS_PED_TOUCHING_OBJECT(Ped ped, Object object) { return invoke<BOOL>(0x0A82C348, ped, object); } // unused
	static void SET_PED_OBLIVIOUS_TO_DANGER(Ped ped, BOOL toggle) { invoke<Void>(0xCD1828FE, ped, toggle); }
	static BOOL IS_PED_IN_MELEE_COMBAT(Ped ped) { return invoke<BOOL>(0xFD7814A5, ped); }
	static void SET_PED_AS_NO_LONGER_NEEDED(Ped* ped) { invoke<Void>(0x9A388380, ped); } // unused
	static void SET_PED_HEALTH_AS_BOOST(Ped ped, int health, BOOL p2) { invoke<Void>(0xDE3B8D3B, ped, health, p2); }
	static void SET_PED_HEALTH(Ped ped, int health, BOOL unk) { invoke<Void>(0x0A325D05, ped, health, unk); }
	static int GET_PED_HEALTH(Ped ped) { return invoke<int>(0x0ECC91AC, ped); }
	static int GET_PED_MAX_HEALTH(Ped ped) { return invoke<int>(0xA45B6C8D, ped); }
	static BOOL IS_PED_STOPPED(Ped ped) { return invoke<BOOL>(0xA0DC0B87, ped); } // unused
	static void SET_PED_ONLY_DAMAGED_BY_PLAYER(Ped ped, BOOL toggle) { invoke<Void>(0x785992AF, ped, toggle); }
	static void SET_PED_ONLY_DAMAGED_BY_RELATIONSHIP_GROUP(Ped ped, BOOL toggle, int relGroupId) { invoke<Void>(0x7CC6EF33, ped, toggle, relGroupId); }
	static void SET_PED_CAN_BE_DAMAGED_BY_RELATIONSHIP_GROUP(Ped ped, BOOL toggle, int relGroupId) { invoke<Void>(0x2F97988A, ped, toggle, relGroupId); }
	static void SET_PED_PROOFS(Ped ped, BOOL p1, BOOL p2, BOOL p3, BOOL p4, BOOL p5) { invoke<Void>(0x094E8BC4, ped, p1, p2, p3, p4, p5); }
	static void SET_PED_DAMAGED_BY_TEAR_GAS(Ped ped, BOOL toggle) { invoke<Void>(0x8C2C034A, ped, toggle); }
	static BOOL IS_PED_ON_SCREEN(Ped ped, BOOL unk) { return invoke<BOOL>(0xDF7C1119, ped, unk); }
	static BOOL IS_PED_SHOOTING_IN_AREA(Ped ped, float x1, float y1, float z1, float x2, float y2, float z2, BOOL p7, BOOL p8) { return invoke<BOOL>(0x741BF04F, ped, x1, y1, z1, x2, y2, z2, p7, p8); } // unused
	static BOOL IS_ANY_PED_SHOOTING_IN_AREA(float x1, float y1, float z1, float x2, float y2, float z2, BOOL p6, BOOL p7) { return invoke<BOOL>(0x91833867, x1, y1, z1, x2, y2, z2, p6, p7); } // unused
	static BOOL IS_PED_SHOOTING(Ped ped) { return invoke<BOOL>(0xE7C3405E, ped); }
	static void SET_PED_ACCURACY(Ped ped, int accuracy) { invoke<Void>(0x6C17122E, ped, accuracy); }
	static void SET_PED_PERFECT_ACCURACY_OVERRIDE(Ped ped, BOOL toggle) { invoke<Void>(0x136BA027, ped, toggle); }
	static void SET_PED_ENABLE_DISTANCE_INACCURACY(Ped ped, BOOL toggle, float p2) { invoke<Void>(0xB6B77BAC, ped, toggle, p2); }
	static void SET_PED_ENABLE_SPAWN_INACCURACY(Ped ped, BOOL toggle) { invoke<Void>(0x305CA230, ped, toggle); }
	static BOOL IS_PED_MODEL(Ped ped, Hash modelHash) { return invoke<BOOL>(0x5F1DDFCB, ped, modelHash); } // unused
	static void EXPLODE_PED_HEAD(Ped ped) { invoke<Void>(0x05CC1380, ped); } // unused
	static void SET_PED_VISIBLE(Ped ped, BOOL toggle) { invoke<Void>(0xD599744F, ped, toggle); }
	static BOOL IS_PED_VISIBLE(Ped ped) { return invoke<BOOL>(0xE285085A, ped); }
	static void SET_PED_VISIBLE_DURING_SEQUENCE(Ped ped, BOOL toggle) { invoke<Void>(0xA76C4A14, ped, toggle); }
	static void REMOVE_PED_ELEGANTLY(Ped* ped) { invoke<Void>(0x4FFB8C6C, ped); } // unused
	static void ADD_ARMOUR_TO_PED(Ped ped, int armour) { invoke<Void>(0xF686B26E, ped, armour); }
	static BOOL HAS_PED_CLEAR_LOS_TO_PED(Ped ped, Ped ped2) { return invoke<BOOL>(0xED49888E, ped, ped2); }
	static BOOL HAS_PED_CLEAR_LOS_TO_SPHERE(Ped ped, float x, float y, float z, float radius) { return invoke<BOOL>(0x07D2C95F, ped, x, y, z, radius); }
	static BOOL IS_PED_LOS_CLEAR_TO_TARGET_PED(Ped ped, Ped ped2) { return invoke<BOOL>(0xBEE1E2F1, ped, ped2); }
	static void SET_PED_INTO_VEHICLE(Ped ped, Vehicle vehicle, int seatIndex) { invoke<Void>(0x07500C79, ped, vehicle, seatIndex); }
	static void SET_PED_OUT_OF_VEHICLE(Ped ped) { invoke<Void>(0x22AE6723, ped); }
	static BOOL CAN_CREATE_RANDOM_PED() { return invoke<BOOL>(0xF9ABE88F); } // unused
	static Ped CREATE_RANDOM_PED(float x, float y, float z) { return invoke<Ped>(0x5A949543, x, y, z); } // unused
	static Ped CREATE_RANDOM_MALE_PED(float x, float y, float z) { return invoke<Ped>(0xD5E380F3, x, y, z); } // unused
	static Ped CREATE_RANDOM_FEMALE_PED(float x, float y, float z) { return invoke<Ped>(0x5847ADE0, x, y, z); } // unused
	static Ped CREATE_RANDOM_PED_AS_DRIVER(Vehicle vehicle) { return invoke<Ped>(0xB927CE9A, vehicle); } // unused
	static void SET_PED_ANIM_SPEED(Ped ped, char* animDict, char* animName, float speed) { invoke<Void>(0x40B81E24, ped, animDict, animName, speed); } // unused
	static void SET_PED_ALL_ANIMS_SPEED(Ped ped, float speed) { invoke<Void>(0x83C20759, ped, speed); } // unused
	static void SET_PED_MOVE_ANIMS_BLEND_OUT(Ped ped) { invoke<Void>(0x20E01957, ped); } // unused
	static void SET_PED_CAN_BE_DRAGGED_OUT(Ped ped, BOOL toggle) { invoke<Void>(0xAA7F1131, ped, toggle); } // unused
	static BOOL IS_PED_MALE(Ped ped) { return invoke<BOOL>(0x90950455, ped); } // unused
	static Vehicle GET_VEHICLE_PED_IS_IN(Ped ped) { return invoke<Vehicle>(0xAFE92319, ped); }
	static void SET_PED_DENSITY_MULTIPLIER(float multiplier) { invoke<Void>(0x87FDB5D1, multiplier); } // unused
	static void SET_SCENARIO_PED_DENSITY_MULTIPLIER(float p0, float p1) { invoke<Void>(0x874B05BE, p0, p1); } // unused
	static Hash GET_CURRENT_BASIC_COP_MODEL() { return invoke<Hash>(0xCDA04E40); } // unused
	static void GET_CURRENT_COP_MODEL(Hash* modelHash) { invoke<Void>(0xB26E12B4, modelHash); } // unused
	static void SET_SCRIPTED_CONVERSION_COORD(float x, float y, float z) { invoke<Void>(0x4A97C006, x, y, z); } // unused
	static void CLEAR_SCRIPTED_CONVERSION_COORD() { invoke<Void>(0xBFA2E595); } // unused
	static void SET_PED_NON_REMOVAL_AREA(float x1, float y1, float z1, float x2, float y2, float z2) { invoke<Void>(0x599D82E7, x1, y1, z1, x2, y2, z2); } // unused
	static void CLEAR_PED_NON_REMOVAL_AREA() { invoke<Void>(0xB5BA896B); } // unused
	static void SET_PED_NON_CREATION_AREA(float x1, float y1, float z1, float x2, float y2, float z2) { invoke<Void>(0x7A97283F, x1, y1, z1, x2, y2, z2); } // unused
	static void CLEAR_PED_NON_CREATION_AREA() { invoke<Void>(0x6F7043A3); } // unused
	static void SET_PED_SUFFERS_CRITICAL_HITS(Ped ped, BOOL toggle) { invoke<Void>(0x6F6FC7E6, ped, toggle); }
	static void SET_PED_READY_TO_BE_STUNNED(Ped ped, BOOL toggle) { invoke<Void>(0xC6787268, ped, toggle); } // unused
	static BOOL GET_PED_READY_TO_BE_STUNNED(Ped ped) { return invoke<BOOL>(0x082EF96E); } // unused
	static void SET_PED_READY_TO_BE_EXECUTED(Ped ped, BOOL toggle) { invoke<Void>(0x4D19C95B, ped, toggle); } // unused
	static BOOL GET_PED_READY_TO_BE_EXECUTED(Ped ped) { return invoke<BOOL>(0x0C2D76D7); } // unused
	static void SET_PED_MELEE_ACTION_FLAG0(Ped ped, BOOL toggle) { invoke<Void>(0x358850B0), ped, toggle; } // unused
	static BOOL GET_PED_MELEE_ACTION_FLAG0(Ped ped) { return invoke<BOOL>(0x98A851EE); } // unused
	static void SET_PED_MELEE_ACTION_FLAG1(Ped ped, BOOL toggle) { invoke<Void>(0xEB55BC44, ped, toggle); } // unused
	static BOOL GET_PED_MELEE_ACTION_FLAG1(Ped ped) { return invoke<BOOL>(0xB4EF8A7C); } // unused
	static void SET_PED_MELEE_MOVEMENT_CONSTRAINT_BOX(Ped ped, float x1, float y1, float z1, float x2, float y2, float z2) { invoke<Void>(0x3D3C9BB7, ped, x1, y1, z1, x2, y2, z2); } // unused
	static BOOL IS_PED_SITTING_IN_VEHICLE(Ped ped, Vehicle vehicle) { return invoke<BOOL>(0xDDDE26FA, ped, vehicle); } // unused
	static BOOL IS_PED_SITTING_IN_ANY_VEHICLE(Ped ped) { return invoke<BOOL>(0x0EA9CA03, ped); }
	static BOOL IS_PED_ON_FOOT(Ped ped) { return invoke<BOOL>(0xC60D0785, ped); } // unused
	static BOOL IS_PED_ON_ANY_BIKE(Ped ped) { return invoke<BOOL>(0x4D885B2E, ped); } // unused
	static Vector3 GET_DEAD_PED_PICKUP_COORDS(Ped ped) { return invoke<Vector3>(0x129F9DC1, ped); } // unused
	static BOOL IS_PED_IN_ANY_BOAT(Ped ped) { return invoke<BOOL>(0x1118A947, ped); } // unused
	static BOOL IS_PED_IN_ANY_HELI(Ped ped) { return invoke<BOOL>(0x7AB5523B, ped); } // unused
	static BOOL IS_PED_IN_ANY_PLANE(Ped ped) { return invoke<BOOL>(0x51BBCE7E, ped); } // unused
	static BOOL IS_PED_IN_WATER(Ped ped) { return invoke<BOOL>(0x2A7FBBDF, ped); }
	static void SET_PED_SWEAT(Ped ped, float sweat, float unused) { invoke<Void>(0x76A1DB9F, ped, sweat, unused); }
	static float GET_PED_SWEAT(Ped ped) { return invoke<float>(0x44B91E94, ped); }
	static void SET_SWEAT_ENABLED(BOOL toggle) { invoke<Void>(0x296668CC, toggle); }
	static void SET_PED_WETNESS(Ped ped, float wetness, float wetHeight) { invoke<Void>(0x836E9462, ped, wetness, wetHeight); } // unused
	static float GET_PED_WETNESS(Ped ped) { return invoke<float>(0xF402C171, ped); } // unused
	static float GET_PED_WET_HEIGHT(Ped ped) { return invoke<float>(0x5DBBFF35, ped); } // unused
	static Vector3 GET_OFFSET_FROM_PED_IN_WORLD_COORDS(Ped ped, float x, float y, float z) { return invoke<Vector3>(0xAD515B68, ped, x, y, z); }
	static BOOL IS_PED_IN_FLYING_VEHICLE(Ped ped) { return invoke<BOOL>(0xCA072485, ped); } // unused
	static void FREEZE_PED_POSITION(Ped ped, BOOL toggle) { invoke<Void>(0xA34E3DEA, ped, toggle); }
	static void SET_PED_USES_DYING_ANIM(Ped ped, BOOL toggle) { invoke<Void>(0x4F0D8111, ped, toggle); }
	static void SET_PED_DIES_IN_WATER(Ped ped, BOOL toggle) { invoke<Void>(0x604C872B, ped, toggle); }
	static void SET_PED_DIES_IN_SINKING_VEHICLE(Ped ped, BOOL toggle) { invoke<Void>(0x8D4D9ABB, ped, toggle); }
	static int GET_PED_ARMOUR(Ped ped) { return invoke<int>(0x2CE311A7, ped); } // unused
	static BOOL IS_PED_WAITING_FOR_WORLD_COLLISION(Ped ped) { return invoke<BOOL>(0x28BCF200, ped); } // unused
	static BOOL HAS_PED_BEEN_DAMAGED_BY_PED(Ped ped, Ped ped2, BOOL p2) { return invoke<BOOL>(0xEA58F6FB, ped, ped2, p2); }
	static BOOL HAS_PED_BEEN_DAMAGED_BY_VEHICLE(Ped ped, Vehicle vehicle) { return invoke<BOOL>(0x437430FB, ped, vehicle); } // unused
	static void SET_PED_STAY_IN_VEHICLE_WHEN_JACKED(Ped ped, BOOL toggle) { invoke<Void>(0xB014A09C, ped); } // unused
	static BOOL IS_PED_TOUCHING_VEHICLE(Ped ped, Vehicle vehicle) { return invoke<BOOL>(0x22D9AC0C, ped, vehicle); }
	static void SET_PED_CAN_BE_SHOT_IN_VEHICLE(Ped ped, BOOL toggle) { invoke<Void>(0x5DB7B3A9, ped, toggle); } // unused
	static void CLEAR_PED_LAST_DAMAGE_ENTITY(Ped ped) { invoke<Void>(0xBDB4D36B, ped); }
	static BOOL GET_PED_LAST_DAMAGE_BONE(Ped ped, int* bone) { return invoke<BOOL>(0xAB933841, ped, bone); } // unused
	static void CLEAR_PED_LAST_DAMAGE_BONE(Ped ped) { invoke<Any>(0x56CB715E, ped); } // unused
	static void SET_PED_CAN_BE_TARGETTED(Ped ped, BOOL toggle) { invoke<Void>(0x75C49F74, ped, toggle); }
	static BOOL IS_PED_IN_ANY_POLICE_VEHICLE(Ped ped) { return invoke<BOOL>(0x84FA790D, ped); } // unused
	static BOOL DOES_PED_EXIST(Ped ped) { return invoke<BOOL>(0xF7C8D072, ped); }
	static void FREEZE_PED_POSITION_AND_DONT_LOAD_COLLISION(Ped ped, BOOL toggle) { invoke<Void>(0xF99B8DE7, ped, toggle); } // unused
	static void SET_LOAD_COLLISION_FOR_PED_FLAG(Ped ped, BOOL toggle) { invoke<Void>(0x887E7D88, ped, toggle); }
	static void SET_PED_DUCKING(Ped ped, BOOL toggle) { invoke<Void>(0xB90353D7, ped, toggle); }
	static BOOL IS_PED_DUCKING(Ped ped) { return invoke<BOOL>(0x9199C77D, ped); }
	static BOOL IS_PED_IN_ANY_TAXI(Ped ped) { return invoke<BOOL>(0x16FD386C, ped); } // unused
	static void SET_PED_SENSE_RANGE(Ped ped, float range) { invoke<Void>(0x7AC6C04A, ped, range); }
	static void SET_PED_ID_RANGE(Ped ped, float range) { invoke<Void>(0xEF3B4ED9, ped, range); }
	static void SET_PED_SEEING_RANGE(Ped ped, float range, int p2) { invoke<Void>(0x4BD72FE8, ped, range, p2); }
	static void SET_PED_HEARING_RANGE(Ped ped, float range) { invoke<Void>(0xB32087E0, ped, range); }
	static void SET_PED_FIELD_OF_VIEW(Ped ped, float p1, float p2, float p3) { invoke<Void>(0x57655E86, ped, p1, p2, p3); }
	static void SET_PED_STEALTH_MOVEMENT(Ped ped, BOOL toggle) { invoke<Void>(0x67E28E1D, ped, toggle); } // unused
	static BOOL GET_PED_STEALTH_MOVEMENT(Ped ped) { return invoke<BOOL>(0x40321B83, ped); } // unused
	static BOOL IS_PED_PLAYING_ANIM(Ped ped, char* animDict, char* animName) { return invoke<BOOL>(0x0C504868, ped, animDict, animName); } // unused
	static BOOL HAS_PED_ANIM_FINISHED(Ped ped, char* animDict, char* animName) { return invoke<BOOL>(0xBB6C6A0B, ped, animDict, animName); } // unused
	static BOOL PED_ANIM_EVENT_OLD(Ped ped, int p1) { return invoke<BOOL>(0x27F99158, ped, p1); }
	static BOOL PED_ANIM_EVENT(Ped ped, Hash p1) { return invoke<BOOL>(0xC0D17E4F, ped, p1); }
	static float GET_PED_ANIM_CURRENT_TIME(Ped ped, char* animDict, char* animName) { return invoke<float>(0x1BAAE533, ped, animDict, animName); } // unused
	static void SET_PED_ANIM_CURRENT_TIME(Ped ped, char* animDict, char* animName, float time) { invoke<Void>(0xF1C753D6, ped, animDict, animName, time); } // unused
	static void SET_PED_COLLISION(Ped ped, BOOL toggle) { invoke<Void>(0xDB1B8AAC, ped, toggle); }
	static float GET_PED_ANIM_TOTAL_TIME(Ped ped, char* animDict, char* animName) { return invoke<float>(0xB8945721, ped, animDict, animName); } // unused
	static Group CREATE_GROUP(int unused, BOOL p1) { return invoke<Group>(0x8DC0368D, unused, p1); }
	static void SET_PED_AS_GROUP_LEADER(Ped ped, Group group) { invoke<Void>(0x7265BEA2, ped, group); }
	static void SET_PED_AS_GROUP_MEMBER(Ped ped, Group group) { invoke<Void>(0x0EE13F92, ped, group); }
	static void REMOVE_GROUP(Group group) { invoke<Void>(0x48D72B88, group); } // unused
	static void REMOVE_DECISION_MAKER(ScrHandle decisionMaker) { invoke<Void>(0x95465154, decisionMaker); } // unused
	static Hash GET_PED_MODEL(Ped ped) { return invoke<Hash>(0x25F5E8E1, ped); } // unused
	static float GET_PED_SPEED(Ped ped) { return invoke<float>(0xBB824586, ped); }
	static void REMOVE_PED_FROM_GROUP(Ped ped) { invoke<Void>(0x82697713, ped); }
	static BOOL IS_PED_GROUP_MEMBER(Ped ped, Group group) { return invoke<BOOL>(0x876D5363, ped, group); } // unused
	static BOOL IS_PED_GROUP_LEADER(Ped ped, Group group) { return invoke<BOOL>(0xC8A9FB5A, ped, group); } // unused
	static void SET_GROUP_SEPARATION_RANGE(Group group, float range) { invoke<Void>(0x7B820CD5, group, range); } // unused
	static void SET_GROUP_RATIO_FIRING_AT_VISIBLE(Group group, float ratio) { invoke<Void>(0x16BCC68E, group, ratio); }
	static void SET_GROUP_RATIO_FIRING_AT_INVISIBLE(Group group, float ratio) { invoke<Void>(0x4A7E7B71, group, ratio); }
	static void SET_GROUP_MAX_NUMS_FIRING(Group group, int* values) { invoke<Void>(0x291609A6, group, values); }
	static void SET_GROUP_MAX_NUM_MOVING(Group group, int value) { invoke<Void>(0x8F0D887F, group, value); }
	static void SET_GROUP_MAX_NUM_ADVANCING(Group group, int value) { invoke<Void>(0x085CE849, group, value); }
	static void SET_GROUP_LAST_ALIVE_AS_LONE_WOLF(Group group, BOOL toggle) { invoke<Void>(0x32F7BB3B, group, toggle); }
	static Any CLEAR_PED_DECISION_MAKER_EVENT_RESPONSE() { return invoke<Any>(0x6BEC1C96); } // unused
	static Any ADD_PED_DECISION_MAKER_EVENT_RESPONSE() { return invoke<Any>(0x2B02F9D4); } // unused
	static Any COPY_PED_DECISION_MAKER() { return invoke<Any>(0x95C28AAA); } // unused
	static Any COPY_GROUP_PED_DECISION_MAKER() { return invoke<Any>(0xFC573D85); } // unused
	static Any LOAD_PED_DECISION_MAKER() { return invoke<Any>(0xCEA92F74); } // unused
	static Any SET_PED_DECISION_MAKER() { return invoke<Any>(0x13A0D6D5); } // unused
	static Any SET_PED_DECISION_MAKER_TO_DEFAULT() { return invoke<Any>(0xDD2DEE0A); } // unused
	static Any SET_GROUP_PED_DECISION_MAKER() { return invoke<Any>(0xD93095B3); } // unused
	static BOOL IS_PED_RELOADING(Ped ped) { return invoke<BOOL>(0x961E1745, ped); }
	static BOOL IS_PED_DUAL_WIELDING(Ped ped) { return invoke<BOOL>(0x03418403, ped); }
	static BOOL IS_PED_INVESTIGATING(Ped ped) { return invoke<BOOL>(0x53806A49, ped); } // unused
	static BOOL IS_PED_IN_COMBAT(Ped ped) { return invoke<BOOL>(0xFE027CB5, ped); }
	static BOOL IS_PED_DOING_DRIVEBY(Ped ped) { return invoke<BOOL>(0xAC3CEB9C, ped); } // unused
	static BOOL IS_PED_JACKING(Ped ped) { return invoke<BOOL>(0x3B321816, ped); } // unused
	static BOOL IS_PED_BEING_JACKED(Ped ped) { return invoke<BOOL>(0xD45D605C, ped); } // unused
	static BOOL IS_PED_RETREATING(Ped ped) { return invoke<BOOL>(0x27240BFE, ped); } // unused
	static BOOL IS_PED_FLEEING(Ped ped) { return invoke<BOOL>(0x85D813C6, ped); } // unused
	static BOOL IS_PED_IN_COVER(Ped ped) { return invoke<BOOL>(0x972C5A8B, ped); }
	static Any SET_PED_PINNED_DOWN(Ped ped, BOOL toggle, int p2) { return invoke<Any>(0xCC78999D, ped, toggle, p2); }
	static BOOL IS_PED_RUNNING_TASK(Ped ped, int task) { return invoke<BOOL>(0x10BF1163, ped, task); } // unused
	static void GIVE_PED_PICKUP_OBJECT(Ped ped, Object object, BOOL p2) { invoke<Void>(0x3B653867, ped, object, p2); } // unused
	static void SET_PED_RELATIONSHIP_GROUP(Ped ped, int relGroupIndex) { invoke<Void>(0x859990D1, ped, relGroupIndex); }
	static void SET_GANG_RELATIONSHIPS_CAN_BE_CHANGED_BY_NEXT_COMMAND(BOOL toggle) { invoke<Void>(0x2682B38B, toggle); } // unused
	static void SET_RELATIONSHIP_BETWEEN_REL_GROUPS(int relGroupId1, int relGroupId2, int flags) { invoke<Void>(0xDB37D46E, relGroupId1, relGroupId2, flags); }
	static void CLEAR_RELATIONSHIP_BETWEEN_REL_GROUPS(int relGroupId1, int relGroupId2, int flags) { invoke<Void>(0x1AB5F830, relGroupId1, relGroupId2, flags); } // unused
	static void SET_PED_RELATIONSHIP(Ped ped, int relGroupId, int flags) { invoke<Void>(0x3326679D, ped, relGroupId, flags); }
	static void CLEAR_PED_RELATIONSHIP(Ped ped, int relGroupId, int flags) { invoke<Void>(0xD7EF3057, ped, relGroupId, flags); } // unused
	static void SET_PED_CAN_BE_TARGETED_WITHOUT_LOS(Ped ped, BOOL toggle) { invoke<Void>(0x7FDDC0A6, ped, toggle); }
	static void SET_PED_TO_INFORM_RESPECTED_FRIENDS(Ped ped, float radius, int maxFriends) { invoke<Void>(0xD78AC46C, ped, radius, maxFriends); }
	static BOOL IS_PED_RESPONDING_TO_EVENT(Ped ped, int event) { return invoke<BOOL>(0x7A877554, ped, event); } // unused
	static void SET_PED_IS_TARGET_PRIORITY(Ped ped, BOOL toggle) { invoke<Void>(0xBA055544, ped, toggle); } // unused
	static void SET_PED_SHOOT_RATE(Ped ped, int shootRate) { invoke<Void>(0xFB301746, ped, shootRate); } // unused
	static int GET_GROUP_SIZE(Group group) { return invoke<int>(0xF7E1A691, group); }
	static BOOL DOES_GROUP_EXIST(Group group) { return invoke<BOOL>(0x935C978D, group); }
	static Group GET_PED_GROUP_INDEX(Ped ped) { return invoke<Group>(0x134E0785, ped); }
	static BOOL IS_PED_IN_GROUP(Ped ped, Group group) { return invoke<BOOL>(0x836D9795, ped, group); } // unused
	static void SET_GROUP_FORMATION(Group group, int formation) { invoke<Void>(0x08FAC739, group, formation); }
	static void SET_GROUP_FORMATION_SPACING(Group group, float spacing) { invoke<Void>(0xB1E086FF, group, spacing); }
	static void SET_GROUP_FORMATION_WALK_ALONGSIDE_LEADER_WHEN_CLOSE(Group group, BOOL toggle) { invoke<Void>(0x55D415AA, group, toggle); } // unused
	static void SET_GROUP_FORMATION_MAX_MOVE_SPEED(Group group, int speedIndex) { invoke<Void>(0x76EEE1E6, group, speedIndex); }
	static void SET_GROUP_GRENADE_PARAMS(Group group, int params) { invoke<Void>(0xAB1DEE08, group, params); }
	static Vehicle GET_VEHICLE_PED_IS_USING(Ped ped) { return invoke<Vehicle>(0x6DE3AADA, ped); } // unused
	static BOOL IS_PED_IN_AIR(Ped ped) { return invoke<BOOL>(0xD0060B64, ped); }
	static float GET_PED_HEIGHT_ABOVE_GROUND(Ped ped) { return invoke<float>(0x1E853FEC, ped); }
	static void SET_PED_GRAVITY(Ped ped, BOOL toggle) { invoke<Void>(0x3CA16652, ped, toggle); } // unused
	static void SET_PED_VELOCITY(Ped ped, float x, float y, float z) { invoke<Void>(0xD34337FB, ped, x, y, z); }
	static Vector3 GET_PED_VELOCITY(Ped ped) { return invoke<Vector3>(0xB954696C, ped); }
	static void SET_PED_ROTATION(Ped ped, float pitch, float roll, float yaw) { invoke<Void>(0xE0C7B6BB, ped, pitch, roll, yaw); } // unused
	static void APPLY_DAMAGE_TO_PED(Ped ped, int damageAmount, BOOL p2) { invoke<Void>(0x4DC27FCF, ped, damageAmount, p2); }
	static void APPLY_DAMAGE_TO_PED_WITH_HASH(Ped ped, int damageAmount, Hash damageTypeHash) { invoke<Void>(0x78C7D607, ped, damageAmount, damageTypeHash); } // unused
	static void SET_PED_ALLOWED_TO_DUCK(Ped ped, BOOL toggle) { invoke<Void>(0xC4D122F8, ped, toggle); }
	static void SET_PED_ALLOWED_TO_STAND(Ped ped, BOOL toggle) { invoke<Void>(0x86A96807, ped, toggle); } // unused
	static void SET_PED_ALLOWED_TO_ATTACK_IF_SURRENDERED(Ped ped, BOOL toggle) { invoke<Void>(0xDA7D361A, ped, toggle); } // unused
	static void SET_PED_ALLOWED_TO_DESTROY_IF_SURRENDERED(Ped ped, BOOL toggle) { invoke<Void>(0x6400B52C, ped, toggle); } // unused
	static void SET_PED_ALLOWED_TO_SURRENDER(Ped ped, BOOL toggle) { invoke<Void>(0xBCFA8338, ped, toggle); }
	static BOOL GET_PED_HAS_SURRENDERED(Ped ped) { return invoke<BOOL>(0xAA538B02, ped); } // unused
	static void SET_PED_ALLOWED_TO_KNEEL_AND_FIRE(Ped ped, BOOL toggle) { invoke<Void>(0x05A338B9, ped, toggle); }
	static void SET_PED_FORCE_KNEEL_AND_FIRE(Ped ped, BOOL toggle) { invoke<Void>(0xDF8ACDEE, ped, toggle); }
	static void SET_PED_NEVER_LEAVES_GROUP(Ped ped, BOOL toggle) { invoke<Void>(0x0E038813, ped, toggle); }
	static void SET_PED_FORCE_FIRE(Ped ped) { invoke<Void>(0x7FD3A5E9, ped); }
	static Vector3 GET_DEAD_PED_COORDS(Ped ped) { return invoke<Vector3>(0xD5BB9787, ped); }
	static int GET_PED_TYPE(Ped ped) { return invoke<int>(0xB1460D43, ped); } // unused
	static void SET_PED_MAX_HEALTH(Ped ped, int health) { invoke<Void>(0x5533F60B, ped, health); }
	static void SET_PED_MAX_TIME_IN_WATER(Ped ped, float time) { invoke<Void>(0xFE0A106B, ped, time); } // unused
	static void SET_PED_MAX_TIME_UNDERWATER(Ped ped, float time) { invoke<Void>(0x082EF240, ped, time); } // unused
	static void SET_GROUP_PED_DUCKS_WHEN_AIMED_AT(Ped ped, BOOL toggle) { invoke<Void>(0x013408C5, ped, toggle); }
	static void SET_PED_COMBAT_ADVANCE_DELAY_TIME(Ped ped, float p1, float p2) { invoke<Void>(0x3561D19D, ped, p1, p2); }
	static void SET_PED_CAN_BE_KNOCKED_OFF_BIKE(Ped ped, int state) { invoke<Void>(0x83645D83, state); } // unused
	static void KNOCK_PED_OFF_BIKE(Ped ped) { invoke<Void>(0x98200D3C, ped); } // unused
	static void SET_PED_COORDS_NO_GANG(Ped ped, float x, float y, float z) { invoke<Void>(0x9561AD98, ped, x, y, z); } // unused
	static Ped GET_PED_AS_GROUP_MEMBER(Group group, int memberIndex) { return invoke<Ped>(0x9AA3CC8C, group, memberIndex); } // unused
	static Ped GET_PED_AS_GROUP_LEADER(Group group) { return invoke<Ped>(0x52873C6A, group); } // unused
	static BOOL IS_PED_STUCK_UNDER_VEHICLE(Ped ped) { return invoke<BOOL>(0x2645971C, ped); } // unused
	static void SET_PED_KEEP_TASK(Ped ped, BOOL toggle) { invoke<Void>(0xA7EC79CE, ped, toggle); }
	static BOOL IS_PED_SWIMMING(Ped ped) { return invoke<BOOL>(0x7AB43DB8, ped); } // unused
	static void SET_PED_COORDS_NO_OFFSET(Ped ped, float x, float y, float z) { invoke<Void>(0x293C3D75, ped, x, y, z); }
	static void SET_PED_DIES_IN_VEHICLE(Ped ped, BOOL toggle) { invoke<Void>(0x6FE1E440, ped, toggle); }
	static void SET_CREATE_RANDOM_COPS(BOOL toggle) { invoke<Void>(0x23441648, toggle); } // unused
	static BOOL CAN_CREATE_RANDOM_COPS() { return invoke<BOOL>(0xAA73DAD9); } // unused
	static void SET_PED_DRUGGED_UP(Ped ped, BOOL toggle) { invoke<Void>(0xC89BFBED, ped, toggle); } // unused
	static void SET_PED_IN_CUTSCENE(Ped ped, BOOL toggle) { invoke<Void>(0x96937FF3, ped, toggle); } // unused
	static void SET_PED_AS_ENEMY(Ped ped, BOOL toggle) { invoke<Void>(0xAE620A1B, ped, toggle); } // unused
	static void SET_PED_AS_PRIMARY_CHAR(Ped ped, BOOL toggle) { invoke<Void>(0x551FE4E8, ped, toggle); }
	static void SET_PED_CAN_SMASH_GLASS(Ped ped, BOOL toggle) { invoke<Void>(0x149C60A8, ped, toggle); }
	static BOOL IS_PED_IN_ANY_TRAIN(Ped ped) { return invoke<BOOL>(0x759EF63A, ped); } // unused
	static void SET_PED_WANTED_BY_POLICE(Ped ped, BOOL toggle) { invoke<Void>(0xB255B830), ped, toggle; } // unused
	static BOOL IS_PED_GETTING_INTO_A_VEHICLE(Ped ped) { return invoke<BOOL>(0x90E805AC, ped); } // unused
	static void SET_PED_MAX_COVER_SEARCH_RADIUS(Ped ped, float radius) { invoke<Void>(0x69B6D9F0, ped, radius); } // unused
	static BOOL IS_PED_TRYING_TO_ENTER_A_LOCKED_VEHICLE(Ped ped) { return invoke<BOOL>(0x46828B4E, ped); } // unused
	static int GET_PED_ALERTNESS(Ped ped) { return invoke<int>(0xF83E4DAF, ped); } // unused
	static void SET_PED_ALERTNESS(Ped ped, int alertness) { invoke<Void>(0x2C32D9AE, ped, alertness); }
	static BOOL HAS_PED_CLEAR_LOS_TO_PED_IN_FRONT(Ped ped, Ped ped2) { return invoke<BOOL>(0xDDA4D00F, ped, ped2); }
	static BOOL DOES_DECISION_MAKER_EXIST(ScrHandle decisionMaker) { return invoke<BOOL>(0x5F912485, decisionMaker); } // unused
	static void SET_PED_GET_OUT_UPSIDE_DOWN_VEHICLE(Ped ped, BOOL toggle) { invoke<Void>(0x89AD49FF, ped, toggle); } // unused
	static void SET_PED_CAN_REMAIN_ON_BOAT_AFTER_MISSION_ENDS(Ped ped, BOOL toggle) { invoke<Void>(0x3B9C6330, ped, toggle); } // unused
	static BOOL IS_PED_TOUCHING_PED(Ped ped, Ped ped2) { return invoke<BOOL>(0x12C5484A, ped, ped2); }
	static void SET_PED_ANIM_GROUP(Ped ped, char* name) { invoke<Void>(0x55617E2A, ped, name); } // unused
	static void GET_PED_ANIM_GROUP(int bufferSize, char* buffer, Ped ped) { invoke<Void>(0xFAF5A3C5, bufferSize, buffer, ped); } // unused
	static void SET_PED_USES_DEAFULT_ANIM_GROUP_WHEN_FLEEING(Ped ped, BOOL toggle) { invoke<Void>(0xF604C9E2, ped, toggle); } // unused
	static void SET_PED_GESTURE_GROUP(Ped ped, char* name) { invoke<Void>(0x170DA109, ped, name); } // unused
	static void COPY_ANIMATIONS(Ped ped, Ped ped2, float p2) { invoke<Void>(0x2ED971A5, ped, ped2, p2); } // unused
	static int GET_PED_DRAWABLE_VARIATION(Ped ped, int componentId) { return invoke<int>(0x29850FE2, ped, componentId); } // unused
	static int GET_NUMBER_OF_PED_DRAWABLE_VARIATIONS(Ped ped, int componentId) { return invoke<int>(0x9754C27D, ped, componentId); } // unused
	static int GET_PED_TEXTURE_VARIATION(Ped ped, int componentId) { return invoke<int>(0xC0A8590A, ped, componentId); } // unused
	static int GET_NUMBER_OF_PED_TEXTURE_VARIATIONS(Ped ped, int componentId, int drawableIndex) { return invoke<int>(0x83D9FBE7, ped, componentId, drawableIndex); } // unused
	static int GET_PED_PALETTE_VARIATION(Ped ped, int componentId) { return invoke<int>(0xEF1BC082, ped, componentId); } // unused
	static BOOL GET_PED_HAS_PALETTE_VARIATIONS(Ped ped, Hash p1, Hash p2) { return invoke<BOOL>(0xFE522C50, ped, p1, p2); } // unused
	static void SET_PERSISTENT_PED_VARIATION(Ped ped, char* name) { invoke<Void>(0x3DDDB088, ped, name); }
	static void SET_PERSISTENT_PED_VARIATION_ENUM(Ped ped, Hash hash) { invoke<Void>(0x20485584, ped, hash); }
	static Hash GET_SCENE_PED_MODEL(Hash unkHash) { return invoke<Hash>(0x236815DF, unkHash); }
	static void _0xF1B4EEAE(int p0) { invoke<Void>(0xF1B4EEAE, p0); }
	static void SET_PERSISTENT_STREAM_PED_VARIATION(Ped ped, char* name) { invoke<Void>(0x4206DB40, ped, name); } // unused
	static void SET_PERSISTENT_STREAM_PED_VARIATION_ENUM(Ped ped, Hash hash) { invoke<Void>(0x91B49B0B, ped, hash); } // unused
	static void SET_STREAM_PED_CUSTOMISATION_DATA(Ped ped, Hash hash) { invoke<Void>(0xA3E802DD, ped, hash); } // unused
	static int GET_STREAM_PED_PACK_ID(Hash hash) { return invoke<int>(0x70833487, hash); }
	static void SET_PED_COMPONENT_VARIATION(Ped ped, int componentId, int drawableId, int textureId, int paletteId) { invoke<Void>(0xD4F7B05C, ped, componentId, drawableId, textureId, paletteId); }
	static void SET_STREAM_PED_COMPONENT_VARIATION(Ped ped, int componentId, int drawableId, int textureId, int paletteId) { invoke<Void>(0x9F59036F, ped, componentId, drawableId, textureId, paletteId); } // unused
	static void _SET_STREAM_PED_COMPONENT_VARIATION_2(Ped ped, int componentId, int drawableId, int textureId, int paletteId) { invoke<Void>(0x5C75CD2D, ped, componentId, drawableId, textureId, paletteId); }
	static void SET_PED_RANDOM_COMPONENT_VARIATION(Ped ped) { invoke<Void>(0x4111BA46, ped); } // unused
	static void SET_PED_DEFAULT_COMPONENT_VARIATION(Ped ped) { invoke<Void>(0xC866A984, ped); } // unused
	static void PRELOAD_PLAYER_VARIATION(Ped ped, int componentId, int drawableId, int textureId, int paletteId) { invoke<Void>(0x292A475A, ped, componentId, drawableId, textureId, paletteId); }
	static void APPLY_PLAYER_PRELOAD_VARIATION(Ped ped, int index) { invoke<Void>(0xAC6A7AD3, ped, index); }
	static int GET_PED_PROP_INDEX(Ped ped, int componentId) { return invoke<int>(0x746DDAC0, ped, componentId); }
	static void SET_PED_PROP_INDEX(Ped ped, int componentId, int drawableId, int textureId, int unk) { invoke<Void>(0x0829F2E2, ped, componentId, drawableId, textureId, unk); }
	static void CLEAR_PED_PROP(Ped ped, int propIndex) { invoke<Void>(0x2D23D743, ped, propIndex); }
	static void CLEAR_ALL_PED_PROPS(Ped ped) { invoke<Void>(0x81DF8B43, ped); }
	static void PRELOAD_STREAM_COMPONENT(int p0, int p1, int p2, int p3) { invoke<Void>(0x01E1DCDC, p0, p1, p2, p3); }
	static void RELEASE_PRELOADED_STREAM_COMPONENT(int p0, int p1, int p2, int p3) { invoke<Void>(0x2501E8E5, p0, p1, p2, p3); }
	static void _APPLY_LOADOUT_ITEM(Ped ped, Hash p1, Hash p2) { invoke<Void>(0x33EA6ABF, ped, p1, p2); }
	static void SET_HELMET_KNOCK_OFF_HEALTH(Ped ped, float health) { invoke<Void>(0x844A6C50, ped, health); }
	static void KNOCK_OFF_PROP_AT_ANCHOR_POINT(Ped ped, int propIndex) { invoke<Void>(0xDE473335, ped, propIndex); }
	static Vector3 GET_PED_PROP_POSITION(Ped ped, int propIndex) { return invoke<Vector3>(0x7277314C, ped, propIndex); }
	static Vector3 GET_PEP_PROP_ROTATION(Ped ped, int propIndex) { return invoke<Vector3>(0x2B4DECF4, ped, propIndex); }
	static Vector3 _0x9A2923D0(Ped ped, float p1, float* p2) { return invoke<Vector3>(0x9A2923D0, ped, p1, p2); }
	static void GIVE_PED_ARMOUR_MP_REWARD(Ped ped, Hash hash) { invoke<Void>(0x1DE9A391, ped, hash); }
	static void SET_BLOCKING_OF_NON_TEMPORARY_EVENTS(Ped ped, BOOL toggle) { invoke<Void>(0xDFE34E4A, ped, toggle); }
	static BOOL GET_BLOCKING_OF_NON_TEMPORARY_EVENTS(Ped ped) { return invoke<BOOL>(0xC38F2076, ped); }
	static void SET_BLOCKING_OF_PED_TARGETTING(Ped ped, BOOL toggle) { invoke<Void>(0xFB55CFD0, ped, toggle); }
	static BOOL GET_BLOCKING_OF_PED_TARGETTING(Ped ped) { return invoke<BOOL>(0x8C2FD714, ped); } // unused
	static void REGISTER_TARGET(Ped ped, Ped targetPed) { invoke<Void>(0x50A95442, ped, targetPed); }
	static void REGISTER_HATED_TARGETS_IN_AREA(Ped ped, float x, float y, float z, float radius) { invoke<Void>(0x53CEFAA1, ped, x, y, z, radius); } // unused
	static void REGISTER_HATED_TARGETS_AROUND_PED(Ped ped, float radius) { invoke<Void>(0x7F87559E, ped, radius); } // unused
	static void SET_LOCKED_TARGET(Ped ped, Ped targetPed) { invoke<Void>(0xE0E4C21C, ped, targetPed); }
	static void CLEAR_LOCKED_TARGET(Ped ped) { invoke<Void>(0xCEC0CF8C, ped); }
	static void SET_ROOM_FOR_PED_BY_NAME(Ped ped, char* name) { invoke<Void>(0xD363B660, ped, name); }
	static void SET_ROOM_FOR_PED_BY_KEY(Ped ped, Hash hash) { invoke<Void>(0x41FC2A85, ped, hash); }
	static void CLEAR_ROOM_FOR_PED(Ped ped) { invoke<Void>(0xAABFC73C, ped); }
	static Hash GET_KEY_FOR_PED_IN_ROOM(Ped ped) { return invoke<Hash>(0x2A870D57, ped); } // unused
	static Interior GET_INTERIOR_FROM_PED(Ped ped) { return invoke<Interior>(0xC5F6B455, ped); }
	static Ped GET_RANDOM_PED_AT_COORD(float x, float y, float z, float xRadius, float yRadius, float zRadius) { return invoke<Ped>(0xDC8239EB, x, y, z, xRadius, yRadius, zRadius); } // unused
	static BOOL GET_CLOSEST_PED(float x, float y, float z, float radius, BOOL p4, BOOL p5, Ped* outPed) { return invoke<BOOL>(0x8F6C1F55, x, y, z, radius, p4, p5, outPed); } // unused
	static BOOL GET_CLOSEST_ENEMY_PED(Ped ped, float p1, float p2, float p3, float p4, BOOL p5, BOOL p6, BOOL p7, BOOL p8, BOOL p9, BOOL p10, Ped* outPed) { return invoke<BOOL>(0x3E184D2D, ped, p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, outPed); }
	static BOOL GET_RANDOM_ENEMY_PED(Ped ped, float p1, float p2, float p3, float p4, BOOL p5, BOOL p6, BOOL p7, BOOL p8, BOOL p9, BOOL p10, Ped* outPed) { return invoke<BOOL>(0xD48A59F0, ped, p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, outPed); } // unused
	static void START_PED_SEARCH_CRITERIA() { invoke<Void>(0x12B1686A); } // unused
	static void STOP_PED_SEARCH_CRITERIA() { invoke<Void>(0xE9AFE4DE); } // unused
	static void SEARCH_CRITERIA_CONSIDER_PEDS_WITH_FLAG_TRUE(int flag) { invoke<Void>(0x611870D2, flag); } // unused
	static void SEARCH_CRITERIA_REJECT_PEDS_WITH_FLAG_TRUE(int flag) { invoke<Void>(0x044EC539, flag); } // unused
	static void SET_SCENARIO_PEDS_TO_BE_RETURNED_BY_NEXT_COMMAND(BOOL toggle) { invoke<Void>(0x85615FD0, toggle); } // unused
	static void APPLY_FORCE_TO_PED(Ped ped, int forceType, float forceX, float forceY, float forceZ, float offX, float offY, float offZ, int bone, BOOL isDirectionRel, BOOL ignoreUpVec, BOOL isForceRel) { invoke<Void>(0x343ABB0E, ped, forceType, forceX, forceY, forceZ, offX, offY, offZ, bone, isDirectionRel, ignoreUpVec, isForceRel); }
	static BOOL SET_PED_TO_RAGDOLL(Ped ped, int time1, int time2, int p3, BOOL p4, BOOL p5, BOOL p6, float p7) { return invoke<BOOL>(0x83CB5052, ped, time1, time2, p3, p4, p5, p6, p7); }
	static BOOL SET_PED_TO_RAGDOLL_WITH_FALL(Ped ped, int time1, int time2, int ragdollType, float p4, float p5, float p6, float p7, float p8, float p9, float p10, float p11, float p12, float p13) { return invoke<BOOL>(0xFA12E286, ped, time1, time2, ragdollType, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13); }
	static BOOL SET_PED_TO_RAGDOLL_WITH_EXPLOSION(Ped ped, int time1, int time2, float x, float y, float z) { return invoke<BOOL>(0xF561B007, ped, time1, time2, x, y, z); }
	static void SET_PED_TO_ANIMATED(Ped ped, BOOL toggle) { invoke<Void>(0x48ED4F81, ped, toggle); } // unused
	static BOOL IS_PED_RAGDOLL(Ped ped, BOOL p1) { return invoke<BOOL>(0xC833BBE1, ped, p1); }
	static void SET_PED_CAN_RAGDOLL(Ped ped, BOOL toggle) { invoke<Void>(0xCF1384C4, ped, toggle); }
	static void SET_PED_AS_MISSION_PED(Ped ped) { invoke<Void>(0x8F46967F, ped); } // unused
	static void SET_PED_ANGLED_DEFENSIVE_AREA(Ped ped, float x1, float y1, float z1, float x2, float y2, float z2, float angle) { invoke<Void>(0x3EFBDD9B, ped, x1, y1, z1, x2, y2, z2, angle); } // unused
	static void SET_PED_SPHERE_DEFENSIVE_AREA(Ped ped, float x, float y, float z, float radius) { invoke<Void>(0xBD96D8E8, ped, x, y, z, radius); } // unused
	static void SET_PED_DEFENSIVE_AREA_ATTACHED_TO_PED(Ped ped, Ped ped2, float x1, float y1, float z1, float x2, float y2, float z2, float angle, BOOL p9) { invoke<Void>(0x74BDA7CE, ped, ped2, x1, y1, z1, x2, y2, z2, angle, p9); } // unused
	static void SET_PED_DEFENSIVE_AREA_DIRECTION(Ped ped, float xDir, float yDir, float zDir) { invoke<Void>(0xB66B0C9A, ped, xDir, yDir, zDir); } // unused
	static void REMOVE_PED_DEFENSIVE_AREA(Ped ped) { invoke<Void>(0x34AAAFA5, ped); } // unused
	static void SET_PED_CAN_MOVE_WHEN_INJURED(Ped ped, BOOL toggle) { invoke<Void>(0xF6589BD1, ped, toggle); } // unused
	static void REVIVE_INJURED_PED(Ped ped) { invoke<Void>(0x14D3E6E3, ped); } // unused
	static void SET_PED_NAME_DEBUG(Ped ped, char* name) { invoke<Void>(0x20D6273E, ped, name); }
	static Vector3 GET_PED_EXTRACTED_DISPLACEMENT(Ped ped, BOOL worldSpace) { return invoke<Vector3>(0x5231F901, ped, worldSpace); } // unused
	static void SET_PED_DIES_WHEN_INJURED(Ped ped, BOOL toggle) { invoke<Void>(0xE94E24D4, ped, toggle); }
	static void SET_PED_REQUIRE_HEADSHOT_TO_KILL(Ped ped, BOOL toggle) { invoke<Void>(0x12085B68, ped, toggle); }
	static void ATTACH_PED_TO_VEHICLE(Ped ped, Vehicle vehicle, int bone, float p3, float p4, float p5, float p6, float p7, BOOL p8, BOOL p9, BOOL p10, BOOL p11) { invoke<Void>(0x07A41569, ped, vehicle, bone, p3, p4, p5, p6, p7, p8, p9, p10, p11); }
	static void ATTACH_PED_TO_VEHICLE_PHYSICALLY(Ped ped, Vehicle vehicle, int bone1, int bone2, float p4, float p5, float p6, float p7, BOOL p8, BOOL p9) { invoke<Void>(0x7A9DBF0D, ped, vehicle, bone1, bone2, p4, p5, p6, p7, p8, p9); } // unused
	static void ATTACH_PED_TO_OBJECT(Any p0, Any p1, Any p2, Any p3, Any p4, Any p5, Any p6, Any p7, Any p8, Any p9) { invoke<Void>(0x107FDC53, p0, p1, p2, p3, p4, p5, p6, p7, p8, p9); }
	static Any ATTACH_PED_TO_OBJECT_PHYSICALLY() { return invoke<Any>(0x37F17899); } // unused
	static void ATTACH_PED_TO_WORLD_PHYSICALLY(Any p0, Any p1, Any p2, Any p3, Any p4, Any p5, Any p6, Any p7, Any p8, Any p9) { invoke<Void>(0xAF7B92C2, p0, p1, p2, p3, p4, p5, p6, p7, p8, p9); }
	static Any ATTACH_PED_TO_PED() { return invoke<Any>(0xAFB33CC2); } // unused
	static Any ATTACH_PED_TO_PED_PHYSICALLY() { return invoke<Any>(0x10673612); } // unused
	static void DETACH_PED(Ped ped, BOOL p1) { invoke<Void>(0xB65BD564, ped, p1); }
	static void DETACH_PED_FROM_WITHIN_VEHICLE(Ped ped, BOOL p1) { invoke<Void>(0x7ABAB86B, ped, p1); }
	static void SET_HEADING_LIMIT_FOR_ATTACHED_PED(Ped ped, float p1, float p2) { invoke<Void>(0xA7813774, ped, p1, p2); } // unused
	static void SET_ATTACHED_PED_ROTATION(Ped ped, float xRot, float yRot, float zRot) { invoke<Void>(0xFFE0FCD5, ped, xRot, yRot, zRot); } // unused
	static BOOL IS_PED_ATTACHED_TO_ANY_VEHICLE(Ped ped) { return invoke<BOOL>(0x0679A04D, ped); }
	static BOOL IS_PED_ATTACHED_TO_OBJECT(Ped ped, Object object) { return invoke<BOOL>(0xEA085F14, ped, object); } // unused
	static BOOL IS_PED_A_MISSION_PED(Ped ped) { return invoke<BOOL>(0xB653748D, ped); }
	static void APPLY_DAMAGE_TO_PED_BODY_PART(Ped ped, int bodyPartId, int amount) { invoke<Void>(0x6B997326, ped, bodyPartId, amount); }
	static int GET_PED_BODY_PART_DAMAGE(Ped ped, int bodyPartId) { return invoke<int>(0x326CB003, ped, bodyPartId); } // unused
	static void RESET_PED_VISIBLE_DAMAGE(Ped ped) { invoke<Void>(0xC4BC4841, ped); }
	static Vector3 GET_PED_BONE_COORDS(Ped ped, int boneId, float offsetX, float offsetY, float offsetZ) { return invoke<Vector3>(0x4579CAB1, ped, boneId, offsetX, offsetY, offsetZ); }
	static Any TOGGLE_NM_BINDPOSE_TASK() { return invoke<Any>(0x8F0F700B); } // unused
	static void CREATE_NM_MESSAGE(int flags, int messageId) { invoke<Void>(0x1CFBFD4B, flags, messageId); } // unused
	static void GIVE_PED_NM_MESSAGE(Ped ped) { invoke<Void>(0x737C3689, ped); } // unused
	static void SET_NM_MESSAGE_FLOAT(int messageId, float value) { invoke<Void>(0xE2959702, messageId, value); } // unused
	static void SET_NM_MESSAGE_INT(int messageId, int value) { invoke<Void>(0x7FA76EE4, messageId, value); } // unused
	static void SET_NM_MESSAGE_BOOL(int messageId, BOOL value) { invoke<Void>(0xAEF25DC5, messageId, value); } // unused
	static void SET_NM_MESSAGE_VEC3(int messageId, float x, float y, float z) { invoke<Void>(0x535F6DCE, messageId, x, y, z); } // unused
	static void SET_NM_MESSAGE_INSTANCE_INDEX(int messageId, Ped ped, Vehicle vehicle, Object object) { invoke<Void>(0xC8B5DFE3, messageId, ped, vehicle, object); } // unused
	static void SET_NM_MESSAGE_STRING(int messageId, char* value) { invoke<Void>(0x7A0DF013, messageId, value); } // unused
	static void SET_PED_NM_ANIM_POSE(Ped ped, char* clipDictName, char* animName, float p3) { invoke<Void>(0x2771F8D3, ped, clipDictName, animName, p3); } // unused
	static Any SET_PED_BLEND_FROM_NM_WITH_ANIM() { return invoke<Any>(0x6C433786); } // unused
	static BOOL GET_PED_NM_FEEDBACK(Ped ped, int p1, int p2) { return invoke<BOOL>(0x7A8E12C1, ped, p1, p2); }
	static void ADD_SCENARIO_BLOCKING_AREA(float x1, float y1, float z1, float x2, float y2, float z2) { invoke<Void>(0xA38C0234, x1, y1, z1, x2, y2, z2); } // unused
	static void REMOVE_SCENARIO_BLOCKING_AREAS() { invoke<Void>(0x4DDF845F); } // unused
	static void SET_SCENARIO_PEDS_SPAWN_IN_SPHERE_AREA(float x, float y, float z, float radius, int p4) { invoke<Void>(0x80EAD297, x, y, z, radius, p4); } // unused
	static BOOL IS_PED_USING_SCENARIO(Ped ped, char* scenarioName) { return invoke<BOOL>(0x0F65B0D4, ped, scenarioName); } // unused
	static BOOL IS_PED_USING_ANY_SCENARIO(Ped ped) { return invoke<BOOL>(0x195EF5B7, ped); } // unused
	static void SET_PED_WITH_BRAIN_CAN_BE_CONVERTED_TO_DUMMY_PED(Ped ped, BOOL toggle) { invoke<Void>(0x71060A53, ped, toggle); } // unused
	static BOOL IS_PED_GESTURING(Ped ped) { return invoke<BOOL>(0x28ADE9BC, ped); } // unused
	static void SET_PED_CAN_HEAD_IK(Ped ped, BOOL toggle) { invoke<Void>(0xD3B04476, ped, toggle); } // unused
	static void SET_PED_CAN_PLAY_GESTURE_ANIMS(Ped ped, BOOL toggle) { invoke<Void>(0xE131E3B3, ped, toggle); } // unused
	static void SET_PED_CAN_PLAY_VISEME_ANIMS(Ped ped, BOOL toggle) { invoke<Void>(0xA2FDAF27, ped, toggle); } // unused
	static void SET_PED_CAN_PLAY_AMBIENT_ANIMS(Ped ped, BOOL toggle) { invoke<Void>(0xF8053081, ped, toggle); }
	static void SET_PED_ENABLE_HEADLOOK_CONTROLLER(Ped ped, BOOL toggle) { invoke<Void>(0xD74C9BA1, ped, toggle); }
	static void SET_PED_CAN_USE_AUTO_CONVERSATION_LOOKAT(Ped ped, BOOL toggle) { invoke<Void>(0x584C5178, ped, toggle); } // unused
	static void SET_PED_CAN_TRIGGER_BULLET_CAM(Ped ped, BOOL toggle) { invoke<Void>(0x7DF0538C, ped, toggle); }
	static BOOL GET_PED_CAN_TRIGGER_BULLET_CAM(Ped ped) { return invoke<BOOL>(0x28EAACA6, ped); }
	static void SET_PED_CAN_INITIATE_BULLET_CAM(Ped ped, BOOL toggle) { invoke<Void>(0x63621CC9, ped, toggle); }
	static BOOL GET_PED_CAN_INITIATE_BULLET_CAM(Ped ped) { return invoke<BOOL>(0xC15F38C0, ped); } // unused
	static void SET_PED_VALIDATE_BULLET_CAM_HIT(Ped ped, BOOL toggle) { invoke<Void>(0xFBB7E5C8, ped, toggle); }
	static void SET_BULLET_CAM_PREF(Ped ped, char* p1, char* p2, char* p3, char* p4, BOOL p5, char* p6, char* p7, char* p8, char* p9, char* p10, char* p11, char* p12) { invoke<Void>(0xC82AD002, ped, p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12); }
	static Any GET_BULLET_CAM_PREF(Ped ped, int index) { return invoke<Any>(0xCA8E8FCC, ped, index); } // unused
	static void SET_BULLET_CAM_ON_NEXT_PROJECTILE(Ped ped, char* p1) { invoke<Void>(0xE9B08533, ped, p1); }
	static BOOL IS_PED_HEADTRACKING_PED(Ped ped1, Ped ped2) { return invoke<BOOL>(0x2A5DF721, ped1, ped2); } // unused
	static void SET_PED_PRIMARY_LOOKAT(Ped ped, Ped lookat) { invoke<Void>(0x6DEF6F1C, ped, lookat); }
	static void SET_COORD_PRIMARY_LOOKAT(Ped ped, float x, float y, float z) { invoke<Void>(0xEAA16410, ped, x, y, z); }
	static void SET_PED_SECONDARY_LOOKAT(Ped ped, Ped lookat) { invoke<Void>(0x09B700AE, ped, lookat); } // unused
	static void CLEAR_PED_PRIMARY_LOOKAT(Ped ped) { invoke<Void>(0xFFFE3FBF, ped); }
	static void CLEAR_PED_SECONDARY_LOOKAT(Ped ped) { invoke<Void>(0x0D7D2CA7, ped); } // unused
	static void SET_IK_ATTACH_TARGET_PED(Ped ped, Ped targetPed, char* boneName) { invoke<Void>(0x14A13274, ped, targetPed, boneName); } // unused
	static void SET_IK_ATTACH_TARGET_OBJ(Ped ped, Vehicle targetVehicle, char* boneName) { invoke<Void>(0x77315EBE, ped, targetVehicle, boneName); }
	static void SET_IK_ATTACH_TARGET_VEH(Ped ped, Object targetObject, char* boneName) { invoke<Void>(0x00497A7F, ped, targetObject, boneName); }
	static void CLEAR_IK_ATTACH_TARGET(Ped ped) { invoke<Void>(0x923D602F, ped); }
	static void SET_PED_INVINCIBLE(Ped ped, BOOL toggle) { invoke<Void>(0x1FC771E2, ped, toggle); }
	static void SET_PED_CAN_FLY_THROUGH_WINDSCREEN(Ped ped, BOOL toggle) { invoke<Void>(0x348F2753, ped, toggle); } // unused
	static void SET_PED_DONT_USE_VEHICLE_SPECIFIC_ANIMS(Ped ped, BOOL toggle) { invoke<Void>(0x23108373, ped, toggle); } // unused
	static void SET_PED_GROUP_MEMBER_PASSENGER_INDEX(Ped ped, int index) { invoke<Void>(0x2AB3670B, ped, index); } // unused
	static void SET_PED_IGNORE_LOS_CHECKS(Ped ped, BOOL toggle) { invoke<Void>(0x007FED1F, ped, toggle); }
	static void SET_PED_CAN_EVASIVE_DIVE(Ped ped, BOOL toggle) { invoke<Void>(0x542FEB4D, ped, toggle); } // unused
	static void SET_PED_SHOOTS_AT_COORD(Ped ped, float x, float y, float z) { invoke<Void>(0xFD64EAE5, ped, x, y, z); }
	static void SET_PED_PROJECTILE_OVERRIDE_PARAMETERS(Ped ped, BOOL p1, float p2, float p3, BOOL p4, BOOL p5) { invoke<Void>(0x708DE568, ped, p1, p2, p3, p4, p5); }
	static void SET_PED_MODEL_IS_SUPPRESSED(Hash modelHash, BOOL toggle) { invoke<Void>(0x7820CA43, modelHash, toggle); } // unused
	static void STOP_ANY_PED_MODEL_BEING_SUPPRESSED() { invoke<Void>(0x5AD7DC55); } // unused
	static void SET_PED_CAN_BE_TARGETED_WHEN_INJURED(Ped ped, BOOL toggle) { invoke<Void>(0x6FD9A7CD, ped, toggle); } // unused
	static void SET_PED_GENERATES_DEAD_BODY_EVENTS(Ped ped, BOOL toggle) { invoke<Void>(0xE9B97A2B, ped, toggle); } // unused
	static void SET_PED_WILL_ONLY_ATTACK_WANTED_PLAYER(Ped ped, BOOL toggle) { invoke<Void>(0xF4C0C377, ped, toggle); } // unused
	static void SET_PED_CAN_RAGDOLL_FROM_PLAYER_IMPACT(Ped ped, BOOL toggle) { invoke<Void>(0xE9BD733A, ped, toggle); }
	static void GIVE_PED_HELMET(Ped ped, BOOL cannotRemove) { invoke<Void>(0x1862A461, ped, cannotRemove); } // unused
	static void GIVE_PED_HELMET_WITH_OPTS(Ped ped, BOOL cannotRemove) { invoke<Void>(0x0BEC2729, ped, cannotRemove); } // unused
	static void REMOVE_PED_HELMET(Ped ped, BOOL instantly) { invoke<Void>(0x2086B1F0, ped, instantly); } // unused
	static void SET_PED_HELMET(Ped ped, BOOL canWearHelmet) { invoke<Void>(0xED366E53, ped, canWearHelmet); } // unused
	static void SET_PED_TO_LOAD_COVER(Ped ped, BOOL toggle) { invoke<Void>(0xCF94BA97, ped, toggle); } // unused
	static void SET_PED_CAN_COWER_IN_COVER(Ped ped, BOOL toggle) { invoke<Void>(0x5194658B, ped, toggle); } // unused
	static void SET_PED_CAN_PEEK_IN_COVER(Ped ped, BOOL toggle) { invoke<Void>(0xC1DAE216, ped, toggle); }
	static void SET_PED_CAN_INTERACT_WITH_DOORS(Ped ped, BOOL toggle) { invoke<Void>(0x60055ED3, ped, toggle); }
	static void SET_ALLOW_DUMMY_CONVERSIONS(BOOL toggle) { invoke<Void>(0x7F0D7E5B, toggle); } // unused
	static void SET_PED_PLAYS_HEAD_ON_HORN_ANIM_WHEN_DIES_IN_VEHICLE(Ped ped, BOOL toggle) { invoke<Void>(0x7C563CD2, ped, toggle); } // unused
	static void SET_PED_HEEDS_THE_EVERYONE_IGNORE_PLAYER_FLAG(Ped ped, BOOL toggle) { invoke<Void>(0x31A06AF4, ped, toggle); } // unused
	static void SET_PED_LEG_IK_MODE(Ped ped, int mode) { invoke<Void>(0xFDDB042E, ped, mode); } // unused
	static Any GIVE_PED_FAKE_NETWORK_NAME() { return invoke<Any>(0xBA223E7B); } // unused
	static void REMOVE_FAKE_NETWORK_NAME_FROM_PED(Ped ped) { invoke<Void>(0xAB07F041, ped); } // unused
	static void ADD_PED_TO_MISSION_DELETION_LIST(Ped ped, BOOL p1) { invoke<Void>(0x302E8AC8, ped, p1); } // unused
	static Any SET_PED_ALPHA() { return invoke<Any>(0xB94DA9B3); } // unused
	static void SET_PED_CAN_SWITCH_WEAPON(Ped ped, BOOL toggle) { invoke<Void>(0xB5F8BA28, ped, toggle); }
	static void SET_PED_DIES_INSTANTLY_IN_WATER(Ped ped, BOOL toggle) { invoke<Void>(0xFE2554FC, ped, toggle); }
	static void SET_PED_CLIMB_ANIM_RATE(Ped ped, float rate) { invoke<Void>(0x571A7C60, ped, rate); } // unused
	static void SET_PED_EDGE_COVER_BLINDFIRE_ARC_OVERRIDE(Ped ped, float p1) { invoke<Void>(0xFDB77BC9, ped, p1); } // unused
	static BOOL IS_PED_IN_SPHERE_AREA_OF_ANY_ENEMY_PEDS(Ped ped, float x, float y, float z, float radius, BOOL p5) { return invoke<BOOL>(0x0A76F4AE, ped, x, y, z, radius, p5); }
	static void STOP_PED_WEAPON_FIRING_WHEN_DROPPED(Ped ped) { invoke<Void>(0x4AC3421E, ped); } // unused
	static void STOP_PED_DOING_FALL_OFF_TESTS_WHEN_SHOT(Ped ped) { invoke<Void>(0x5B01902A, ped); } // unused
	static void SET_SCRIPTED_ANIM_SEAT_OFFSET(Ped ped, float offset) { invoke<Void>(0x7CEFFA45, ped, offset); } // unused
	static void SET_PED_COMBAT_MOVEMENT(Ped ped, int type) { invoke<Void>(0x12E62F9E, ped, type); }
	static int GET_PED_COMBAT_MOVEMENT(Ped ped) { return invoke<int>(0xF3E7730E, ped); }
	static void SET_PED_COMBAT_ABILITY(Ped ped, int type) { invoke<Void>(0x6C23D329, ped, type); }
	static int GET_PED_COMBAT_ABILITY(Ped ped) { return invoke<int>(0xDCC779BB, ped); } // unused
	static void SET_PED_COMBAT_RANGE(Ped ped, int type) { invoke<Void>(0x8818A959, ped, type); }
	static void SET_PED_COMBAT_RANGE_MIN(Ped ped, float range) { invoke<Void>(0xFF2BE6DE, ped, range); }
	static void SET_PED_COMBAT_RANGE_MAX(Ped ped, float range) { invoke<Void>(0x7DC35B63, ped, range); }
	static void SET_PED_COMBAT_RANGE_HALF_HEIGHT(Ped ped, float value) { invoke<Void>(0xC551CE6B, ped, value); } // unused
	static float GET_PED_COMBAT_RANGE_MIN(Ped ped) { return invoke<float>(0x6BEBA6A8, ped); }
	static float GET_PED_COMBAT_RANGE_MAX(Ped ped) { return invoke<float>(0x647EA0D6, ped); }
	static float GET_PED_COMBAT_RANGE_HALF_HEIGHT(Ped ped) { return invoke<float>(0x6E4808B0, ped); } // unused
	static void SET_PED_COMBAT_ATTRIBUTES(Ped ped, int attributes, BOOL enabled) { invoke<Void>(0x81D64248, ped, attributes, enabled); }
	static void SET_PED_EMOTION_STATE(Ped ped, int state) { invoke<Void>(0xF8A51CEC, ped, state); }
	static int GET_PED_EMOTION_STATE(Ped ped) { return invoke<int>(0x329F833E, ped); } // unused
	static void SET_PED_AUTO_UPDATE_EMOTION_STATE(Ped ped, BOOL toggle) { invoke<Void>(0x50F22719, ped, toggle); }
	static Any SET_PED_STEALTH_ATTRIBUTES() { return invoke<Any>(0xB24394CA); } // unused
	static void SET_PED_FLEE_ATTRIBUTES(Ped ped, int attributes, BOOL enabled) { invoke<Void>(0xA717A875, ped, attributes, enabled); } // unused
	static void SET_PED_LOD_THRESHOLD(Ped ped, float threshold) { invoke<Void>(0xEB6AC9D5, ped, threshold); } // unused
	static void SET_PED_SUPERLOD_THRESHOLD(Ped ped, float threshold) { invoke<Void>(0x666EC267, ped, threshold); }
	static Any START_RECORDING_PED() { return invoke<Any>(0x7AE7B65B); } // unused
	static Any STOP_RECORDING_PEDS() { return invoke<Any>(0x0DFEB5BF); } // unused
	static void START_PLAYBACK_RECORDED_PED(Ped ped, int recordingIndex) { invoke<Void>(0x436563F4, ped, recordingIndex); } // unused
	static void STOP_PLAYBACK_RECORDED_PED(Ped ped) { invoke<Void>(0xD7358C69, ped); } // unused
	static void PAUSE_PLAYBACK_RECORDED_PED(Ped ped) { invoke<Void>(0x44240A58, ped); } // unused
	static void UNPAUSE_PLAYBACK_RECORDED_PED(Ped ped) { invoke<Void>(0x57988394, ped); } // unused
	static BOOL IS_PLAYBACK_GOING_ON_FOR_PED(Ped ped) { return invoke<BOOL>(0xEAD70A7A, ped); } // unused
	static int GET_CURRENT_PLAYBACK_NUMBER_FOR_PED(Ped ped) { return invoke<int>(0x2BAA832F, ped); } // unused
	static BOOL IS_RECORDING_GOING_ON_FOR_PED(Ped ped) { return invoke<BOOL>(0x520CCC09, ped); } // unused
	static void SKIP_TIME_IN_PLAYBACK_RECORDED_PED(Ped ped, float time) { invoke<Void>(0x699F9D74, ped, time); } // unused
	static void REQUEST_PED_RECORDING(int recordingIndex) { invoke<Void>(0x3974EC21, recordingIndex); } // unused
	static BOOL HAS_PED_RECORDING_BEEN_LOADED(int recordingIndex) { return invoke<BOOL>(0xAE24DA83, recordingIndex); } // unused
	static void REMOVE_PED_RECORDING(int recordingIndex) { invoke<Void>(0x3BBFFA45, recordingIndex); } // unused
	static void SET_PED_RECORDING_PLAYBACK_SPEED(Ped ped, float speed) { invoke<Void>(0x74C0A42E, ped, speed); } // unused
	static Any STOP_RECORDING_PED() { return invoke<Any>(0xEA90369A); } // unused
	static float GET_POSITION_IN_PED_RECORDING(Ped ped) { return invoke<float>(0xC722356B, ped); } // unused
	static float GET_TIME_POSITION_IN_PED_RECORDING(Ped ped) { return invoke<float>(0x42BD5D0F, ped); } // unused
	static void SET_PED_STEERS_AROUND_PEDS(Ped ped, BOOL toggle) { invoke<Void>(0x797CAE4F, ped, toggle); } // unused
	static BOOL GET_PED_STEERS_AROUND_PEDS(Ped ped) { return invoke<BOOL>(0x3FEB6AB3, ped); } // unused
	static void SET_PED_STEERS_AROUND_OBJECTS(Ped ped, BOOL toggle) { invoke<Void>(0x3BD9B0A6, ped, toggle); } // unused
	static BOOL GET_PED_STEERS_AROUND_OBJECTS(Ped ped) { return invoke<BOOL>(0xE4E47CBF, ped); } // unused
	static void GAMEPLAY_HELPER_BOX_CREATE_PED_ATTACHED(int p0, char* name, Ped ped, float p3, float p4, float p5, float p6, float p7, float p8, float p9, float p10, float p11, BOOL p12, BOOL p13) { invoke<Void>(0x33AAB546, p0, name, ped, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13); }
	static void GAMEPLAY_HELPER_CYLINDER_CREATE_PED_ATTACHED(int p0, char* name, Ped ped, float p3, float p4, float p5, float p6) { invoke<Void>(0xF60A8C33, p0, name, ped, p3, p4, p5, p6); } // unused
	static void SET_PED_TETHERING_ADD_BOX(Ped ped, char* name) { invoke<Void>(0x0E697ED0, ped, name); }
	static void SET_PED_TETHERING_REMOVE_BOX(Ped ped, char* name) { invoke<Void>(0x13DAB679, ped, name); }
	static void RESET_PED_TETHERING(Ped ped) { invoke<Void>(0x37E095B5, ped); }
	static void SET_PED_TETHERING_OPTION(Ped ped, int option) { invoke<Void>(0x2FE1B82A, ped, option); }
	static void SET_PED_FLEEZONE_ADD_BOX(Ped ped, char* name) { invoke<Void>(0xDAC64BE1, ped, name); }
	static void SET_PED_FLEEZONE_REMOVE_BOX(Ped ped, char* name) { invoke<Void>(0x17ED932A, ped, name); } // unused
	static void RESET_PED_FLEEZONE(Ped ped) { invoke<Void>(0xAE3D290C, ped); } // unused
	static void SET_PED_FLEEZONE_OPTION(Ped ped, int option) { invoke<Void>(0x3C2DBC49, ped, option); }
	static void SET_PED_SUGGESTED_COMBAT_AREA_ADD_BOX(Ped ped, char* name) { invoke<Void>(0x4A92C506, ped, name); }
	static void SET_PED_SUGGESTED_COMBAT_AREA_REMOVE_BOX(Ped ped, char* name) { invoke<Void>(0xF2C00944, ped, name); }
	static void RESET_PED_SUGGESTED_COMBAT_AREA(Ped ped) { invoke<Void>(0xBF29DB3C, ped); }
	static BOOL IS_PED_IN_GAMEPLAY_HELPER_BOX(Ped ped, char* name) { return invoke<BOOL>(0xEEC61845, ped, name); }
	static BOOL IS_PED_IN_GAMEPLAY_HELPER_VOLUME(Ped ped, char* name) { return invoke<BOOL>(0xF6AC4889, ped, name); }
	static void SET_PED_SUGGESTED_COMBAT_AREA_STEP(Ped ped, float value) { invoke<Void>(0xD4781ED2, ped, value); } // unused
	static void SET_GLOBAL_SUGGESTED_COMBAT_AREA_WEIGHT(float value) { invoke<Void>(0x84ED684E, value); } // unused
	static BOOL IS_PED_CLONED_EVERYWHERE(Ped ped) { return invoke<BOOL>(0xEBA43DE8, ped); } // unused
	static BOOL PED_HACK_DISABLE_INAIR_EVENT(Ped ped, BOOL toggle) { return invoke<BOOL>(0x7400CF35, ped, toggle); } // unused
	static BOOL ACTION_TREE_LOAD(char* name) { return invoke<BOOL>(0x8520911A, name); }
	static BOOL IS_ACTION_TREE_LOADED(char* name) { return invoke<BOOL>(0x79A8621E, name); }
	static BOOL PED_ACTION_TREE_PLAY_NODE(Ped ped, char* name) { return invoke<BOOL>(0x95DEDF47, ped, name); }
	static void PED_ACTION_TREE_RESET_HELPER(Ped ped) { invoke<Void>(0xA46CEFD8, ped); }
	static BOOL ACTION_TREE_UNLOAD(char* name) { return invoke<BOOL>(0x620BE3A3, name); }
	static BOOL ACTION_TREE_FORCE_UNLOAD(char* name) { return invoke<BOOL>(0xD99BD3AF, name); }
	static void PED_RESET_IK(Ped ped) { invoke<Void>(0xA42336C0, ped); }
	static BOOL GET_PED_AWARENESS_STATE(Ped ped, Ped targetPed, int p2) { return invoke<BOOL>(0x40877917, ped, targetPed, p2); }
	static BOOL GET_PED_HAS_SEEN_DEAD_PED(Ped ped, BOOL p1, Ped* ped2) { return invoke<BOOL>(0xD05D0C57, ped, p1, ped2); } // unused
	static float GET_PED_TOXICITY_LEVEL(Ped ped) { return invoke<float>(0xD9809ECA, ped); }
	static void SET_TOXICITY_LEVEL_TIME(float p0, float p1, float p2) { invoke<Void>(0x0AA9761E, p0, p1, p2); } // unused
	static BOOL GET_PED_REACHED_TARGETED_GRAVWELL_CENTER(Ped ped, char* p1, char* p2, BOOL p3) { return invoke<BOOL>(0xA897DA4F, ped, p1, p2, p3); }
	static void ENABLE_PED_JUMPING(Ped ped, BOOL toggle) { invoke<Void>(0x2B499736, ped, toggle); }
	static int GET_TIME_SINCE_REMOTE_PED_MOVED(Ped ped) { return invoke<int>(0xA06F9B6C, ped); }
	static void REACT_TO_COLLISION(Ped ped, float p1, float p2, float p3) { invoke<Void>(0x17F1AAF6, ped, p1, p2, p3); } // unused
	static void PED_SET_ACTION_INTENTION(Ped ped, int actionId, int duration, float p3, float p4, float p5) { invoke<Void>(0x6C7E6B6A, ped, actionId, duration, p3, p4, p5); }
	static int PED_GET_ACTION_INTENTION_STATUS(Ped ped, int actionId) { return invoke<int>(0x400A3649, ped, actionId); }
	static void PED_FINISH_ACTION_INTENTION(Ped ped, int p1) { invoke<Void>(0x11128D62, ped, p1); }
	static void PED_SET_ACTION_DIRECTION(Ped ped, float xDir, float yDir, float zDir) { invoke<Void>(0xC04CEC0C, ped, xDir, yDir, zDir); }
	static void PED_SET_STRING_INPUT_SIGNAL(Ped ped, char* inputSignal) { invoke<Void>(0x216656A0, ped, inputSignal); } // unused
	static void SET_PED_PANIC_RANGE_OVERRIDE(Ped ped, float range) { invoke<Void>(0xB83B634D, ped, range); }
	static void OVERRIDE_MOVER_PHYSICS_ON_RAGDOLL_SLEEP(Ped ped, BOOL toggle) { invoke<Void>(0xE396361C, ped, toggle); }
	static void SET_PED_AI_TEMPLATE(Ped ped, char* name) { invoke<Void>(0x740A036E, ped, name); }
	static void SET_PED_DEFAULT_AIM_AT_PED(Ped ped, Ped targetPed) { invoke<Void>(0x32BF7F45, ped, targetPed); }
	static void SET_PED_DEFAULT_AIM_AT_COORD(Ped ped, float x, float y, float z) { invoke<Void>(0x313066FE, ped, x, y, z); }
	static void SET_PED_DEFAULT_AIM_AHEAD(Ped ped) { invoke<Void>(0x068A4CCB, ped); }
	static void CLEAR_PED_DEFAULT_AIM(Ped ped) { invoke<Void>(0xC7E6D674, ped); }
	static void SET_PED_CORPSE(Ped ped, BOOL unk) { invoke<Void>(0x804AC45F, ped, unk); }
	static void SET_PED_CORPSE_FROM_ANIM(Ped ped, char* dictName, char* animName, float p3, BOOL p4) { invoke<Void>(0x73405D87, ped, dictName, animName, p3, p4); }
	static void SET_PED_USES_ANIMATED_DEATH(Ped ped, BOOL toggle) { invoke<Void>(0x7F575B71, ped, toggle); }
	static void SET_PED_CHANCE_TO_SHOOT_AT_DESTRUCTIBLES(Ped ped, int chance) { invoke<Void>(0x4E22797C, ped, chance); }
	static void SET_PED_CHANCE_TO_REACT_TO_IMMINENT_DANGER(Ped ped, int chance) { invoke<Void>(0x75959444, ped, chance); }
	static void REMOVE_LOCAL_PLAYER_ARMOUR_AND_SPECIAL_ITEMS() { invoke<Void>(0x6919A93C); }
	static int GET_PED_BULLETTIME_STATUS(Ped ped) { return invoke<int>(0xD2B258C4, ped); } // unused
	static void SET_PED_SYNC_POINT(Ped ped, float x, float y, float z, float heading) { invoke<Void>(0x495AD422, ped, x, y, z, heading); }
	static BOOL HAS_PED_TRIGGERED_MPM(Ped ped) { return invoke<BOOL>(0x78314008, ped); } // unused
	static void SET_COLLISION_BETWEEN_PEDS(Ped ped, BOOL toggle) { invoke<Void>(0x2279CFD3, ped, toggle); }
	static void SET_NO_COLLISION_TO_PED(Ped ped, Ped ped2, BOOL p2, BOOL p3) { invoke<Void>(0x16D410E1, ped, ped2, p2, p3); }
	static void SET_PED_SILHOUETTE_ENABLED(Ped ped, BOOL toggle) { invoke<Void>(0x56FB3FFD, ped, toggle); }
	static void SET_PED_SILHOUETTE_WHENVISIBLE_ENABLED(Ped ped, BOOL toggle) { invoke<Void>(0x3429857E, ped, toggle); }
	static void SET_PED_SILHOUETTE_COLOUR(Ped ped, int color) { invoke<Void>(0x97F0EE26, ped, color); }
	static void SET_TIMEWARP_FIRE_SCALE(Ped ped, float scale) { invoke<Void>(0x68883C5E, ped, scale); } // unused
	static void SET_PED_FLAG_COMBAT_LEADER(Ped ped, BOOL toggle) { invoke<Void>(0x757654BD, ped, toggle); }
	static void SET_PED_FLAG_AGGRESSIVE_CHARGER(Ped ped, BOOL toggle) { invoke<Void>(0xAA129637, ped, toggle); }
	static void SET_PED_FLAG_SNIPE_MOVING_TARGETS_OVERRIDE(Ped ped, BOOL toggle) { invoke<Void>(0xB1880102, ped, toggle); }
	static void SET_PED_FLAG_LOCK_TO_COVER(Ped ped, BOOL toggle) { invoke<Void>(0xB845B91D, ped, toggle); }
	static void SET_PED_FLAG_ALWAYS_HIDE_WHEN_IN_COVER(Ped ped, BOOL toggle) { invoke<Void>(0x76529381, ped, toggle); }
	static void SET_PED_FLAG_FORCE_BLINDFIRE_IN_COVER(Ped ped, BOOL toggle) { invoke<Void>(0x28E044EB, ped, toggle); }
	static void SET_PED_FLAG_FORCE_LEANFIRE_IN_COVER(Ped ped, BOOL toggle) { invoke<Void>(0x25866265, ped, toggle); }
	static void SET_PED_FLAG_FORCE_THROW_PROJECTILE_IN_COVER(Ped ped, BOOL toggle) { invoke<Void>(0x70F9E56C, ped, toggle); }
	static void SET_PED_FLAG_FIRE_UNTIL_EMPTY_IN_COVER(Ped ped, BOOL toggle) { invoke<Void>(0x852834FB, ped, toggle); }
	static void SET_PED_FLAG_BLOCK_GORE_REACTION(Ped ped, BOOL toggle) { invoke<Void>(0x3D64E5F1, ped, toggle); }
	static void SET_PED_FLAG_BLOCK_WOUNDED_MOVEMENT(Ped ped, BOOL toggle) { invoke<Void>(0xCE23372D, ped, toggle); }
	static void SET_PED_FLAG_BLOCK_BLINDFIRE_IN_COVER(Ped ped, BOOL toggle) { invoke<Void>(0xE80E66BF, ped, toggle); }
	static void SET_PED_FLAG_BLOCK_LEANFIRE_IN_COVER(Ped ped, BOOL toggle) { invoke<Void>(0x1335ACA9, ped, toggle); }
	static void SET_PED_FLAG_SCRIPTED_PROJECTILE_USE(Ped ped, BOOL toggle) { invoke<Void>(0x5D1A0A76, ped, toggle); }
	static void SET_PED_AIM_LOCKONABLE(Ped ped, BOOL toggle) { invoke<Void>(0xF68161DB, ped, toggle); }
	static BOOL IS_PED_IN_CROSSHAIR_CYLINDER(Ped ped, float p1, float p2, BOOL p3, float p4) { return invoke<BOOL>(0xC98A0FFA, ped, p1, p2, p3, p4); }
	static BOOL IS_PED_IN_CROSSHAIR_CYLINDER_OFFSET(Ped ped, float p1, float p2, float p3, float p4, float p5, float p6, BOOL p7) { return invoke<BOOL>(0xCA2F07C7, ped, p1, p2, p3, p4, p5, p6, p7); }
	static void TRIGGER_PED_PORTAL_RESCAN(Ped ped, float p1) { invoke<Void>(0xE1531B10, ped, p1); } // unused
	static void SET_PED_CAN_MELEE(Ped ped, BOOL toggle) { invoke<Void>(0xF4B9253B, ped, toggle); }
	static void SET_PED_CAN_BE_MELEED(Ped ped, BOOL toggle) { invoke<Void>(0x48AF2BA0, ped, toggle); }
	static void SET_PED_WEAPON_BLOCK_CHECK(Ped ped, BOOL toggle) { invoke<Void>(0x06519D09, ped, toggle); } // unused
	static BOOL IS_PED_USING_MP3_COVER_TASK(Ped ped) { return invoke<BOOL>(0x3ACBC86C, ped); }
	static BOOL IS_PED_PEEKING_IN_COVER(Ped ped) { return invoke<BOOL>(0xA612B87E, ped); } // unused
	static BOOL IS_PED_BLINDFIRING_IN_COVER(Ped ped) { return invoke<BOOL>(0x12A8D4BA, ped); } // unused
	static BOOL IS_TARGET_IN_VALID_COVER_FROM_PED(Ped ped, Ped ped2) { return invoke<BOOL>(0x7DFDA8DA, ped, ped2); }
	static void SET_PED_NUM_ADVANCERS_OVERRIDE(Any p0, Any p1) { invoke<Void>(0xB194E66C, p0, p1); }
	static Any SET_PED_ADVANCE_DELAY_OVERRIDE() { return invoke<Any>(0xE8B068A7); } // unused
	static void SET_PED_NUM_CHARGERS_OVERRIDE(Any p0, Any p1) { invoke<Void>(0x1A7D00D1, p0, p1); }
	static Any SET_PED_CHARGE_DELAY_OVERRIDE() { return invoke<Any>(0x3B2E3E6B); } // unused
	static void SET_PED_MELEE_TRIGGER_DIST_OVERRIDE(Any p0, Any p1) { invoke<Void>(0xA7222120, p0, p1); }
	static void SET_PED_FORCE_START_FIRING_FROM_COVER(Any p0) { invoke<Void>(0xF8064C9C, p0); }
	static void SET_PED_FORCE_STOP_FIRING_FROM_COVER(Any p0) { invoke<Void>(0x26B05910, p0); }
	static void SET_PED_START_SUPPRESSIVE_FIRE(Ped ped, float p1, float p2, float p3, float p4) { invoke<Void>(0xE96A849D, ped, p1, p2, p3, p4); } // unused
	static void SET_PED_STOP_SUPPRESSIVE_FIRE(Ped ped) { invoke<Void>(0x601F77B7, ped); } // unused
	static void SET_PED_COVER_REQUEST_PEEK(Ped ped) { invoke<Void>(0xD00F7A1A, ped); } // unused
	static void SET_PED_COVER_REQUEST_BLINDFIRE(Ped ped) { invoke<Void>(0x9FF457F8, ped); } // unused
	static void SET_PED_COVER_TARGET_PED(Ped ped, Ped targetPed) { invoke<Void>(0x895736EF, ped, targetPed); }
	static void SET_PED_COVER_TARGET_COORD(Ped ped, float x, float y, float z) { invoke<Void>(0xA4AEF03C, ped, x, y, z); }
	static Any SET_PED_COVER_TARGET_PED_WITH_OFFSET() { return invoke<Any>(0x094B495D); } // unused
	static void SET_PED_COVER_TARGET_VEHICLE(Any p0, Any p1, Any p2, Any p3, Any p4, Any p5) { invoke<Void>(0xBA0BDD53, p0, p1, p2, p3, p4, p5); }
	static Any SET_PED_COVER_TARGET_PED_WITH_BONE_AND_OFFSET() { return invoke<Any>(0x3A6625BB); } // unused
	static void SET_PED_CLEAR_COVER_TARGET(Ped ped) { invoke<Void>(0xAE78C3AE, ped); }
	static void SET_PED_SUGGESTED_COVER_POINT(Any p0, Any p1, Any p2) { invoke<Void>(0x198A63E4, p0, p1, p2); }
	static BOOL IS_PED_HIDING_IN_COVER(Ped ped) { return invoke<BOOL>(0x931B95B5, ped); } // unused
	static void SET_PED_STAND_GROUND_ON_PLAYER_IMPACT(Any p0, Any p1) { invoke<Void>(0x9660FB67, p0, p1); }
	static void SET_PED_REACT_TO_CAR_COLLISION(Any p0, Any p1) { invoke<Void>(0x6B4C2CC6, p0, p1); }
	static Any SET_PED_FORCE_USE_MUZZLE_DIRECTION() { return invoke<Any>(0x3D6DECE5); } // unused
	static void SET_PED_AS_ONE_SHOT_KILL(Ped ped, BOOL toggle) { invoke<Void>(0x46ED955A, ped, toggle); }
	static void TEMPORARILY_DISABLE_PED_SELF_COLLISION(Ped ped, int duration) { invoke<Void>(0x212533EF, ped, duration); }
	static void SET_PED_CAN_AVOID_DEATH_ZONES(Ped ped, BOOL toggle) { invoke<Void>(0x712B78D8, ped, toggle); }
	static void SET_AI_SHOULD_ALWAYS_MISS_PED(Ped ped, BOOL toggle) { invoke<Void>(0x9B7A250B, ped, toggle); }
	static void OVERRIDE_PED_FIRING_PATTERN(Ped ped, Hash firingPatternHash) { invoke<Void>(0xC7DD4AA6, ped, firingPatternHash); }
	static void STOP_OVERRIDING_PED_FIRING_PATTERN(Ped ped) { invoke<Void>(0x954F6D21, ped); }
	static void OVERRIDE_PED_FIRING_PATTERN_CUSTOM(Ped ped, BOOL toggle) { invoke<Void>(0xD622F7DE, ped, toggle); }
	static void SET_PED_CUSTOM_FIRING_PATTERN_TIME_BETWEEN_BURSTS(Ped ped, float p1, float p2) { invoke<Void>(0x8572A5F9, ped, p1, p2); }
	static void SET_PED_CUSTOM_FIRING_PATTERN_TIME_BETWEEN_SHOTS(Ped ped, float p1, float p2) { invoke<Void>(0x86B5FF2B, ped, p1, p2); } // unused
	static void SET_PED_CUSTOM_FIRING_PATTERN_SHOTS_PER_BURST(Ped ped, int p1, int p2) { invoke<Void>(0x91ACB728, ped, p1, p2); }
	static void SET_PED_CAN_PUSH_PLAYER(Ped ped, BOOL toggle) { invoke<Void>(0xCEEB20E6, ped, toggle); }
	static void SET_PED_FORCED_TO_WALK(Ped ped, BOOL toggle) { invoke<Void>(0xA3D46847, ped, toggle); }
	static BOOL GET_IS_PED_FORCED_TO_WALK(Ped ped) { return invoke<BOOL>(0xB947D1CE, ped); }
	static void SET_PED_FORCED_TO_RUN(Ped ped, BOOL toggle) { invoke<Void>(0xDA7588A3, ped, toggle); }
	static BOOL GET_IS_PED_FORCED_TO_RUN(Ped ped) { return invoke<BOOL>(0x8E3AA72A, ped); } // unused
	static void SET_PED_CAN_PLAY_LOCO_FLAVOR_STARTS(Ped ped, BOOL toggle) { invoke<Void>(0xAA96A1D3, ped, toggle); }
	static BOOL GET_CAN_PED_PLAY_LOCO_FLAVOR_STARTS(Ped ped) { return invoke<BOOL>(0xD8BE7688, ped); } // unused
	static void SET_PED_CAN_SLOW_DOWN_WHEN_TURNING(Ped ped, BOOL toggle) { invoke<Void>(0xC7628C42, ped, toggle); }
	static BOOL GET_CAN_PED_CAN_SLOW_DOWN_WHEN_TURNING(Ped ped) { return invoke<BOOL>(0x45E894EA, ped); } // unused
	static void SET_PED_NO_RAGDOLL_TO_EXPLOSION_UNLESS_DEAD(Ped ped, BOOL toggle) { invoke<Void>(0x49CCB497, ped, toggle); }
	static BOOL GET_ALLOWED_TO_FAIL_COVER_FOR_BLOCKING_LINE_OF_FIRE() { return invoke<BOOL>(0xCB1E7ADE); } // unused
	static void SET_ALLOWED_TO_FAIL_COVER_FOR_BLOCKING_LINE_OF_FIRE(BOOL toggle) { invoke<Void>(0x0D35CCB6, toggle); }
	static Ped GET_PEDS_LAST_ATTACKER(Ped ped) { return invoke<Ped>(0x0B82351F, ped); } // unused
	static BOOL IS_PED_VAULTING(Ped ped) { return invoke<BOOL>(0xC3169BDA, ped); }
	static void SET_PED_RESIST_TO_OBJECT_COLLISION(Ped ped, BOOL toggle) { invoke<Void>(0x2720C246, ped, toggle); }
	static void SET_CAN_AI_KICK_THROUGH_CORPSES(Ped ped, BOOL toggle) { invoke<Void>(0xB17BD0FF, ped, toggle); }
	static void SET_USE_ANIMATED_VELOCITY(Ped ped, BOOL toggle) { invoke<Void>(0x92FE3DB8, ped, toggle); }
	static void SET_CUFF_HANDS(Ped ped, BOOL toggle) { invoke<Void>(0xF5B13A88, ped, toggle); }
	static void SET_APPLY_WATER_PHYSICS_TO_RAGDOLL(Ped ped, BOOL toggle) { invoke<Void>(0xE0394FC2, ped, toggle); }
	static void SET_PED_FREEZE_ORIENTATION(Ped ped, BOOL toggle) { invoke<Void>(0x72F54163, ped, toggle); }
	static void SET_DEAD_FORCE_WATER_DEPTH(float depth) { invoke<Void>(0x4FBA6300, depth); }
	static void SET_DEAD_FORCE_WATER_DEPTH_TO_DEFAULT() { invoke<Void>(0x1333A7F3); }
	static BOOL IS_PED_BEING_GRAPPLED(Ped ped) { return invoke<BOOL>(0x67C09EDB, ped); } // unused
	static void SET_PED_FREEZE_PROCESSING(Ped ped, BOOL toggle) { invoke<Void>(0x390BF58B, ped, toggle); }
	static BOOL IS_PED_PROCESSING_FROZEN(Ped ped) { return invoke<BOOL>(0xE1203F37, ped); }
	static void SET_PED_FORCE_USE_RAGDOLL(Ped ped, BOOL p1, BOOL p2) { invoke<Void>(0x9960303A, ped, p1, p2); }
	static void RELOAD_PED_WEAPONS(Ped ped) { invoke<Void>(0x9E1C4C76, ped); }
	static void SET_PED_NO_RAGDOLL_TO_BULLET_UNLESS_DEAD(Ped ped, BOOL toggle) { invoke<Void>(0xCEEE9EFE, ped, toggle); }
	static void SET_PED_REDUCED_DAMAGE_IK(Ped ped, BOOL toggle) { invoke<Void>(0x23754843, ped, toggle); }
	static void SET_PED_CAN_PUT_PLAYER_INTO_LMS(Ped ped, BOOL toggle) { invoke<Void>(0x6B2B3B17, ped, toggle); }
	static void SET_PED_GIVE_POST_LMS_BREAK(Ped ped, BOOL toggle) { invoke<Void>(0x2C7E761A, ped, toggle); }
	static void SET_FOOT_STEP_AUDIO_MOVEMENT(Ped ped, BOOL toggle) { invoke<Void>(0x1911F7DF, ped, toggle); }
	static void SET_PED_MODEL_LOD_DISTANCES(Hash modelHash, float min, float max) { invoke<Void>(0x33659A97, modelHash, min, max); }
	static void RESET_PED_MODEL_LOD_DISTANCES(Hash modelHash) { invoke<Void>(0xDB778444, modelHash); }
	static void REGISTER_PED_SHOT_TUNING_SPECIAL01(Ped ped) { invoke<Void>(0xCCC01196, ped); }
	static void SET_PED_BLEND_TO_CROUCHING_FROM_NM(Ped ped, BOOL toggle) { invoke<Void>(0xB16475C3, ped, toggle); } // unused
	static BOOL RESET_LEVEL_ANIM_DICTIONARIES() { return invoke<BOOL>(0xC76D45D7); } // unused
	static void FORCE_PED_TO_USE_DEATH_SUGGESTION_WHEN_SHOT(Ped ped, BOOL p1, BOOL p2, BOOL p3, BOOL p4, BOOL p5) { invoke<Void>(0x290EC656, ped, p1, p2, p3, p4, p5); }
	static Any ADD_PED_IGNORE_COVER_ENTRY() { return invoke<Any>(0x89C1F145); } // unused
	static Any REMOVE_PED_IGNORE_COVER_ENTRY() { return invoke<Any>(0xC5D2232C); } // unused
	static void ADD_PED_USE_COVER_ENTRY(Any p0, Any p1) { invoke<Void>(0x71F647CC, p0, p1); }
	static Any REMOVE_PED_USE_COVER_ENTRY() { return invoke<Any>(0xADE53B26); } // unused
	static void SET_PED_ONLY_COLLIDE_WITH_RAGDOLL_BOUNDS(Ped ped, BOOL toggle) { invoke<Void>(0x2B87EED7, ped, toggle); }
	static void APPLY_UNIFORMLY_DISTRIBUTED_IMPULSE_TO_RAGDOLL(Ped ped, float xOffset, float yOffset, float zOffset) { invoke<Void>(0x5B121A4C, ped, xOffset, yOffset, zOffset); }
	static void SET_PED_BOSS_PECENT_DAMAGED(Ped ped, BOOL toggle) { invoke<Void>(0x90C7954A, ped, toggle); }
	static void SET_BOSS_PECENT_DAMAGE(float percentage) { invoke<Void>(0xC95210CF, percentage); }
	static void SET_PED_CAN_BE_SNAPPED_TO_GROUND(Ped ped, BOOL toggle) { invoke<Void>(0xBE7D2E94, ped, toggle); }
	static void SET_PED_BLOODSPRAY_ENABLE(Ped ped, BOOL toggle) { invoke<Void>(0xAD56E6F2, ped, toggle); }
	static void SET_PED_WEAPON_OBSTRUCTION_CHECK_DISTANCE(Any p0, Any p1) { invoke<Void>(0x6F1AC8DC, p0, p1); }
	static void SET_PED_GLOBAL_PERCENT_DODGE_CHANCE(int chance) { invoke<Void>(0xE4641DD3, chance); } // unused
	static void SET_PED_GLOBAL_KNEELING_ALLOWED(BOOL toggle) { invoke<Void>(0x954A05B9, toggle); } // unused
	static void SET_PED_FIRE_AT_COVER(Ped ped, BOOL toggle) { invoke<Void>(0x29AD93BB, ped, toggle); }
	static void SET_GLOBAL_PHASE_OVERRIDE(float value) { invoke<Void>(0x80E71892, value); }
	static BOOL IS_PED_PICKING_UP_PICKUP(Ped ped) { return invoke<BOOL>(0xC213D3FA, ped); }
	static void PED_FORCE_TARGETABLE(Ped ped, BOOL toggle) { invoke<Void>(0x4A9A29C4, ped, toggle); }
	static void _0x0E70E240(Ped ped, float p1, float p2, int p3) { invoke<Void>(0x0E70E240, ped, p1, p2, p3); } // unused
	static void _0xEC7E68C1(Ped ped) { invoke<Void>(0xEC7E68C1, ped); } // unused
	static BOOL _0x6E0969C7(Ped ped) { return invoke<BOOL>(0x6E0969C7, ped); } // unused
	static int _0xE5CD2418(Ped ped) { return invoke<int>(0xE5CD2418, ped); } // unused
	static void _0xD4622A46(Ped ped, Ped ped2) { invoke<Void>(0xD4622A46, ped); } // unused
	static void _0x46AFF937(Ped ped, BOOL p1) { invoke<Void>(0x46AFF937, ped, p1); } // unused
	static void _0x276362EA(Ped ped, BOOL p1) { invoke<Void>(0x276362EA, ped, p1); } // unused
	static void _0x263F8BFD(Ped ped, BOOL toggle) { invoke<Void>(0x263F8BFD, ped, toggle); }
}

namespace PEDGROUPTASK
{
	static void PEDGROUPTASK_DESTROY(Any p0, Any p1) { invoke<Void>(0x47AEEC8E, p0, p1); }
	static Any PEDGROUPTASK_ADVANCE_CREATE(Any p0) { return invoke<Any>(0x54436897, p0); }
	static void PEDGROUPTASK_ADVANCE_ASSIGNPED(Any p0, Any p1, Any p2) { invoke<Void>(0xC923DB84, p0, p1, p2); }
	static void PEDGROUPTASK_ADVANCE_SETPEDCANADVANCE(Any p0, Any p1, Any p2, Any p3) { invoke<Void>(0x322E3B5D, p0, p1, p2, p3); }
	static void PEDGROUPTASK_ADVANCE_SETTARGET_PED(Any p0, Any p1, Any p2) { invoke<Void>(0xB35F39A7, p0, p1, p2); }
	static void _PEDGROUPTASK_ADVANCE_SETTARGET_PED_2(Any p0, Any p1, Any p2) { invoke<Void>(0xA861186C, p0, p1, p2); }
	static Any PEDGROUPTASK_ADVANCE_SETTARGET_POS() { return invoke<Any>(0x97D7FBD1); } // unused
	static void PEDGROUPTASK_ADVANCE_TRIGGER_MOVE(Any p0, Any p1) { invoke<Void>(0x20F68DB8, p0, p1); }
	static void PEDGROUPTASK_ADVANCE_SETTIMETOHIDE(Any p0, Any p1, Any p2) { invoke<Void>(0x926BAF07, p0, p1, p2); }
	static void PEDGROUPTASK_ADVANCE_SETTIMETOIDLE(Any p0, Any p1, Any p2) { invoke<Void>(0xB8B227D4, p0, p1, p2); }
	static void PEDGROUPTASK_ADVANCE_SETADVANCEDISTANCE(Any p0, Any p1, Any p2) { invoke<Void>(0x6F24894B, p0, p1, p2); }
	static Any PEDGROUPTASK_ADVANCE_SETCOVERSEARCHOFFSETFORWARD() { return invoke<Any>(0x82FE5DEA); } // unused
	static void PEDGROUPTASK_ADVANCE_SETADVANCERELATIVETO(Any p0, Any p1, Any p2) { invoke<Void>(0x7DF6683B, p0, p1, p2); }
	static void PEDGROUPTASK_ADVANCE_SETTIMERANGEFORALLPEDSTOSTARTFIRING(Any p0, Any p1, Any p2) { invoke<Void>(0x4352BEF3, p0, p1, p2); }
	static void PEDGROUPTASK_ADVANCE_SETNUMPEDSTOADVANCE(Any p0, Any p1, Any p2) { invoke<Void>(0x0AC69B43, p0, p1, p2); }
	static Any PEDGROUPTASK_COVERFIRE_CREATE() { return invoke<Any>(0xB12779C8); } // unused
	static Any PEDGROUPTASK_COVERFIRE_ASSIGNPED() { return invoke<Any>(0x9F362EA8); } // unused
	static Any PEDGROUPTASK_COVERFIRE_SETTARGET_PED() { return invoke<Any>(0x131D9EE9); } // unused
	static Any PEDGROUPTASK_COVERFIRE_SETTARGET_POS() { return invoke<Any>(0xBF55758E); } // unused
	static Any PEDGROUPTASK_COVERFIRE_TRIGGER_HIDE() { return invoke<Any>(0xCAC7EFC1); } // unused
	static Any PEDGROUPTASK_COVERFIRE_TRIGGER_FIRE() { return invoke<Any>(0xA546FB73); } // unused
	static Any PEDGROUPTASK_COVERFIRE_STOP_FIRING() { return invoke<Any>(0x935C7975); } // unused
	static Any PEDGROUPTASK_TACTICALCORNER_CREATE(Any p0, Any p1, Any p2) { return invoke<Any>(0x165687CB, p0, p1, p2); }
	static void PEDGROUPTASK_TACTICALCORNER_ASSIGNPED(Any p0, Any p1, Any p2) { invoke<Void>(0x72DF209B, p0, p1, p2); }
	static void PEDGROUPTASK_TACTICALCORNER_SETTARGET_PED(Any p0, Any p1, Any p2) { invoke<Void>(0xBDCD7309, p0, p1, p2); }
	static Any PEDGROUPTASK_TACTICALCORNER_SETTARGET_POS() { return invoke<Any>(0xB54BDB46); } // unused
	static Any PEDGROUPTASK_FLANK_CREATE() { return invoke<Any>(0x8A7938A8); } // unused
	static Any PEDGROUPTASK_FLANK_TRIGGERVOLUME() { return invoke<Any>(0xB5D4C0FE); } // unused
	static Any PEDGROUPTASK_FLANK_FLANKVOLUME() { return invoke<Any>(0x06262EDA); } // unused
	static Any PEDGROUPTASK_FLANK_ASSIGNPEDTOFLANK() { return invoke<Any>(0x8370A7AC); } // unused
	static Any PEDGROUPTASK_FLANK_ASSIGNPEDTOCOVERFIRE() { return invoke<Any>(0xFAD36337); } // unused
	static Any PEDGROUPTASK_FLANK_TUNE_TIMEREADYTRIGGERMOVE() { return invoke<Any>(0x70DCAB00); } // unused
	static Any PEDGROUPTASK_FLANK_TUNE_TIMETARGETINSIDETRIGGERVOLUMETOSTART() { return invoke<Any>(0x4D888CFB); } // unused
	static Any PEDGROUPTASK_FLANK_TUNE_TARGETOUTSIDETRIGGERVOLUMETOCANCEL() { return invoke<Any>(0x0DBFC2F3); } // unused
}

namespace PLAYER
{
	static Any CREATE_PLAYER(Any p0, float x, float y, float z) { return invoke<Any>(0x584BA966, p0, x, y, z); }
	static Any CREATE_PLAYER_WITH_MODEL(Hash modelHash, float x, float y, float z) { return invoke<Any>(0xE043534F, modelHash, x, y, z); }
	static Any CREATE_PLAYER_WITH_AVATAR(Hash avatarHash, float x, float y, float z, BOOL p4) { return invoke<Any>(0x3A072305, avatarHash, x, y, z, p4); }
	static Ped GET_PLAYER_PED(Player player) { return invoke<Ped>(0x6E31E993, player); }
	static void SET_PLAYER_MODEL(Player player, Hash modelHash) { invoke<Void>(0x774A4C54, player, modelHash); } // unused
	static BOOL NETWORK_PLAYER_HAS_PED(Player player) { return invoke<BOOL>(0x1D185E7D, player); } // unused
	static int NETWORK_GET_AVATAR_SLOT_SELECTED_SEX(Hash avatarHash) { return invoke<int>(0x7EF9234A, avatarHash); }
	static int NETWORK_GET_PLAYER_AVATAR_SEX(Player player) { return invoke<int>(0xBD0930B9, player); }
	static Hash NETWORK_GET_PLAYER_AVATAR_SLOT_HASH(Player player) { return invoke<Hash>(0xEEFC5BFB, player); }
	static Hash NETWORK_GET_AVATAR_SELECTED_DEATHMATCH_SLOT_HASH() { return invoke<Hash>(0x51611F4D); }
	static void NETWORK_PRELOAD_AVATAR(Hash avatarHash) { invoke<Void>(0x38209242, avatarHash); }
	static void NETWORK_RELEASE_PRELOADED_AVATAR(Hash avatarHash) { invoke<Void>(0x6B197E0D, avatarHash); } // unused
	static void _0xE0343F94(BOOL toggle) { invoke<Void>(0xE0343F94, toggle); } // unused
	static BOOL NETWORK_IS_AVATAR_PAYNEKILLER_CHARACTER(Hash avatarHash) { invoke<Void>(0x8F49794B, avatarHash); } // unused
	static void GET_PLAYER_RGB_COLOUR(Player player, int* r, int* g, int* b) { invoke<Void>(0x6EF43BBB, player, r, g, b); } // unused
	static void SET_PLAYER_COLOUR(Player player, int color) { invoke<Void>(0x24750296, player, color); }
	static int GET_NUMBER_OF_PLAYERS() { return invoke<int>(0x4C1B8867); }
	static int GET_PLAYER_TEAM(Player player) { return invoke<int>(0x9873E404, player); }
	static void SET_PLAYER_TEAM(Player player, int team) { invoke<Void>(0x725ADCF2, player, team); }
	static int GET_NUMBER_OF_PLAYERS_IN_TEAM(int team) { return invoke<int>(0x06435F71, team); }
	static void GET_PLAYER_NAME(int bufferSize, char* buffer, Player player, BOOL withGangTag) { invoke<Void>(0x406B4B20, bufferSize, buffer, player, withGangTag); }
	static void SET_PLAYER_INFINTE_STAMINA(Player player, BOOL toggle) { invoke<Void>(0x44466C42, player, toggle); }
	static void ADD_PLAYER_SCORE(Player player, int amount) { invoke<Void>(0x692414AA, player, amount); } // unused
	static BOOL IS_PLAYER_SCORE_GREATER(Player player, int score) { return invoke<BOOL>(0xFA624B66, player, score); } // unused
	static int GET_PLAYER_SCORE(Player player) { return invoke<int>(0xA9FF2C40, player); } // unused
	static void SET_PLAYER_WANTED_LEVEL(Player player, int wantedLevel) { invoke<Void>(0xB7A0914B, player, wantedLevel); } // unused
	static void SET_PLAYER_WANTED_LEVEL_NO_DROP(Player player, int wantedLevel) { invoke<Void>(0xED6F44F5, player, wantedLevel); } // unused
	static void SET_PLAYER_WANTED_LEVEL_NOW(Player player) { invoke<Void>(0xAF3AFD83, player); } // unused
	static Any ARE_PLAYER_FLASHING_STARS_ABOUT_TO_DROP() { return invoke<Any>(0xE13A71C7); } // unused
	static Any ARE_PLAYER_STARS_GREYED_OUT() { return invoke<Any>(0x5E72AB72); } // unused
	static Any SET_DISPATCH_COPS_FOR_PLAYER() { return invoke<Any>(0x48A18913); } // unused
	static Any IS_PLAYER_WANTED_LEVEL_GREATER() { return invoke<Any>(0x589A2661); } // unused
	static void CLEAR_PLAYER_WANTED_LEVEL(Player player) { invoke<Void>(0x54EA5BCC, player); } // unused
	static BOOL IS_PLAYER_DEAD(Player player) { return invoke<BOOL>(0x140CA5A8, player); }
	static BOOL IS_PLAYER_PRESSING_HORN(Player player) { return invoke<BOOL>(0xED1D1662, player); } // unused
	static void SET_PLAYER_CONTROL(Player player, BOOL toggle, int flags) { invoke<Void>(0xD17AFCD8, player, toggle, flags); }
	static void SET_PLAYER_CONTROL_FOR_NETWORK(Player player, BOOL toggle, BOOL p2) { invoke<Void>(0x04E33A0A, player, toggle, p2); }
	static void REENABLE_PLAYER_INPUT(int index) { invoke<Void>(0x69A8E8A7, index); }
	static int GET_PLAYER_WANTED_LEVEL(Player player) { return invoke<int>(0xBDCDD163, player); } // unused
	static void SET_MAX_WANTED_LEVEL(int wantedLevel) { invoke<Void>(0x665A06F5, wantedLevel); } // unused
	static void SET_POLICE_RADAR_BLIPS(BOOL toggle) { invoke<Void>(0x8E114B10, toggle); } // unused
	static void SET_POLICE_IGNORE_PLAYER(BOOL toggle) { invoke<Void>(0xE6DE71B7, toggle); } // unused
	static BOOL IS_PLAYER_PLAYING(Player player) { return invoke<BOOL>(0xE15D777F, player); }
	static void SET_EVERYONE_IGNORE_PLAYER(Player player, BOOL toggle) { invoke<Void>(0xC915285E, player, toggle); } // unused
	static void SET_ALL_RANDOM_PEDS_FLEE(Player player, BOOL toggle) { invoke<Void>(0x49EAE968, player, toggle); } // unused
	static void SET_IGNORE_LOW_PRIORITY_SHOCKING_EVENTS(Player player, BOOL toggle) { invoke<Void>(0xA3D675ED); } // unused
	static void SET_WANTED_LEVEL_MULTIPLIER(float multiplier) { invoke<Void>(0x1359292F, multiplier); } // unused
	static void START_FIRING_AMNESTY() { invoke<Void>(0x5F8A22A6); } // unused
	static BOOL CAN_PLAYER_START_MISSION(Player player) { return invoke<BOOL>(0x39E3CB3F, player); } // unused
	static void SET_PLAYER_SAFE_FOR_CUTSCENE(Player player) { invoke<Void>(0x7EBFBB34, player); } // unused
	static BOOL IS_PLAYER_READY_FOR_CUTSCENE(Player player) { return invoke<BOOL>(0xBB77E9CD, player); } // unused
	static BOOL IS_PLAYER_TARGETTING_PED(Player player, Ped ped) { return invoke<BOOL>(0xDBE470DD, player, ped); } // unused
	static BOOL IS_PLAYER_FREE_AIMING_AT_PED(Player player, Ped ped) { return invoke<BOOL>(0x571529AE, player, ped); }
	static BOOL IS_PLAYER_PED_FREE_AIMING_AT_PED(Ped playerPed, Ped ped) { return invoke<BOOL>(0x8E8B926C, playerPed, ped); }
	static BOOL IS_PLAYER_TARGETTING_OBJECT(Player player, Object object) { return invoke<BOOL>(0x622796D5, player, object); } // unused
	static void SET_PLAYER_CAN_DO_DRIVE_BY(Player player, Object object) { invoke<Void>(0xF4D99685, player, object); } // unused
	static void SET_PLAYER_CAN_BE_HASSLED_BY_GANGS(Player player, Object object) { invoke<Void>(0x71B305BB, player, object); } // unused
	static void SET_PLAYER_CAN_USE_COVER(Player player, BOOL toggle) { invoke<Void>(0x13CAFAFA, player, toggle); }
	static void SET_PLAYER_USING_COVER(Player player, BOOL toggle) { invoke<Void>(0x67A896B3, player, toggle); }
	static Any SNAP_PLAYER_TO_COVER_COORDS(Any p0, Any p1, Any p2, Any p3, Any p4, Any p5) { return invoke<Any>(0xEC2D5CFB, p0, p1, p2, p3, p4, p5); }
	static Any SNAP_PLAYER_TO_COVERPOINT(Any p0, Any p1, Any p2, Any p3) { return invoke<Any>(0x464B1DB1, p0, p1, p2, p3); }
	static Any SNAP_PLAYER_TO_COVERLINE(Any p0, Any p1, Any p2, Any p3, Any p4, Any p5, Any p6) { return invoke<Any>(0x5A54CE7D, p0, p1, p2, p3, p4, p5, p6); }
	static Any PLAYER_USE_COVERPOINT(Any p0, Any p1, Any p2, Any p3) { return invoke<Any>(0x822F99DE, p0, p1, p2, p3); }
	static Any PLAYER_USE_COVERLINE() { return invoke<Any>(0x004C99D6); } // unused
	static void SET_PLAYER_LOCKED_IN_COVER(Player player, BOOL toggle) { invoke<Void>(0xAFD8C788, player, toggle); }
	static BOOL IS_PLAYER_LOCKED_IN_COVER(Player player) { return invoke<BOOL>(0x78A1970D, player); } // unused
	static BOOL IS_LOCAL_PLAYER_STILL_SCANNING_WORLD() { return invoke<BOOL>(0x6AADAD69); }
	static void SET_PLAYER_CAN_USE_SHOOTDODGE(Player player, BOOL toggle) { invoke<Void>(0x880FAED5, player, toggle); }
	static void SET_LOCAL_PLAYER_CAN_USE_SHOOTDODGE(BOOL toggle) { invoke<Void>(0xC6BB1780, toggle); }
	static int GET_MAX_WANTED_LEVEL() { return invoke<int>(0x457F1E44); } // unused
	static BOOL IS_PLAYER_TARGETTING_ANYTHING(Player player) { return invoke<BOOL>(0x456DB50D, player); } // unused
	static int GET_LOCAL_PLAYER_AGILITY() { return invoke<int>(0xDE0266E7); }
	static BOOL IS_LOCAL_PLAYER_SPRINTING() { return invoke<BOOL>(0x4D6AC4DF); }
	static BOOL GET_LOCAL_PLAYER_SPRINT_METER(float* outValue) { return invoke<BOOL>(0x50A43014, outValue); }
	static void SET_PLAYER_SPRINT(Player player, BOOL toggle) { invoke<Void>(0x7DD7900C, player, toggle); }
	static void SET_PLAYER_SPRINT_SP(Player player, BOOL toggle) { invoke<Void>(0x92282FE2, player, toggle); } // unused
	static void SET_PLAYER_PLAYER_TARGETTING(BOOL toggle) { invoke<Void>(0xF12A7F7D, toggle); } // unused
	static Group GET_PLAYER_GROUP(Player player) { return invoke<Group>(0xA5EDCDE8, player); } // unused
	static BOOL IS_2PLAYER_GAME_GOING_ON() { return invoke<BOOL>(0xD60115D4); } // unused
	static int GET_PLAYER_MAX_ARMOUR(Player player) { return invoke<int>(0x02A50657, player); } // unused
	static BOOL IS_PLAYER_CONTROL_ON(Player player) { return invoke<BOOL>(0x618857F2, player); }
	static BOOL IS_PLAYER_SCRIPT_CONTROL_ON(Player player) { return invoke<BOOL>(0x61B00A84, player); } // unused
	static BOOL IS_PLAYER_CLIMBING(Player player) { return invoke<BOOL>(0x4A9E9AE0, player); } // unused
	static Vehicle GET_PLAYERS_LAST_VEHICLE() { return invoke<Vehicle>(0xE2757AC1); } // unused
	static Player GET_PLAYER_ID() { return invoke<Player>(0x1CC648EA); }
	static Player INT_TO_PLAYERINDEX(int value) { return invoke<Player>(0x98DD98F1, value); }
	static BOOL IS_PLAYER_FREE_FOR_AMBIENT_TASK(Player player) { return invoke<BOOL>(0x85C7E232, player); } // unused
	static BOOL HAS_DEATHARREST_EXECUTED() { return invoke<BOOL>(0x6DCD115A); } // unused
	static void SET_FAKE_DEATHARREST() { invoke<Void>(0x4A21BA25); } // unused
	static BOOL IS_PLAYER_PISSED_OFF(Player player) { return invoke<BOOL>(0x21A65E2F, player); } // unused
	static void SET_PLAYER_MOOD_NORMAL(Player player) { invoke<Void>(0xB1FF6041, player); } // unused
	static void SET_PLAYER_MOOD_PISSED_OFF(Player player, int seconds) { invoke<Void>(0x6F60E94E, player, seconds); } // unused
	static void SET_PLAYER_MAY_ONLY_ENTER_THIS_VEHICLE(Player player, Vehicle vehicle) { invoke<Void>(0xA454DD29, player, vehicle); } // unused
	static BOOL GIVE_ACHIEVEMENT_TO_PLAYER(int index) { return invoke<BOOL>(0x822BC992, index); }
	static BOOL HAS_ACHIEVEMENT_BEEN_PASSED(int index) { return invoke<BOOL>(0x136A5BE9, index); }
	static Any COMMIT_EXPERIENCE() { return invoke<Any>(0x494CD629); } // unused
	static void SET_EXPERIENCE_MULTIPLIER(int multiplier) { invoke<Void>(0xC4E91E1D, multiplier); }
	static void SET_LOCAL_EXPERIENCE_MULTIPLIER(float multiplier) { invoke<Void>(0xECF21382, multiplier); }
	static int GET_PLAYER_RANK() { return invoke<int>(0x0302394F); }
	static int GET_PLAYER_EXPERIENCE() { return invoke<int>(0x2100F7A5); } // unused
	static int GET_PLAYER_POINTS() { return invoke<int>(0x38111C8B); }
	static void SET_PLAYER_POINTS(int value) { invoke<Void>(0xAE5A0494, value); }
	static int GET_EXPERIENCE_FOR_RANK(int rank) { return invoke<int>(0x16F1F9ED, rank); } // unused
	static int GET_EXPERIENCE_MAX_RANK() { return invoke<int>(0x4C0782C8); } // unused
	static int GET_LOCAL_PLAYER_LEGEND_LEVEL() { return invoke<int>(0x495092E8); }
	static Any GET_RECENT_WEAPON_LEVEL_UP() { return invoke<Any>(0x304C0CF0); }
	static int GET_WEAPON_LEVEL(Hash weaponHash) { return invoke<int>(0x4F06494C, weaponHash); }
	static BOOL IS_PLAYER_ONLINE() { return invoke<BOOL>(0x9FAB6729); } // unused
	static BOOL IS_PLAYER_LOGGING_IN_NP() { return invoke<BOOL>(0x8F72FAD0); } // unused
	static BOOL IS_PLAYER_ONLINE_NP() { return invoke<BOOL>(0x41FAD3E2); } // unused
	static BOOL IS_PLAYER_ONLINE_GAMESPY() { return invoke<BOOL>(0x86D608A4); } // unused
	static void DISPLAY_SYSTEM_SIGNIN_UI() { invoke<Void>(0x4264CED2); } // unused
	static BOOL IS_SYSTEM_UI_BEING_DISPLAYED() { return invoke<BOOL>(0xE495B6DA); } // unused
	static void SET_PLAYER_KEEPS_WEAPONS_WHEN_RESPAWNED(Player player) { invoke<Void>(0xD10FC340); } // unused
	static void SET_PLAYER_INVINCIBLE(Player player, BOOL toggle) { invoke<Void>(0xDFB9A2A2, player, toggle); }
	static void SET_PLAYER_CAN_CARRY_NON_MISSION_OBJECTS(Player player) { invoke<Void>(0x54B0C19B); } // unused
	static Any REMOVE_PLAYER_HELMET() { return invoke<Any>(0x6255F3B4); } // unused
	static void GIVE_PLAYER_RAGDOLL_CONTROL(Player player, BOOL toggle) { invoke<Void>(0xC7B4D7AC, player, toggle); } // unused
	static void SET_PLAYER_LOCKON(Player player, BOOL toggle) { invoke<Void>(0x0B270E0F, player, toggle); } // unused
	static void SET_LOCKON_TO_FRIENDLY_PLAYERS(Player player, BOOL toggle) { invoke<Void>(0x60FFC7F8, player, toggle); } // unused
	static Object GET_OBJECT_PLAYER_WILL_PICKUP(Player player) { return invoke<Object>(0x45A04432, player); } // unused
	static void CLEAR_PLAYER_HAS_DAMAGED_AT_LEAST_ONE_PED(Player player) { invoke<Void>(0x1D31CBBD, player); }
	static BOOL HAS_PLAYER_DAMAGED_AT_LEAST_ONE_PED(Player player) { return invoke<BOOL>(0x14F52453, player); }
	static void SET_AIR_DRAG_MULTIPLIER_FOR_PLAYERS_VEHICLE(Player player, float multiplier) { invoke<Void>(0xF20F72E5, player, multiplier); } // unused
	static Vehicle GET_TRAIN_PLAYER_WOULD_ENTER() { return invoke<Vehicle>(0xCB979EE4); } // unused
	static void DISPLAY_PLAYER_COMPONENT(int component, BOOL toggle) { invoke<Void>(0xA57B18ED, component, toggle); } // unused
	static BOOL DOES_MAIN_PLAYER_EXIST() { return invoke<BOOL>(0x2528378B); }
	static void ASSISTED_MOVEMENT_OPEN_ROUTE() { invoke<Void>(0x830DDFC9); } // unused
	static void ASSISTED_MOVEMENT_CLOSE_ROUTE() { invoke<Void>(0xF23277F3); } // unused
	static void ASSISTED_MOVEMENT_FLUSH_ROUTE() { invoke<Void>(0xD04568B9); } // unused
	static void ASSISTED_MOVEMENT_ADD_POINT(float x, float y, float z) { invoke<Void>(0xD48E643D, x, y, z); } // unused
	static void ASSISTED_MOVEMENT_SET_WIDTH(float width) { invoke<Void>(0x76FFD005, width); } // unused
	static BOOL ASSISTED_MOVEMENT_IS_ON_ANY_ROUTE() { return invoke<BOOL>(0x7B3F0F02); } // unused
	static int ASSISTED_MOVEMENT_IS_ON_SCRIPTED_ROUTE() { return invoke<int>(0x1EFF3C50); } // unused
	static void SET_PLAYER_FORCED_AIM(ScrHandle playerOrPed, BOOL p1, BOOL p2) { invoke<Void>(0x94E42E2E, playerOrPed, p1, p2); }
	static void SET_PLAYER_FORCED_AIM_MAINTAIN_DIRECTION(ScrHandle playerOrPed, BOOL p1, BOOL p2) { invoke<Void>(0xFE1EC142, playerOrPed, p1, p2); }
	static int GET_TIME_SINCE_LAST_LMS_ACTIVATION() { return invoke<int>(0x9A1FA508); }
	static void SET_DAMAGE_TO_PLAYER_MULTIPLIER(float damage) { invoke<Void>(0xB871820B, damage); } // unused
	static void SET_DAMAGE_FROM_PLAYER_MULTIPLIER(float damage) { invoke<Void>(0xD88BF32D, damage); } // unused
	static void SET_POST_LMS_DAMAGE_TO_PLAYER_OVERRIDES(int p0, float p1) { invoke<Void>(0xB9C2BFBD, p0, p1); }
	static void ADD_ADRENALINE(float amount, BOOL p1) { invoke<Void>(0x9818A492, amount, p1); }
	static float GET_ADRENALINE_AMT() { return invoke<float>(0x1D2B1092); }
	static void ADD_PAYNEKILLER(int amount) { invoke<Void>(0xEFBF6795, amount); }
	static int GET_PAYNEKILLER_AMT() { return invoke<int>(0x8DF47C9D); }
	static void SET_PAYNEKILLER_HEALTH_BOOST(float value) { invoke<Void>(0x5E231B87, value); } // unused
	static void RESET_PAYNEKILLER_HEALTH_BOOST(float unused) { invoke<Void>(0xC19A5559, unused); } // unused
	static Any SET_PAYNEKILLER_RECHARGE_RATE() { return invoke<Any>(0x54A5A6C3); } // unused
	static Any RESET_PAYNEKILLER_RECHARGE_RATE() { return invoke<Any>(0x89413073); } // unused
	static void SET_ADRENALINE_AMT(float amount) { invoke<Void>(0x9D4FBDF6, amount); }
	static void SET_ADRENALINE_PAUSE(BOOL toggle) { invoke<Void>(0xE4D33791, toggle); } // unused
	static void SET_ADRENALINE_NOT_ALLOW(BOOL toggle) { invoke<Void>(0x51D0A04A, toggle); }
	static void SET_ADRENALINE_STREAKTIME(int time) { invoke<Void>(0xE6E47779, time); }
	static int GET_PLAYER_STREAK_ACTIVATION_LEVEL() { return invoke<int>(0x77C2EB66); }
	static void SET_PAYNEKILLER_AMT(int amount) { invoke<Void>(0x3DE72BB3, amount); }
	static Any SET_PAYNEKILLER_BOTTLE_COUNT() { return invoke<Any>(0xF3DE9E5D); } // unused
	static void SET_PLAYER_CAN_ACTIVATE_BULLET_TIME(Player player, BOOL toggle) { invoke<Void>(0xECD0EB64, toggle); }
	static void ACTIVATE_BULLET_TIME(BOOL p0, float p1, BOOL p2) { invoke<Void>(0xFF9FE21C, p0, p1, p2); }
	static Any ACTIVATE_BULLET_TIME_AS_PLAYER() { return invoke<Any>(0x25B796C8); } // unused
	static void DEACTIVATE_BULLET_TIME(BOOL toggle, BOOL ignoreScript) { invoke<Void>(0x3C85EF7C, toggle, ignoreScript); }
	static Any DEACTIVATE_BULLET_TIME_AS_PLAYER() { return invoke<Any>(0xF73F2994); } // unused
	static void DBG_ACTIVATE_BULLET_CAM_TIME(float p0) { invoke<Void>(0x1A5014DC, p0); }
	static void DBG_DEACTIVATE_BULLET_CAM_TIME(BOOL p0) { invoke<Void>(0x0820C255, p0); }
	static int GET_BULLET_TIME_COUNT() { return invoke<int>(0x934E7F2D); } // unused
	static int GET_BULLET_TIME_TEAM_COUNT() { return invoke<int>(0x55EF252D); } // unused
	static void ENABLE_LAST_MAN_STANDING(BOOL toggle) { invoke<Void>(0x9E8A0C27, toggle); }
	static void ENABLE_MP_LAST_MAN_STANDING(BOOL toggle) { invoke<Void>(0x3324F915, toggle); }
	static void LAST_MAN_STANDING_RECOVER() { invoke<Void>(0xC383F5A3); }
	static Any LAST_MAN_STANDING_REVIVE() { return invoke<Any>(0x21192AE3); } // unused
	static void SET_MP_LAST_MAN_STANDING_DOWN_TIME(int time) { invoke<Void>(0x8E926913, time); }
	static void SET_MP_LAST_MAN_STANDING_FLAGS(BOOL p0, BOOL p1, BOOL p2, BOOL p3, int p4) { invoke<Void>(0xAFF1FF49, p0, p1, p2, p3, p4); }
	static void PAUSE_MP_LAST_MAN_STANDING(BOOL toggle) { invoke<Void>(0xD32E394C, toggle); } // unused
	static void SET_MP_LAST_MAN_STANDING_INVINCIBLE_TIME(int time) { invoke<Void>(0x08261FB4, time); } // unused
	static void START_PLAYER_SHOOTDODGE(float p0, float p1, float p2, BOOL p3, BOOL p4, float p5, float p6) { invoke<Void>(0x96BB9783, p0, p1, p2, p3, p4, p5, p6); }
	static void SET_PLAYER_SHOOTDODGE_GET_UP_STATE(int state) { invoke<Void>(0x5EDA74EA, state); }
	static void SET_PLAYER_CAN_CANCEL_SHOOTDODGE(BOOL toggle) { invoke<Void>(0x8FD7169A, toggle); }
	static BOOL IS_PLAYER_SHOOTDODGING() { return invoke<BOOL>(0xEEA47566); }
	static BOOL LOCAL_PLAYER_CAN_DO_MP_INTERACTIONS() { return invoke<BOOL>(0x6BBDF4CB); } // unused
	static void PLAYER_SET_AIM_MODE(int mode) { invoke<Void>(0x8E1BD7A4, mode); }
	static void PLAYER_SET_WARP_FIRE_SCALE(float scale) { invoke<Void>(0x13F1FCBC, scale); }
	static float PLAYER_GET_TIMEWARP_MODIFIER() { return invoke<float>(0x0EACC1A2); } // unused
	static BOOL PLAYER_HAS_MP_SPECIAL_ITEM(Player player, int item) { return invoke<BOOL>(0x1FE6D589, player, item); }
	static void GIVE_PLAYER_MP_SPECIAL_ITEM(Player player, int item) { invoke<Void>(0x778E0144, player, item); } // unused
	static void REMOVE_LOCAL_PLAYER_MP_SPECIAL_ITEM(int item) { invoke<Void>(0xF13C1F3F, item); } // unused
	static void SET_PLAYER_COMBAT_TIMER_MODE(int mode) { invoke<Void>(0x5E348DA2, mode); }
	static void SET_PLAYER_GLOBAL_COMBAT_TIMER_STATE(BOOL state) { invoke<Void>(0xC02C4FE7, state); }
	static BOOL IS_LAST_MAN_STANDING_ACTIVE() { return invoke<BOOL>(0xB9087B11); }
	static void DISABLE_PICKUPS_FOR_PLAYER(BOOL toggle) { invoke<Void>(0xD06B1A42, toggle); }
	static void SIMULATE_PLAYER_INPUT_GAIT(Player player, float amount, int gaitType, float speed) { invoke<Void>(0x0D77CC34, player, amount, gaitType, speed); }
	static void RESET_PLAYER_INPUT_GAIT(Player player) { invoke<Void>(0x4A701EE1, player); }
	static void SET_PLAYER_CACHED_CAMERA_ORIENTATION(float orientation) { invoke<Void>(0x4B35E639, orientation); } // unused
	static void PLAYER_ENABLE_COMPONENT(int component, BOOL toggle) { invoke<Void>(0xCF91F01D, component, toggle); }
	static void ENABLE_PLAYER_TAUNT(BOOL toggle) { invoke<Void>(0x1BE48B46, toggle); }
	static void ENABLE_ADRENALINE(int index, BOOL toggle) { invoke<Void>(0xC399BC03, index, toggle); }
	static void ENABLE_ALL_ADRENALINE(BOOL toggle) { invoke<Void>(0x13B5D49D, toggle); }
	static void RESET_ADRENALINE_ENABLE() { invoke<Void>(0xB0E2ED32); }
	static void SET_ADRENALINE_OVERRIDE(int index, float value) { invoke<Void>(0x4AAB8E1B, index, value); }
	static void RESET_ADRENALINE_OVERRIDES() { invoke<Void>(0xAE97DC89); } // unused
	static void RESET_ADRENALINE_OVERRIDE(int index) { invoke<Void>(0xEE8F876F, index); }
	static BOOL IS_PLAYER_DOING_MELEE_GRAPPLE(Player player) { return invoke<BOOL>(0x5EECF4E4, player); }
	static void USE_ANIMATED_LAST_MAN_STANDING(BOOL toggle) { invoke<Void>(0x3345BB01, toggle); }
	static BOOL IS_USING_ANIMATED_LAST_MAN_STANDING() { return invoke<BOOL>(0xC98EAAFC); } // unused
	static void HOLD_LAST_MAN_STAND_ANIMATED_RECOVERY(Any p0) { invoke<Void>(0xB90B9868, p0); }
	static BOOL IS_LAST_MAN_STAND_ANIMATED_RECOVERY_BEING_HELD() { return invoke<BOOL>(0x76DDD1A5); }
	static void BLOCK_PLAYER_COVER_MOVEMENT_TRANSITIONS(BOOL toggle) { invoke<Void>(0x51C32D10, toggle); }
	static BOOL ARE_PLAYER_COVER_MOVEMENT_TRANSITIONS_BLOCKED() { return invoke<BOOL>(0x047D2668); } // unused
	static void SET_SCRIPT_CONTROL_RESET_ON_PLAYER_DEATH(BOOL toggle) { invoke<Void>(0x107EA41E, toggle); }
	static BOOL NETWORK_IS_PLAYER_VISIBLE(Any p0, Any p1, Any p2) { return invoke<BOOL>(0x56D96854, p0, p1, p2); }
	static BOOL NETWORK_IS_PLAYER_VISIBLE_TO_TEAM(Any p0, Any p1, Any p2) { return invoke<BOOL>(0xC459CF02, p0, p1, p2); }
	static void SET_FORCED_AIM_INTENTION_DIRECTION(float dirX, float dirY, float dirZ) { invoke<Void>(0xEE232DCC, dirX, dirY, dirZ); }
	static void RESET_FORCED_AIM_INTENTION_DIRECTION() { invoke<Void>(0x1C66206F); }
	static void SET_FORCED_FORWARD_DIRECTION(float dirX, float dirY, float dirZ) { invoke<Void>(0xCE0B5E35, dirX, dirY, dirZ); }
	static void RESET_FORCED_FORWARD_DIRECTION() { invoke<Void>(0x6FEAA869); }
	static void SET_FREEZE_HEADING_BLEND(int p0) { invoke<Void>(0xE2E61E48, p0); }
	static void SET_ALLOW_MOLOTOV_DAMAGE(BOOL toggle) { invoke<Void>(0x791C4E27, toggle); }
	static void ENABLE_SHOOT_DODGE_HIGH_FALL_STAIRS_DETECTION(BOOL toggle) { invoke<Void>(0xD579FE07, toggle); }
	static BOOL UNLOCK(char* unlockSemantic, BOOL p1, BOOL p2) { return invoke<BOOL>(0x98BAB591, unlockSemantic, p1, p2); }
	static BOOL MODIFY_UNLOCK(char* unlockSemantic, BOOL p1, BOOL p2, BOOL p3) { return invoke<BOOL>(0xF203B6DD, unlockSemantic, p1, p2, p3); }
	static BOOL GET_UNLOCK_EXISTS(char* unlockSemantic) { return invoke<BOOL>(0x55C1F862, unlockSemantic); } // unused
	static BOOL GET_IS_UNLOCKED(char* unlockSemantic) { return invoke<BOOL>(0x2B86B773, unlockSemantic); }
	static BOOL GET_UNLOCK_IS_VISIBLE(char* unlockSemantic) { return invoke<BOOL>(0x02BFABD3, unlockSemantic); } // unused
	static BOOL GET_UNLOCK_IS_NEW(char* unlockSemantic) { return invoke<BOOL>(0xE2158FEF, unlockSemantic); } // unused
	static void MARK_UNLOCK_AS_SEEN(char* unlockSemantic) { invoke<Void>(0xC2C8DA09, unlockSemantic); } // unused
	static BOOL GET_EXISTS_IN_PLAYER_SAVE(char* unlockSemantic) { return invoke<BOOL>(0x2F849928, unlockSemantic); } // unused
	static void SET_ALLOW_PLAYER_REACT_TO_EXPLOSION(Ped ped, BOOL toggle, float p2) { invoke<Void>(0x0EE93EDE, ped, toggle, p2); }
	static void SET_FAIL_PROMPT_BUTTON_AND_TEXT(Ped ped, int button, char* textLabel) { invoke<Void>(0x18EE1B87, ped, button, textLabel); }
	static void SET_CAN_ROLL_DODGE(Ped ped, BOOL toggle) { invoke<Void>(0xBD808BA0, ped, toggle); }
	static void SET_CAN_ROLLING_PICKUP(Ped ped, BOOL toggle) { invoke<Void>(0x34638D43, ped, toggle); } // unused
	static void SET_USE_WEAPON_BOUND(Ped ped, BOOL toggle) { invoke<Void>(0xD1827431, ped, toggle); } // unused
	static void SET_PLAYER_THREAT_REACTION(Ped ped, BOOL toggle) { invoke<Void>(0xE050BAC4, ped, toggle); }
	static void SET_MONITORED_STATS(Any* p0) { invoke<Void>(0x2AC96CE9, p0); }
	static BOOL QUERY_MONITORED_STATS(int p0, Any* p1) { return invoke<BOOL>(0x264C2677, p0, p1); }
	static Any QUERY_MONITORED_STAT_ENTRY(int p0, int p1) { return invoke<Any>(0xA18210A2, p0, p1); } // unused
	static BOOL IS_PLAYER_GUN_RAISED(Player player) { return invoke<BOOL>(0x94985FF7, player); }
	static Hash GET_PLAYER_COVER_UID(Player player) { return invoke<Hash>(0xCDF4F42F, player); } // unused
	static Hash GET_PLAYER_COVER_SECTION_UID(Player player) { return invoke<Hash>(0x14288A76, player); } // unused
	static BOOL GET_PLAYER_COVER_FACING_LEFT(Player player) { return invoke<BOOL>(0xD56D622D, player); } // unused
	static BOOL SNAP_PLAYER_TO_COVERPOINT_FROM_UID(Player player, Hash coverSectionUID, Hash coverUID, BOOL p3) { return invoke<BOOL>(0x4548143F, player, coverSectionUID, coverUID, p3); } // unused
	static void SET_PLAYER_OXYGEN(Player player, int oxygen) { invoke<Void>(0x1B92B5E5, oxygen); } // unused
	static int GET_PLAYER_OXYGEN(Player player) { return invoke<int>(0x35EBD55D, player); } // unused
	static void SET_PLAYER_CAN_BE_PINNED_IN_COVER(Player player, BOOL toggle) { invoke<Void>(0x02343733, player, toggle); }
	static void SET_PLAYER_FORCE_PAIN_KILLER(BOOL toggle) { invoke<Void>(0x49F9AB61, toggle); }
	static void SET_PLAYER_CAN_USE_FREEFORM_STRIKE(BOOL toggle) { invoke<Void>(0x21FC90F7, toggle); }
	static void SET_PLAYER_IN_BECKER_BOSS_FIGHT(Player player, BOOL toggle) { invoke<Void>(0x31539EA2, player, toggle); }
	static void SET_ALLOW_PLAYER_DIE_FROM_SHOOT_DODGE(BOOL toggle) { invoke<Void>(0x1D0AAF37, toggle); }
	static void REGISTER_DETACH_PLAYER_FOR_CUTSCENE() { invoke<Void>(0x057D2D26); }
	static void _SET_UNK_TEAR_GAS_MODIFIER(float modifier) { invoke<Void>(0x46CE66CF, modifier); }
	static void _SET_UNK_LOCAL_PLAYER_BOOL(BOOL toggle) { invoke<Void>(0x006D3541, toggle); }
}

namespace TASK
{
	static void TASK_PAUSE(Ped ped, int duration) { invoke<Void>(0x17A64668, ped, duration); }
	static void TASK_STAND_STILL(Ped ped, int duration) { invoke<Void>(0x6F80965D, ped, duration); }
	static void TASK_JUMP(Ped ped, BOOL p1) { invoke<Void>(0x0356E3CE, ped, p1); } // unused
	static void TASK_JUMP_FORWARD(Ped ped) { invoke<Void>(0x3F5D4488, ped); } // unused
	static void TASK_DODGE(Ped ped) { invoke<Void>(0xE1931B3A, ped); } // unused
	static void TASK_COWER(Ped ped) { invoke<Void>(0x9CF1C19B, ped); }
	static void TASK_HANDS_UP(Ped ped, int duration) { invoke<Void>(0x8DCC19C5, ped, duration); } // unused
	static void TASK_DUCK(Ped ped, int duration) { invoke<Void>(0x396A40E9, ped, duration); } // unused
	static void TASK_OPEN_VEHICLE_DOOR(Ped ped, Vehicle vehicle, int timeout, int doorIndex) { invoke<Void>(0x8EE06BF4, ped, vehicle, timeout, doorIndex); } // unused
	static void TASK_ENTER_VEHICLE(Ped ped, Vehicle vehicle, int timeout, int doorIndex) { invoke<Void>(0xB8689B4E, ped, vehicle, timeout, doorIndex); } // unused
	static void TASK_LEAVE_VEHICLE(Ped ped, Vehicle vehicle) { invoke<Void>(0x7B1141C6, ped, vehicle); }
	static void TASK_LEAVE_VEHICLE_DONT_CLOSE_DOOR(Ped ped, Vehicle vehicle) { invoke<Void>(0xF13827AD, ped, vehicle); }
	static void TASK_LEAVE_VEHICLE_IN_DIRECTION(Ped ped, Vehicle vehicle, BOOL direction) { invoke<Void>(0x4D7BF56D, ped, vehicle, direction); } // unused
	static void TASK_GET_OFF_BOAT(Vehicle boat, int duration) { invoke<Void>(0x4293601F, boat, duration); } // unused
	static void TASK_GET_ON_CUSTOM_VEHICLE(Vehicle vehicle, Ped ped, float p2, float p3, float p4, float p5, char* p6, char* p7) { invoke<Void>(0x87354C85, vehicle, ped, p2, p3, p4, p5, p6, p7); }
	static Any TASK_GET_ON_CUSTOM_BOAT() { return invoke<Any>(0x39E721B7); } // unused
	static Any TASK_GET_OFF_CUSTOM_BOAT() { return invoke<Any>(0x9A082E32); } // unused
	static Any TASK_NAVIGATE_THROUGH_TRAM_CARS() { return invoke<Any>(0x2E63F94A); } // unused
	static Any TASK_LEAVE_VEHICLE_AND_FLEE() { return invoke<Any>(0x8626D6F8); } // unused
	static void TASK_VEHICLE_DRIVE_TO_COORD(Any p0, Any p1, Any p2, Any p3, Any p4, Any p5, Any p6, Any p7, Any p8, Any p9, Any p10) { invoke<Void>(0xE4AC0387, p0, p1, p2, p3, p4, p5, p6, p7, p8, p9, p10); }
	static Any TASK_VEHICLE_DRIVE_TO_COORD_RUBBER_BAND() { return invoke<Any>(0x72960B42); } // unused
	static Any TASK_VEHICLE_DRIVE_WANDER() { return invoke<Any>(0x36EC0EB0); } // unused
	static Any TASK_FOLLOW_TO_OFFSET_OF_PED() { return invoke<Any>(0x8F10A775); } // unused
	static void TASK_SMART_FOLLOW_PED(Ped ped, Ped ped2, float p2, float p3, float p4, Any p5, int p6, float p7, BOOL p8, BOOL p9) { invoke<Void>(0x22CFC4BD, ped, ped2, p2, p3, p4, p5, p6, p7, p8, p9); }
	static void TASK_GO_STRAIGHT_TO_COORD(Any p0, Any p1, Any p2, Any p3, Any p4, Any p5) { invoke<Void>(0x80A9E7A7, p0, p1, p2, p3, p4, p5); }
	static Any TASK_GO_STRAIGHT_TO_COORD_RELATIVE_TO_VEHICLE() { return invoke<Any>(0x5BE44EF2); } // unused
	static void TASK_ACHIEVE_HEADING(Any p0, Any p1, Any p2, Any p3) { invoke<Void>(0x0A0E9B42, p0, p1, p2, p3); }
	static void TASK_FLUSH_ROUTE() { invoke<Void>(0x34219154); } // unused
	static Any TASK_EXTEND_ROUTE() { return invoke<Any>(0x43271F69); } // unused
	static Any TASK_FOLLOW_POINT_ROUTE() { return invoke<Any>(0xB837C816); } // unused
	static void TASK_GO_TO_PED(Ped ped, Ped ped2, int p2, float p3) { invoke<Void>(0xC2F0E987, ped, ped2, p2, p3); }
	static Any TASK_SMART_FLEE_COORD() { return invoke<Any>(0xB2E686FC); } // unused
	static void TASK_SMART_FLEE_PED(Any p0, Any p1, Any p2, Any p3, Any p4) { invoke<Void>(0xE52EB560, p0, p1, p2, p3, p4); }
	static Any TASK_WANDER_STANDARD() { return invoke<Any>(0xAF59151A); } // unused
	static Any TASK_STATIONARY_STRAFE_ATTACK() { return invoke<Any>(0xAC987362); } // unused
	static Any TASK_CAUTIOUS_ADVANCE() { return invoke<Any>(0xC559BB30); } // unused
	static void TASK_FOLLOW_NAV_MESH_TO_COORD(Ped ped, float x, float y, float z, int moveSpeedId, int duration, float p6, int flags, float p8) { invoke<Void>(0xFE4A10D9, ped, x, y, z, moveSpeedId, duration, p6, flags, p8); }
	static void TASK_FOLLOW_NAV_MESH_TO_COORD_ADVANCED(Ped ped, float x, float y, float z, int moveSpeedId, int duration, float p6, int flags, Vector3* p8, float p9) { invoke<Void>(0x6BF6E296, ped, x, y, z, moveSpeedId, duration, p6, flags, p8, p9); } // unused
	static void SET_PED_PATH_CAN_USE_CLIMBOVERS(Ped ped, BOOL toggle) { invoke<Void>(0xB7B7D442, ped, toggle); }
	static void SET_PED_PATH_CAN_USE_LADDERS(Ped ped, BOOL toggle) { invoke<Void>(0x53A879EE, ped, toggle); } // unused
	static void SET_PED_PATH_CAN_DROP_FROM_HEIGHT(Ped ped, BOOL toggle) { invoke<Void>(0x394B7AC9, ped, toggle); }
	static void SET_PED_PATH_CAN_ENTER_WATER(Ped ped, BOOL toggle) { invoke<Void>(0xC61CA38D, ped, toggle); }
	static void SET_PED_PATH_CAN_AVOID_DYNAMIC_OBJECTS(Ped ped, BOOL toggle) { invoke<Void>(0x57A414E5, ped, toggle); }
	static void SET_PED_PATH_CAN_OPEN_CLOSED_DOORS(Ped ped, BOOL toggle) { invoke<Void>(0x7C0C0376, ped, toggle); } // unused
	static void SET_PED_PATH_CAN_AVOID_LINE_OF_FIRE(Ped ped, BOOL toggle) { invoke<Void>(0x626D65F6, ped, toggle); }
	static void SET_PED_PATH_VAULTING_USAGE(Ped ped, int p1, int p2, int p3) { invoke<Void>(0x1E7312D0, ped, p1, p2, p3); }
	static int GET_NAVMESH_ROUTE_DISTANCE_REMAINING(Ped ped, float* p1, BOOL* p2) { return invoke<int>(0xD9281778, ped, p1, p2); } // unused
	static void TASK_GO_TO_COORD_ANY_MEANS(Ped ped, float x, float y, float z, int p4, Vehicle vehicle) { invoke<Void>(0xF91DF93B, ped, x, y, z, p4, vehicle); } // unused
	static void TASK_PLAY_ANIM(Ped ped, char* animDict, char* animName, float speed, float speedMultiplier, int duration, int flags) { invoke<Void>(0x5AB552C6, ped, animDict, animName, speed, speedMultiplier, duration, flags); }
	static void TASK_LOOK_AT_COORD(Any p0, Any p1, Any p2, Any p3, Any p4, Any p5) { invoke<Void>(0x7B784DD8, p0, p1, p2, p3, p4, p5); }
	static void TASK_LOOK_AT_PED(Ped ped, Ped ped2, int duration, int flags) { invoke<Void>(0x930AE844, ped, ped2, duration, flags); }
	static void TASK_LOOK_AT_VEHICLE(Ped ped, Vehicle vehicle, int duration, int flags) { invoke<Void>(0x45651376, ped, vehicle, duration, flags); } // unused
	static void TASK_LOOK_AT_OBJECT(Ped ped, Object object, int duration, int flags) { invoke<Void>(0x44C5D95B, ped, object, duration, flags); }
	static void TASK_CLEAR_LOOK_AT(Any p0) { invoke<Void>(0x60EB4054, p0); }
	static void OPEN_SEQUENCE_TASK(ScrHandle* taskSequence) { invoke<Void>(0xABA6923E, taskSequence); }
	static void CLOSE_SEQUENCE_TASK(ScrHandle taskSequence) { invoke<Void>(0x1A7CEBD0, taskSequence); }
	static void TASK_PERFORM_SEQUENCE(Ped ped, ScrHandle taskSequence) { invoke<Void>(0x4D9FBD11, ped, taskSequence); }
	static void TASK_PERFORM_SEQUENCE_LOCALLY(Ped ped, ScrHandle taskSequence) { invoke<Void>(0x974D3D66, ped, taskSequence); } // unused
	static void CLEAR_SEQUENCE_TASK(ScrHandle taskSequence) { invoke<Void>(0x47ED03CE, taskSequence); }
	static void SET_SEQUENCE_TO_REPEAT(ScrHandle taskSequence, BOOL repeat) { invoke<Void>(0xCDDF1508, taskSequence, repeat); }
	static int GET_SEQUENCE_PROGRESS(ScrHandle taskSequence) { return invoke<int>(0xA3419909, taskSequence); }
	static void TASK_LEAVE_VEHICLE_IMMEDIATELY(Ped ped, Vehicle vehicle) { invoke<Void>(0x59CC2ED0, ped, vehicle); }
	static int GET_SCRIPT_TASK_STATUS(Ped ped, int task) { return invoke<int>(0xB2477B23, ped, task); }
	static void TASK_LEAVE_ANY_VEHICLE(Ped ped) { invoke<Void>(0xDBDD79FA, ped); }
	static void TASK_AIM_GUN_AT_PED(Ped ped, Ped targetPed, int duration, BOOL p3) { invoke<Void>(0x3B4CA777, ped, targetPed, duration, p3); }
	static void TASK_GO_TO_COORD_WHILE_SHOOTING(Ped ped, float x, float y, float z, int a5, float a6, float a7, Ped ped2, BOOL a9) { invoke<Void>(0x424FED42, ped, x, y, z, a5, a6, a7, ped2, a9); } // unused
	static void TASK_TURN_PED_TO_FACE_PED(Any p0, Any p1, Any p2, Any p3) { invoke<Void>(0xDE13490F, p0, p1, p2, p3); }
	static void TASK_AIM_GUN_AT_COORD(Any p0, Any p1, Any p2, Any p3, Any p4, Any p5) { invoke<Void>(0xFBF44AD3, p0, p1, p2, p3, p4, p5); }
	static void TASK_SHOOT_AT_COORD(Any p0, Any p1, Any p2, Any p3, Any p4, Any p5, Any p6, Any p7) { invoke<Void>(0x601C22E3, p0, p1, p2, p3, p4, p5, p6, p7); }
	static void TASK_SHUFFLE_TO_NEXT_VEHICLE_SEAT(Ped ped, Vehicle vehicle) { invoke<Void>(0xBEAF8F67, ped, vehicle); } // unused
	static void TASK_CHAT_WITH_PED(Ped ped, Ped ped2, BOOL p2, BOOL p3) { invoke<Void>(0xBECAED75, ped, ped2, p2, p3); } // unused
	static void CLEAR_PED_TASKS(Ped ped) { invoke<Void>(0xDE3316AB, ped); }
	static void CLEAR_PED_SECONDARY_TASK(Ped ped) { invoke<Void>(0xA635F451, ped); } // unused
	static void TASK_EVERYONE_LEAVE_VEHICLE(Ped ped) { invoke<Void>(0xC1971F30, ped); } // unused
	static void TASK_GOTO_PED_OFFSET(Ped ped, Ped ped2, int p2, float p3, float p4) { invoke<Void>(0x92B6581E, ped, ped2, p2, p3, p4); } // unused
	static void TASK_SIT_DOWN(Ped ped, int p1, int p2, int p3) { invoke<Void>(0xB40FC847, ped, p1, p2, p3); } // unused
	static void TASK_SIT_DOWN_ON_SEAT(Ped ped, int p1, int p2, float x, float y, float z, float p6, int p7) { invoke<Void>(0xB457570A, ped, p1, p2, x, y, z, p6, p7); } // unused
	static void TASK_SIT_DOWN_INSTANTLY(Ped ped, int p1, int p2, int p3) { invoke<Void>(0xCAC2792F, ped, p1, p2, p3); } // unused
	static void TASK_SIT_DOWN_ON_OBJECT(Ped ped, int p1, int p2, Object object, float x, float y, float z, float p7, int p8, BOOL p9) { invoke<Void>(0x595E56B4, ped, p1, p2, object, x, y, z, p7, p8, p9); } // unused
	static BOOL IS_PED_SITTING_IDLE(Ped ped) { return invoke<BOOL>(0x98F2F27D, ped); } // unused
	static void SET_PED_SIT_IDLE_ANIM(Ped ped, char* animDict, char* animName, BOOL p3) { invoke<Void>(0x1F0EFD92, ped, animDict, animName, p3); } // unused
	static BOOL HAS_OVERRIDEN_SIT_IDLE_ANIM_FINISHED(Ped ped) { return invoke<BOOL>(0xD8A5D041, ped); } // unused
	static BOOL IS_SITTING_OBJECT_NEAR(float x, float y, float z, Hash modelHash) { return invoke<BOOL>(0xD81F06C2, x, y, z, modelHash); } // unused
	static void TASK_SIT_DOWN_ON_NEAREST_OBJECT(Ped ped, int p1, int p2, float x, float y, float z, Hash modelHash, float p7, int p8, BOOL p9) { invoke<Void>(0xA287D0BD, ped, p1, p2, x, y, z, modelHash, p7, p8, p9); } // unused
	static void TASK_TURN_PED_TO_FACE_COORD(Any p0, Any p1, Any p2, Any p3, Any p4, Any p5) { invoke<Void>(0x30463D73, p0, p1, p2, p3, p4, p5); }
	static void TASK_DRIVE_POINT_ROUTE(Ped driver, Vehicle vehicle, float p2) { invoke<Void>(0x4A2F3753, driver, vehicle, p2); } // unused
	static void TASK_VEHICLE_TEMP_ACTION(Ped driver, Vehicle vehicle, int action, int time) { invoke<Void>(0x0679DFB8, driver, vehicle, action, time); } // unused
	static void TASK_VEHICLE_MISSION(Any p0, Any p1, Any p2, Any p3, Any p4, Any p5, Any p6, Any p7, Any p8, Any p9) { invoke<Void>(0x20609E56, p0, p1, p2, p3, p4, p5, p6, p7, p8, p9); }
	static Any TASK_VEHICLE_MISSION_PED_TARGET() { return invoke<Any>(0xC81C4677); } // unused
	static Any TASK_VEHICLE_MISSION_COORS_TARGET() { return invoke<Any>(0x6719C109); } // unused
	static void TASK_HELI_MISSION(Any p0, Any p1, Any p2, Any p3, Any p4, Any p5, Any p6, Any p7, Any p8, Any p9, Any p10, Any p11, Any p12) { invoke<Void>(0x0C143E97, p0, p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12); }
	static void TASK_GO_TO_OBJECT(Ped ped, Object object, int p2, float p3) { invoke<Void>(0x01BACD08, ped, object, p2, p3); } // unused
	static Any TASK_WEAPON_ROLL() { return invoke<Any>(0x123B2716); } // unused
	static void TASK_PICKUP_AND_CARRY_OBJECT(Ped ped, Object object, float x, float y, float z, BOOL p5) { invoke<Void>(0x6C47A7D6, ped, object, x, y, z, p5); } // unused
	static Any SET_PED_DROPS_OBJECT() { return invoke<Any>(0x4D75C27C); } // unused
	static void TASK_DRIVE_BY(Ped driverPed, Ped targetPed, Vehicle targetVehicle, float targetX, float targetY, float targetZ, float distanceToShoot, Any p7, BOOL p8, int pedAccuracy) { invoke<Void>(0x2B84D1C4, driverPed, targetPed, targetVehicle, targetX, targetY, targetZ, distanceToShoot, p7, p8, pedAccuracy); } // unused
	static void TASK_DRIVER_COMBAT(Any p0, Any p1, Any p2, Any p3, Any p4, Any p5, Any p6, Any p7, Any p8, Any p9, Any p10) { invoke<Void>(0xAB123B77, p0, p1, p2, p3, p4, p5, p6, p7, p8, p9, p10); }
	static void TASK_USE_MOBILE_PHONE(Ped ped, BOOL p1) { invoke<Void>(0x225A38C8, ped, p1); } // unused
	static void TASK_USE_MOBILE_PHONE_TIMED(Ped ped, int time) { invoke<Void>(0xC99C19F5, ped, time); } // unused
	static void TASK_USE_WALKIE_TALKIE(Ped ped, char* p1) { invoke<Void>(0x3868BDE6, ped, p1); } // unused
	static void TASK_CHAT_TO_PED(Ped ped, Ped ped2, BOOL p2, BOOL p3) { invoke<Void>(0xA2BE1821, ped, ped2, p2, p3); } // unused
	static void ADD_FOLLOW_NAVMESH_TO_PHONE_TASK(Ped ped, float x, float y, float z) { invoke<Void>(0x00D7303F, ped, x, y, z); } // unused
	static BOOL GET_MOBILE_PHONE_TASK_SUB_TASK(Ped ped, int* subtask) { return invoke<BOOL>(0xB47C4CF0, ped, subtask); } // unused
	static void TASK_WARP_PED_INTO_VEHICLE(Ped ped, Vehicle vehicle, int seatIndex) { invoke<Void>(0x65D4A35D, ped, vehicle, seatIndex); } // unused
	static void TASK_SHOOT_AT_PED(Ped ped, Ped targetPed, int duration, Hash firingPatternHash, BOOL p4, BOOL p5, BOOL p6) { invoke<Void>(0xE878CC20, ped, targetPed, duration, firingPatternHash, p4, p5, p6); }
	static void TASK_SHOOT_AT_VEHICLE(Any p0, Any p1, Any p2, Any p3, Any p4, Any p5, Any p6, Any p7, Any p8, Any p9) { invoke<Void>(0x009D5555, p0, p1, p2, p3, p4, p5, p6, p7, p8, p9); }
	static void TASK_AIM_GUN_AT_VEHICLE(Any p0, Any p1, Any p2, Any p3, Any p4, Any p5, Any p6, Any p7) { invoke<Void>(0x217E69A2, p0, p1, p2, p3, p4, p5, p6, p7); }
	static void TASK_GOTO_VEHICLE(Ped ped, Vehicle vehicle, int p2, float p3) { invoke<Void>(0x08DE489D, ped, vehicle, p2, p3); } // unused
	static void CLEAR_PED_TASKS_IMMEDIATELY(Ped ped) { invoke<Void>(0xBC045625, ped); }
	static void TASK_PERFORM_SEQUENCE_FROM_PROGRESS(Ped ped, ScrHandle taskSequence, int p2, int p3) { invoke<Void>(0xFA60601B, ped, taskSequence, p2, p3); } // unused
	static void SET_NEXT_DESIRED_MOVE_STATE(int moveState) { invoke<Void>(0x4E937D57, moveState); } // unused
	static void SET_CURRENT_PED_MOVE_STATE(Ped ped, int moveState) { invoke<Void>(0x5D6384AC, ped, moveState); } // unused
	static Any TASK_GOTO_PED_AIMING() { return invoke<Any>(0x676649DA); } // unused
	static Any TASK_SET_PED_DECISION_MAKER() { return invoke<Any>(0xB6C665A7); } // unused
	static Any TASK_PED_SLIDE_TO_COORD() { return invoke<Any>(0x225380EF); } // unused
	static Any TASK_PED_SLIDE_TO_COORD_AND_PLAY_ANIM() { return invoke<Any>(0x94BBE5C4); } // unused
	static Any TASK_PED_SLIDE_TO_COORD_AND_PLAY_ANIM_HDG_RATE() { return invoke<Any>(0x95ABC676); } // unused
	static Any TASK_PED_SLIDE_TO_COORD_HDG_RATE() { return invoke<Any>(0x38A995C1); } // unused
	static Any TASK_DRIVE_POINT_ROUTE_ADVANCED() { return invoke<Any>(0x5BE99735); } // unused
	static void TASK_FOLLOW_PATROL_ROUTE(Ped ped, int p1, int p2) { invoke<Void>(0xADDF1C66, ped, p1, p2); } // unused
	static void TASK_COMBAT_PED(Ped ped, Ped targetPed) { invoke<Void>(0xCB0D8932, ped, targetPed); }
	static void TASK_COMBAT_PED_TIMED(Ped ped, Ped targetPed, int time) { invoke<Void>(0xF5CA2A45, ped, targetPed, time); } // unused
	static void TASK_COMBAT_MOVE_TO_COVER(Ped ped, char* p1, char* p2, Ped ped2) { invoke<Void>(0x98F7B4E3, ped, p1, p2, ped2); }
	static void TASK_COMBAT_MOVE_TO_COVER_COORDS(Ped ped, float x, float y, float z, Ped ped2) { invoke<Void>(0xC219CD65, ped, x, y, z, ped2); }
	static void TASK_COMBAT_SNAP_TO_COVER(Ped ped, char* p1, char* p2, Ped ped2) { invoke<Void>(0x62DA169D, ped, p1, p2, ped2); }
	static void TASK_COMBAT_SNAP_TO_COVER_COORDS(Ped ped, float x, float y, float z, Ped ped2) { invoke<Void>(0x7342B8FD, ped, x, y, z, ped2); }
	static void TASK_COMBAT_SNAP_TO_COVER_AMBUSH(Ped ped, char* p1, char* p2, int p3, int p4, BOOL p5) { invoke<Void>(0xB42E30A0, ped, p1, p2, p3, p4, p5); }
	static void TASK_COMBAT_SNAP_TO_COVER_AMBUSH_COORDS(Ped ped, float x, float y, float z, int p3, int p4, BOOL p5) { invoke<Void>(0xC047B95C, ped, x, y, z, p3, p4, p5); } // unused
	static void TASK_COMBAT_MOVE_TO_COVER_TACTICAL(Ped ped, char* p1, char* p2, BOOL p3, Ped ped2) { invoke<Void>(0xB54F8633, ped, p1, p2, p3, ped2); }
	static void TASK_COMBAT_MOVE_TO_COVER_TACTICAL_COORDS(Ped ped, float x, float y, float z, BOOL p4, Ped ped2) { invoke<Void>(0xA538B46E, ped, x, y, z, p4, ped2); }
	static void TASK_COMBAT_SNAP_TO_COVER_TACTICAL(Ped ped, char* p1, char* p2, BOOL p3, Ped ped2) { invoke<Void>(0x60C0C2F7, ped, p1, p2, p3, ped2); }
	static void TASK_COMBAT_SNAP_TO_COVER_TACTICAL_COORDS(Ped ped, float x, float y, float z, BOOL p4, Ped ped2) { invoke<Void>(0x9BB448D7, ped, x, y, z, p4, ped2); } // unused
	static Any ADD_SPATIALDATA_COVER_POINT(Any p0, Any p1, Any p2, Any p3, Any p4, Any p5, Any p6, Any p7, Any p8, Any p9) { return invoke<Any>(0x184DE0A6, p0, p1, p2, p3, p4, p5, p6, p7, p8, p9); }
	static void REMOVE_SPATIALDATA_COVER_POINT(Any p0) { invoke<Void>(0x0FDFDEF0, p0); }
	static Any DOES_SPATIALDATA_COVER_POINT_EXIST(Any p0) { return invoke<Any>(0x2AFC1D34, p0); }
	static void TASK_TOGGLE_DUCK(Ped ped, int p1) { invoke<Void>(0x61CFBCBF, ped, p1); } // unused
	static Any TASK_GUARD_CURRENT_POSITION() { return invoke<Any>(0x2FB099E9); } // unused
	static Any TASK_GUARD_ASSIGNED_DEFENSIVE_AREA() { return invoke<Any>(0x7AF0133D); } // unused
	static Any TASK_GUARD_ANGLED_DEFENSIVE_AREA() { return invoke<Any>(0xD2062CA9); } // unused
	static Any TASK_GUARD_SPHERE_DEFENSIVE_AREA() { return invoke<Any>(0x86B76CB7); } // unused
	static Any TASK_STAND_GUARD() { return invoke<Any>(0xD130F636); } // unused
	static Any SET_DRIVE_TASK_CRUISE_SPEED() { return invoke<Any>(0x3CEC07B1); } // unused
	static Any ADD_COVER_BLOCKING_AREA() { return invoke<Any>(0x3536946F); } // unused
	static Any REMOVE_ALL_COVER_BLOCKING_AREAS() { return invoke<Any>(0xCF9221A7); } // unused
	static Any TASK_START_SCENARIO_IN_PLACE() { return invoke<Any>(0xE50D6DDE); } // unused
	static Any TASK_START_SCENARIO_AT_POSITION() { return invoke<Any>(0xAA2C4AC2); } // unused
	static Any TASK_USE_NEAREST_SCENARIO_TO_COORD() { return invoke<Any>(0x9C50FBF0); } // unused
	static Any TASK_USE_NEAREST_SCENARIO_TO_COORD_WARP() { return invoke<Any>(0x1BE9D65C); } // unused
	static Any DOES_SCENARIO_EXIST_IN_AREA() { return invoke<Any>(0xFA7F5047); } // unused
	static Any TASK_COMBAT_HATED_TARGETS_IN_AREA() { return invoke<Any>(0xDF099E18); } // unused
	static void TASK_COMBAT_HATED_TARGETS_AROUND_PED(Any p0, Any p1) { invoke<Void>(0x2E7064E4, p0, p1); }
	static Any TASK_COMBAT_HATED_TARGETS_AROUND_PED_TIMED() { return invoke<Any>(0xF127AD6A); } // unused
	static void TASK_SELECT_WEAPON_TO_HAND(Ped ped, Weapon weapon, int p2) { invoke<Void>(0xEF4D8FD9, ped, weapon, p2); }
	static void TASK_SWAP_WEAPON(Ped ped, BOOL p1) { invoke<Void>(0xDAF4F8FC, ped, p1); }
	static void TASK_DROP_WEAPON(Ped ped, Weapon weapon) { invoke<Void>(0xBCC51D2B, ped, weapon); }
	static void TASK_COMBAT_ROLL(Ped ped, int p1) { invoke<Void>(0x8BB401CE, ped, p1); } // unused
	static void TASK_MOBILE_CONVERSATION(Ped ped, BOOL wander) { invoke<Void>(0x060DA456, ped, wander); } // unused
	static BOOL IS_PED_GETTING_UP(Ped ped) { return invoke<BOOL>(0x320813E6, ped); }
	static Any TASK_USE_DPV() { return invoke<Any>(0x518F8CF2); } // unused
	static void TASK_GO_TO_COORD_DPV(Ped ped, float x, float y, float z) { invoke<Void>(0x0B374EC5, ped, x, y, z); } // unused
	static void OPEN_PATROL_ROUTE(char* patrolRouteName) { invoke<Void>(0xF33F83CA, patrolRouteName); } // unused
	static void CLOSE_PATROL_ROUTE() { invoke<Void>(0x67305E59); } // unused
	static void ADD_PATROL_ROUTE_NODE(int p0, char* p1, float x1, float y1, float z1, float x2, float y2, float z2, int p8) { invoke<Void>(0x21B48F10, p0, p1, x1, y1, z1, x2, y2, z2, p8); } // unused
	static void ADD_PATROL_ROUTE_LINK(int p0, int p1) { invoke<Void>(0xD8761BB3, p0, p1); } // unused
	static void CREATE_PATROL_ROUTE() { invoke<Void>(0x0A6C7864); } // unused
	static void DELETE_PATROL_ROUTE(char* patrolRouteName) { invoke<Void>(0x2A4E6706, patrolRouteName); } // unused
	static BOOL GET_PATROL_TASK_INFO(Ped ped, Any* p1, Any* p2) { return invoke<BOOL>(0xFED7AA39, ped, p1, p2); } // unused
	static void TASK_PATROL(Ped ped, char* patrolRouteName, int p2, BOOL p3, BOOL p4) { invoke<Void>(0xB92E5AF6, ped, patrolRouteName, p2, p3, p4); } // unused
	static Any ADD_VEHICLE_SUBTASK_ATTACK_COORD() { return invoke<Any>(0x50779A2C); } // unused
	static Any ADD_VEHICLE_SUBTASK_ATTACK_PED() { return invoke<Any>(0x80461113); } // unused
	static Any ADD_VEHICLE_SUBTASK_STRAFE_COORDS() { return invoke<Any>(0xDDA8AA23); } // unused
	static void TASK_VEHICLE_SHOOT_AT_PED(Any p0, Any p1) { invoke<Void>(0x59677BA0, p0, p1); }
	static void TASK_VEHICLE_SHOOT_AT_COORD(Any p0, Any p1, Any p2, Any p3) { invoke<Void>(0xA7AAA4D6, p0, p1, p2, p3); }
	static void TASK_HANG_GLIDER(Ped ped, Object object) { invoke<Void>(0xA0A33F8A, ped, object); } // unused
	static void SET_HANG_GLIDER_AIR_SPEED(Ped ped, float p1, float p2, float p3) { invoke<Void>(0x300EF97E, ped, p1, p2, p3); } // unused
	static void TASK_GO_TO_COORD_WHILE_AIMING_AT_COORD(Any p0, Any p1, Any p2, Any p3, Any p4, Any p5, Any p6, Any p7, Any p8, Any p9, Any p10, Any p11, Any p12) { invoke<Void>(0x1552DC91, p0, p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12); }
	static void TASK_GO_TO_COORD_WHILE_AIMING_AT_PED(Any p0, Any p1, Any p2, Any p3, Any p4, Any p5, Any p6, Any p7, Any p8, Any p9, Any p10) { invoke<Void>(0x19E32C2E, p0, p1, p2, p3, p4, p5, p6, p7, p8, p9, p10); }
	static void TASK_GO_TO_COORD_WHILE_AIMING_AT_VEHICLE(Any p0, Any p1, Any p2, Any p3, Any p4, Any p5, Any p6, Any p7, Any p8, Any p9, Any p10) { invoke<Void>(0x56B67746, p0, p1, p2, p3, p4, p5, p6, p7, p8, p9, p10); }
	static Any TASK_GO_TO_COORD_WHILE_AIMING_AT_OBJECT() { return invoke<Any>(0xEA0E01E5); } // unused
	static Any TASK_GO_TO_PED_WHILE_AIMING_AT_COORD() { return invoke<Any>(0x4DF287BB); } // unused
	static void TASK_GO_TO_PED_WHILE_AIMING_AT_PED(Any p0, Any p1, Any p2, Any p3, Any p4, Any p5, Any p6, Any p7, Any p8) { invoke<Void>(0x7068FC67, p0, p1, p2, p3, p4, p5, p6, p7, p8); }
	static Any TASK_GO_TO_PED_WHILE_AIMING_AT_VEHICLE() { return invoke<Any>(0x572F5FDF); } // unused
	static Any TASK_GO_TO_PED_WHILE_AIMING_AT_OBJECT() { return invoke<Any>(0x1A817446); } // unused
	static void TASK_SET_BLOCKING_OF_NON_TEMPORARY_EVENTS(Ped ped, BOOL toggle) { invoke<Void>(0x1B54FB6B, ped, toggle); }
	static void TASK_SET_BLOCKING_OF_PED_TARGETTING(Ped ped, BOOL toggle) { invoke<Void>(0xC8CC8A7E, ped, toggle); }
	static void TASK_SET_PLAYER_CONTROL(Ped ped, BOOL p1, int p2) { invoke<Void>(0x834490D1, ped, p1, p2); } // unused
	static void TASK_CAUTIOUS_MOVETO(Ped ped, float x, float y, float z) { invoke<Void>(0x77B12033, ped, x, y, z); } // unused
	static void TASK_ATTACK_MOVE(Ped ped, float p1, float p2, float p3, float p4, float p5, float p6, int p7) { invoke<Void>(0x72EA9C48, ped, p1, p2, p3, p4, p5, p6, p7); }
	static void TASK_ATTACK_MOVE_WHILE_AIMING_AT_PED(Ped ped, float p1, float p2, float p3, Ped ped2, BOOL p5, float p6, float p7, float p8, int p9) { invoke<Void>(0x1AD378CB, ped, p1, p2, p3, ped2, p5, p6, p7, p8, p9); }
	static void TASK_ATTACK_MOVE_WHILE_AIMING_AT_COORD(Ped ped, float p1, float p2, float p3, float p4, float p5, float p6, BOOL p7, float p8, float p9, float p10, int p11) { invoke<Void>(0xA08CC22F, ped, p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11); }
	static void TASK_USE_NEAREST_MOUNTED_WEAPON(Ped ped) { invoke<Void>(0xB9F6EB6C, ped); }
	static void TASK_DEFAULT_AIM_AT_PED(Ped ped, Ped targetPed) { invoke<Void>(0x806DCEC3, ped, targetPed); } // unused
	static void TASK_DEFAULT_AIM_AT_COORD(Ped ped, float x, float y, float z) { invoke<Void>(0x24190EC9, ped, x, y, z); }
	static void TASK_DEFAULT_AIM_AHEAD(Ped ped) { invoke<Void>(0x5748EDC0, ped); } // unused
	static void TASK_CLEAR_DEFAULT_AIM(Ped ped) { invoke<Void>(0x009F9B15, ped); } // unused
	static void TASK_SURRENDER(Ped ped, Ped targetPed, float heading) { invoke<Void>(0xC5FA9CD6, ped, targetPed, heading); }
	static void TASK_MELEE_LITE(Ped ped, Ped targetPed, BOOL p2) { invoke<Void>(0x91BAB133, ped, targetPed, p2); }
	static void SET_AI_PROJECTILE_THROW_USE_ACTION_TREE(BOOL toggle) { invoke<Void>(0x9E17D62C, toggle); } // unused
	static void SET_PROJECTILE_THROW_USE_DAMPING_COMPENSATION(BOOL toggle) { invoke<Void>(0xBA40DC95, toggle); }
	static void SET_AI_PROJECTILE_THROW_ENABLED(BOOL toggle) { invoke<Void>(0xEB576EAB, toggle); }
	static void TASK_REACT_INITIAL(Ped ped, Ped ped2) { invoke<Void>(0x43A09C27, ped, ped2); }
	static void TASK_SEARCH_FOR_UNSEEN_ENEMY(Ped ped, BOOL p1) { invoke<Void>(0x5246FFFA, ped, p1); }
	static void TASK_SEARCH_FOR_PED_AT_COVER_POINT(Ped ped, char* p1, char* p2, BOOL p3) { invoke<Void>(0x72C2B487, ped, p1, p2, p3); }
	static void TASK_MELEE_GRAPPLE(Ped ped, Ped targetPed, BOOL p2) { invoke<Void>(0x51B6927F, ped, targetPed, p2); }
	static void SET_MELEE_GRAPPLE_FAIL(Ped ped) { invoke<Void>(0xE7360DE9, ped); } // unused
	static void SET_MELEE_GRAPPLE_SUCCESS(Ped ped) { invoke<Void>(0xF8251BF3, ped); } // unused
	static BOOL GET_MELEE_GRAPPLE_FAIL_CHECK_ON(Ped ped) { return invoke<BOOL>(0xAE5FA062, ped); } // unused
	static void TASK_SET_ACTION_INTENTION(Ped ped, int p1, int p2, int p3) { invoke<Void>(0x2E56473E, ped, p1, p2, p3); }
	static void TASK_SHOOTDODGE(Ped ped, BOOL p1, float p2, float p3) { invoke<Void>(0x1DBC90B4, ped, p1, p2, p3); }
	static void _0xED42DFFC(float p0) { invoke<Void>(0xED42DFFC, p0); }
}

namespace VEHICLE
{
	static void SET_VEHICLE_AS_ENTITY_SYNC_POINT(Vehicle vehicle, Ped ped) { invoke<Void>(0xAEB6D2DE, vehicle, ped); }
	static void SET_TRAFFIC_SYSTEM(BOOL toggle) { invoke<Void>(0xB0ABF560, toggle); }
	static Vehicle CREATE_VEHICLE(Hash modelHash, float x, float y, float z, float heading, BOOL isNetwork, BOOL dontOwn) { return invoke<Vehicle>(0xDD75460A, modelHash, x, y, z, heading, isNetwork, dontOwn); }
	static void DELETE_VEHICLE(Vehicle* vehicle) { invoke<Void>(0x9803AF60, vehicle); }
	static void REMOVE_VEHICLE_FROM_PARKED_VEHICLES_BUDGET(Vehicle vehicle, BOOL toggle) { invoke<Void>(0xF8CFFB40, vehicle, toggle); } // unused
	static void SET_VEHICLE_IN_CUTSCENE(Vehicle vehicle, BOOL toggle) { invoke<Void>(0x25533564, vehicle, toggle); }
	static Vector3 GET_VEHICLE_COORDS(Vehicle vehicle) { return invoke<Vector3>(0x01935124, vehicle); }
	static Vector3 GET_DEAD_VEHICLE_COORDS(Vehicle vehicle) { return invoke<Vector3>(0x3C076D19, vehicle); } // unused
	static void SET_VEHICLE_COORDS(Vehicle vehicle, float x, float y, float z) { invoke<Void>(0x54C9AD1D, vehicle, x, y, z); }
	static int GET_VEHICLE_BONE_INDEX(Vehicle vehicle, char* boneName) { return invoke<int>(0x235C4335, vehicle, boneName); } // unused
	static BOOL IS_VEHICLE_IN_AREA(Vehicle vehicle, float x1, float y1, float z1, float x2, float y2, float z2, BOOL p7, BOOL p8) { return invoke<BOOL>(0xEAC5449E, vehicle, x1, y1, z1, x2, y2, z2, p7, p8); } // unused
	static BOOL IS_VEHICLE_DEAD(Vehicle vehicle) { return invoke<BOOL>(0x95D58E26, vehicle); }
	static BOOL IS_VEHICLE_MODEL(Vehicle vehicle, Hash modelHash) { return invoke<BOOL>(0x013B10B6, vehicle, modelHash); } // unused
	static int CREATE_SCRIPT_VEHICLE_GENERATOR(float x, float y, float z, float heading, float p4, float p5, Hash modelHash, int p7, int p8, int p9, int p10, BOOL p11, int p12, int p13) { return invoke<int>(0x25A9A261, x, y, z, heading, p4, p5, modelHash, p7, p8, p9, p10, p11, p12, p13); } // unused
	static void DELETE_SCRIPT_VEHICLE_GENERATOR(int scriptVehicleGenerator) { invoke<Void>(0xE4328E3F, scriptVehicleGenerator); } // unused
	static void SET_SCRIPT_VEHICLE_GENERATOR(int scriptVehicleGenerator, int p1) { invoke<Void>(0x40D73747, scriptVehicleGenerator, p1); } // unused
	static void SET_ALL_VEHICLE_GENERATORS_ACTIVE_IN_AREA(float x1, float y1, float z1, float x2, float y2, float z2, BOOL toggle) { invoke<Void>(0xB4E0E69A, x1, y1, z1, x2, y2, z2, toggle); } // unused
	static void SET_ALL_VEHICLE_GENERATORS_ACTIVE() { invoke<Void>(0xAB1FDD76); } // unused
	static void SET_ALL_LOW_PRIORITY_VEHICLE_GENERATORS_ACTIVE(BOOL toggle) { invoke<Void>(0x87F767F2, toggle); } // unused
	static void NETWORK_SET_ALL_LOW_PRIORITY_VEHICLE_GENERATORS_WITH_HELI_ACTIVE(BOOL toggle) { invoke<Void>(0x35A050E1, toggle); } // unused
	static float GET_VEHICLE_HEADING(Vehicle vehicle) { return invoke<float>(0x4155B124, vehicle); }
	static void SET_VEHICLE_HEADING(Vehicle vehicle, float heading) { invoke<Void>(0x3E502113, vehicle, heading); }
	static BOOL SET_VEHICLE_ON_GROUND_PROPERLY(Vehicle vehicle) { return invoke<BOOL>(0xE14FDBA6, vehicle); }
	static BOOL IS_VEHICLE_STUCK_ON_ROOF(Vehicle vehicle) { return invoke<BOOL>(0x18D07C6C, vehicle); } // unused
	static void ADD_VEHICLE_UPSIDEDOWN_CHECK(Vehicle vehicle) { invoke<Void>(0x3A13D384, vehicle); } // unused
	static void REMOVE_VEHICLE_UPSIDEDOWN_CHECK(Vehicle vehicle) { invoke<Void>(0xF390BA1B, vehicle); } // unused
	static BOOL IS_VEHICLE_AT_COORD(Vehicle vehicle, float xPos, float yPos, float zPos, float xSize, float ySize, float zSize, BOOL p7, BOOL p8) { return invoke<BOOL>(0x8BC9D2F9, vehicle, xPos, yPos, zPos, xSize, ySize, zSize, p7, p8); } // unused
	static BOOL IS_VEHICLE_STOPPED(Vehicle vehicle) { return invoke<BOOL>(0x655F072C, vehicle); } // unused
	static void SET_VEHICLE_AS_NO_LONGER_NEEDED(Vehicle* vehicle) { invoke<Void>(0x9B0E10BE, vehicle); } // unused
	static int GET_VEHICLE_NUMBER_OF_PASSENGERS(Vehicle vehicle) { return invoke<int>(0x1EF20849, vehicle); } // unused
	static int GET_VEHICLE_MAX_NUMBER_OF_PASSENGERS(Vehicle vehicle) { return invoke<int>(0x0A2FC08C, vehicle); } // unused
	static void SET_VEHICLE_DENSITY_MULTIPLIER(float multiplier) { invoke<Void>(0x8B289F79, multiplier); } // unused
	static void SET_RANDOM_VEHICLE_DENSITY_MULTIPLIER(float multiplier) { invoke<Void>(0x876A0BCE, multiplier); } // unused
	static void SET_PARKED_VEHICLE_DENSITY_MULTIPLIER(float multiplier) { invoke<Void>(0x98E5C8A7, multiplier); } // unused
	static void SET_NUMBER_OF_PARKED_VEHICLES(int value) { invoke<Void>(0x206A58E8, value); } // unused
	static BOOL IS_VEHICLE_IN_AIR_PROPER(Vehicle vehicle) { return invoke<BOOL>(0x36DA3EB9, vehicle); } // unused
	static BOOL IS_VEHICLE_UPSIDEDOWN(Vehicle vehicle) { return invoke<BOOL>(0xD45346E7, vehicle); }
	static void SET_VEHICLE_DOORS_LOCKED(Vehicle vehicle, int status) { invoke<Void>(0x4CDD35D0, vehicle, status); }
	static void EXPLODE_VEHICLE(Vehicle vehicle, BOOL p1, BOOL p2) { invoke<Void>(0xBEDEACEB, vehicle, p1, p2); }
	static BOOL IS_VEHICLE_UPRIGHT(Vehicle vehicle) { return invoke<BOOL>(0x3E5E91E4, vehicle); }
	static void SET_TAXI_LIGHTS(Vehicle vehicle, BOOL toggle) { invoke<Void>(0x68639D85, vehicle, toggle); } // unused
	static BOOL IS_TAXI_LIGHT_ON(Vehicle vehicle) { return invoke<BOOL>(0x6FC4924A, vehicle); } // unused
	static void SET_VEHICLE_HEALTH(Vehicle vehicle, int health) { invoke<Void>(0x3BCB0EA4, vehicle, health); }
	static int GET_VEHICLE_HEALTH(Vehicle vehicle) { return invoke<int>(0x3FBCAEB5, vehicle); }
	static void SET_VEHICLE_COLOURS(Vehicle vehicle, int primaryColor, int secondaryColor) { invoke<Void>(0x57F24253, vehicle, primaryColor, secondaryColor); } // unused
	static void SET_CAN_RESPRAY_VEHICLE(Vehicle vehicle, BOOL toggle) { invoke<Void>(0x37677590, vehicle, toggle); } // unused
	static void SET_VEHICLE_ONLY_DAMAGED_BY_PLAYER(Vehicle vehicle, BOOL toggle) { invoke<Void>(0x5F6A171F, vehicle, toggle); }
	static void SET_VEHICLE_ONLY_DAMAGED_BY_RELATIONSHIP_GROUP(Vehicle vehicle, BOOL toggle, int relGroupId) { invoke<Void>(0x5A7B778A, vehicle, toggle, relGroupId); } // unused
	static void SET_VEHICLE_PROOFS(Vehicle vehicle, BOOL p1, BOOL p2, BOOL p3, BOOL p4, BOOL p5) { invoke<Void>(0x23448784, vehicle, p1, p2, p3, p4, p5); }
	static BOOL IS_VEHICLE_IN_WATER(Vehicle vehicle) { return invoke<BOOL>(0x20B649B6, vehicle); }
	static BOOL IS_VEHICLE_ON_SCREEN(Vehicle vehicle) { return invoke<BOOL>(0x485E14C0, vehicle); }
	static float GET_VEHICLE_SPEED(Vehicle vehicle) { return invoke<float>(0x9B115A40, vehicle); }
	static float GET_VEHICLE_FORWARD_X(Vehicle vehicle) { return invoke<float>(0x48F59C5E, vehicle); } // unused
	static float GET_VEHICLE_FORWARD_Y(Vehicle vehicle) { return invoke<float>(0x780C7A8B, vehicle); } // unused
	static void SET_BOAT_ANCHOR(Vehicle boat, BOOL toggle) { invoke<Void>(0xA3906284, boat, toggle); } // unused
	static void SET_VEHICLE_VISIBLE(Vehicle vehicle, BOOL toggle) { invoke<Void>(0x033C606E, vehicle, toggle); }
	static void SET_VEHICLE_SIREN(Vehicle vehicle, BOOL toggle) { invoke<Void>(0x4AC1EFC7, vehicle, toggle); }
	static int GET_VEHICLE_SIREN_HEALTH(Vehicle vehicle) { return invoke<int>(0x64F0CA0B, vehicle); } // unused
	static BOOL IS_VEHICLE_SIREN_ON(Vehicle vehicle) { return invoke<BOOL>(0x25EB5873, vehicle); } // unused
	static void SET_VEHICLE_TURNS_TO_FACE_COORD(Vehicle vehicle, float x, float y) { invoke<Void>(0x9F751407, vehicle, x, y); } // unused
	static void SET_VEHICLE_STRONG(Vehicle vehicle, BOOL toggle) { invoke<Void>(0xC758D19F, vehicle, toggle); }
	static void ADD_VEHICLE_STUCK_CHECK(Vehicle vehicle, float p1, int p2) { invoke<Void>(0x3619F647, vehicle, p1, p2); } // unused
	static void REMOVE_VEHICLE_STUCK_CHECK(Vehicle vehicle) { invoke<Void>(0x81594917, vehicle); } // unused
	static void GET_VEHICLE_COLOURS(Vehicle vehicle, int* primaryColor, int* secondaryColor) { invoke<Void>(0x40D82D88, vehicle, primaryColor, secondaryColor); } // unused
	static void SET_ALL_VEHICLES_CAN_BE_DAMAGED(BOOL value) { invoke<Void>(0x74BF2EAA, value); } // unused
	static void SET_VEHICLE_CAN_BE_DAMAGED(Vehicle vehicle, BOOL toggle) { invoke<Void>(0x2386C5B7, vehicle, toggle); }
	static void SET_VEHICLE_ENGINE_CAN_BE_DAMAGED(Vehicle vehicle, BOOL toggle) { invoke<Void>(0x5AAB9674, vehicle, toggle); }
	static void SET_VEHICLE_ONLY_EXPLODES_WHEN_HIT_BY_MULTIPLE_EXPLOSIONS(Vehicle vehicle, BOOL toggle, int p2) { invoke<Void>(0x2A61C5E7, vehicle, toggle, p2); }
	static Vector3 GET_OFFSET_FROM_VEHICLE_IN_WORLD_COORDS(Vehicle vehicle, float offsetX, float offsetY, float offsetZ) { return invoke<Vector3>(0x724D8621, vehicle, offsetX, offsetY, offsetZ); } // unused
	static Vector3 GET_OFFSET_FROM_VEHICLE_GIVEN_WORLD_COORDS(Vehicle vehicle, float offsetX, float offsetY, float offsetZ) { return invoke<Vector3>(0x912027D9, vehicle, offsetX, offsetY, offsetZ); }
	static BOOL IS_VEHICLE_SEAT_FREE(Vehicle vehicle, int seatIndex) { return invoke<BOOL>(0xDAF42B02, vehicle, seatIndex); }
	static Ped GET_PED_IN_VEHICLE_SEAT(Vehicle vehicle, int seatIndex) { return invoke<Ped>(0x388FDE9A, vehicle, seatIndex); }
	static Hash GET_VEHICLE_MODEL(Vehicle vehicle) { return invoke<Hash>(0x70FB6D3A, vehicle); }
	static void SET_VEHICLE_RANDOM_ROUTE_SEED(Vehicle vehicle, int seed) { invoke<Void>(0x18271E90, vehicle, seed); } // unused
	static BOOL IS_VEHICLE_ON_FIRE(Vehicle vehicle) { return invoke<BOOL>(0x9818A08C, vehicle); }
	static void STOP_VEHICLE_FIRE(Vehicle vehicle) { invoke<Void>(0xCEC13B6B, vehicle); }
	static BOOL IS_VEHICLE_TYRE_BURST(Vehicle vehicle, int tireIndex) { return invoke<BOOL>(0x48C80210, vehicle, tireIndex); }
	static void SET_VEHICLE_FORWARD_SPEED(Vehicle vehicle, float speed) { invoke<Void>(0x69880D14, vehicle, speed); }
	static void SET_VEHICLE_AS_CONVOY_VEHICLE(Vehicle vehicle, BOOL toggle) { invoke<Void>(0x2CF62ABD, vehicle, toggle); } // unused
	static void SET_VEHICLE_CONTROL_TO_PLAYER(Vehicle vehicle) { invoke<Void>(0x6BC7338F, vehicle); } // unused
	static void SET_CAR_BOOT_OPEN(Vehicle car) { invoke<Void>(0x72E346DD, car); } // unused
	static BOOL IS_VEHICLE_WAITING_FOR_WORLD_COLLISION(Vehicle vehicle) { return invoke<BOOL>(0x4BEF6ADD, vehicle); } // unused
	static void SET_VEHICLE_TYRE_BURST(Vehicle vehicle, int tire) { invoke<Void>(0x89D28068, vehicle, tire); } // unused
	static void SET_VEHICLE_DOORS_SHUT(Vehicle vehicle) { invoke<Void>(0xBB1FF6E7, vehicle); } // unused
	static void FREEZE_VEHICLE_POSITION(Vehicle vehicle, BOOL toggle) { invoke<Void>(0x1112EFCE, vehicle, toggle); }
	static void SET_VEHICLE_NOT_EXPLODABLE(Vehicle vehicle, BOOL toggle) { invoke<Void>(0x5F2B2A1C, vehicle, toggle); }
	static BOOL HAS_VEHICLE_BEEN_DAMAGED_BY_PED(Vehicle vehicle, Ped ped) { return invoke<BOOL>(0x4C5F25C0, vehicle, ped); } // unused
	static BOOL HAS_VEHICLE_BEEN_DAMAGED_BY_VEHICLE(Vehicle vehicle, Vehicle vehicle2) { return invoke<BOOL>(0xBCE93004, vehicle, vehicle2); } // unused
	static Vehicle GET_RANDOM_VEHICLE_OF_TYPE_IN_AREA(float x, float y, float z, float radius, Hash modelHash) { return invoke<Vehicle>(0x2FA2DADF, x, y, z, radius, modelHash); } // unused
	static void SET_VEHICLE_TYRES_CAN_BURST(Vehicle vehicle, BOOL toggle) { invoke<Void>(0xA198DB54, vehicle, toggle); } // unused
	static void CLEAR_VEHICLE_LAST_DAMAGE_ENTITY(Vehicle vehicle) { invoke<Void>(0xC041027A, vehicle); } // unused
	static BOOL DOES_VEHICLE_EXIST(Vehicle vehicle) { return invoke<BOOL>(0x8737CC23, vehicle); }
	static void FREEZE_VEHICLE_POSITION_AND_DONT_LOAD_COLLISION(Vehicle vehicle, BOOL toggle) { invoke<Void>(0xBF3DF0C9, vehicle, toggle); } // unused
	static void SET_LOAD_COLLISION_FOR_VEHICLE_FLAG(Vehicle vehicle, BOOL flag) { invoke<Void>(0x3AEC5728, vehicle, flag); }
	static Any START_RECORDING_VEHICLE() { return invoke<Any>(0x50117078); } // unused
	static Any START_RECORDING_VEHICLE_TRANSITION_FROM_PLAYBACK() { return invoke<Any>(0x1BDB2B3C); } // unused
	static Any STOP_RECORDING_ALL_VEHICLES() { return invoke<Any>(0x9A9A3735); } // unused
	static void START_PLAYBACK_RECORDED_VEHICLE_USING_AI(Vehicle vehicle, int recordingIndex) { invoke<Void>(0x8DE8E24E, vehicle, recordingIndex); } // unused
	static void REQUEST_VEHICLE_RECORDING(int recordingIndex) { invoke<Void>(0x91AFEFD9, recordingIndex); }
	static void REMOVE_VEHICLE_RECORDING(int recordingIndex) { invoke<Void>(0xD3C05B00, recordingIndex); }
	static void START_PLAYBACK_RECORDED_VEHICLE(Vehicle vehicle, int recordingIndex) { invoke<Void>(0xCF614CA8, vehicle, recordingIndex); }
	static void STOP_PLAYBACK_RECORDED_VEHICLE(Vehicle vehicle) { invoke<Void>(0xAE99C57C, vehicle); }
	static void PAUSE_PLAYBACK_RECORDED_VEHICLE(Vehicle vehicle) { invoke<Void>(0xCCF54912, vehicle); }
	static void UNPAUSE_PLAYBACK_RECORDED_VEHICLE(Vehicle vehicle) { invoke<Void>(0x59060F75, vehicle); }
	static void SET_PLAYBACK_SPEED(Vehicle vehicle, float speed) { invoke<Void>(0x684E26E4, vehicle, speed); }
	static void SKIP_TIME_IN_PLAYBACK_RECORDED_VEHICLE(Vehicle vehicle, float time) { invoke<Void>(0xCF3EFA4B, vehicle, time); }
	static BOOL IS_PLAYBACK_GOING_ON_FOR_VEHICLE(Vehicle vehicle) { return invoke<BOOL>(0x61F7650D, vehicle); }
	static BOOL IS_PLAYBACK_USING_AI_GOING_ON_FOR_VEHICLE(Vehicle vehicle) { return invoke<BOOL>(0x63022C58, vehicle); } // unused
	static int GET_CURRENT_PLAYBACK_NUMBER_FOR_VEHICLE(Vehicle vehicle) { return invoke<int>(0x748702A9, vehicle); }
	static float GET_POSITION_IN_RECORDING(Vehicle vehicle) { return invoke<float>(0x7DCD644C, vehicle); } // unused
	static float GET_TIME_POSITION_IN_RECORDING(Vehicle vehicle) { return invoke<float>(0xF8C3E4A2, vehicle); }
	static float GET_TIME_POSITION_IN_RECORDED_RECORDING(Any p0) { return invoke<float>(0xF6C0D8CA, p0); } // unused
	static float GET_TOTAL_DURATION_OF_VEHICLE_RECORDING(int recordingIndex) { return invoke<float>(0x5B35EEB7, recordingIndex); }
	static void SET_VEHICLE_DOOR_OPEN(Vehicle vehicle, int door) { invoke<Void>(0xBB75D38B, vehicle, door); }
	static void REMOVE_VEHICLE_WINDOW(Vehicle vehicle, int window) { invoke<Void>(0xBB8104A3, vehicle, window); }
	static void SMASH_VEHICLE_WINDOW(Vehicle vehicle, int window) { invoke<Void>(0xDDD9A8C2, vehicle, window); } // unused
	static void SET_VEHICLE_LIGHTS(Vehicle vehicle, int state) { invoke<Void>(0xE8930226, vehicle, state); }
	static void SET_VEHICLE_ALARM(Vehicle vehicle, BOOL state) { invoke<Void>(0x24877D84, vehicle, state); } // unused
	static void START_VEHICLE_ALARM(Vehicle vehicle) { invoke<Void>(0x5B451FF7, vehicle); } // unused
	static void SET_VEHICLE_INTERIORLIGHT(Vehicle vehicle, BOOL toggle) { invoke<Void>(0x9AD1FE1E, vehicle, toggle); }
	static void SET_VEHICLE_LIGHT_MULTIPLIER(Vehicle vehicle, float multiplier) { invoke<Void>(0x48039D6A, vehicle, multiplier); }
	static BOOL ARE_VEHICLE_HEADLIGHTS_BROKEN(Vehicle vehicle) { return invoke<BOOL>(0xE9C0A5A0, vehicle); } // unused
	static BOOL IS_LEFT_VEHICLE_HEADLIGHT_BROKEN(Vehicle vehicle) { return invoke<BOOL>(0x49A6D893, vehicle); } // unused
	static BOOL IS_RIGHT_VEHICLE_HEADLIGHT_BROKEN(Vehicle vehicle) { return invoke<BOOL>(0x9D508577, vehicle); } // unused
	static void ATTACH_VEHICLE_TO_VEHICLE(Vehicle vehicle1, Vehicle vehicle2, int bone, float xPos, float yPos, float zPos, float xRot, float yRot, float zRot) { invoke<Void>(0x016B0817, vehicle1, vehicle2, bone, xPos, yPos, zPos, xRot, yRot, zRot); } // unused
	static void ATTACH_VEHICLE_TO_VEHICLE_PHYSICALLY(Vehicle vehicle1, Vehicle vehicle2, int bone1, int bone2, float xPos1, float yPos1, float zPos1, float xPos2, float yPos2, float zPos2, float xRot, float yRot, float zRot, float breakForce, BOOL fixedRot) { invoke<Void>(0x9C548435, vehicle1, vehicle2, bone1, bone2, xPos1, yPos1, zPos1, xPos2, yPos2, zPos2, xRot, yRot, zRot, breakForce, fixedRot); } // unused
	static void ATTACH_VEHICLE_TO_OBJECT(Vehicle vehicle, Object object, int bone, float xPos, float yPos, float zPos, float xRot, float yRot, float zRot) { invoke<Void>(0x0923DE0E, vehicle, object, bone, xPos, yPos, zPos, xRot, yRot, zRot); } // unused
	static void DETACH_VEHICLE(Vehicle vehicle) { invoke<Void>(0xCDDBE650, vehicle); } // unused
	static BOOL IS_VEHICLE_ATTACHED(Vehicle vehicle) { return invoke<BOOL>(0x65ECB112, vehicle); } // unused
	static void SET_VEHICLE_TYRE_FIXED(Vehicle vehicle, int tire) { invoke<Void>(0xA42EFA6B, vehicle, tire); } // unused
	static Vector3 GET_VEHICLE_SPEED_VECTOR(Vehicle vehicle, BOOL relative) { return invoke<Vector3>(0x2E52BB9A, vehicle, relative); }
	static Vector3 GET_VEHICLE_FORWARD_VECTOR(Vehicle vehicle) { return invoke<Vector3>(0xEE053B15, vehicle); }
	static BOOL IS_RECORDING_GOING_ON_FOR_VEHICLE(Vehicle vehicle) { return invoke<BOOL>(0x19F57601, vehicle); }
	static float GET_VEHICLE_ROLL(Vehicle vehicle) { return invoke<float>(0xD48A9E8B, vehicle); } // unused
	static void SKIP_TO_END_AND_STOP_PLAYBACK_RECORDED_VEHICLE(Vehicle vehicle) { invoke<Void>(0x8DEA18C8, vehicle); }
	static void SET_RANDOM_TRAINS(BOOL toggle) { invoke<Void>(0xD461CA7F, toggle); } // unused
	static Vehicle CREATE_MISSION_TRAIN(int variation, float x, float y, float z, BOOL direction) { return invoke<Vehicle>(0xD4C2EAFD, variation, x, y, z, direction); }
	static void SET_MISSION_TRAINS_AS_NO_LONGER_NEEDED() { invoke<Void>(0x22BEB86E); } // unused
	static void DELETE_ALL_TRAINS() { invoke<Void>(0x83DE7ABF); } // unused
	static void SET_TRAIN_SPEED(Vehicle train, float speed) { invoke<Void>(0xDFC35E4D, train, speed); }
	static void SET_TRAIN_CRUISE_SPEED(Vehicle train, float speed) { invoke<Void>(0xB507F51D, train, speed); }
	static Vehicle GET_TRAIN_CABOOSE(Vehicle train) { return invoke<Vehicle>(0xD717AD46, train); }
	static void SET_TRAIN_STOPS_FOR_STATIONS(Vehicle train, BOOL toggle) { invoke<Void>(0x43E5F109, train, toggle); }
	static void SET_TRAIN_IS_STOPPED_AT_STATION(Vehicle train) { invoke<Void>(0xE276A20D, train); } // unused
	static void SET_TRAIN_LEAVES_STATION(Vehicle train) { invoke<Void>(0x4438873D, train); }
	static void SET_RANDOM_BOATS(BOOL toggle) { invoke<Void>(0xB505BD89, toggle); } // unused
	static void SET_GARBAGE_TRUCKS(BOOL toggle) { invoke<Void>(0xD9ABB0FF, toggle); } // unused
	static BOOL DOES_VEHICLE_HAVE_STUCK_VEHICLE_CHECK(Vehicle vehicle) { return invoke<BOOL>(0x5D91D9AC, vehicle); } // unused
	static void EXPLODE_VEHICLE_IN_CUTSCENE(Vehicle vehicle, BOOL p1) { invoke<Void>(0xA85207B5, vehicle, p1); } // unused
	static void ADD_VEHICLE_STUCK_CHECK_WITH_WARP(Vehicle vehicle, float p1, int p2, BOOL p3, BOOL p4, BOOL p5, int p6) { invoke<Void>(0xC8B789AD, vehicle, p1, p2, p3, p4, p5, p6); } // unused
	static void SET_VEHICLE_MODEL_IS_SUPPRESSED(Hash modelHash, BOOL toggle) { invoke<Void>(0x42A08C9B, modelHash, toggle); } // unused
	static Vehicle GET_RANDOM_VEHICLE_IN_SPHERE(float x, float y, float z, float radius, Hash modelHash, int flags) { return invoke<Vehicle>(0x57216D03, x, y, z, radius, modelHash, flags); } // unused
	static Vehicle GET_RANDOM_VEHICLE_FRONT_BUMPER_IN_SPHERE(float x, float y, float z, float radius, Hash modelHash, int flags) { return invoke<Vehicle>(0xDCADEB66, x, y, z, radius, modelHash, flags); } // unused
	static Vehicle GET_RANDOM_VEHICLE_BACK_BUMPER_IN_SPHERE(float x, float y, float z, float radius, Hash modelHash, int flags) { return invoke<Vehicle>(0xD6343F6B, x, y, z, radius, modelHash, flags); } // unused
	static Vehicle GET_CLOSEST_VEHICLE(float x, float y, float z, float radius, Hash modelHash, int flags) { return invoke<Vehicle>(0xD7E26B2C, x, y, z, radius, modelHash, flags); } // unused
	static Any STOP_RECORDING_VEHICLE() { return invoke<Any>(0x3ED10195); } // unused
	static void SET_VEHICLE_AS_MISSION_VEHICLE(Vehicle vehicle) { invoke<Void>(0x73FA1219, vehicle); }
	static float GET_VEHICLE_PITCH(Vehicle vehicle) { return invoke<float>(0x2680C924, vehicle); } // unused
	static Vehicle GET_TRAIN_CARRIAGE(Vehicle train, int carriage) { return invoke<Vehicle>(0x2544E7A6, train, carriage); }
	static void SET_HELI_SPEED_CHEAT(Vehicle heli, BOOL toggle) { invoke<Void>(0xA694F55D, heli, toggle); } // unused
	static void DELETE_MISSION_TRAIN(Vehicle train) { invoke<Void>(0x86C9497D, train); }
	static void SET_MISSION_TRAIN_AS_NO_LONGER_NEEDED(Vehicle train) { invoke<Void>(0x19808560, train); } // unused
	static BOOL HAS_VEHICLE_RECORDING_BEEN_LOADED(int recordingIndex) { return invoke<BOOL>(0xF52CD7F5, recordingIndex); }
	static Any DISPLAY_PLAYBACK_RECORDED_VEHICLE() { return invoke<Any>(0x894D590B); } // unused
	static void GET_VEHICLE_QUATERNION(Vehicle vehicle, float* x, float* y, float* z, float* w) { invoke<Void>(0xD30891FA, vehicle, x, y, z, w); } // unused
	static void SET_VEHICLE_QUATERNION(Vehicle vehicle, float x, float y, float z, float w) { invoke<Void>(0x7A5B849E, vehicle, x, y, z, w); } // unused
	static void SET_MISSION_TRAIN_COORDS(Vehicle train, float x, float y, float z) { invoke<Void>(0xD6D70803, train, x, y, z); }
	static void APPLY_FORCE_TO_VEHICLE(Vehicle vehicle, int forceType, float forceX, float forceY, float forceZ, float offX, float offY, float offZ, int bone, BOOL isDirectionRel, BOOL ignoreUpVec, BOOL isForceRel) { invoke<Void>(0x3130AB0A, vehicle, forceType, forceX, forceY, forceZ, offX, offY, offZ, bone, isDirectionRel, ignoreUpVec, isForceRel); }
	static BOOL IS_THIS_MODEL_A_BOAT(Hash modelHash) { return invoke<BOOL>(0x10F6085C, modelHash); } // unused
	static BOOL IS_THIS_MODEL_A_PLANE(Hash modelHash) { return invoke<BOOL>(0x3B3907BB, modelHash); } // unused
	static BOOL IS_THIS_MODEL_A_HELI(Hash modelHash) { return invoke<BOOL>(0x8AF7F568, modelHash); } // unused
	static BOOL IS_THIS_MODEL_A_CAR(Hash modelHash) { return invoke<BOOL>(0x60E4C22F, modelHash); } // unused
	static BOOL IS_THIS_MODEL_A_TRAIN(Hash modelHash) { return invoke<BOOL>(0xF87DCFFD, modelHash); } // unused
	static BOOL IS_THIS_MODEL_A_BIKE(Hash modelHash) { return invoke<BOOL>(0x7E702CDD, modelHash); } // unused
	static void SET_HELI_BLADES_FULL_SPEED(Vehicle heli) { invoke<Void>(0x033A9408, heli); }
	static float GET_VEHICLE_UPRIGHT_VALUE(Vehicle vehicle) { return invoke<float>(0x1D761FBC, vehicle); } // unused
	static void SET_VEHICLE_CAN_BE_TARGETTED(Vehicle vehicle, BOOL toggle) { invoke<Void>(0x64B70B1D, vehicle, toggle); }
	static void SET_VEHICLE_CAN_BE_VISIBLY_DAMAGED(Vehicle vehicle, BOOL toggle) { invoke<Void>(0xC5D94017, vehicle, toggle); }
	static float GET_VEHICLE_DIRT_LEVEL(Vehicle vehicle) { return invoke<float>(0xFD15C065, vehicle); } // unused
	static void SET_VEHICLE_DIRT_LEVEL(Vehicle vehicle, float dirtLevel) { invoke<Void>(0x2B39128B, vehicle, dirtLevel); }
	static void SET_VEHICLE_COORDS_NO_OFFSET(Vehicle vehicle, float x, float y, float z) { invoke<Void>(0x67714186, vehicle, x, y, z); } // unused
	static BOOL IS_VEHICLE_DOOR_FULLY_OPEN(Vehicle vehicle, int door) { return invoke<BOOL>(0xC2385B6F, vehicle, door); } // unused
	static void SET_FREEBIES_IN_VEHICLE(Vehicle vehicle, BOOL toggle) { invoke<Void>(0x84C8F466, vehicle, toggle); } // unused
	static Any SET_ROCKET_LAUNCHER_FREEBIE_IN_HELI() { return invoke<Any>(0x62F3E0F3); } // unused
	static void SET_VEHICLE_ENGINE_ON(Vehicle vehicle, BOOL value, BOOL instantly) { invoke<Void>(0x7FBC86F1, vehicle, value, instantly); }
	static void SET_VEHICLE_PROVIDES_COVER(Vehicle vehicle, BOOL toggle) { invoke<Void>(0xEFC01CA9, vehicle, toggle); } // unused
	static void SET_VEHICLE_DOOR_CONTROL(Any p0, Any p1, Any p2, Any p3) { invoke<Void>(0x572DD360, p0, p1, p2, p3); }
	static void SET_VEHICLE_DOOR_LATCHED(Any p0, Any p1, Any p2, Any p3) { invoke<Void>(0x4EB7BBFC, p0, p1, p2, p3); }
	static Any GET_VEHICLE_DOOR_ANGLE_RATIO(Any p0, Any p1) { return invoke<Any>(0x0E399C26, p0, p1); }
	static void SET_VEHICLE_DOOR_SHUT(Any p0, Any p1, Any p2, Any p3) { invoke<Void>(0x142606BD, p0, p1, p2, p3); }
	static void SET_VEHICLE_DOOR_BROKEN(Any p0, Any p1, Any p2) { invoke<Void>(0x8147FEA7, p0, p1, p2); }
	static void SET_VEHICLE_CAN_BREAK(Vehicle vehicle, BOOL toggle) { invoke<Void>(0x90A810D1, vehicle, toggle); } // unused
	static BOOL DOES_VEHICLE_HAVE_ROOF(Vehicle vehicle) { return invoke<BOOL>(0xDB817403, vehicle); } // unused
	static BOOL IS_BIG_VEHICLE(Vehicle vehicle) { return invoke<BOOL>(0x9CDBA8DE, vehicle); } // unused
	static int GET_NUMBER_OF_VEHICLE_COLOURS(Vehicle vehicle) { return invoke<int>(0xF2442EE2, vehicle); } // unused
	static void SET_VEHICLE_COLOUR_COMBINATION(Vehicle vehicle, int colorCombination) { invoke<Void>(0xA557AEAD, vehicle, colorCombination); }
	static void SET_VEHICLE_COLLISION(Vehicle vehicle, BOOL toggle) { invoke<Void>(0xC7A6A137, vehicle, toggle); }
	static void SET_PLAYBACK_TO_USE_AI(Vehicle vehicle) { invoke<Void>(0xB536CCD7, vehicle); } // unused
	static void SET_PLAYBACK_TO_USE_AI_TRY_TO_REVERT_BACK_LATER(Vehicle vehicle, int p1) { invoke<Void>(0x0C8ABAA4, vehicle, p1); } // unused
	static void SET_VEHICLE_IS_CONSIDERED_BY_PLAYER(Vehicle vehicle, BOOL toggle) { invoke<Void>(0x14413319, vehicle, toggle); } // unused
	static void GET_RANDOM_VEHICLE_MODEL_IN_MEMORY(BOOL p0, Hash* modelHash, int* successIndicator) { invoke<Void>(0xE2C45631, p0, modelHash, successIndicator); } // unused
	static Hash GET_CURRENT_BASIC_POLICE_VEHICLE_MODEL() { return invoke<Hash>(0xE8F2B493); } // unused
	static Hash GET_CURRENT_POLICE_VEHICLE_MODEL() { return invoke<Hash>(0xAD1B93E5); } // unused
	static Hash GET_CURRENT_TAXI_VEHICLE_MODEL() { return invoke<Hash>(0x5CC9B637); } // unused
	static int GET_VEHICLE_DOOR_LOCK_STATUS(Vehicle vehicle) { return invoke<int>(0x0D72CEF2, vehicle); } // unused
	static BOOL IS_VEHICLE_DOOR_DAMAGED(Vehicle vehicle, int door) { return invoke<BOOL>(0x4999E3C3, vehicle, door); } // unused
	static BOOL IS_COP_VEHICLE_IN_AREA_3D(float x1, float y1, float z1, float x2, float y2, float z2) { return invoke<BOOL>(0xFB16C6D1, x1, y1, z1, x2, y2, z2); } // unused
	static BOOL IS_VEHICLE_TOUCHING_VEHICLE(Vehicle vehicle1, Vehicle vehicle2) { return invoke<BOOL>(0xC86D447B, vehicle1, vehicle2); } // unused
	static void SET_TRAIN_FORCED_TO_SLOW_DOWN(Vehicle train, BOOL toggle) { invoke<Void>(0x7C3600D4, train, toggle); } // unused
	static BOOL IS_VEHICLE_ON_ALL_WHEELS(Vehicle vehicle) { return invoke<BOOL>(0x10089F8E, vehicle); }
	static int GET_VEHICLE_MODEL_VALUE(Hash modelHash) { return invoke<int>(0x58FEFC3D, modelHash); } // unused
	static BOOL GET_TRAIN_DIRECTION(Vehicle train) { return invoke<BOOL>(0x8DAF79B6, train); } // unused
	static void SKIP_TO_NEXT_ALLOWED_STATION(Vehicle train) { invoke<Void>(0xCF682EC7, train); } // unused
	static int GET_NEXT_STATION_FOR_TRAIN(Vehicle train) { return invoke<int>(0x234B1475, train); } // unused
	static int GET_CURRENT_STATION_FOR_TRAIN(Vehicle train) { return invoke<int>(0x3B7DCCAA, train); } // unused
	static int GET_TIME_TIL_NEXT_STATION(Vehicle train) { return invoke<int>(0x443BD51F, train); } // unused
	static void SET_RENDER_TRAIN_AS_DERAILED(Vehicle train, BOOL toggle) { invoke<Void>(0x899D9092, train, toggle); } // unused
	static void GET_STATION_NAME(int bufferSize, char* buffer, Vehicle train, int p3) { invoke<Void>(0x62D15DE6, bufferSize, buffer, train, p3); } // unused
	static void SET_WAITING_AT_STATION_TIME(Vehicle train, int time) { invoke<Void>(0x745EA145, train, time); } // unused
	static void FORCE_TRAIN_DOOR_OPEN_CLOSE(Vehicle train, int p1, BOOL p2, BOOL p3, BOOL p4) { invoke<Void>(0xD1E9352D, train, p1, p2, p3, p4); }
	static void SET_TRAIN_SHAKE(Vehicle train, float p1, float p2, BOOL p3) { invoke<Void>(0x1C6901B3, train, p1, p2, p3); }
	static void SET_VEHICLE_EXTRA_COLOURS(Vehicle vehicle, int pearlescentColor, int wheelColor) { invoke<Void>(0x515DB2A0, vehicle, pearlescentColor, wheelColor); } // unused
	static void GET_VEHICLE_EXTRA_COLOURS(Vehicle vehicle, int* pearlescentColor, int* wheelColor) { invoke<Void>(0x80E4659B, vehicle, pearlescentColor, wheelColor); } // unused
	static BOOL HAS_VEHICLE_BEEN_RESPRAYED(Vehicle vehicle) { return invoke<BOOL>(0x22F50111, vehicle); } // unused
	static void SET_VEHICLE_FIXED(Vehicle vehicle) { invoke<Void>(0x17469AA1, vehicle); } // unused
	static void SET_ROOM_FOR_VEHICLE_BY_NAME(Vehicle vehicle, char* name) { invoke<Void>(0xCC9D85E7, vehicle, name); }
	static void SET_ROOM_FOR_VEHICLE_BY_KEY(Vehicle vehicle, char* name) { invoke<Void>(0x83AFEA05, vehicle, name); } // unused
	static void CLEAR_ROOM_FOR_VEHICLE(Vehicle vehicle) { invoke<Void>(0x7F01E3CF, vehicle); }
	static Hash GET_KEY_FOR_VEHICLE_IN_ROOM(Vehicle vehicle) { return invoke<Hash>(0x660E2D00, vehicle); } // unused
	static Interior GET_INTERIOR_FROM_VEHICLE(Vehicle vehicle) { return invoke<Interior>(0x50768666, vehicle); } // unused
	static float GET_HEIGHT_OF_VEHICLE(Vehicle vehicle, float x, float y, float z, BOOL p4, BOOL p5) { return invoke<float>(0x62990CD4, vehicle, x, y, z, p4, p5); } // unused
	static void SET_MAD_DRIVERS(BOOL toggle) { invoke<Void>(0x4B7E75DC, toggle); } // unused
	static void REMOVE_VEHICLES_FROM_GENERATORS_IN_AREA(float x1, float y1, float z1, float x2, float y2, float z2) { invoke<Void>(0x42CC15E0, x1, y1, z1, x2, y2, z2); } // unused
	static void SET_VEHICLE_STEER_BIAS(Vehicle vehicle, float value) { invoke<Void>(0x7357C1EB, vehicle, value); } // unused
	static BOOL HAS_VEHICLE_STOPPED_BECAUSE_OF_LIGHT(Vehicle vehicle) { return invoke<BOOL>(0xCCA89C4C, vehicle); } // unused
	static Vector3 GET_POSITION_OF_VEHICLE_RECORDING_AT_TIME(int recordingIndex, float time) { return invoke<Vector3>(0x7178558D, recordingIndex, time); }
	static BOOL IS_VEHICLE_EXTRA_TURNED_ON(Vehicle vehicle, int extra) { return invoke<Any>(0x042098B5, vehicle, extra); }
	static void SET_VEHICLE_EXTRA(Vehicle vehicle, int extra, BOOL p2) { invoke<Void>(0x642D065C, vehicle, extra, p2); }
	static void SET_CONVERTIBLE_ROOF(Vehicle vehicle, BOOL toggle) { invoke<Void>(0xC87B6A51, vehicle, toggle); } // unused
	static void SET_GANG_VEHICLE(Vehicle vehicle, BOOL toggle) { invoke<Void>(0x924C8DBE, vehicle, toggle); } // unused
	static BOOL IS_VEHICLE_STOPPED_AT_TRAFFIC_LIGHTS(Vehicle vehicle) { return invoke<BOOL>(0x69200FA4, vehicle); } // unused
	static void SET_VEHICLE_DAMAGE(Vehicle vehicle, float xOffset, float yOffset, float zOffset, float damage, float radius, BOOL p6) { invoke<Void>(0x21B458B2, vehicle, xOffset, yOffset, zOffset, damage, radius, p6); }
	static float GET_VEHICLE_ENGINE_HEALTH(Vehicle vehicle) { return invoke<float>(0x8880038A, vehicle); }
	static void SET_VEHICLE_ENGINE_HEALTH(Vehicle vehicle, float health) { invoke<Void>(0x1B760FB5, vehicle, health); }
	static float GET_VEHICLE_PETROL_TANK_HEALTH(Vehicle vehicle) { return invoke<float>(0xE41595CE, vehicle); }
	static void SET_VEHICLE_PETROL_TANK_HEALTH(Vehicle vehicle, float health) { invoke<Void>(0x660A3692, vehicle, health); }
	static void SET_VEHICLE_BLOWUP_ON_NEXT_COLLISION(Vehicle vehicle) { invoke<Void>(0xAF0FD67A, vehicle); }
	static void SET_BOAT_PETROLTANK_BURN_RATE(Vehicle boat, float rate) { invoke<Void>(0x2EC18514, boat, rate); } // unused
	static void SET_PETROLTANK_BURN_RATE(Vehicle vehicle, float rate) { invoke<Void>(0xC06ADE7A, vehicle, rate); }
	static void SET_BOAT_WILL_SINK(Vehicle boat, BOOL toggle) { invoke<Void>(0x74A6548F, toggle); }
	static BOOL IS_VEHICLE_A_MISSION_VEHICLE(Vehicle vehicle) { return invoke<BOOL>(0x7716B579, vehicle); } // unused
	static BOOL IS_VEHICLE_STUCK_TIMER_UP(Vehicle vehicle, int index, int time) { return invoke<BOOL>(0x2FCF58C1, vehicle, index, time); } // unused
	static void RESET_VEHICLE_STUCK_TIMER(Vehicle vehicle, int index) { invoke<Void>(0xEF2A6016, vehicle, index); } // unused
	static BOOL IS_VEHICLE_DRIVEABLE(Vehicle vehicle) { return invoke<BOOL>(0x41A7267A, vehicle); } // unused
	static void SET_VEHICLE_HAS_BEEN_OWNED_BY_PLAYER(Vehicle vehicle, BOOL toggle) { invoke<Void>(0xB4D3DBFB, vehicle, toggle); } // unused
	static void SET_VEHICLE_NEEDS_TO_BE_HOTWIRED(Vehicle vehicle, BOOL toggle) { invoke<Void>(0xD8260751, vehicle, toggle); } // unused
	static void SET_VEHICLE_BLIP_THROTTLE_RANDOMLY(Vehicle vehicle, BOOL toggle) { invoke<Void>(0xC2F6FE4A, vehicle, toggle); } // unused
	static void SET_POLICE_FOCUS_WILL_TRACK_VEHICLE(Vehicle vehicle, BOOL toggle) { invoke<Void>(0x5690F6C3, vehicle, toggle); } // unused
	static void START_VEHICLE_HORN(Vehicle vehicle, int duration) { invoke<Void>(0x0DF5ADB3, vehicle, duration); } // unused
	static void SET_VEHICLE_HAS_STRONG_AXLES(Vehicle vehicle, BOOL toggle) { invoke<Void>(0x0D1CBC65, vehicle, toggle); } // unused
	static void GET_DISPLAY_NAME_FROM_VEHICLE_MODEL(int bufferSize, char* buffer, Hash modelHash) { invoke<Void>(0xEC86DF39, bufferSize, buffer, modelHash); } // unused
	static Vector3 GET_VEHICLE_DEFORMATION_AT_POS(Vehicle vehicle, float offsetX, float offsetY, float offsetZ) { return invoke<Vector3>(0xABF02075, vehicle, offsetX, offsetY, offsetZ); } // unused
	static void ADD_VEHICLE_TO_MISSION_DELETION_LIST(Vehicle vehicle) { invoke<Void>(0xF6E45147, vehicle); } // unused
	static Any SET_VEHICLE_ALPHA() { return invoke<Any>(0x5D4A2BC2); } // unused
	static void SET_VEHICLE_LIVERY(Vehicle vehicle, int liveryIndex) { invoke<Void>(0x7AD87059, vehicle, liveryIndex); } // unused
	static BOOL IS_VEHICLE_WINDOW_INTACT(Vehicle vehicle, int window) { return invoke<BOOL>(0xAC4EF23D, vehicle, window); } // unused
	static void RESET_VEHICLE_WHEELS(Vehicle vehicle, BOOL p1) { invoke<Void>(0xD5FFE779, vehicle, p1); } // unused
	static void SET_ALL_VEHICLES_HIGH_LOD(BOOL toggle) { invoke<Void>(0xA2EEE161, toggle); }
	static BOOL IS_HELI_PART_BROKEN(Vehicle heli, BOOL p1, BOOL p2, BOOL p3) { return invoke<BOOL>(0xF4E4C439, heli, p1, p2, p3); } // unused
	static Vehicle GET_NEAREST_CABLE_CAR(float x, float y, float z, float radius) { return invoke<Vehicle>(0xF2218830, x, y, z, radius); } // unused
	static void SET_VEHICLE_NAME_DEBUG(Vehicle vehicle, char* name) { invoke<Void>(0xA712FF5C, vehicle, name); }
	static void SET_VEHICLE_EXPLODES_ON_HIGH_EXPLOSION_DAMAGE(Vehicle vehicle, BOOL toggle) { invoke<Void>(0x38CC692B, vehicle, toggle); } // unused
	static void SET_VEHICLE_EXPLODES_ONLY_FROM_PROJECTILE_EXPLOSIONS(Vehicle vehicle, BOOL toggle) { invoke<Void>(0x8D359F17, vehicle, toggle); }
	static BOOL IS_PED_INSIDE_TRAIN(Ped ped, Vehicle train) { return invoke<BOOL>(0x84D170A5, ped, train); }
	static void SET_BOAT_OUT_OF_CONTROL_AND_BLOW_UP_WHEN_DRIVER_DEAD(BOOL toggle) { invoke<Void>(0x89B5EA50, toggle); }
	static void SET_CAR_OUT_OF_CONTROL_AND_BLOW_UP_WHEN_DRIVER_DEAD(BOOL toggle) { invoke<Void>(0xC981C67D, toggle); } // unused
	static void SET_VEHICLE_DRIVE_FORCE_IN_AIR(Vehicle vehicle, BOOL toggle) { invoke<Void>(0x2B97EF1F, vehicle, toggle); } // unused
	static BOOL IS_DAMAGE_BY_PROJECTILE(Vehicle vehicle) { return invoke<BOOL>(0x16BE6900, vehicle); } // unused
	static void SET_DAMAGE_BY_PROJECTILE(Vehicle vehicle, BOOL toggle) { invoke<Void>(0x97468654, vehicle, toggle); } // unused
	static void SET_BOAT_TILT_IN_AIR(Vehicle boat, BOOL p1, float p2, float p3) { invoke<Void>(0x2361ABFA, boat, p1, p2, p3); } // unused
	static void SET_VEHICLE_CAN_TRIGGER_BULLET_CAM(Vehicle vehicle, BOOL toggle) { invoke<Void>(0xDF932BC, vehicle, toggle); } // unused
	static void SET_VEHICLE_BULLET_CAM_PREF(Vehicle vehicle, char* p1) { invoke<Void>(0x84DA3B85, vehicle, p1); } // unused
	static void SET_VEHICLE_BULLET_CAMERA_ON_NEXT_HIT(Vehicle vehicle) { invoke<Void>(0x7394BC1C, vehicle); } // unused
	static void SET_VEHICLE_FIXED_WEAPON_DAMAGE(Vehicle vehicle, float damage, int weaponIndex) { invoke<Void>(0x4F177788, vehicle, damage, weaponIndex); }
	static float GET_VEHICLE_FIXED_WEAPON_DAMAGE(Vehicle vehicle, int weaponIndex) { return invoke<float>(0x05C718BD, vehicle, weaponIndex); } // unused
	static void SET_VEHICLE_FIXED_WEAPON_ACCURACY(Vehicle vehicle, float accurary, int weaponIndex) { invoke<Void>(0xC38EDA8A, vehicle, accurary, weaponIndex); }
	static float GET_VEHICLE_FIXED_WEAPON_ACCURACY(Vehicle vehicle, int weaponIndex) { return invoke<float>(0x5A18B080, vehicle, weaponIndex); } // unused
	static void SET_VEHICLE_FIXED_WEAPON_FIRING_PATTERN_SET(Vehicle vehicle, int weaponIndex, Hash firingPatternHash1, Hash firingPatternHash2, Hash firingPatternHash3, Hash firingPatternHash4, Hash firingPatternHash5, Hash firingPatternHash6, Hash firingPatternHash7, Hash firingPatternHash8, Hash firingPatternHash9, Hash firingPatternHash10) { invoke<Void>(0x0B4F809D, vehicle, weaponIndex, firingPatternHash1, firingPatternHash2, firingPatternHash3, firingPatternHash4, firingPatternHash5, firingPatternHash6, firingPatternHash7, firingPatternHash8, firingPatternHash9, firingPatternHash10); }
	static void SET_VEHICLE_FIXED_WEAPON_FIRING_PATTERN_MODE(Vehicle vehicle, int mode, int weaponIndex) { invoke<Void>(0xC8FF4A34, vehicle, mode, weaponIndex); }
	static int GET_VEHICLE_FIXED_WEAPON_FIRING_PATTERN_MODE(Vehicle vehicle, int weaponIndex) { return invoke<int>(0x38D33245, vehicle, weaponIndex); } // unused
	static void HELI_SPOTLIGHT_TRACK_PED(Vehicle heli, Ped ped, BOOL p2) { invoke<Void>(0x5F44E3E6, heli, ped, p2); }
	static void ALLOCATE_VEHICLE_INST_LIGHT_TUNE_DATA(Vehicle vehicle) { invoke<Void>(0x33837FD9, vehicle); } // unused
	static void FREE_VEHICLE_INST_LIGHT_TUNE_DATA(Vehicle vehicle) { invoke<Void>(0x8DA263E8, vehicle); }
	static void SET_VEHICLE_INST_LIGHT_TUNE_VALUES(Vehicle vehicle, Any* data) { invoke<Void>(0x3ADF1AAA, vehicle, data); } // unused
	static void SET_VEHICLE_FREEZE_AFTER_BLOWING_UP(Vehicle vehicle, BOOL toggle) { invoke<Void>(0xFCD50E3D, vehicle, toggle); }
	static void GAMEPLAY_HELPER_BOX_CREATE_VEHICLE_ATTACHED(int p0, char* name, Vehicle vehicle, float p3, float p4, float p5, float p6, float p7, float p8, float p9, float p10, float p11, BOOL p12, BOOL p13) { invoke<Void>(0x1859C65D, p0, name, vehicle, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13); }
	static void SET_VEHICLE_REACT_TO_EXPLOSION(Vehicle vehicle, BOOL toggle) { invoke<Void>(0xB755CE11, vehicle, toggle); }
	static BOOL PLAY_VEHICLE_ANIM(Vehicle vehicle, char* animName, char* animDict, float speedMultiplier, BOOL p4, BOOL p5) { return invoke<BOOL>(0x6EB2CA78, vehicle, animName, animDict, speedMultiplier, p4, p5); }
	static void DELETE_VEHICLE_ANIMATOR(Vehicle vehicle) { invoke<Void>(0xBD510181, vehicle); } // unused
}

namespace OBJECT
{
	static Object CREATE_OBJECT(Hash modelHash, float x, float y, float z, BOOL dynamic, BOOL dontOwn) { return invoke<Object>(0x2F7AA05C, modelHash, x, y, z, dynamic, dontOwn); }
	static Object CREATE_OBJECT_NO_OFFSET(Hash modelHash, float x, float y, float z, BOOL dynamic, BOOL dontOwn) { return invoke<Object>(0x58040420, modelHash, x, y, z, dynamic, dontOwn); }
	static Object CREATE_OBJECT_MOVER(Hash modelHash, float x, float y, float z, BOOL dynamic, char* pathName, BOOL dontOwn) { return invoke<Object>(0x757194AC, modelHash, x, y, z, dynamic, pathName, dontOwn); }
	static void DELETE_OBJECT(Object* object) { invoke<Void>(0xD6EF9DA7, object); }
	static float GET_OBJECT_HEADING(Object object) { return invoke<float>(0x1C02D2F8, object); } // unused
	static void SET_OBJECT_HEADING(Object object, float heading) { invoke<Void>(0xE094E341, object, heading); }
	static Vector3 GET_OBJECT_COORDS(Object object) { return invoke<Vector3>(0x7CA0C8FB, object); }
	static void SET_OBJECT_COORDS(Object object, float x, float y, float z) { invoke<Void>(0x3C07FE50, object, x, y, z); }
	static float GET_OBJECT_MASS(Object object) { return invoke<float>(0x449F0820, object); }
	static void SET_OBJECT_AS_NO_LONGER_NEEDED(Object* object) { invoke<Void>(0x3F6B949F, object); } // unused
	static Any GET_SAFE_PLACEMENT_COORDS() { return invoke<Any>(0x5491A6F9); } // unused
	static Any GET_PICKUP_TYPE_FROM_WEAPON_TYPE(Any p0) { return invoke<Any>(0x3F2D18CE, p0); }
	static Any CREATE_PLACEMENT() { return invoke<Any>(0xD8BC413C); } // unused
	static Any CREATE_PLACEMENT_ROTATE(Any p0, Any p1, Any p2, Any p3, Any p4, Any p5, Any p6, Any p7, Any p8, Any p9, Any p10) { return invoke<Any>(0xA460F7A8, p0, p1, p2, p3, p4, p5, p6, p7, p8, p9, p10); }
	static Any CREATE_AMMOBAG_PLACEMENT() { return invoke<Any>(0x4976E3EC); } // unused
	static Any CREATE_AMMOBAG_PLACEMENT_ROTATE(Any p0, Any p1, Any p2, Any p3, Any p4, Any p5, Any p6, Any p7, Any p8, Any p9) { return invoke<Any>(0x85481503, p0, p1, p2, p3, p4, p5, p6, p7, p8, p9); }
	static void SET_AMMOBAG_AMMO_AMOUNT(Any p0, Any p1, Any p2) { invoke<Void>(0xD70FCA05, p0, p1, p2); }
	static void SET_AMMOBAG_ENABLED(Any p0, Any p1) { invoke<Void>(0x95B7945E, p0, p1); }
	static void SET_AMMOBAG_REGEN_TIME(Any p0, Any p1) { invoke<Void>(0x6599E1E4, p0, p1); }
	static void SET_AMMOBAG_REGEN_RANGE(Any p0, Any p1) { invoke<Void>(0xAEDBB3B9, p0, p1); }
	static Any SET_PICKUP_LIMIT_ANGLE() { return invoke<Any>(0x12177009); } // unused
	static Vector3 GET_PLACEMENT_COORDS(int index) { return invoke<Vector3>(0x8E2F0A39, index); }
	static void REMOVE_ALL_PICKUPS_AND_PLACEMENTS_OF_TYPE(Any p0) { invoke<Void>(0xC58DF6C6, p0); }
	static void REMOVE_ALL_PICKUPS() { invoke<Void>(0x04BF00F0); }
	static void REMOVE_ALL_PLACEMENTS() { invoke<Void>(0x0DD8A1EE); } // unused
	static void SET_PICKUP_REMOVAL_TIMES(Any p0, Any p1) { invoke<Void>(0x172FA186, p0, p1); }
	static void SET_AUTODESTROY_MPITEMS_WHEN_PICKED_BY_AN_ENEMY(Any p0) { invoke<Void>(0x63309241, p0); }
	static Any GET_NUMBER_OF_PICKUPS_AND_PLACEMENTS_OF_TYPE() { return invoke<Any>(0x22DEA3F4); } // unused
	static BOOL HAS_PLACEMENT_BEEN_COLLECTED(int index) { return invoke<BOOL>(0xC516E7D1, index); }
	static void REMOVE_PLACEMENT(int index) { invoke<Void>(0x0BDA43DD, index); }
	static Pickup GET_PICKUP_FROM_PLACEMENT(int index) { return invoke<Pickup>(0x59A39BA3, index); }
	static void ENABLE_PICKUP_ATTACHMENT(Any p0, Any p1, Any p2) { invoke<Void>(0xE7836549, p0, p1, p2); }
	static void TOGGLE_PICKUP_ATTACHMENT(Any p0, Any p1, Any p2) { invoke<Void>(0xDB0A1DF3, p0, p1, p2); }
	static Any IS_PICKUP_ATTACHMENT_ENABLED() { return invoke<Any>(0x565F0B42); } // unused
	static Any IS_PICKUP_ATTACHMENT_TOGGLED() { return invoke<Any>(0x89F779D5); } // unused
	static Any SET_PICKUP_LASER_SIGHT_ATTACHMENT() { return invoke<Any>(0xB3C7B87A); } // unused
	static Any GET_PICKUP_LASER_SIGHT_ATTACHMENT() { return invoke<Any>(0x5B17CB61); } // unused
	static void SET_PICKUP_WEAPON_DATA_FROM_WEAPON(Any p0, Any p1) { invoke<Void>(0x00D3791A, p0, p1); }
	static void SET_PICKUP_AMMO(Any p0, Any p1) { invoke<Void>(0xCCA72391, p0, p1); }
	static Any GET_PICKUP_AMMO() { return invoke<Any>(0x8B9EE98B); } // unused
	static void REMOVE_PICKUP(Pickup pickup) { invoke<Void>(0x64A7A0E0, pickup); }
	static void REMOVE_PICKUPS_OF_TYPE_IN_GAMEPLAY_HELPER_BOX(Hash pickupHash, char* name) { invoke<Void>(0xDBA0AF51, pickupHash, name); }
	static Any SET_DEAD_PEDS_DROP_WEAPONS() { return invoke<Any>(0x197472B9); } // unused
	static Any SET_PLAYERS_DROP_MONEY_IN_NETWORK_GAME() { return invoke<Any>(0x0806204B); } // unused
	static BOOL IS_OBJECT_ON_SCREEN(Object object) { return invoke<BOOL>(0x2AE883EB); }
	static BOOL ROTATE_OBJECT(Object object, float p1, float p2, BOOL p3) { return invoke<BOOL>(0x2F4D8D44, object, p1, p2, p3); } // unused
	static BOOL SLIDE_OBJECT(Object object, float toX, float toY, float toZ, float speedX, float speedY, float speedZ, BOOL collision) { return invoke<BOOL>(0x63BFA7A0, object, toX, toY, toZ, speedX, speedY, speedZ, collision); } // unused
	static void SET_OBJECT_TARGETTABLE(Object object, BOOL toggle) { invoke<Void>(0x3F88CD86, object, toggle); }
	static void SET_VISIBILITY_OF_CLOSEST_OBJECT_OF_TYPE(float x, float y, float z, float radius, Hash modelHash, BOOL visible) { invoke<Void>(0x702FAEEB, x, y, z, radius, modelHash, visible); }
	static BOOL HAS_OBJECT_BEEN_DAMAGED(Object object) { return invoke<BOOL>(0x3B4FB8FD, object); }
	static void SET_OBJECT_INITIAL_VELOCITY(Object object, float x, float y, float z) { invoke<Void>(0xE20C80E4, object, x, y, z); }
	static void SET_OBJECT_COLLISION(Object object, BOOL toggle) { invoke<Void>(0xEDEA40E8, object, toggle); }
	static void SET_OBJECT_DYNAMIC(Object object, BOOL toggle) { invoke<Void>(0xD73719EF, object, toggle); }
	static void SET_NETWORK_OBJECT_TERRITORY_EFFECT(Object object, float p1, float p2, int color) { invoke<Void>(0xB0A0AF9E, object, p1, p2, color); }
	static void CLEAR_NETWORK_OBJECT_TERRITORY_EFFECT(Object object) { invoke<Void>(0xE095DEAC, object); }
	static BOOL DOES_OBJECT_EXIST(Object object) { return invoke<BOOL>(0xB2A3021E, object); }
	static Vector3 GET_OFFSET_FROM_OBJECT_IN_WORLD_COORDS(Object object, float offsetX, float offsetY, float offsetZ) { return invoke<Vector3>(0x66DF1BF5, object, offsetX, offsetY, offsetZ); }
	static void SET_OBJECT_ROTATION(Object object, float pitch, float roll, float yaw) { invoke<Void>(0xB9BF4EA7, object, pitch, roll, yaw); }
	static Vector3 GET_OBJECT_ROTATION(Object object) { return invoke<Vector3>(0x28567FDD, object); }
	static void SET_OBJECT_RECORDS_COLLISIONS(Object object, BOOL toggle) { invoke<Void>(0x26461274, object, toggle); } // unused
	static BOOL HAS_OBJECT_COLLIDED_WITH_ANYTHING(Object object) { return invoke<BOOL>(0xD9B3DBC9, object); } // unused
	static void SET_OBJECT_REFLECTS(Object object, BOOL toggle) { invoke<Void>(0x867B848E, object, toggle); } // unused
	static BOOL GET_OBJECT_REFLECTS(Object object) { return invoke<BOOL>(0x8A60400E, object); } // unused
	static BOOL IS_OBJECT_AT_COORD(Object object, float p1, float p2, float p3, float p4, float p5, float p6, BOOL p7, BOOL p8) { return invoke<BOOL>(0x0C1C0A8B, object, p1, p2, p3, p4, p5, p6, p7, p8); } // unused
	static BOOL IS_OBJECT_IN_WATER(Object object) { return invoke<BOOL>(0xEB448F66, object); } // unused
	static BOOL IS_OBJECT_IN_AREA(Object object, float x1, float y1, float z1, float x2, float y2, float z2, BOOL p7, BOOL p8) { return invoke<BOOL>(0x3DDBD2DE, object, x1, y1, z1, x2, y2, z2); } // unused
	static BOOL IS_OBJECT_IN_CROSSHAIR_CYLINDER(Object object, float p1, float p2, BOOL p3) { return invoke<BOOL>(0x0BA48CEA, object, p1, p2, p3); }
	static void FREEZE_OBJECT_POSITION(Object object, BOOL toggle) { invoke<Void>(0xAAFBDB10, object, toggle); }
	static void ADD_OBJECT_TO_EXPLOSION_OCCLUSION_TESTS(Object object, BOOL toggle) { invoke<Void>(0xC88787A4, object, toggle); }
	static Vector3 GET_OBJECT_VELOCITY(Object object) { return invoke<Vector3>(0x2A8801CB, object); } // unused
	static BOOL IS_OBJECT_STATIC(Object object) { return invoke<BOOL>(0x49A1DD0E, object); } // unused
	static BOOL IS_OBJECT_FIXED_WAITING_FOR_COLLISION(Object object) { return invoke<BOOL>(0x56AD22D0, object); } // unused
	static Vector3 GET_OBJECT_ROTATION_VELOCITY(Object object) { return invoke<Vector3>(0x5B075C62, object); } // unused
	static float GET_OBJECT_SPEED(Object object) { return invoke<float>(0xA059FF6B, object); } // unused
	static void ATTACH_OBJECT_TO_VEHICLE(Any p0, Any p1, Any p2, Any p3, Any p4, Any p5, Any p6, Any p7, Any p8) { invoke<Void>(0x3DC7AC96, p0, p1, p2, p3, p4, p5, p6, p7, p8); }
	static Any ATTACH_OBJECT_TO_VEHICLE_PHYSICALLY() { return invoke<Any>(0xF903C741); } // unused
	static void ATTACH_OBJECT_TO_OBJECT(Any p0, Any p1, Any p2, Any p3, Any p4, Any p5, Any p6, Any p7, Any p8) { invoke<Void>(0x75F6A13E, p0, p1, p2, p3, p4, p5, p6, p7, p8); }
	static Any ATTACH_OBJECT_TO_OBJECT_PHYSICALLY() { return invoke<Any>(0x7C98BD8E); } // unused
	static void ATTACH_OBJECT_TO_PED(Object object, Ped ped, int boneId, float p3, float p4, float p5, float p6, float p7, float p8, BOOL p9) { invoke<Void>(0xDB806B1D, object, ped, boneId, p3, p4, p5, p6, p7, p8, p9); }
	static void DETACH_OBJECT(Object object, BOOL p1) { invoke<Void>(0x6A1DF29F, object, p1); }
	static BOOL IS_OBJECT_ATTACHED(Object object) { return invoke<BOOL>(0xAD08BA79, object); } // unused
	static Vehicle GET_VEHICLE_OBJECT_IS_ATTACHED_TO(Object object) { return invoke<Vehicle>(0x5DFD6E29, object); } // unused
	static Ped GET_PED_OBJECT_IS_ATTACHED_TO(Object object) { return invoke<Ped>(0x72ADF3FC, object); } // unused
	static Any IS_CLOSEST_OBJECT_OF_TYPE_SMASHED_OR_DAMAGED() { return invoke<Any>(0x7E3857CE); } // unused
	static void SMASH_GLASS_IN_RADIUS(Any p0, Any p1, Any p2, Any p3, Any p4) { invoke<Void>(0x71B56B9F, p0, p1, p2, p3, p4); }
	static void DAMAGE_GLASS_IN_RADIUS(Any p0, Any p1, Any p2, Any p3, Any p4) { invoke<Void>(0xE8F0A90E, p0, p1, p2, p3, p4); }
	static Any IS_GLASS_BROKEN_IN_RADIUS() { return invoke<Any>(0x42A3F611); } // unused
	static Any IS_GLASS_BROKEN_ON_OBJECT() { return invoke<Any>(0xDAEAC978); } // unused
	static float GET_OBJECT_HEALTH(Object object) { return invoke<float>(0xF9D59802, object); }
	static void SET_OBJECT_HEALTH(Any p0, Any p1) { invoke<Void>(0x06ACE668, p0, p1); }
	static void SET_OBJECT_VISIBLE(Object object, BOOL toggle) { invoke<Void>(0x9DB02973, object, toggle); }
	static BOOL PLAY_OBJECT_ANIM(Object object, char* animDict, char* animName, float speedMultiplier, BOOL p4, BOOL p5) { return invoke<BOOL>(0x853E879E, object, animDict, animName, speedMultiplier, p4, p5); }
	static Any OBJECT_ANIM_EVENT_OLD() { return invoke<Any>(0x0BF0BC0D); } // unused
	static Any OBJECT_ANIM_EVENT() { return invoke<Any>(0x105F06CB); } // unused
	static Any GET_OBJECT_ANIM_CURRENT_TIME(Any p0, Any p1, Any p2) { return invoke<Any>(0x39F0D010, p0, p1, p2); }
	static void SET_OBJECT_ANIM_CURRENT_TIME(Any p0, Any p1, Any p2, Any p3) { invoke<Void>(0xDFA5AD5A, p0, p1, p2, p3); }
	static void SET_OBJECT_ANIM_SPEED(Any p0, Any p1, Any p2, Any p3) { invoke<Void>(0x485459F9, p0, p1, p2, p3); }
	static BOOL IS_OBJECT_PLAYING_ANIM(Object object, char* animName, char* animDict) { return invoke<BOOL>(0x8CA17B14, object, animName, animDict); }
	static void FORCE_UPDATE_OBJECT_PHYSICAL_STATE(Object object) { invoke<Void>(0xD2BB4445, object); }
	static int GET_OBJECT_BONE_INDEX(Object object, char* boneName) { return invoke<int>(0x59F98953, object, boneName); }
	static Vector3 GET_OBJECT_BONE_COORDS(Object object, int boneId, BOOL p2) { return invoke<Vector3>(0x2046F7A6, object, boneId, p2); }
	static Vector3 GET_OBJECT_BONE_ORIENTATION(Object object, int boneId, BOOL p2) { return invoke<Vector3>(0x4B9341F4, object, boneId, p2); } // unused
	static void GET_OBJECT_QUATERNION(Object object, float* x, float* y, float* z, float* w) { invoke<Void>(0x9DAE7D3B, object, x, y, z, w); } // unused
	static void SET_OBJECT_QUATERNION(Object object, float x, float y, float z, float w) { invoke<Void>(0x1BAC5DC1, object, x, y, z, w); } // unused
	static void SET_OBJECT_ONLY_DAMAGED_BY_PLAYER(Object object, BOOL toggle) { invoke<Void>(0x9D22CD69, object, toggle); }
	static void SET_USES_COLLISION_OF_CLOSEST_OBJECT_OF_TYPE(float x, float y, float z, float radius, Hash modelHash, BOOL toggle) { invoke<Void>(0x88042DC7, x, y, z, radius, modelHash, toggle); } // unused
	static void FREEZE_POSITION_OF_CLOSEST_OBJECT_OF_TYPE(float x, float y, float z, float radius, Hash modelHash, BOOL toggle) { invoke<Void>(0xE3709D6D, x, y, z, radius, modelHash, toggle); } // unused
	static void SET_HEADING_OF_CLOSEST_OBJECT_OF_TYPE(float x, float y, float z, float radius, Hash modelHash, float heading, BOOL p6) { invoke<Void>(0xB74D0E1B, x, y, z, radius, modelHash, heading, p6); } // unused
	static void SET_STATE_OF_CLOSEST_DOOR_OF_TYPE(Hash modelHash, float x, float y, float z, BOOL locked, float heading) { invoke<Void>(0x38C951A4, modelHash, x, y, z, locked, heading); }
	static void GET_STATE_OF_CLOSEST_DOOR_OF_TYPE(Hash modelHash, float x, float y, float z, BOOL* locked, float* heading) { invoke<Void>(0x4B44A83D, modelHash, x, y, z, locked, heading); }
	static Any DOOR_GET_AUTO_CLOSE() { return invoke<Any>(0x92765D98); } // unused
	static Any DOOR_GET_CLOSE() { return invoke<Any>(0x3C4E25B7); } // unused
	static Any DOOR_GET_LATCH() { return invoke<Any>(0x2395F97B); } // unused
	static Any DOOR_GET_LIMIT_MIN() { return invoke<Any>(0x06B267A5); } // unused
	static Any DOOR_GET_LIMIT_MAX() { return invoke<Any>(0xABF225B6); } // unused
	static Any DOOR_GET_IS_AFFECTED_BY_BULLETS(Any p0) { return invoke<Any>(0x7EE155C5, p0); }
	static Any DOOR_SET_AUTO_CLOSE() { return invoke<Any>(0x2110CDEF); } // unused
	static Any DOOR_SET_CLOSE() { return invoke<Any>(0x8FB665F4); } // unused
	static Any DOOR_SET_LATCH() { return invoke<Any>(0x14F0F123); } // unused
	static Any DOOR_SET_LIMIT() { return invoke<Any>(0xB0F0CB71); } // unused
	static Any DOOR_SET_LIMIT_MIN() { return invoke<Any>(0xEB21CBB9); } // unused
	static Any DOOR_SET_LIMIT_MAX() { return invoke<Any>(0xC14B5D0D); } // unused
	static Any DOOR_ACTIVATE_SPATIAL_DATA() { return invoke<Any>(0x9EC0CA1C); } // unused
	static void DOOR_SET_IS_AFFECTED_BY_BULLETS(Any p0, Any p1) { invoke<Void>(0x90E38365, p0, p1); }
	static Any DOOR_FIND_CLOSEST_GET_AUTO_CLOSE() { return invoke<Any>(0xBD2B780C); } // unused
	static Any DOOR_FIND_CLOSEST_GET_CLOSE() { return invoke<Any>(0x6258B9D5); } // unused
	static Any DOOR_FIND_CLOSEST_GET_LATCH() { return invoke<Any>(0xE7771339); } // unused
	static Any DOOR_FIND_CLOSEST_GET_LIMIT_MIN() { return invoke<Any>(0xF54D9BF1); } // unused
	static Any DOOR_FIND_CLOSEST_GET_LIMIT_MAX() { return invoke<Any>(0x3CBDA1D0); } // unused
	static Any DOOR_FIND_CLOSEST(Any p0, Any p1, Any p2, Any p3) { return invoke<Any>(0x3D92CE51, p0, p1, p2, p3); }
	static void DOOR_FIND_CLOSEST_SET_AUTO_CLOSE(Any p0, Any p1, Any p2, Any p3, Any p4) { invoke<Void>(0x5742CA6E, p0, p1, p2, p3, p4); }
	static void DOOR_FIND_CLOSEST_SET_CLOSE(Any p0, Any p1, Any p2, Any p3, Any p4) { invoke<Void>(0xA38DC937, p0, p1, p2, p3, p4); }
	static void DOOR_FIND_CLOSEST_SET_LATCH(Any p0, Any p1, Any p2, Any p3, Any p4) { invoke<Void>(0xF72AADBB, p0, p1, p2, p3, p4); }
	static Any DOOR_FIND_CLOSEST_SET_LIMIT() { return invoke<Any>(0x335910F4); } // unused
	static void DOOR_FIND_CLOSEST_SET_LIMIT_MIN(Any p0, Any p1, Any p2, Any p3, Any p4) { invoke<Void>(0x16F2B72D, p0, p1, p2, p3, p4); }
	static void DOOR_FIND_CLOSEST_SET_LIMIT_MAX(Any p0, Any p1, Any p2, Any p3, Any p4) { invoke<Void>(0x12063620, p0, p1, p2, p3, p4); }
	static void DOOR_FIND_CLOSEST_ACTIVATE_SPATIAL_DATA(Any p0, Any p1, Any p2, Any p3, Any p4) { invoke<Void>(0xE902B02D, p0, p1, p2, p3, p4); }
	static BOOL DOES_OBJECT_OF_TYPE_EXIST_AT_COORDS(float x, float y, float z, float radius, Hash modelHash) { return invoke<BOOL>(0x23FF2BA4, x, y, z, radius, modelHash); }
	static BOOL IS_OBJECT_IN_ANGLED_AREA(Object object, float x1, float y1, float z1, float x2, float y2, float z2, float p7, BOOL p8, BOOL p9) { return invoke<BOOL>(0xABF09CB4, object, x1, y1, z1, x2, y2, z2, p7, p8, p9); } // unused
	static BOOL IS_OBJECT_IN_GAMEPLAY_HELPER_BOX(Object object, char* name) { return invoke<BOOL>(0xB51CBB2F, object, name); }
	static void SET_OBJECT_AS_STEALABLE(Object object, BOOL toggle) { invoke<Void>(0x23A96397, object, toggle); } // unused
	static BOOL HAS_OBJECT_BEEN_UPROOTED(Object object) { return invoke<BOOL>(0xC220DB67, object); } // unused
	static Hash GET_OBJECT_MODEL(Object object) { return invoke<Hash>(0x70BECF6A, object); }
	static void SET_OBJECT_PROOFS(Object object, BOOL p1, BOOL p2, BOOL p3, BOOL p4, BOOL p5) { invoke<Void>(0x07EA4940, object, p1, p2, p3, p4, p5); }
	static BOOL DOES_PLACEMENT_EXIST(int index) { return invoke<BOOL>(0x002D7902, index); }
	static BOOL DOES_PICKUP_EXIST(Pickup pickup) { return invoke<BOOL>(0x9C6DA0B3, pickup); }
	static void GET_NEAREST_COLLECTABLE_BIN_BAGS(float x, float y, float z) { invoke<Void>(0xCAEBB272, x, y, z); } // unused
	static BOOL GET_INFO_ABOUT_NEARBY_ENTITY_WITH_SPECIAL_ATTRIBUTE(int index, Vector3* coords, float* p2, BOOL* p3, Hash* modelHash, float* p5) { return invoke<BOOL>(0x111F28AD, index, coords, p2, p3, modelHash, p5); } // unused
	static Object GET_NEARBY_OBJECT_WITH_SPECIAL_ATTRIBUTE(int index) { return invoke<Object>(0x7BAE3F92, index); } // unused
	static void SWAP_NEAREST_BUILDING_MODEL(float x, float y, float z, float radius, Hash modelHashFrom, Hash modelHashTo) { invoke<Void>(0xFBD8341B, x, y, z, radius, modelHashFrom, modelHashTo); }
	static Interior GET_INTERIOR_AT_COORDS(float x, float y, float z) { return invoke<Interior>(0xA17FBF37, x, y, z); }
	static Any GET_ROOM_AT_COORDS(float x, float y, float z) { return invoke<Any>(0xAE7AA07B, x, y, z); }
	static Interior GET_INTERIOR_FROM_NAME(char* name, int numAttempts) { return invoke<Interior>(0x0572A936, name, numAttempts); }
	static void ADD_OBJECT_TO_INTERIOR_ROOM_BY_NAME(Object object, char* name) { invoke<Void>(0x27F07BD9, object, name); }
	static void ADD_OBJECT_TO_INTERIOR_ROOM_BY_KEY(Object object, Any p1, Any p2) { invoke<Void>(0xF062047C, object, p1, p2); }
	static void CLEAR_ROOM_FOR_OBJECT(Object object) { invoke<Void>(0x4CF50AEB, object); }
	static Any GET_ROOM_KEY_FROM_OBJECT(Object object) { return invoke<Any>(0xFC452887, object); } // unused
	static void ADD_PLACEMENT_TO_INTERIOR_ROOM_BY_NAME(Any p0, Any p1) { invoke<Void>(0xE4961E79, p0, p1); }
	static Any GET_ROOM_KEY_FROM_PLACEMENT() { return invoke<Any>(0x3B9A0C3D); } // unused
	static void APPLY_FORCE_TO_OBJECT(Object object, int forceType, float forceX, float forceY, float forceZ, float offX, float offY, float offZ, int bone, BOOL isDirectionRel, BOOL ignoreUpVec, BOOL isForceRel) { invoke<Void>(0xB4FCA1F9, object, forceType, forceX, forceY, forceZ, offX, offY, offZ, bone, isDirectionRel, ignoreUpVec, isForceRel); } // unused
	static BOOL IS_OBJECT_UPRIGHT(Object object, float p1) { return invoke<BOOL>(0x45D7281E, object, p1); } // unused
	static void SET_OBJECT_PHYSICS_PARAMS(Object object, float p1, float p2, float p3, float p4, float p5, float p6, float p7, float p8, float p9, float p10) { invoke<Void>(0xE8D11C58, object, p1, p2, p3, p4, p5, p6, p7, p8, p9, p10); } // unused
	static float GET_OBJECT_FRAGMENT_DAMAGE_HEALTH(Object object, BOOL p1) { return invoke<float>(0xF0B330AD, object, p1); } // unused
	static BOOL HAS_FRAGMENT_ANY_OF_OBJECT_BEEN_DAMAGED(Object object) { return invoke<BOOL>(0x02AD2B87, object); } // unused
	static BOOL HAS_FRAGMENT_ROOT_OF_OBJECT_BEEN_DAMAGED(Object object) { return invoke<BOOL>(0xD9EA7576, object); }
	static BOOL HAS_FRAGMENT_ROOT_OF_CLOSEST_OBJECT_OF_TYPE_BEEN_DAMAGED(float x, float y, float z, float radius, Hash modelHash) { return invoke<BOOL>(0x08DF011C, x, y, z, radius, modelHash); } // unused
	static BOOL HAS_OBJECT_BEEN_DAMAGED_BY_PED(Object object, Ped ped) { return invoke<BOOL>(0x730EAA9E, object, ped); }
	static BOOL HAS_CLOSEST_OBJECT_OF_TYPE_BEEN_DAMAGED_BY_PED(float x, float y, float z, float radius, Hash modelHash, Ped ped) { return invoke<BOOL>(0x25620891, x, y, z, radius, modelHash, ped); } // unused
	static BOOL HAS_OBJECT_BEEN_DAMAGED_BY_VEHICLE(Object object, Vehicle vehicle) { return invoke<BOOL>(0x7098F746, object, vehicle); } // unused
	static void CLEAR_OBJECT_LAST_DAMAGE_ENTITY(Object object) { invoke<Void>(0x0FAB3AA7, object); } // unused
	static void SET_ACTIVATE_OBJECT_PHYSICS_AS_SOON_AS_IT_IS_UNFROZEN(Object object, BOOL toggle) { invoke<Void>(0x3E263AE1, object, toggle); }
	static void SET_ACTIVATE_FRAG_OBJECT_PHYSICS_AS_SOON_AS_IT_IS_UNFROZEN(Object object, BOOL toggle) { invoke<Void>(0x2E2212DD, object, toggle); }
	static void SET_OBJECT_INVINCIBLE(Object object, BOOL toggle) { invoke<Void>(0xEF19EDA6, object, toggle); }
	static BOOL SMASH_GLASS_ON_OBJECT(float x, float y, float z, float radius, Hash modelHash, float p5) { return invoke<BOOL>(0x4CB06A9F, x, y, z, radius, modelHash, p5); }
	static BOOL IS_NON_FRAG_OBJECT_SMASHED(float x, float y, float z, float radius, Hash modelHash) { return invoke<BOOL>(0xF7AE77B6, x, y, z, radius, modelHash); } // unused
	static void SET_OBJECT_LIGHTS(Object object, BOOL toggle) { invoke<Void>(0x88EB06E8, object, toggle); }
	static Any SET_OBJECT_ALPHA() { return invoke<Any>(0x98E5B61D); } // unused
	static Any SET_MULTIPLE_DRIVEBY_PICKUPS() { return invoke<Any>(0xC619A53A); } // unused
	static Any PICKUPS_PASS_TIME() { return invoke<Any>(0xA629E201); } // unused
	static void SET_ARROW_ABOVE_BLIPPED_PICKUPS(BOOL toggle) { invoke<Void>(0xEDE49B32, toggle); } // unused
	static void SET_OBJECT_ANCHOR(Object object, BOOL toggle, float p2) { invoke<Void>(0xC97C227A, object, toggle, p2); } // unused
	static BOOL DOES_OBJECT_HAVE_PHYSICS(Object object) { return invoke<BOOL>(0x45D1813F, object); } // unused
	static void SET_MOVER_SPEED(Object object, float p1, float p2) { invoke<Void>(0xACF9574C, object, p1, p2); }
	static void SET_MOVER_ACTIVE(Object object, BOOL toggle) { invoke<Void>(0xD1064073, object, toggle); } // unused
	static Vector3 GET_OBJECT_MATRIX_VECTOR(Object object, char* axisName) { return invoke<Vector3>(0x8B83EE94, object, axisName); } // unused
	static void GET_OBJECT_MATRIX(Object object, Vector3* rightVector, Vector3* forwardVector, Vector3* upVector, Vector3* position) { invoke<Void>(0xF301B4FF, object, rightVector, forwardVector, upVector, position); } // unused
	static void SET_OBJECT_CAN_TRIGGER_BULLET_CAM(Object object, BOOL toggle) { invoke<Void>(0x9D9BD0D4, object, toggle); } // unused
	static BOOL GET_OBJECT_CAN_TRIGGER_BULLET_CAM(Object object) { return invoke<BOOL>(0xBFD5EBD4, object); } // unused
	static void SET_OBJECT_BULLET_CAM_PREF(Object object, char* p1) { invoke<Void>(0x35B1DB56, object, p1); } // unused
	static void DESTROY_FRAGMENT_OBJECT(Object object) { invoke<Void>(0x9A5285B6, object); }
	static void SET_OBJECT_AS_PATH_OBSTACLE(Object object) { invoke<Void>(0x2AD60AF9, object); }
	static void SET_OBJECT_AS_NON_PATH_OBSTACLE(Object object) { invoke<Void>(0xB507654A, object); }
	static void SET_OBJECT_AS_FLIPPABLE_TABLE(Object object, BOOL toggle) { invoke<Void>(0xBF817CCD, object, toggle); }
	static void GENERATE_OBJECT_CRUSH_IMMINENT_EVENT(Object object) { invoke<Void>(0x7B18DE4C, object); }
	static void SYNC_FRAGMENT_OBJECTS(Hash modelHash) { invoke<Void>(0x521555E5, modelHash); } // unused
	static void SET_OBJECT_SILHOUETTE_ENABLED(Object object, BOOL p1, BOOL p2) { invoke<Void>(0xB0533CEB, object, p1, p2); }
	static void SET_OBJECT_SILHOUETTE_COLOUR(Object object, int color) { invoke<Void>(0x70F34A3E, object, color); }
	static void DAMAGE_ALL_GROUPS_ON_OBJECT(Object object) { invoke<Void>(0x607F48DE, object); }
	static void WAKE_RESTING_OBJECTS_AROUND(Object object) { invoke<Void>(0x14EF5CEE, object); }
	static Object FIND_OBJECT_AT_POSITION(char* modelName, float x, float y, float z, float radius) { return invoke<Object>(0x77984D34, modelName, x, y, z, radius); }
	static void SET_PLACEMENT_CAN_BE_COLLECTED(int index, BOOL toggle) { invoke<Void>(0x9AB53495, index, toggle); } // unused
	static void DOOR_FIND_CLOSEST_SET_FORCE_CLOSE(Hash modelHash, float x, float y, float z, BOOL p4, BOOL p5) { invoke<Void>(0xCBB6E705, modelHash, x, y, z, p4, p5); }
	static void SET_OBJECT_COLLIDE_WITH_NON_PLAYER_CHARACTER(Object object, BOOL toggle) { invoke<Void>(0xF77D385E, object, toggle); }
	static void SET_OBJECT_USE_WATER_PARTICLES(Object object, BOOL toggle) { invoke<Void>(0x549C7D2A, object, toggle); }
	static void FORCE_REMOVE_AND_ADD_OBJECT(Object object) { invoke<Void>(0x180D3A13, object); }
	static void SET_OBJECT_COLLIDE_WITH_OTHER_OBJECTS(Object object, BOOL toggle) { invoke<Void>(0x53B55EE5, object, toggle); }
	static Object CREATE_SIMPLE_PED(Hash modelHash, float x, float y, float z, float heading, Hash p6, BOOL p7) { return invoke<Object>(0x43010177, modelHash, x, y, z, heading, p6, p7); }
	static void DELETE_SIMPLE_PED(Object* ped) { invoke<Void>(0x3A945159, ped); }
	static BOOL PLAY_SIMPLE_PED_ANIM(Object ped, char* animDict, char* animName, float speedMultiplier, BOOL p4, BOOL p5) { return invoke<BOOL>(0x5DC2CC31, ped, animDict, animName, speedMultiplier, p4, p5); }
	static void _0x017A92A7(Hash modelHash, float x, float y, float z, float radius) { invoke<Void>(0x017A92A7, modelHash, x, y, z, radius); }
}

namespace SCRIPT
{
	static Request_s REQUEST_SCRIPT(char* name) { return invoke<Request_s>(0xE26B2666, name); }
	static void SET_SCRIPT_AS_NO_LONGER_NEEDED(char* name) { invoke<Void>(0x6FCB7795, name); }
	static BOOL HAS_SCRIPT_LOADED(char* name) { return invoke<BOOL>(0x5D67F751, name); }
	static BOOL DOES_SCRIPT_EXIST(char* name) { return invoke<BOOL>(0xDEAB87AB, name); } // unused
	static void TERMINATE_THREAD(int threadId) { invoke<Void>(0x253FD520, threadId); } // unused
	static void SET_EXITFLAG_FOR_SCRIPT(int threadId) { invoke<Void>(0x8A79C0E0, threadId); }
	static BOOL IS_EXITFLAG_SET(int threadId) { return invoke<BOOL>(0x687ECC3C, threadId); }
	static void SET_EXITFLAG_RESPONSE() { invoke<Void>(0x551125B9); }
	static BOOL IS_THREAD_ACTIVE(int threadId) { return invoke<BOOL>(0x78D7A5A0, threadId); }
	static BOOL IS_THIS_THREAD_ISOLATED(int threadId) { return invoke<BOOL>(0x79C9D9AF, threadId); }
	static BOOL IS_THIS_THREAD_CONNECTED(int threadId) { return invoke<BOOL>(0x5DE08B39, threadId); }
	static void GET_THIS_THREAD_FRIENDLY_NAME(int bufferSize, char* buffer) { invoke<Void>(0x277B10EE, bufferSize, buffer); } // unused
	static int GET_ID_OF_THIS_THREAD() { return invoke<int>(0xDE524830); }
	static void TERMINATE_THIS_THREAD() { invoke<Void>(0x3CD9CBB7); }
	static int GET_NUMBER_OF_THREADS_RUNNING_THIS_SCRIPT(char* scriptName) { return invoke<int>(0x1E941253, scriptName); }
	static int COMPARE_AND_SWAP(int* p0, int p1, int p2) { return invoke<int>(0xC3FFAA9F, p0, p1, p2); } // unused
	static void CHECKPOINT_STORAGE_SAVE(Any* data, int dataSize, int checkpoint) { invoke<Void>(0x2C0A7F20, data, dataSize, checkpoint); }
	static BOOL CHECKPOINT_STORAGE_LOAD(Any* data, int dataSize) { return invoke<BOOL>(0x08FE3BFF, data, dataSize); }
	static void SET_LEVEL_COMPLETION(int value) { invoke<Void>(0x03C14716, value); } // unused
	static int GET_LEVEL_COMPLETION() { return invoke<int>(0xD58CA839); } // unused
	static void CLEAR_LEVEL_COMPLETION() { invoke<Void>(0xCDA1884F); } // unused
	static BOOL IS_TUTORIAL_COMPLETE() { return invoke<BOOL>(0xB1E326FE); }
	static void SET_TUTORIAL_COMPLETE() { invoke<Void>(0x854FAB50); }
	static BOOL IS_LMS_TUTORIAL_COMPLETE() { return invoke<BOOL>(0x8357057A); } // unused
	static void SET_LMS_TUTORIAL_COMPLETE() { invoke<Void>(0x6715E605); } // unused
	static void CLEAR_TUTORIAL_COMPLETE() { invoke<Void>(0xF29F7694); } // unused
	static void SAVE_PICKUPS() { invoke<Void>(0x4CED5E31); }
	static void RESTORE_PICKUPS() { invoke<Void>(0x15E96C6B); }
	static BOOL EXISTS_SCRIPT_TUNABLE_VARIABLE_BOOL(char* context, char* name) { return invoke<BOOL>(0x34E79A7D, context, name); } // unused
	static BOOL GET_SCRIPT_TUNABLE_VARIABLE_BOOL(char* context, char* name) { return invoke<BOOL>(0x12427628, context, name); } // unused
	static BOOL REGISTER_SCRIPT_TUNABLE_VARIABLE_INT(char* context, char* name, int* value) { return invoke<BOOL>(0xFA39724D, context, name, value); }
	static BOOL REGISTER_SCRIPT_TUNABLE_VARIABLE_FLOAT(char* context, char* name, float* value) { return invoke<BOOL>(0xF6F9855F, context, name, value); }
	static BOOL ADD_SCRIPT_TUNABLE_BOOL(char* context, char* name, BOOL value) { return invoke<BOOL>(0x9F25E66C, context, name, value); } // unused
	static BOOL ADD_SCRIPT_TUNABLE_INT(char* context, char* name, int value) { return invoke<BOOL>(0x84C024B8, context, name, value); } // unused
	static BOOL ADD_SCRIPT_TUNABLE_FLOAT(char* context, char* name, float value) { return invoke<BOOL>(0x7DA01BE3, context, name, value); } // unused
	static BOOL EXISTS_SCRIPT_TUNABLE_VARIABLE_CRC_BOOL(Hash tunableHash) { return invoke<BOOL>(0xA8D360E2, tunableHash); } // unused
	static BOOL GET_SCRIPT_TUNABLE_VARIABLE_CRC_BOOL(Hash tunableHash) { return invoke<BOOL>(0x29DC159B, tunableHash); } // unused
	static BOOL REGISTER_SCRIPT_TUNABLE_VARIABLE_CRC_INT(Hash tunableHash, int* value) { return invoke<BOOL>(0x9E87D9D6, tunableHash, value); } // unused
	static BOOL REGISTER_SCRIPT_TUNABLE_VARIABLE_CRC_FLOAT(Hash tunableHash, float* value) { return invoke<BOOL>(0x5EB671C0, tunableHash, value); } // unused
	static BOOL ADD_SCRIPT_TUNABLE_CRC_BOOL(Hash tunableHash, BOOL value) { return invoke<BOOL>(0x754B769B, tunableHash, value); } // unused
	static BOOL ADD_SCRIPT_TUNABLE_CRC_INT(Hash tunableHash, int value) { return invoke<BOOL>(0x07A49981, tunableHash, value); } // unused
	static BOOL ADD_SCRIPT_TUNABLE_CRC_FLOAT(Hash tunableHash, float value) { return invoke<BOOL>(0xB16DFC67, tunableHash, value); } // unused
	static Any PROFILER_DUMP_VALUES() { return invoke<Any>(0x604930BC); } // unused
	static void FLUSH_DISCARDABLE_MEMORY(int p0) { invoke<Void>(0x8C3169D5, p0); }
	static void FLUSH_STREAM_MEMORY() { invoke<Void>(0x59085E59); }
}

namespace STATS
{
	static void STAT_HASH_INCREMENT_INT(Hash statHash, int value) { invoke<Void>(0xD2B83ECE, statHash, value); }
	static void STAT_HASH_DECREMENT_INT(Hash statHash, int value) { invoke<Void>(0x04FBDB9F, statHash, value); }
	static void STAT_HASH_INCREMENT_FLOAT(Hash statHash, float value) { invoke<Void>(0x9130A032, statHash, value); }
	static void STAT_HASH_DECREMENT_FLOAT(Hash statHash, float value) { invoke<Void>(0xBA1661EC, statHash, value); } // unused
	static void STAT_HASH_SET_INT(Hash statHash, int value) { invoke<Void>(0x2D2ECF2D, statHash, value); }
	static void STAT_HASH_SET_FLOAT(Hash statHash, float value) { invoke<Void>(0xF7291D39, statHash, value); }
	static void STAT_INCREMENT_INT(char* statName, int value) { invoke<Void>(0x4470A2D3, statName, value); } // unused
	static void STAT_DECREMENT_INT(char* statName, int value) { invoke<Void>(0x5C7AA25B, statName, value); } // unused
	static void STAT_INCREMENT_FLOAT(char* statName, float value) { invoke<Void>(0x562B69E2, statName, value); } // unused
	static void STAT_DECREMENT_FLOAT(char* statName, float value) { invoke<Void>(0xEEB7CFAD, statName, value); } // unused
	static void STAT_SET_INT(char* statName, int value) { invoke<Void>(0xC9CC1C5C, statName, value); }
	static void STAT_SET_FLOAT(char* statName, float value) { invoke<Void>(0x6CEA96F2, statName, value); } // unused
	static void SCRIPT_VAR_HASH_SET_INT(Hash hash, int value) { invoke<Void>(0x8298D3E8, hash, value); }
	static void SCRIPT_VAR_HASH_SET_FLOAT(Hash hash, float value) { invoke<Void>(0xE17F81DB, hash, value); }
	static void SCRIPT_VAR_SET_INT(Hash hash, int value) { invoke<Void>(0x61EF16A0, hash, value); }
	static void SCRIPT_VAR_SET_FLOAT(Hash hash, float value) { invoke<Void>(0x31BE53D4, hash, value); } // unused
	static void INCREMENT_STREAK_STAT(char* statName, int p1, int p2) { invoke<Void>(0x3CBC4B74, statName, p1, p2); }
	static void CLEAR_KILL_STREAK_RECORDS() { invoke<Void>(0xD3B3E2DB); }
	static void CLEAR_COLLECTABLE_STATS() { invoke<Void>(0x9535509B); } // unused
	static BOOL IS_STAT_FLOAT(char* statName) { return invoke<BOOL>(0x0E0AB836, statName); } // unused
	static BOOL IS_STAT_HASH_FLOAT(Hash statHash) { return invoke<BOOL>(0xEF26133B, statHash); }
	static int STAT_GET_INT(char* statName) { return invoke<int>(0x1C6FE43E, statName); }
	static float STAT_GET_FLOAT(char* statName) { return invoke<float>(0xFCBDA612, statName); } // unused
	static int STAT_HASH_GET_INT(Hash statHash) { return invoke<int>(0xEC6F7181, statHash); }
	static float STAT_HASH_GET_FLOAT(Hash statHash) { return invoke<float>(0xE143F19A, statHash); }
	static int SCRIPT_VAR_HASH_GET_INT(Hash hash) { return invoke<int>(0x00CF2FB4, hash); }
	static float SCRIPT_VAR_HASH_GET_FLOAT(Hash hash) { return invoke<float>(0xBFADDD7B, hash); } // unused
	static int SCRIPT_VAR_GET_INT(char* name) { return invoke<int>(0x3CD83D18, name); }
	static float SCRIPT_VAR_GET_FLOAT(char* name) { return invoke<float>(0x7544B570, name); } // unused
	static void STAT_HASH_WAIT_FOR_CHANGE_INT(Hash statHash, int value) { invoke<Void>(0x59D78FCB, statHash, value); } // unused
	static void STAT_HASH_WAIT_FOR_CHANGE_FLOAT(Hash statHash, float value) { invoke<Void>(0xEA2D7D0D, statHash, value); } // unused
	static void STAT_WAIT_FOR_CHANGE_INT(char* statName, int value) { invoke<Void>(0x04E41F40, statName, value); } // unused
	static void STAT_WAIT_FOR_CHANGE_FLOAT(char* statName, float value) { invoke<Void>(0x48E0F996, statName, value); } // unused
	static void STAT_WAIT(int argCount, ...) // unused
	{
		NativeContext cxt;

		va_list _nativeVarArgsList; const int _nativeVarArgsCount = argCount * 2; ((_nativeVarArgsList) = __va_funcx (2, (char *) __builtin_addrof((_nativeVarArgsCount))));;
		cxt.nativePush(argCount);
		for (int i = 0; i < _nativeVarArgsCount; i++) { cxt . nativePush((*((Any *) __va_funcx (3, (_nativeVarArgsList),((Any *) 0))))); };
		((void) 0);;

		nativeCall<Void>(0x6E4FDBAF, &cxt);
	}
	static void STAT_WAIT_UNTIL_EXIST(int argCount, ...) // unused
	{
		NativeContext cxt;

		va_list _nativeVarArgsList; const int _nativeVarArgsCount = argCount * 2; ((_nativeVarArgsList) = __va_funcx (2, (char *) __builtin_addrof((_nativeVarArgsCount))));;
		cxt.nativePush(argCount);
		for (int i = 0; i < _nativeVarArgsCount; i++) { cxt . nativePush((*((Any *) __va_funcx (3, (_nativeVarArgsList),((Any *) 0))))); };
		((void) 0);;

		nativeCall<Void>(0x7B9443BF, &cxt);
	}
	static Any SCRIPT_VAR_HASH_WAIT_FOR_CHANGE_INT() { return invoke<Any>(0xFF735813); } // unused
	static Any SCRIPT_VAR_HASH_WAIT_FOR_CHANGE_FLOAT() { return invoke<Any>(0xEC96E1B4); } // unused
	static Any SCRIPT_VAR_WAIT_FOR_CHANGE_INT() { return invoke<Any>(0x2A05F0E3); } // unused
	static Any SCRIPT_VAR_WAIT_FOR_CHANGE_FLOAT() { return invoke<Any>(0xB4123E01); } // unused
	static void SCRIPT_VAR_WAIT(int argCount, ...) // unused
	{
		NativeContext cxt;

		va_list _nativeVarArgsList; const int _nativeVarArgsCount = argCount * 2; ((_nativeVarArgsList) = __va_funcx (2, (char *) __builtin_addrof((_nativeVarArgsCount))));;
		cxt.nativePush(argCount);
		for (int i = 0; i < _nativeVarArgsCount; i++) { cxt . nativePush((*((Any *) __va_funcx (3, (_nativeVarArgsList),((Any *) 0))))); };
		((void) 0);;

		nativeCall<Void>(0xB4A10F8D, &cxt);
	}
	static void SCRIPT_VAR_WAIT_UNTIL_EXIST(int argCount, ...) // unused
	{
		NativeContext cxt;

		va_list _nativeVarArgsList; const int _nativeVarArgsCount = argCount * 2; ((_nativeVarArgsList) = __va_funcx (2, (char *) __builtin_addrof((_nativeVarArgsCount))));;
		cxt.nativePush(argCount);
		for (int i = 0; i < _nativeVarArgsCount; i++) { cxt . nativePush((*((Any *) __va_funcx (3, (_nativeVarArgsList),((Any *) 0))))); };
		((void) 0);;

		nativeCall<Void>(0x1348D449, &cxt);
	}
	static BOOL STAT_HASH_EXISTS(Hash statHash) { return invoke<BOOL>(0x2146FEC9, statHash); }
	static void STAT_HASH_ADD_INT(Hash statHash, BOOL p1, BOOL p2) { invoke<Void>(0xA820FB24, statHash, p1, p2); } // unused
	static void STAT_HASH_ADD_FLOAT(Hash statHash, BOOL p1, BOOL p2) { invoke<Void>(0xB5B89FD2, statHash, p1, p2); } // unused
	static BOOL STAT_EXISTS(char* statName) { return invoke<BOOL>(0x3076C37C, statName); }
	static void STAT_ADD_INT(char* statName, BOOL p1, BOOL p2) { invoke<Void>(0x528AA36E, statName, p1, p2); } // unused
	static void STAT_ADD_FLOAT(char* statName, BOOL p1, BOOL p2) { invoke<Void>(0xA54780E8, statName, p1, p2); } // unused
	static BOOL SCRIPT_VAR_HASH_EXISTS(Hash hash) { return invoke<BOOL>(0x1046A414, hash); }
	static void SCRIPT_VAR_HASH_ADD_INT(Hash hash) { invoke<Void>(0xC8B588A8, hash); }
	static void SCRIPT_VAR_HASH_ADD_FLOAT(Hash hash) { invoke<Void>(0x785C8236, hash); }
	static BOOL SCRIPT_VAR_EXISTS(char* name) { return invoke<BOOL>(0x9073311E, name); }
	static void SCRIPT_VAR_ADD_INT(char* name) { invoke<Void>(0xFC611F3C, name); }
	static void SCRIPT_VAR_ADD_FLOAT(char* name) { invoke<Void>(0x1F48312D, name); } // unused
	static BOOL ARE_SP_STATS_LOADED() { return invoke<BOOL>(0xA73A7E53); }
	static BOOL ARE_MP_STATS_LOADED() { return invoke<BOOL>(0x2469CD25); } // unused
	static Any LEADERBOARDS_GET_NUMBER_OF_COLUMNS(Any p0) { return invoke<Any>(0x0A56EE34, p0); }
	static Any LEADERBOARDS_GET_COLUMN_ID() { return invoke<Any>(0x3821A334); } // unused
	static Any LEADERBOARDS_WRITE_PLAYER_DATA(Any p0, Any p1) { return invoke<Any>(0xFF8BA326, p0, p1); }
	static Any LEADERBOARDS_WRITE_GROUP_DATA(Any p0, Any p1) { return invoke<Any>(0xB7CBBFC1, p0, p1); }
	static Any LEADERBOARDS_WRITE__ROS__PLAYER_DATA(Any p0, Any p1) { return invoke<Any>(0x2A12675D, p0, p1); }
	static Any LEADERBOARDS_WRITE_FLUSH() { return invoke<Any>(0x7579C0B4); }
	static Any LEADERBOARDS_READ_BY_GAMER() { return invoke<Any>(0x37338B11); } // unused
	static Any LEADERBOARDS_READ_BY_COMMUNITY(Any p0) { return invoke<Any>(0x5023C8AB, p0); }
	static Any LEADERBOARDS_READ_BY_RANK_EX(Any p0, Any p1, Any p2, Any p3, Any p4) { return invoke<Any>(0xB5F57E71, p0, p1, p2, p3, p4); }
	static Any LEADERBOARDS_READ_BY_RADIUS_EX() { return invoke<Any>(0xCD659683); } // unused
	static Any LEADERBOARDS_READ_FOR_LOCAL_GAMER_EX(Any p0, Any p1) { return invoke<Any>(0xF872E9F6, p0, p1); }
	static BOOL LEADERBOARDS_READ__ROS__FOR_LOCAL_GAMER(Any p0) { return invoke<BOOL>(0x9349F590, p0); }
	static Any LEADERBOARDS_READ_PENDING(Any p0) { return invoke<Any>(0xEEB8BF5C, p0); }
	static Any LEADERBOARDS_READ_FINISHED_AND_SUCCEEDED(Any p0) { return invoke<Any>(0x556A674E, p0); }
	static Any LEADERBOARDS_READ_GET_NUM_ROWS_EX() { return invoke<Any>(0xE60FFF5C); } // unused
	static Any LEADERBOARDS_READ_GET_ROW_DATA_EX(Any p0, Any p1, Any p2, Any p3) { return invoke<Any>(0x8B4ABFF9, p0, p1, p2, p3); }
	static Any LEADERBOARDS_READ_GET_ROW_DATA_FOR_LOCAL_GAMER_EX(Any p0, Any p1, Any p2) { return invoke<Any>(0x680D09F3, p0, p1, p2); }
	static void LEADERBOARDS_READ_RELEASE_DATA(Any p0) { invoke<Void>(0x18E901C2, p0); }
	static void START_CONTEXT_HASH(Hash hash) { invoke<Void>(0x906945AC, hash); }
	static void END_CONTEXT_HASH(Hash hash) { invoke<Void>(0x1211D06C, hash); }
	static void START_CONTEXT(char* name) { invoke<Void>(0xF1A3B61A, name); }
	static void END_CONTEXT(char* name) { invoke<Void>(0xDFFE2760, name); }
	static Any BG_SCRIPT_ADJUST_BY_UNIT(Any p0, Any p1) { return invoke<Any>(0x6124EBD6, p0, p1); }
	static int GET_BG_SCRIPT_UNIT(int index) { return invoke<int>(0x46D59A47, index); } // unused
	static Any GET_ICON_TEXTURE_FOR_BG_SCRIPT(Any p0) { return invoke<Any>(0x4FB44F82, p0); }
	static Any GET_ICON_TEXTURE_DICTIONARY_FOR_BG_SCRIPT(Any p0) { return invoke<Any>(0x424BE196, p0); }
	static void GET_BG_TEXTURE_FOR_BG_SCRIPT(Any p0, Any* p1, Any* p2) { invoke<Void>(0x943C6E08, p0, p1, p2); }
	static Any GET_UI_NAME_FOR_BG_SCRIPT(Any p0) { return invoke<Any>(0x6873C76D, p0); }
	static Any GET_UI_DESCRIPTION_FOR_BG_SCRIPT(Any p0) { return invoke<Any>(0xDAFCCF7F, p0); }
	static void DEBUG_GET_BG_SCRIPT_NAME(int index, int bufferSize, char* buffer) { invoke<Void>(0x03882657, index, bufferSize, buffer); }
	static int GET_GRIND_PROGRESS(int grindId) { return invoke<int>(0x455FF144, grindId); }
	static BOOL SET_GRIND_PROGRESS(int grindId, int progress) { return invoke<BOOL>(0xC97141EE, grindId, progress); }
	static int GET_GRIND_GOAL(int grindId) { return invoke<int>(0xCB12EA00, grindId); } // unused
	static int GET_COMPLETED_GRIND_GOAL(int grindId) { return invoke<int>(0x0EF6FE8F, grindId); }
	static BOOL IS_GRIND_COMPLETE(int grindId) { return invoke<BOOL>(0x81AB05BB, grindId); }
	static int GET_GRIND_LEVEL(int grindId) { return invoke<int>(0x20E6EB3A, grindId); }
	static int GET_CHALLENGE_PROGRESS(int challengeId) { return invoke<int>(0x653D3616, challengeId); }
	static BOOL SET_CHALLENGE_PROGRESS(int challengeId) { return invoke<BOOL>(0x45052DC3, challengeId); }
	static BOOL GET_CHALLENGE_FAILED_STATE(int challengeId) { return invoke<BOOL>(0x8BD57283, challengeId); } // unused
	static BOOL SET_CHALLENGE_FAILED_STATE(int challengeId, BOOL state) { return invoke<BOOL>(0x6DDDD8C3, challengeId, state); }
	static BOOL DID_PLAYER_QUIT_LEVEL(Any p0) { return invoke<BOOL>(0x28041AC7, p0); }
	static BOOL GET_BG_SCRIPT_LEADERBOARD_NAME(int index, int bufferSize, char* buffer) { return invoke<BOOL>(0x2694F2B0, index, bufferSize, buffer); }
	static BOOL HAS_ACHIEVEMENT_HASH(int p0) { return invoke<BOOL>(0xCE0909E9, p0); }
	static Hash GET_ACHIEVEMENT_HASH(int p0) { return invoke<Hash>(0x902D558D, p0); }
	static BOOL DOES_LAUNCH_PARAM_EXIST(int p0, char* paramName) { return invoke<BOOL>(0x4EE8FFA2, p0, paramName); }
	static int GET_LAUNCH_PARAM_VALUE(int p0, char* paramName) { return invoke<int>(0x7C68A735, p0, paramName); }
	static Any _0xEDEF3C86(int p0, char* p1) { return invoke<Any>(0xEDEF3C86, p0, p1); } // unused
	static BOOL COMPARE_AGAINST_SCORE_PARAM(int p0, int p1, char* paramName) { return invoke<BOOL>(0xD79D2DA4, p0, p1, paramName); }
	static int GET_SCRIPT_ID_FROM_NAME_HASH(Hash hash) { return invoke<int>(0xB28F8DC4, hash); }
	static void GIVE_BG_SCRIPT_AWARD(int awardId, BOOL* p1) { invoke<Void>(0xDE4ECCE9, awardId, p1); }
	static void _0x553C4809(BOOL toggle) { invoke<Void>(0x553C4809, toggle); }
}

namespace STREAMING
{
	static void LOAD_ALL_OBJECTS_NOW() { invoke<Void>(0xC9DBDA90); }
	static void LOAD_SCENE(float x, float y, float z) { invoke<Void>(0xB72403F5, x, y, z); }
	static void NETWORK_START_LOAD_SCENE(float x, float y, float z) { invoke<Void>(0x4280D528, x, y, z); }
	static BOOL NETWORK_UPDATE_LOAD_SCENE() { return invoke<BOOL>(0xC76E023C); }
	static void LOAD_SCENE_FOR_ROOM_BY_KEY(Interior interior, Hash roomHash) { invoke<Void>(0x2CE2EEF9, interior, roomHash); }
	static void MARK_INTERIOR_COLLISION_REQUIRED(Interior interior) { invoke<Void>(0x3CC6D319, interior); }
	static void CLEAR_INTERIOR_COLLISION_REQUIRED(Interior interior) { invoke<Void>(0xA868D193, interior); }
	static void SET_INTERIOR_ACTIVE(Interior interior, BOOL p1, BOOL p2) { invoke<Void>(0xE1013910, interior, p1, p2); }
	static void SET_INTERIOR_FORCE_INSTANTIATION(Interior interior, BOOL toggle) { invoke<Void>(0x449FEFDF, interior, toggle); }
	static Request_s REQUEST_MODEL(Hash modelHash) { return invoke<Request_s>(0xFFF1B500, modelHash); }
	static BOOL HAS_MODEL_LOADED(Hash modelHash) { return invoke<BOOL>(0x62BFDB37, modelHash); }
	static void GET_MODEL_NAME(int bufferSize, char* buffer, Hash modelHash) { invoke<Void>(0xCBDB1D12, bufferSize, buffer, modelHash); } // unused
	static void REQUEST_WEAPON(Hash weaponHash) { invoke<Void>(0xA9D5ADEC, weaponHash); }
	static BOOL HAS_WEAPON_LOADED(Hash weaponHash) { return invoke<BOOL>(0x4132E42F, weaponHash); }
	static void REQUEST_INTERIOR_MODELS(Hash modelHash, char* p1) { invoke<Void>(0x0514857A, modelHash, p1); } // unused
	static void SET_MODEL_AS_NO_LONGER_NEEDED(Hash modelHash) { invoke<Void>(0xAE0F069E, modelHash); }
	static void SET_WEAPON_AS_NO_LONGER_NEEDED(Hash weaponHash) { invoke<Void>(0x9A0E29DE, weaponHash); }
	static BOOL IS_MODEL_IN_CDIMAGE(Hash modelHash) { return invoke<BOOL>(0x1094782F, modelHash); }
	static BOOL GET_PED_MODEL_FROM_INDEX(int index, Hash* modelHash) { return invoke<BOOL>(0xC4765BEE, index, modelHash); } // unused
	static BOOL GET_VEHICLE_MODEL_FROM_INDEX(int index, Hash* modelHash) { return invoke<BOOL>(0x70691B3C, index, modelHash); } // unused
	static BOOL IS_MODEL_A_PED(Hash modelHash) { return invoke<BOOL>(0x4B933365, modelHash); } // unused
	static BOOL IS_MODEL_A_VEHICLE(Hash modelHash) { return invoke<BOOL>(0xFFFC85D4, modelHash); } // unused
	static void SET_STREAMING_POINT_OF_INTEREST(float p0, float p1, float p2, BOOL p3, float p4) { invoke<Void>(0x27BA0211, p0, p1, p2, p3, p4); }
	static void RESET_STREAMING_POINT_OF_INTEREST() { invoke<Void>(0x9364E0D4); }
	static void FORCE_ALL_STREAMING_HELPERS_ACTIVE(BOOL toggle) { invoke<Void>(0xAD8BE232, toggle); }
	static void _0x10216522(BOOL toggle) { invoke<Void>(0x10216522, toggle); }
	static void REQUEST_COLLISION_AT_COORD(float x, float y, float z) { invoke<Void>(0xCD9805E7, x, y, z); }
	static void REQUEST_ROOM_MINIMAL_COLLISION_MESH_BY_KEY(Hash roomHash) { invoke<Void>(0x97E21CB0, roomHash); }
	static void REQUEST_COLLISION_FOR_MODEL(Hash modelHash) { invoke<Void>(0x3930C042, modelHash); } // unused
	static BOOL HAS_COLLISION_FOR_MODEL_LOADED(Hash modelHash) { return invoke<BOOL>(0x41A094F8, modelHash); } // unused
	static Request_s REQUEST_ANIM_DICT(char* dictName, BOOL p1) { return invoke<Request_s>(0xDCA96950, dictName, p1); }
	static BOOL HAS_ANIM_DICT_LOADED(char* dictName, BOOL p1) { return invoke<BOOL>(0x05E6763C, dictName, p1); }
	static void REMOVE_ANIM_DICT(char* dictName, BOOL p1) { invoke<Void>(0x0AE050B5, dictName, p1); }
	static void REQUEST_IPL(char* iplName, BOOL p1) { invoke<Void>(0x3B70D1DB, iplName, p1); }
	static void REMOVE_IPL(char* iplName, BOOL p1) { invoke<Void>(0xDF7CBD36, iplName, p1); }
	static void SYNC_FRAGMENT_OBJECTS_IN_IPL(char* iplName, BOOL toggle) { invoke<Void>(0xCD06F35C, iplName, toggle); }
	static void SET_ROOM_FOR_OBJECTS_IN_IPL(Any p0, Any p1, Any p2) { invoke<Void>(0x2BE9CC9D, p0, p1, p2); }
	static void SET_IPL_ALWAYS_SEES_EXPLOSION(char* iplName) { invoke<Void>(0xC59C35A7, iplName); }
	static void SET_NEXT_STREAMING_REQUEST_A_PRIORITY() { invoke<Void>(0x20F0F689); } // unused
	static void SET_STREAMING(BOOL toggle) { invoke<Void>(0x27EF6CB2, toggle); }
	static void SET_SCENE_STREAMING(BOOL toggle) { invoke<Void>(0xC988470E, toggle); } // unused
	static Any RESERVE_STREAMING_MEMORY() { return invoke<Any>(0xACD474EB); } // unused
	static Any RELEASE_STREAMING_MEMORY() { return invoke<Any>(0x53CB7864); } // unused
	static void FORCE_WEAPON_LOAD() { invoke<Void>(0xD97732B9); }
	static void SET_OBJECTS_AT_COORD_NOT_REMOVED_BY_STREAMING(float x, float y, float z) { invoke<Void>(0x45BDCE6D, x, y, z); } // unused
	static void SET_GAME_PAUSES_FOR_STREAMING(BOOL toggle) { invoke<Void>(0x9211A28A, toggle); } // unused
	static void SET_REDUCE_PED_MODEL_BUDGET(BOOL toggle) { invoke<Void>(0xAFCB2B86, toggle); } // unused
	static void SET_REDUCE_VEHICLE_MODEL_BUDGET(BOOL toggle) { invoke<Void>(0xCDB4FB7E, toggle); } // unused
	static void SET_DITCH_POLICE_MODELS(BOOL toggle) { invoke<Void>(0x3EA7FCE4, toggle); } // unused
	static int GET_STABLE_NUM_OF_STREAMING_REQUESTS() { return invoke<int>(0xCDADFF5D); }
	static int GET_STABLE_NUM_OF_PRIORITY_REQUESTS() { return invoke<int>(0x84BBBC8B); }
	static int GET_NUMBER_OF_STREAMING_REQUESTS() { return invoke<int>(0xC2EE9A02); }
	static BOOL IS_STREAMING_PRIORITY_REQUESTS() { return invoke<BOOL>(0xD2E1E5DC); } // unused
	static BOOL HAS_STREAMPED_LOADED(Ped ped) { return invoke<BOOL>(0x216F12A4, ped); } // unused
	static void STREAM_HELPERS_INIT() { invoke<Void>(0x13D43922); }
	static void SET_HELPER_TRACKING_MODE(int mode) { invoke<Void>(0xC935A93D, mode); }
	static void SET_HELPER_ENABLED(char* iplName, BOOL p1, BOOL p2) { invoke<Void>(0x7E9977FC, iplName, p1, p2); }
	static void STREAM_HELPERS_REQUEST_AT_LOC(float x, float y, float z, BOOL p3) { invoke<Void>(0x7C544BF3, x, y, z, p3); }
	static void STREAM_HELPERS_DEACTIVATE() { invoke<Void>(0xBDA5C5F7); } // unused
	static void STREAM_HELPERS_REACTIVATE() { invoke<Void>(0xE2E89E47); } // unused
	static void SET_BULLETCAM_STREAMHELPERS_ENABLED(BOOL toggle) { invoke<Void>(0x19529920, toggle); }
}

namespace PATHFIND
{
	static void SET_ROADS_IN_AREA(float x1, float y1, float z1, float x2, float y2, float z2, BOOL missionFlag) { invoke<Void>(0xEBC7B918, x1, y1, z1, x2, y2, z2, missionFlag); } // unused
	static void SET_PED_PATHS_IN_AREA(float x1, float y1, float z1, float x2, float y2, float z2, BOOL missionFlag) { invoke<Void>(0x2148EA84, x1, y1, z1, x2, y2, z2, missionFlag); } // unused
	static BOOL GET_SAFE_COORD_FOR_PED(float x, float y, float z, BOOL p3, Vector3* coord) { return invoke<BOOL>(0xB370270A, x, y, z, p3, coord); }
	static BOOL GET_CLOSEST_VEHICLE_NODE(float x, float y, float z, Vector3* coords) { return invoke<BOOL>(0x6F5F1E6C, x, y, z, coords); } // unused
	static BOOL GET_CLOSEST_MAJOR_VEHICLE_NODE(float x, float y, float z, Vector3* coords) { return invoke<BOOL>(0x04B5F15B, x, y, z, coords); } // unused
	static BOOL GET_CLOSEST_VEHICLE_NODE_WITH_HEADING(float x, float y, float z, Vector3* coords, float* heading) { return invoke<BOOL>(0x8BD5759B, x, y, z, coords, heading); } // unused
	static BOOL GET_NTH_CLOSEST_VEHICLE_NODE(float x, float y, float z, int n, Vector3* coords) { return invoke<BOOL>(0xF125BFCC, x, y, z, n, coords); } // unused
	static BOOL GET_NTH_CLOSEST_VEHICLE_NODE_WITH_HEADING(float x, float y, float z, int n, Vector3* coords, float* heading) { return invoke<BOOL>(0x7349C856, x, y, z, n, coords, heading); } // unused
	static BOOL GET_NTH_CLOSEST_VEHICLE_NODE_WITH_HEADING_ON_ISLAND(float x, float y, float z, int n, Vector3* coords, float* heading) { return invoke<BOOL>(0x39998BD2, x, y, z, n, coords, heading); } // unused
	static BOOL GET_NEXT_CLOSEST_VEHICLE_NODE_WITH_HEADING_ON_ISLAND(float x, float y, float z, int p3, Vector3* coords, float* heading) { return invoke<BOOL>(0xC70C3E6F, x, y, z, p3, coords, heading); } // unused
	static BOOL GET_NTH_CLOSEST_VEHICLE_NODE_FAVOUR_DIRECTION(float x1, float y1, float z1, float x2, float y2, float z2, int n, Vector3* coords, float* heading) { return invoke<BOOL>(0x928A4DEC, x1, y1, z1, x2, y2, z2, n, coords, heading); } // unused
	static BOOL GET_CLOSEST_ROAD(float x, float y, float z, float p3, Any p4, Vector3* p5, Vector3* p6, Any* p7, Any* p8, Any* p9) { return invoke<BOOL>(0x567B0E11, x, y, z, p3, p4, p5, p6, p7, p8, p9); } // unused
	static void LOAD_PATH_NODES_IN_AREA(float x1, float y1, float x2, float y2) { invoke<Void>(0x8BFF98AC, x1, y1, x2, y2); } // unused
	static void RELEASE_PATH_NODES() { invoke<Void>(0xAD7744E9); } // unused
	static BOOL LOAD_ALL_PATH_NODES(BOOL p0) { return invoke<BOOL>(0xC66E28C3, p0); }
	static void SET_ROADS_BACK_TO_ORIGINAL(float x1, float y1, float z1, float x2, float y2, float z2) { invoke<Void>(0x86AC4A85, x1, y1, z1, x2, y2, z2); } // unused
	static void SET_PED_PATHS_BACK_TO_ORIGINAL(float x1, float y1, float z1, float x2, float y2, float z2) { invoke<Void>(0x3F1ABDA4, x1, y1, z1, x2, y2, z2); } // unused
	static BOOL GET_CLOSEST_NETWORK_RESTART_NODE(float x, float y, float z, Vector3* coords, float* heading) { return invoke<BOOL>(0xFFF0E04A, x, y, z, coords, heading); } // unused
	static BOOL GET_RANDOM_NETWORK_RESTART_NODE(float x, float y, float z, float radius, Vector3* coords, int* nodeId) { return invoke<BOOL>(0x943F64AD, x, y, z, radius, coords, nodeId); } // unused
	static BOOL GET_RANDOM_NETWORK_RESTART_NODE_USING_GROUP_LIST(float x, float y, float z, float radius, Vector3* coords, int* nodeId) { return invoke<BOOL>(0xB150397E, x, y, z, radius, coords, nodeId); } // unused
	static BOOL GET_SORTED_NETWORK_RESTART_NODE(float x, float y, float z, float radius, Vector3* coords, int* nodeId, int p6, int p7, float p8) { return invoke<BOOL>(0x0002B59A, x, y, z, radius, coords, nodeId, p6, p7, p8); } // unused
	static BOOL GET_SORTED_NETWORK_RESTART_NODE_USING_GROUP_LIST(float x, float y, float z, float radius, Vector3* coords, int* nodeId, int p6, int p7, float p8) { return invoke<BOOL>(0x040D4FAA, x, y, z, radius, coords, nodeId, p6, p7, p8); } // unused
	static void CLEAR_NETWORK_RESTART_NODE_GROUP_LIST() { invoke<Void>(0x5B4D98C0); } // unused
	static void ADD_GROUP_TO_NETWORK_RESTART_NODE_GROUP_LIST(int group) { invoke<Void>(0x3105DC1F, group); } // unused
	static void REGISTER_PLAYER_RESPAWN_COORDS(float x, float y, float z) { invoke<Void>(0x7AC5FEDC, x, y, z); } // unused
	static void ADD_SPAWN_BLOCKING_AREA(float x, float y, float z, float radius) { invoke<Void>(0xDAA55B46, x, y, z, radius); } // unused
	static void CLEAR_ALL_SPAWN_BLOCKING_AREAS() { invoke<Void>(0xF00D7922); } // unused
	static void GET_COORDS_FOR_NETWORK_RESTART_NODE(int nodeId, Vector3* coords, float* heading) { invoke<Void>(0xBBC0C52C, nodeId, coords, heading); } // unused
	static BOOL GET_RANDOM_VEHICLE_NODE(float x, float y, float z, float radius, int p4, BOOL p5, BOOL p6, Vector3* coords, int* nodeId) { return invoke<BOOL>(0xAD1476EA, x, y, z, radius, p4, p5, p6, coords, nodeId); } // unused
	static BOOL GET_RANDOM_VEHICLE_NODE_INCLUDE_SWITCHED_OFF_NODES(float x, float y, float z, float radius, int p4, BOOL p5, BOOL p6, Vector3* coords, int* nodeId) { return invoke<BOOL>(0x3D6947A3, x, y, z, radius, p4, p5, p6, coords, nodeId); } // unused
	static BOOL GET_RANDOM_WATER_NODE(float x, float y, float z, float radius, int p4, BOOL p5, BOOL p6, Vector3* coords, int* nodeId) { return invoke<BOOL>(0x869EE56F, x, y, z, radius, p4, p5, p6, coords, nodeId); } // unused
	static void GET_SPAWN_COORDS_FOR_VEHICLE_NODE(int nodeId, float x, float y, float z, Vector3* coords, float* heading) { invoke<Void>(0xC72099BA, nodeId, x, y, z, coords, heading); } // unused
	static void GET_STREET_NAME_AT_COORD(float x, float y, float z, Hash* streetNameHash, Hash* crossingRoadHash) { invoke<Void>(0xDEBEEFCF, x, y, z, streetNameHash, crossingRoadHash); } // unused
	static BOOL ARE_ALL_NAVMESH_REGIONS_LOADED() { return invoke<BOOL>(0x34C4E789); } // unused
	static void CREATE_DIRECTIONS_TO_COORD(float x, float y, float z, int* p3, int* p4) { invoke<Void>(0x0AE0E17F); } // unused
	static int CREATE_DYNAMIC_PATH_OBSTRUCTION(float x1, float y1, float z1, float x2, float y2, float z2, float p6) { return invoke<int>(0x94C84500, x1, y1, z1, x2, y2, z2, p6); }
	static void DESTROY_DYNAMIC_PATH_OBSTRUCTION(int id) { invoke<Void>(0xCFBE7489, id); }
}

namespace WEAPON
{
	static void GET_WEAPON_NAME(int bufferSize, char* buffer, Hash weaponHash) { invoke<Void>(0x0BE7A3F5, bufferSize, buffer, weaponHash); }
	static Hash GET_WEAPON_HUD_TEXTURE(Hash weaponHash) { return invoke<Hash>(0x9D6061F5, weaponHash); }
	static int GET_WEAPONTYPE_AMMO(Hash weaponHash) { return invoke<int>(0x687CABD1, weaponHash); }
	static int GET_WEAPON_GUNTYPE(Hash weaponHash) { return invoke<int>(0x43AF022D, weaponHash); }
	static BOOL IS_THROWN_WEAPON(Hash weaponHash) { return invoke<BOOL>(0x48EF964A, weaponHash); }
	static void SPAWN_GRENADE(Ped ped, Hash p1, float p2, float p3, float p4, float p5) { invoke<Void>(0x34E8E337, ped, p1, p2, p3, p4, p5); }
	static Hash GET_WEAPONTYPE_MODEL(Hash weaponHash) { return invoke<Hash>(0x44E1C269, weaponHash); } // unused
	static void SET_CURRENT_PED_WEAPON(Ped ped, Hash weaponHash, BOOL equipNow) { invoke<Void>(0xB8278882, ped, weaponHash, equipNow); } // unused
	static BOOL GET_CURRENT_PED_WEAPON(Ped ped, Hash* weaponHash, int handType) { return invoke<BOOL>(0xB0237302, ped, weaponHash, handType); } // unused
	static BOOL IS_PED_ARMED(Ped ped) { return invoke<BOOL>(0x0BFC892C, ped); }
	static void SELECT_WEAPON_TO_HAND(Ped ped, Weapon weapon, int handType, BOOL p3) { invoke<Void>(0xEF918984, ped, weapon, handType, p3); }
	static Weapon GET_WEAPON_FROM_HAND(Ped ped, int handType, BOOL p2) { return invoke<Weapon>(0xF5A9F0F9, ped, handType, p2); }
	static Weapon GET_WEAPON_FROM_HOLSTER(Ped ped, int holsterType) { return invoke<Weapon>(0x4F1AB270, ped, holsterType); }
	static BOOL GET_DOES_WEAPON_EXIST(Weapon weapon) { return invoke<BOOL>(0x066A14D7, weapon); }
	static int GET_WEAPON_AMMO(Weapon weapon) { return invoke<int>(0x2AFE4788, weapon); }
	static void SET_WEAPON_AMMO(Weapon weapon, int ammo) { invoke<Void>(0x3A3DB7F1, weapon, ammo); }
	static int GET_WEAPON_AMMO_IN_CLIP(Weapon weapon) { return invoke<int>(0x09E9F10F, weapon); }
	static void SET_WEAPON_AMMO_IN_CLIP(Weapon weapon, int ammo) { invoke<Void>(0xA5F4270F, weapon, ammo); }
	static void SET_PED_CONSUMING_AMMO(Ped ped, BOOL toggle) { invoke<Void>(0xECFC30AE, ped, toggle); }
	static int GET_WEAPON_TYPE(Weapon weapon) { return invoke<int>(0x706A4B6F, weapon); }
	static BOOL HAS_PED_GOT_WEAPON(Ped ped, Hash weaponHash) { return invoke<BOOL>(0x43D2FA82, ped, weaponHash); }
	static BOOL HAS_PED_GOT_SPECIFIC_WEAPON(Ped ped, Hash weaponHash) { return invoke<BOOL>(0x8AF064CF, ped, weaponHash); }
	static int GET_AMMO_IN_PED_WEAPON(Ped ped, Hash weaponHash) { return invoke<int>(0x0C755733, ped, weaponHash); }
	static void ADD_AMMO_TO_PED(Ped ped, Hash weaponHash, int ammo, BOOL p3) { invoke<Void>(0x7F0580C7, ped, weaponHash, ammo, p3); }
	static void SET_PED_AMMO(Ped ped, Hash weaponHash, int ammo) { invoke<Void>(0xBF90DF1A, ped, weaponHash, ammo); }
	static void SET_WEAPON_SLOT(Ped ped, Weapon weapon, int holsterType) { invoke<Void>(0x016DBCD1, ped, weapon, holsterType); }
	static Weapon GET_WEAPON_FROM_SLOT(Ped ped, int holsterType) { return invoke<Weapon>(0x363C0973, ped, holsterType); }
	static Weapon GIVE_WEAPON_TO_PED_HAND(Ped ped, Hash weaponHash, int ammo, int handType) { return invoke<Weapon>(0xD2103032, ped, weaponHash, ammo, handType); }
	static Weapon GIVE_WEAPON_TO_PED_HOLSTER(Ped ped, Hash weaponHash, int ammo, int holsterType) { return invoke<Weapon>(0x865E839A, ped, weaponHash, ammo, holsterType); }
	static Weapon GIVE_WEAPON_TO_PED(Ped ped, Hash weaponHash, int ammo, BOOL equipNow) { return invoke<Weapon>(0xC4D88A85, ped, weaponHash, ammo, equipNow); } // unused
	static Weapon GIVE_DELAYED_WEAPON_TO_PED(Ped ped, Hash weaponHash, int ammo, BOOL equipNow) { return invoke<Weapon>(0x5868D20D, ped, weaponHash, ammo, equipNow); } // unused
	static void REMOVE_ALL_PED_WEAPONS(Ped ped) { invoke<Void>(0xA44CE817, ped); }
	static void REMOVE_ALL_LOCAL_PLAYER_WEAPONS_KEEPING_MPITEMS() { invoke<Void>(0x5307093D); }
	static void REMOVE_WEAPON_FROM_PED(Ped ped, Hash weaponHash) { invoke<Void>(0x9C37F220, ped, weaponHash); }
	static void REMOVE_PED_WEAPON(Ped ped, Weapon weapon) { invoke<Void>(0x1F98B093, weapon); }
	static void ENABLE_WEAPON_ATTACHMENT(Weapon weapon, int attachmentIndex, BOOL toggle) { invoke<Void>(0x46AF0A59, weapon, attachmentIndex, toggle); }
	static void FORCE_WEAPON_SCOPE(BOOL toggle) { invoke<Void>(0x543C127F, toggle); } // unused
	static void TOGGLE_WEAPON_ATTACHMENT(Weapon weapon, int attachmentIndex, BOOL toggle) { invoke<Void>(0xCDA89AA8, weapon, attachmentIndex, toggle); }
	static BOOL IS_WEAPON_ATTACHMENT_ENABLED(Weapon weapon, int attachmentIndex) { return invoke<BOOL>(0xE188437A, weapon, attachmentIndex); }
	static BOOL IS_WEAPON_ATTACHMENT_TOGGLED(Weapon weapon, int attachmentIndex) { return invoke<BOOL>(0x7AADF3E5, weapon, attachmentIndex); }
	static void SET_MAX_SUPPRESSOR_DAMAGE_LEVEL(Weapon weapon, int damageLevel) { invoke<Void>(0x4E17C02F, weapon, damageLevel); }
	static void SET_SUPPRESSOR_DAMAGE_LEVEL(Weapon weapon, int damageLevel) { invoke<Void>(0x5F580A8A, weapon, damageLevel); }
	static int GET_SUPPRESSOR_DAMAGE_LEVEL(Weapon weapon) { return invoke<int>(0x34A03DCE, weapon); }
	static void SET_WEAPON_LIGHT_DATA(Weapon weapon, int index) { invoke<Void>(0x29E99A13, weapon, index); } // unused
	static void SET_WEAPON_LIGHT_DATA_BY_NAME(Weapon weapon, char* name) { invoke<Void>(0x07F9CE88, weapon, name); }
	static void SET_WEAPON_SPAWNS_PICKUP(Weapon weapon, BOOL toggle) { invoke<Void>(0x14645293, weapon, toggle); } // unused
	static BOOL GET_WEAPON_SPAWNS_PICKUP(Weapon weapon) { return invoke<BOOL>(0xCDFDA942, weapon); } // unused
	static void SET_LASER_SIGHT_ATTACHMENT(Weapon weapon, Hash hash) { invoke<Void>(0xF55F503F, weapon, hash); }
	static Hash GET_LASER_SIGHT_ATTACHMENT(Weapon weapon) { return invoke<Hash>(0x5019DC1E, weapon); } // unused
	static void HIDE_PED_WEAPON_FOR_SCRIPTED_CUTSCENE(Ped ped, BOOL toggle) { invoke<Void>(0x00CFD6E9, ped, toggle); }
	static void SET_PED_CURRENT_WEAPON_VISIBLE(Ped ped, BOOL toggle) { invoke<Void>(0x00BECD77, ped, toggle); }
	static void SET_PED_DROPS_WEAPONS_WHEN_DEAD(Ped ped, BOOL toggle) { invoke<Void>(0x8A444056, ped, toggle); }
	static BOOL HAS_PED_BEEN_DAMAGED_BY_WEAPON(Ped ped, Hash weaponHash) { return invoke<BOOL>(0xCDFBBCC6, ped, weaponHash); }
	static Hash GET_PED_DAMAGE_WEAPON_TYPE(Ped ped) { return invoke<Hash>(0x93FBC5C1, ped); } // unused
	static void CLEAR_PED_LAST_WEAPON_DAMAGE(Ped ped) { invoke<Void>(0x52C68832, ped); } // unused
	static BOOL PED_HAS_VALID_THROW_TRAJECTORY_TO_POS(Ped ped, Vector3* pos) { return invoke<BOOL>(0xBF561175, ped, pos); } // unused
	static BOOL HAS_VEHICLE_BEEN_DAMAGED_BY_WEAPON(Vehicle vehicle, Hash weaponHash) { return invoke<BOOL>(0xB14B7C18, vehicle, weaponHash); } // unused
	static void CLEAR_VEHICLE_LAST_WEAPON_DAMAGE(Vehicle vehicle) { invoke<Void>(0xE59FA6AF, vehicle); } // unused
	static Weapon SET_PED_DROPS_WEAPON(Ped ped, Weapon weapon) { return invoke<Weapon>(0x3D3329FA, ped, weapon); }
	static int GET_MAX_AMMO_IN_CLIP(Ped ped, Hash weaponHash) { return invoke<int>(0x6961E2A4, ped, weaponHash); }
	static int GET_MAX_AMMO_IN_HAND_CLIP_MP(Ped ped, int p1) { return invoke<int>(0xE29942BF, ped, p1); }
	static BOOL GET_AMMO_IN_CLIP(Ped ped, Hash weaponHash, int* ammo) { return invoke<BOOL>(0x73C100C3, ped, weaponHash, ammo); }
	static BOOL SET_AMMO_IN_CLIP(Ped ped, Hash weaponHash, int ammo) { return invoke<BOOL>(0xA54B0B10, ped, weaponHash, ammo); }
	static BOOL GET_MAX_AMMO(Ped ped, Hash weaponHash, int* ammo) { return invoke<BOOL>(0x0B294796, ped, weaponHash, ammo); }
	static Any SET_MAX_AMMO_CAP() { return invoke<Any>(0x4C898C45); } // unused
	static void REMOVE_PED_AMMO(Ped ped, Hash weaponHash) { invoke<Void>(0x0BA4956D, ped, weaponHash); }
	static BOOL IS_ANY_GRENADE_IN_HELPER_BOX(float x1, float y1, float z1, float x2, float y2, float z2) { return invoke<BOOL>(0x6171AE9F, x1, y1, z1, x2, y2, z2); }
	static BOOL GET_PED_LAST_WEAPON_IMPACT_COORD(Ped ped, Vector3* coord) { return invoke<BOOL>(0x9B266079, ped, coord); } // unused
	static float GET_IS_PED_LISTENING_TO_PED(Ped ped, Ped ped2) { return invoke<float>(0xBDCBAABF, ped, ped2); } // unused
	static BOOL GET_IS_PED_PHOTOGRAPHING_COORD(Ped ped, float x, float y, float z, float p4, BOOL p5) { return invoke<BOOL>(0xF34F8AF0, ped, x, y, z, p4, p5); } // unused
	static void SET_PED_GADGET(Ped ped, Hash gadgetHash, BOOL p2) { invoke<Void>(0x8A256D0A, ped, gadgetHash, p2); } // unused
	static Hash GET_SELECTED_PED_GADGET(Ped ped) { return invoke<Hash>(0x943379C2, ped); } // unused
	static void EXPLODE_PROJECTILES(Ped ped, Hash weaponHash) { invoke<Void>(0x35A0B955, ped, weaponHash); } // unused
	static void ACTIVATE_DETONATOR(Ped ped, BOOL p1) { invoke<Any>(0x1C5D5D2D, ped, p1); } // unused
	static BOOL GET_IS_DETONATOR_FIRED(Ped ped) { return invoke<BOOL>(0x0897A3AE, ped); } // unused
	static BOOL HAS_VEHICLE_GOT_PROJECTILE_ATTACHED(Ped ped, Vehicle vehicle, Hash projectileHash) { return invoke<BOOL>(0xA57E2E80, ped, vehicle, projectileHash); } // unused
	static void SET_SHELL_LOD_DIST_ENTITY(float value) { invoke<Void>(0xCE6C2A4E, value); } // unused
	static void SET_SHELL_LOD_DIST_MESHFX(float value) { invoke<Void>(0xA17BA731, value); } // unused
	static void ATTACH_WEAPON_TO_VEHICLE(Hash weaponHash, Vehicle vehicle, int p2, float p3, float p4, float p5, float p6, float p7) { invoke<Void>(0x0A4A9A08, weaponHash, vehicle, p2, p3, p4, p5, p6, p7); }
	static void REMOVE_ATTACHED_WEAPONS_FROM_VEHICLE(Vehicle vehicle) { invoke<Void>(0xECB94CFD, vehicle); }
	static void OVERRIDE_WEAPON_VELOCITY(Hash weaponHash, float velocity) { invoke<Void>(0x386F64C0, weaponHash, velocity); } // unused
	static void SET_BULLET_VELOCITY_MODIFIER(Ped ped, float velocity) { invoke<Void>(0x4A55C2DF, ped, velocity); }
	static void ADD_SCRIPTED_WEAPON_MODIFIER(Ped ped, Any p1) { invoke<Void>(0xDC9BD147, ped, p1); }
	static void REMOVE_SCRIPTED_WEAPON_MODIFIER(Ped ped, Any p1) { invoke<Void>(0x7E83BE00, ped, p1); }
	static void REMOVE_ALL_SCRIPTED_WEAPON_MODIFIER(Ped ped) { invoke<Void>(0xA59AF348, ped); }
	static BOOL HAS_SHOT_BEEN_FIRED_IN_AREA(float x, float y, float z, float radius, BOOL p4, Ped* outPed) { return invoke<BOOL>(0xD08B8C7A, x, y, z, radius, p4, outPed); }
	static BOOL HAS_SOMETHING_EXPLODED_IN_AREA(float x, float y, float z, float radius) { return invoke<BOOL>(0x8D098F9F, x, y, z, radius); }
	static BOOL HAS_BULLET_IMPACTED_IN_AREA(float x, float y, float z, float radius, Ped* outPed) { return invoke<BOOL>(0x902BC7D9, x, y, z, radius, outPed); }
	static Vector3 GET_BULLET_IMPACT_AREA(float x, float y, float z, float radius, Ped* outPed) { return invoke<Vector3>(0x4AB5B015, x, y, z, radius, outPed); }
	static void SET_ENABLE_BULLET_IMPACT_WATER(BOOL toggle) { invoke<Void>(0x300D6EF7, toggle); }
	static BOOL THROW_MOLOTOV(Ped ped, float p1, float p2, float p3) { return invoke<BOOL>(0x86770AD0, ped, p1, p2, p3); } // unused
	static void TOGGLE_TRACER(BOOL toggle) { invoke<Void>(0xA4D5C061, toggle); } // unused
	static void SET_INSTANT_FIRE_FORCED(BOOL toggle) { invoke<Void>(0x9BBE36A1, toggle); }
	static void SET_WEAPON_VISIBLE(Weapon weapon, BOOL toggle) { invoke<Void>(0x529A119E, weapon, toggle); }
	static void SET_HOLSTER_VISIBLE(Ped ped, int holsterType, BOOL toggle) { invoke<Void>(0x3AC29772, ped, holsterType, toggle); }
	static void SET_GENERATE_BULLET_SHELLS(BOOL toggle) { invoke<Void>(0xA61EEC65, toggle); }
	static void SET_WEAPON_CHANCE_TO_FIRE_BLANKS(Weapon weapon, int chance) { invoke<Void>(0x40BA5A39, weapon, chance); }
	static BOOL IS_ROCKET_IN_FLIGHT() { return invoke<BOOL>(0x2EC8C1B9); }
	static void FINALE_GRENADE_LAUNCHER_SETTINGS(BOOL enabled, Hash modelHash1, Hash modelHash2, Hash modelHash3) { invoke<Void>(0x85C263C8, enabled, modelHash1, modelHash2, modelHash3); }
	static void FINALE_GRENADE_EXPLODE_ON_IMPACT(BOOL toggle) { invoke<Void>(0x28280ABC, toggle); }
}

namespace FIRE
{
	static FireId START_SCRIPT_FIRE(float x, float y, float z, int maxChildren) { return invoke<FireId>(0xE7529357, x, y, z, maxChildren); }
	static void REMOVE_SCRIPT_FIRE(FireId scriptFire) { invoke<Void>(0x6B21FE26, scriptFire); }
	static FireId START_PED_FIRE(Ped ped, float unk) { return invoke<FireId>(0x604950EB, ped, unk); }
	static void STOP_PED_FIRE(Ped ped) { invoke<Void>(0xABE73926, ped); }
	static BOOL IS_PED_ON_FIRE(Ped ped) { return invoke<BOOL>(0x5EC1A4D3, ped); }
	static BOOL IS_OBJECT_ON_FIRE(Object object) { return invoke<BOOL>(0xAC830162, object); } // unused
	static int GET_NUMBER_OF_FIRES_IN_RANGE(float x, float y, float z, float radius) { return invoke<int>(0x654D93B7, x, y, z, radius); }
	static void STOP_FIRE_IN_RANGE(float x, float y, float z, float radius) { invoke<Void>(0x725C7205, x, y, z, radius); }
	static void ADD_EXPLOSION(float x, float y, float z, int explosionType, float damageScale, BOOL isAudible, BOOL isInvisible, float unk) { invoke<Void>(0x10AF5258, x, y, z, explosionType, damageScale, isAudible, isInvisible, unk); }
	static void ADD_EXPLOSION_WITH_CAUSE(Player player, float x, float y, float z, int explosionType, float damageScale, BOOL isAudible, BOOL isInvisible, float p8, BOOL p9) { invoke<Void>(0x0BF9BBF0, player, x, y, z, explosionType, damageScale, isAudible, isInvisible, p8, p9); }
	static void EXPLODE_OBJECT(Object object) { invoke<Void>(0xD20EAA32, object); } // unused
	static BOOL IS_EXPLOSION_IN_AREA(int explosionType, float x1, float y1, float z1, float x2, float y2, float z2) { return invoke<BOOL>(0xFB40075B, explosionType, x1, y1, z1, x2, y2, z2); }
	static BOOL IS_EXPLOSION_IN_SPHERE(int explosionType, float x, float y, float z, float radius) { return invoke<BOOL>(0xD455A7F3, explosionType, x, y, z, radius); }
}

namespace ZONE
{
	static void SET_ZONE_POPULATION_TYPE(char* zoneName, int type) { invoke<Void>(0xFC30948B, zoneName, type); } // unused
	static void SET_ZONE_SCUMMINESS(char* zoneName, int scumminess) { invoke<Void>(0x6E35CF9A, zoneName, scumminess); } // unused
	static void GET_NAME_OF_ZONE(int bufferSize, char* buffer, float x, float y, float z) { invoke<Void>(0x7875CE91, bufferSize, buffer, x, y, z); } // unused
	static void GET_NAME_OF_INFO_ZONE(int bufferSize, char* buffer, float x, float y, float z) { invoke<Void>(0xA8CB8BF6, bufferSize, buffer, x, y, z); } // unused
	static void SET_ZONE_COPS_ACTIVE(char* zoneName, BOOL toggle) { invoke<Void>(0xD604096C, zoneName, toggle); } // unused
	static int GET_MAP_AREA_FROM_COORDS(float x, float y, float z) { return invoke<int>(0xC7191B29, x, y, z); } // unused
	static void GET_PRIMARY_POPULATION_ZONE_GROUP(int* p0, int* p1) { invoke<Void>(0xBBD63009, p0, p1); } // unused
}

namespace GRAPHICS
{
	static void SET_DEBUG_LINES_AND_SPHERES_DRAWING_ACTIVE(BOOL active) { invoke<Void>(0x1418CA37, active); }
	static Any DRAW_LINE() { invoke<Void>(0xB3426BCC); } // unused
	static void DRAW_DEBUG_LINE(Any p0, Any p1, Any p2, Any p3, Any p4, Any p5, Any p6, Any p7, Any p8, Any p9) { invoke<Void>(0xABF783AB, p0, p1, p2, p3, p4, p5, p6, p7, p8, p9); }
	static Any DRAW_DEBUG_LINE_WITH_TWO_COLOURS() { return invoke<Any>(0xE8BFF632); } // unused
	static void DRAW_DEBUG_POLY(Any p0, Any p1, Any p2, Any p3, Any p4, Any p5, Any p6, Any p7, Any p8, Any p9, Any p10, Any p11, Any p12) { invoke<Void>(0x4213626F, p0, p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12); }
	static Any DRAW_DEBUG_POLY_WITH_THREE_COLOURS() { return invoke<Any>(0x0DB93013); } // unused
	static void DRAW_DEBUG_SPHERE(Vector3 coords, float radius, int r, int g, int b, int a) { invoke<Void>(0x304D0EEF, coords, radius, r, g, b, a); }
	static Any DRAW_DEBUG_BOX() { return invoke<Any>(0x8524A848); } // unused
	static Any DRAW_DEBUG_CROSS() { return invoke<Any>(0xB6DF3709); } // unused
	static void DRAW_DEBUG_TEXT(Any p0, Any p1, Any p2, Any p3, Any p4, Any p5, Any p6, Any p7) { invoke<Void>(0x269B006F, p0, p1, p2, p3, p4, p5, p6, p7); }
	static Any DRAW_DEBUG_TEXT_WITH_OFFSET() { return invoke<Any>(0xAF5808B4); } // unused
	static Any DEBUGDRAW_GETSCREENSPACETEXTHEIGHT() { return invoke<Any>(0x5DD864FD); } // unused
	static Any DRAW_DEBUG_LINE_2D() { return invoke<Any>(0x1C15B9B6); } // unused
	static Any DRAW_DEBUG_LINE_2D_WITH_TWO_COLOURS() { return invoke<Any>(0x1D4DFE1E); } // unused
	static Any DRAW_DEBUG_POLY_2D() { return invoke<Any>(0x510260D0); } // unused
	static Any DRAW_DEBUG_POLY_2D_WITH_THREE_COLOURS() { return invoke<Any>(0x298064B4); } // unused
	static Any DRAW_DEBUG_TEXT_2D() { return invoke<Any>(0x528B973B); } // unused
	static Any DRAW_VECTOR_MAP_LINE() { return invoke<Any>(0x50D36E09); } // unused
	static Any DRAW_VECTOR_MAP_LINE_THICK() { return invoke<Any>(0x86018420); } // unused
	static Any DRAW_VECTOR_MAP_CIRCLE() { return invoke<Any>(0x4B0C1539); } // unused
	static Any DRAW_VECTOR_MAP_POLY() { return invoke<Any>(0x53A77F35); } // unused
	static Any DRAW_VECTOR_MAP_RECTANGLE() { return invoke<Any>(0x2D241271); } // unused
	static Any DRAW_VECTOR_MAP_WEDGE() { return invoke<Any>(0x2206BE27); } // unused
	static Any DRAW_VECTOR_MAP_MARKER() { return invoke<Any>(0x4A1EE5A8); } // unused
	static Any DRAW_VECTOR_MAP_VEHICLE() { return invoke<Any>(0x03B0965C); } // unused
	static Any DRAW_VECTOR_MAP_PED() { return invoke<Any>(0x9A1D0BA2); } // unused
	static Any DRAW_VECTOR_MAP_LOCAL_PLAYER_CAM() { return invoke<Any>(0xB8641116); } // unused
	static Any DRAW_VECTOR_MAP_EVENT_RIPPLE() { return invoke<Any>(0x3D542EE7); } // unused
	static Any DRAW_VECTOR_MAP_TEXT() { return invoke<Any>(0x7F083534); } // unused
	static int CREATE_GLINT(Hash glintType, float x, float y, float z) { return invoke<int>(0x4D85E438, glintType, x, y, z); }
	static BOOL DOES_GLINT_EXIST(int glint) { return invoke<BOOL>(0x81AF036B, glint); }
	static void REMOVE_GLINT(int glint) { invoke<Void>(0xB6DA9D34, glint); }
	static void REMOVE_ALL_GLINTS() { invoke<Void>(0xA7D255E3); }
	static void ENABLE_GLINT(int glint, BOOL toggle) { invoke<Void>(0xC0F842E8, glint, toggle); }
	static void DRAW_SPOT_LIGHT(float posX, float posY, float posZ, float dirX, float dirY, float dirZ, int r, int g, int b, float p9, float p10, float p11, float p12, float p13, float p14, BOOL p15) { invoke<Void>(0xBDBC410C, posX, posY, posZ, dirX, dirY, dirZ, r, g, b, p9, p10, p11, p12, p13, p14, p15); } // unused
	static void DRAW_POINT_LIGHT(float x, float y, float z, int r, int g, int b, float p6, float p7) { invoke<Void>(0xC3277E86, x, y, z, r, g, b, p6, p7); } // unused
	static Any DRAW_SPHERE() { return invoke<Any>(0x4DD1CB3A); } // unused
	static void DRAW_COLOURED_CYLINDER(float x, float y, float z, float p3, int r, int g, int b, int a) { invoke<Void>(0x6ECBA9ED, x, y, z, p3, r, g, b, a); } // unused
	static Any _0xD4A9EE97(Object object, Any p1) { return invoke<Any>(0xD4A9EE97, object, p1); } // unused
	static Any _0xD0732DBA(Object object1, Any p1, Object object2) { return invoke<Any>(0xD0732DBA, object1, p1, object2); }
	static void _0x5851DB72(int r, int g, int b, int a, float p4, float p5, float p6, float p7, float p8, float p9, float p10, float p11) { invoke<Void>(0x5851DB72, r, g, b, a, p4, p5, p6, p7, p8, p9, p10, p11); }
	static void _0x2C3949FE(Any p0, Ped ped) { invoke<Void>(0x2C3949FE, p0, ped); }
	static void _0xA634EDCD(Any p0, float p1, float p2, float p3) { invoke<Void>(0xA634EDCD, p0, p1, p2, p3); }
	static void _0x518EB5A0(Any p0, float p1, float p2, float p3, float p4, float p5, float p6) { invoke<Void>(0x518EB5A0, p0, p1, p2, p3, p4, p5, p6); }
	static ScrHandle CREATE_CHECKPOINT(int type, float posX1, float posY1, float posZ1, float posX2, float posY2, float posZ2, float radius) { return invoke<ScrHandle>(0xF541B690, type, posX1, posY1, posZ1, posX2, posY2, posZ2, radius); } // unused
	static void DELETE_CHECKPOINT(ScrHandle checkpoint) { invoke<Void>(0xB66CF3CA, checkpoint); } // unused
	static Any DRAW_CHECKPOINT() { return invoke<Any>(0x1B58B5C7); } // unused
	static Any DRAW_CHECKPOINT_WITH_ALPHA() { return invoke<Any>(0xCDC4B816); } // unused
	static BOOL _0x891C7BBB() { return invoke<BOOL>(0x891C7BBB); } // unused
	static ScrHandle LOAD_TEXTURE_DICT(char* dictName) { return invoke<ScrHandle>(0xAD3C963A, dictName); } // unused
	static void REMOVE_TEXTURE_DICT(ScrHandle dict) { invoke<Void>(0x098F30A1, dict); } // unused
	static ScrHandle GET_GAME_TEXTURE_DICT(char* dictName) { return invoke<ScrHandle>(0x682D7B70, dictName); } // unused
	static ScrHandle GET_TEXTURE(ScrHandle dict, char* textureName) { return invoke<ScrHandle>(0x6DC9C895, dict, textureName); } // unused
	static void RELEASE_TEXTURE(ScrHandle texture) { invoke<Void>(0xDB7643AC, texture); } // unused
	static void REQUEST_STREAMED_TEXTURE_DICT(char* dictName, BOOL p1) { invoke<Void>(0x4C9B035F, dictName, p1); } // unused
	static BOOL HAS_STREAMED_TEXTURE_DICT_LOADED(char* dictName) { return invoke<BOOL>(0x3F436EEF, dictName); } // unused
	static void SET_STREAMED_TEXTURE_DICT_AS_NO_LONGER_NEEDED(char* dictName) { invoke<Void>(0xF07DDA38, dictName); } // unused
	static ScrHandle GET_TEXTURE_FROM_STREAMED_TEXTURE_DICT(char* dictName, char* textureName) { return invoke<ScrHandle>(0xA8DAC5EC, dictName, textureName); } // unused
	static void SET_MASK_ACTIVE(BOOL toggle) { invoke<Void>(0xFC3F8FE9, toggle); } // unused
	static void SET_MASK_ATTRIBUTES(float p0, float p1, float p2, float p3) { invoke<Void>(0x72C4D458, p0, p1, p2, p3); } // unused
	static void DRAW_RECT(float x, float y, float width, float height, int r, int g, int b, int a) { invoke<Void>(0xDD2BFC77, x, y, width, height, r, g, b, a); }
	static void SET_SPRITES_DRAW_BEFORE_FADE(BOOL toggle) { invoke<Void>(0x275DE46E, toggle); } // unused
	static void DRAW_SPRITE(ScrHandle texture, float screenX, float screenY, float width, float height, float heading, int red, int green, int blue, int alpha) { invoke<Void>(0x1FEC16B0, texture, screenX, screenY, width, height, heading, red, green, blue, alpha); } // unused
	static void PRELOAD_MOVIE(int p0, char* movieName, BOOL p2, BOOL p3) { invoke<Void>(0xC3182968, p0, movieName, p2, p3); }
	static void PLAY_MOVIE(int p0, BOOL p1) { invoke<Void>(0x4F39ED7A, p0, p1); }
	static void STOP_MOVIE(int p0) { invoke<Void>(0x7827E516, p0); }
	static void RELEASE_MOVIE(int p0) { invoke<Void>(0x9EAF5CA0, p0); }
	static void DRAW_MOVIE(float x, float y, float width, float height, float p4, int r, int g, int b, int a, BOOL p9) { invoke<Void>(0xF563194B, x, y, width, height, p4, r, g, b, a, p9); } // unused
	static void SET_MOVIE_TIME(int p0, float time) { invoke<Void>(0xA1930880, p0, time); } // unused
	static void SET_MOVIE_VOLUME(int p0, float volume) { invoke<Void>(0x21D93ADF, p0, volume); }
	static void SET_MOVIE_TINT(int p0, float p1, float p2, float p3, float p4) { invoke<Void>(0x1E907D2D, p0, p1, p2, p3, p4); } // unused
	static void SET_MOVIE_LOOP(int p0, BOOL toggle) { invoke<Void>(0x14A87C9F, p0, toggle); }
	static void SET_TRANSITION_MOVIE_SKIPPABLE(BOOL toggle) { invoke<Void>(0x4278FA3D, toggle); }
	static BOOL IS_TRANSITION_MOVIE_PLAYING() { return invoke<BOOL>(0x66BD2CB0); }
	static BOOL IS_SCRIPT_MOVIE_PLAYING(int p0) { return invoke<BOOL>(0x772006AE, p0); }
	static int GET_TRANSITION_MOVIE_FRAMES_REMAINING() { return invoke<int>(0xC483FB4A); }
	static int GET_SCRIPT_MOVIE_FRAMES_REMAINING(int p0) { return invoke<int>(0xA173AAD6, p0); }
	static void SET_MOVIE_FRAME(int p0, int frame) { invoke<Void>(0xFD8B4DAA, p0, frame); }
	static BOOL IS_INTRO_MOVIE_CANCELLED() { return invoke<BOOL>(0xC5F70C9A); }
	static void DRAW_CURVED_WINDOW(float screenX, float screenY, float width, float height, int alpha) { invoke<Void>(0x91FEC4DF, screenX, screenY, width, height, alpha); } // unused
	static void GET_SCREEN_RESOLUTION(int* x, int* y) { invoke<Void>(0x29F3572F, x, y); } // unused
	static BOOL GET_IS_WIDESCREEN() { return invoke<BOOL>(0xEC717AEF); } // unused
	static BOOL GET_IS_HIDEF() { return invoke<BOOL>(0x1C340359); } // unused
	static void DISPLAY_LOADING_SCREEN_NOW(BOOL p0) { invoke<Void>(0x85DDA5F2, p0); } // unused
	static void SET_NIGHTVISION(BOOL toggle) { invoke<Void>(0xD1E5565F, toggle); } // unused
	static void SET_NOISEOVERIDE(BOOL toggle) { invoke<Void>(0xD576F5DD, toggle); } // unused
	static void SET_NOISINESSOVERIDE(float value) { invoke<Void>(0x046B62D9, value); } // unused
	static void RESET_ALL_PTFX() { invoke<Void>(0x5080E987); }
	static BOOL START_PARTICLE_FX_NON_LOOPED_AT_COORD(char* ptfxName, float posX, float posY, float posZ, float rotX, float rotY, float rotZ, float scale) { return invoke<BOOL>(0xDD79D679, ptfxName, posX, posY, posZ, rotX, rotY, rotZ, scale); }
	static Any START_PARTICLE_FX_NON_LOOPED_AT_COORD_WITH_GROUND_PLANE() { return invoke<Any>(0xD120A4B4); } // unused
	static Any START_PARTICLE_FX_NON_LOOPED_AT_COORD_WITH_OFFSET_GROUND_PLANE() { return invoke<Any>(0xC691A67E); } // unused
	static Any START_PARTICLE_FX_NON_LOOPED_AT_COORD_WITH_NEARBY_COLLISION() { return invoke<Any>(0x5EFBDD3E); } // unused
	static BOOL START_PARTICLE_FX_NON_LOOPED_ON_PED_BONE(char* ptfxName, Ped ped, float offsetX, float offsetY, float offsetZ, float rotX, float rotY, float rotZ, int bone, float scale) { return invoke<BOOL>(0x53DAEF4E, ptfxName, ped, offsetX, offsetY, offsetZ, rotX, rotY, rotZ, bone, scale); }
	static BOOL START_PARTICLE_FX_NON_LOOPED_ON_VEHICLE(char* ptfxName, Vehicle vehicle, float offsetX, float offsetY, float offsetZ, float rotX, float rotY, float rotZ, float scale) { return invoke<BOOL>(0x7C714DA3, ptfxName, vehicle, offsetX, offsetY, offsetZ, rotX, rotY, rotZ, scale); }
	static BOOL START_PARTICLE_FX_NON_LOOPED_ON_OBJECT(char* ptfxName, Object object, float offsetX, float offsetY, float offsetZ, float rotX, float rotY, float rotZ, float scale) { return invoke<BOOL>(0xF9617406, ptfxName, object, offsetX, offsetY, offsetZ, rotX, rotY, rotZ, scale); }
	static ScrHandle START_PARTICLE_FX_LOOPED_AT_COORD(char* ptfxName, float offsetX, float offsetY, float offsetZ, float rotX, float rotY, float rotZ, float scale) { return invoke<ScrHandle>(0xD348E3E6, ptfxName, offsetX, offsetY, offsetZ, rotX, rotY, rotZ, scale); }
	static ScrHandle START_PARTICLE_FX_LOOPED_ON_PED_BONE(char* ptfxName, Ped ped, float offsetX, float offsetY, float offsetZ, float rotX, float rotY, float rotZ, int bone, float scale) { return invoke<ScrHandle>(0xF8FC196F, ptfxName, ped, offsetX, offsetY, offsetZ, rotX, rotY, rotZ, bone, scale); }
	static ScrHandle START_PARTICLE_FX_LOOPED_ON_VEHICLE(char* ptfxName, Vehicle vehicle, float offsetX, float offsetY, float offsetZ, float rotX, float rotY, float rotZ, float scale) { return invoke<ScrHandle>(0x58AA9FC3, ptfxName, vehicle, offsetX, offsetY, offsetZ, rotX, rotY, rotZ, scale); }
	static ScrHandle START_PARTICLE_FX_LOOPED_ON_OBJECT(char* ptfxName, Object object, float offsetX, float offsetY, float offsetZ, float rotX, float rotY, float rotZ, float scale) { return invoke<ScrHandle>(0x4B00E9F2, ptfxName, object, offsetX, offsetY, offsetZ, rotX, rotY, rotZ, scale); }
	static ScrHandle START_PARTICLE_FX_LOOPED_ON_OBJECT_BONE(char* ptfxName, Object object, float offsetX, float offsetY, float offsetZ, float rotX, float rotY, float rotZ, int bone, float scale) { return invoke<ScrHandle>(0x1B34D211, ptfxName, object, offsetX, offsetY, offsetZ, rotX, rotY, rotZ, bone, scale); } // unused
	static void STOP_PARTICLE_FX_LOOPED(ScrHandle ptfxHandle) { invoke<Void>(0xD245455B, ptfxHandle); }
	static void SET_PARTICLE_FX_LOOPED_OFFSETS(ScrHandle ptfxHandle, float p1, float p2, float p3, float p4, float p5, float p6, float p7) { invoke<Void>(0x641F7790, ptfxHandle, p1, p2, p3, p4, p5, p6, p7); } // unused
	static void SET_PARTICLE_FX_LOOPED_EVOLUTION(ScrHandle ptfxHandle, char* propertyName, float value) { invoke<Void>(0x1CBC1373, ptfxHandle, propertyName, value); }
	static void SET_PARTICLE_FX_CAM_INSIDE_VEHICLE(BOOL toggle) { invoke<Void>(0x19EC0001, toggle); } // unused
	static void REMOVE_PARTICLE_FX_FROM_PED(Ped ped) { invoke<Void>(0x2CDB19BD, ped); }
	static void REMOVE_PARTICLE_FX_FROM_VEHICLE(Vehicle vehicle) { invoke<Void>(0x3C9F1B1C, vehicle); }
	static void REMOVE_PARTICLE_FX_FROM_OBJECT(Object object) { invoke<Void>(0xBC603FEC, object); } // unused
	static void REMOVE_PARTICLE_FX(ScrHandle ptfxHandle) { invoke<Void>(0x6BA48C7E, ptfxHandle); }
	static void ADD_GROUND_PLANE_COLLISION_TO_PARTICLE_FX(ScrHandle ptfxHandle, float p1, float p2, float p3, float p4, float p5) { invoke<Void>(0x6DF10D45, ptfxHandle, p1, p2, p3, p4, p5); } // unused
	static void ADD_NEARBY_COLLISION_TO_PARTICLE_FX(ScrHandle ptfxHandle, float x, float y, float z, float radius) { invoke<Void>(0xA3D7374F, ptfxHandle, x, y, z, radius); }
	static int CREATE_LASER(char* p0) { return invoke<int>(0xC530B3B5, p0); } // unused
	static int FIND_LASER(char* p0) { return invoke<int>(0xC1618EF5, p0); } // unused
	static void DESTROY_LASER(int laser) { invoke<Void>(0xA4C87B72, laser); } // unused
	static void ATTACH_LASER_TO_OBJECT(int laser, Object object) { invoke<Void>(0xCF6AD373, laser, object); } // unused
	static void ATTACH_LASER_TO_OBJECT_BONE(int laser, Object object, char* boneName) { invoke<Void>(0xE3667257, laser, object, boneName); } // unused
	static void SET_LASER_SPREAD(int laser, float spread) { invoke<Void>(0xDEDBE1AD, laser, spread); } // unused
	static void SET_LASER_WIDTH(int laser, float width) { invoke<Void>(0x72312BB1, laser, width); } // unused
	static void SET_LASER_COLOR(int laser, float r, float g, float b, float a) { invoke<Void>(0xB76E5912, laser, r, g, b, a); } // unused
	static void WASH_PROJTEX_FROM_VEHICLE(Vehicle vehicle, Any p1) { invoke<Void>(0x090EF385, vehicle, p1); } // unused
	static void REMOVE_PROJTEX_IN_RANGE(float x, float y, float z, float radius) { invoke<Void>(0xB2842710, x, y, z, radius); } // unused
	static void REMOVE_PROJTEX_FROM_OBJECT(Object object) { invoke<Void>(0x119A0327, object); } // unused
	static void SET_TIMECYCLE_MODIFIER(char* modifierName) { invoke<Void>(0xA81F3638, modifierName); }
	static void CLEAR_TIMECYCLE_MODIFIER() { invoke<Void>(0x8D8DF8EE); }
	static void RESET_BLOOD_EFFECTS() { invoke<Void>(0x6FD09D15); }
	static void REMOVE_ALL_ENVIRONMENT_BLOOD() { invoke<Void>(0x5DD738A7); }
	static void REMOVE_ALL_ENVIRONMENT_BLOOD_AT_COORD(float x, float y, float z, float radius) { invoke<Void>(0x66802B77, x, y, z, radius); }
	static void BLOOD_DECAL_ON_PED_BONE(Any p0, Any p1, Any p2, Any p3, Any p4, Any p5) { invoke<Void>(0xF2372566, p0, p1, p2, p3, p4, p5); }
	static void DAMAGE_DECAL_ON_PED_BONE(Any p0, Any p1, Any p2, Any p3, Any p4) { invoke<Void>(0xC7915C3D, p0, p1, p2, p3, p4); }
	static void DAMAGE_DECALS_ON_PED(Any p0, Any p1) { invoke<Void>(0x44944D79, p0, p1); }
	static void ADD_BLOOD_POOL(float x, float y, float z, float p3, float p4, float p5) { invoke<Void>(0xBD6B7E68, x, y, z, p3, p4, p5); }
	static void SET_SILHOUETTE_ACTIVE(BOOL toggle) { invoke<Void>(0xBD11E03E, toggle); }
	static void SET_SILHOUETTE_DISTANCE_FALLOFF(float minDistance, float maxDistance) { invoke<Void>(0x5D9C6169, minDistance, maxDistance); }
	static void SET_SILHOUETTE_RENDER_SETTINGS(float intensity, Any unused) { invoke<Void>(0x251A1458, intensity, unused); }
	static void START_POSTFX_BLENDER(int p0) { invoke<Void>(0x817C43D7, p0); }
	static void END_POSTFX_BLENDER(int p0, BOOL p1) { invoke<Void>(0x2307415F, p0, p1); }
	static void ADD_SPECIAL_FX_MODIFIER(char* name, float p1, float p2, float p3, float p4) { invoke<Void>(0xAC7F5BB8, name, p1, p2, p3, p4); }
	static void DEACTIVATE_SPECIAL_FX_MODIFIER(char* name) { invoke<Void>(0x02970F3E, name); }
	static void UPDATE_SPECIAL_FX_MODIFIER_STRENGTH(Any p0, Any p1, Any p2) { invoke<Void>(0x3D538351, p0, p1, p2); }
	static void SET_TIMECYCLE_MODIFIER_OVERRIDE(char* p0, char* p1, float p2, float p3, int p4) { invoke<Void>(0xBCB2D9B5, p0, p1, p2, p3, p4); }
	static void CLEAR_TIMECYCLE_MODIFIER_OVERRIDE(int p0) { invoke<Void>(0xF1AE66DC, p0); }
	static void ADJUST_TIMECYCLE_MODIFIER_OVERRIDE(float p0, float p1, int p2) { invoke<Void>(0xFE471B6E, p0, p1, p2); } // unused
	static void SET_DEATH_EFFECT_ENABLED(BOOL toggle) { invoke<Void>(0x4441BB4D, toggle); } // unused
	static void SET_TEAR_GAS_EFFECT_AUTO_END(BOOL toggle) { invoke<Void>(0xAA1C242F, toggle); }
	static void PULSE_CROSSHAIR(BOOL p0) { invoke<Void>(0x5FF866E9, p0); }
	static void SET_DISABLE_FADE(BOOL toggle) { invoke<Void>(0x83A90082, toggle); }
	static void SET_SMALL_BOATS_PTFX_MAX_SPEED_EVO(BOOL toggle) { invoke<Void>(0xCC4E37B9, toggle); }
	static void SET_MEDIUM_BOATS_PTFX_MAX_SPEED_EVO(BOOL toggle) { invoke<Void>(0x4CF8B8D7, toggle); }
	static void SET_PAYNE_BOAT_PTFX_MAX_SPEED_EVO(BOOL toggle) { invoke<Void>(0xD1BDFF84, toggle); }
	static void SET_BIG_BOATS_PTFX_MAX_SPEED_EVO(BOOL toggle) { invoke<Void>(0x0B2C4489, toggle); }
	static void SET_SMALL_BOATS_PROPELLOR_PTFX_MAX_SPEED_EVO(BOOL toggle) { invoke<Void>(0xEAB22432, toggle); }
	static void SET_MEDIUM_BOATS_PROPELLOR_PTFX_MAX_SPEED_EVO(BOOL toggle) { invoke<Void>(0x3F38479B, toggle); }
	static void SET_PAYNE_BOAT_PROPELLOR_PTFX_MAX_SPEED_EVO(BOOL toggle) { invoke<Void>(0x3A35B972, toggle); }
	static void SET_BIG_BOATS_PROPELLOR_PTFX_MAX_SPEED_EVO(BOOL toggle) { invoke<Void>(0x4664B095, toggle); }
	static void SET_PAYNE_BOAT_PTFX_SKIP(BOOL toggle) { invoke<Void>(0xE9719836, toggle); }
	static void SET_ALL_BOATS_WAKES_MAX_SPEED_EVO(BOOL toggle) { invoke<Void>(0x2806197D, toggle); }
	static void SET_PAYNE_BOAT_PTFX_CUTSCENE_EFFECT(BOOL toggle) { invoke<Void>(0xDBC06AE9, toggle); }
	static void SET_SMALL_BOAT_PTFX_CUTSCENE_EFFECT(BOOL toggle) { invoke<Void>(0x039101C7, toggle); }
	static void SET_PAYNE_BOAT_PTFX_CUTSCENE_PROPELLOR_EFFECT(BOOL toggle) { invoke<Void>(0x058EBC01, toggle); }
	static void SET_SMALL_BOAT_PTFX_CUTSCENE_PROPELLOR_EFFECT(BOOL toggle) { invoke<Void>(0x3B6463A8, toggle); }
	static void REGISTER_BOAT_WAKE(Vehicle boat, float p1, float p2, float p3, float p4, float p5, float p6, float p7) { invoke<Void>(0x085F3727, boat, p1, p2, p3, p4, p5, p6, p7); }
	static void SET_WAKES_SECTION(int section) { invoke<Void>(0x75BA1528, section); }
	static void SET_PED_PTFX_SPLASH_OUT_SPECIAL_EFFECT(BOOL toggle) { invoke<Void>(0xDE3F2565, toggle); }
	static void PLAY_IMAGEFX(char* fxName, int p1, BOOL p2) { invoke<Void>(0x2CCAA179, fxName, p1, p2); }
	static void STOP_IMAGEFX(int p0, BOOL p1) { invoke<Void>(0xB27BC9FD, p0, p1); }
	static void STOP_ALL_IMAGEFX(BOOL p0) { invoke<Void>(0xB7BC77AB, p0); }
	static void SET_IMAGEFX_ENABLED(BOOL toggle) { invoke<Void>(0x50E9EF0E, toggle); } // unused
	static void SET_TIME_CYCLE_MODIFIERS_ENABLED(BOOL toggle) { invoke<Void>(0xF9665C8C, toggle); } // unused
	static void ENABLE_DIRECTIONAL_SHADOWS(BOOL toggle) { invoke<Void>(0x43ACC998, toggle); } // unused
	static void DISABLE_DIRECTIONAL_LIGHT(BOOL toggle) { invoke<Void>(0x63FA48FD, toggle); }
	static void SKIP_ROTOR_SHADOW(BOOL toggle) { invoke<Void>(0xC96B8836, toggle); }
}

namespace NET
{
	static BOOL NET_GET_GAMER_NAME_WITH_GANG_TAG(Player player, int bufferSize, char* buffer) { return invoke<BOOL>(0x10AB1606, player, bufferSize, buffer); } // unused
	static BOOL NET_GET_PLAYER_GANG_TAG_UI(Player player, int bufferSize, char* buffer) { return invoke<BOOL>(0xF2008295, player, bufferSize, buffer); }
	static BOOL NET_GET_PLAYER_GANG_TAG(Player player, int bufferSize, char* buffer) { return invoke<BOOL>(0x4F64907A, player, bufferSize, buffer); }
	static BOOL NET_GET_PLAYER_GANG_NAME(Player player, int bufferSize, char* buffer) { return invoke<BOOL>(0x0A4BF53A, player, bufferSize, buffer); } // unused
	static int NET_GET_PLAYER_GANG_ID(Player player) { return invoke<int>(0xBB7E7FFA, player); }
	static BOOL NET_IS_GANG_INFO_VALID(Player player) { return invoke<BOOL>(0x6D648816, player); } // unused
	static int NET_GET_PLAYER_GANG_RANK(Player player) { return invoke<int>(0xD40B452C, player); } // unused
	static BOOL NET_ARE_PLAYERS_IN_SAME_GANG(Player player1, Player player2) { return invoke<BOOL>(0xD1B34A9E, player1, player2); }
	static BOOL NET_IS_PLAYER_IN_GANG(Player player) { return invoke<BOOL>(0x45A0B35B, player); }
	static BOOL NET_ARE_PLAYERS_IN_SAME_PARTY(Player player1, Player player2) { return invoke<BOOL>(0x58A5D90C, player1, player2); }
	static Player NET_PARTY_GET_LEADER_PLAYER() { return invoke<Player>(0x6F29E2F9); }
}

namespace CUTSCENE
{
	static void PRE_STREAM_SEAMLESS_CUTSCENE(char* cutsceneName) { invoke<Void>(0x07E152B6, cutsceneName); }
	static void PRE_STREAM_SEAMLESS_CUTSCENE_AT_COORD(char* cutsceneName, float x, float y, float z, float p4) { invoke<Void>(0xEEE3863E, cutsceneName, x, y, z, p4); }
	static void START_SEAMLESS_CUTSCENE() { invoke<Void>(0x243A852E); }
	static void START_SEAMLESS_CUTSCENE_AT_COORDS(float x, float y, float z, float p3) { invoke<Void>(0x08FE348F, x, y, z, p3); }
	static void START_CUTSCENE_WITH_FADES(char* cutsceneName) { invoke<Void>(0x1C21BE91, cutsceneName); } // unused
	static int GET_CUTSCENE_TIME() { return invoke<int>(0x53F5B5AB); }
	static int GET_CUTSCENE_TIME_MS() { return invoke<int>(0x1552C564); }
	static BOOL WAS_CUTSCENE_SKIPPED() { return invoke<BOOL>(0xC9B6949D); }
	static BOOL HAS_CUTSCENE_FINISHED() { return invoke<BOOL>(0x5DED14B4); }
	static BOOL HAS_CUTSCENE_UNLOADED() { return invoke<BOOL>(0x5BBE8974); }
	static void CLEAR_NAMED_CUTSCENE(char* cutsceneName) { invoke<Void>(0x268CC696); }
	static BOOL HAS_CUTSCENE_LOADED() { return invoke<BOOL>(0xF9998582); }
	static int GET_CUTSCENE_SECTION_PLAYING() { return invoke<int>(0x1026F0D6); }
	static Vector3 GET_CUTSCENE_PED_COORD(Any p0) { return invoke<Vector3>(0xEDF371D0, p0); } // unused
	static Any SET_CUTSCENE_EXTRA_ROOM_POS() { return invoke<Any>(0x06EB9A03); } // unused
	static Ped GET_REGISTERED_PED_INDEX_POST_CUTSCENE(char* name) { return invoke<Ped>(0xF6595859, name); } // unused
	static void REGISTER_PED_PRE_SEAMLESS_CUTSCENE(Ped ped, char* name, BOOL p2) { invoke<Void>(0x7DD7BAB9, ped, name, p2); }
	static void REGISTER_PED_POST_SEAMLESS_CUTSCENE(char* name) { invoke<Void>(0x6C2A0780, name); } // unused
	static void SET_PRE_CUTSCENE_PED_NO_LONGER_NEEDED(Ped* ped) { invoke<Void>(0x54D1FACD, ped); } // unused
	static Vehicle GET_REGISTERED_VEHICLE_INDEX_POST_CUTSCENE(char* name) { return invoke<Vehicle>(0x27400942, name); } // unused
	static void REGISTER_VEHICLE_PRE_SEAMLESS_CUTSCENE(Vehicle vehicle, char* name, BOOL p2) { invoke<Void>(0xECBB0F14, vehicle, name, p2); }
	static void REGISTER_VEHICLE_POST_SEAMLESS_CUTSCENE(char* name) { invoke<Void>(0x4B4BB60E, name); } // unused
	static void SET_PRE_CUTSCENE_VEHICLE_NO_LONGER_NEEDED(Vehicle* vehicle) { invoke<Void>(0x2A9FF799, vehicle); } // unused
	static void REGISTER_HIDE_ENTITY_AT_POSITION(Hash modelHash, float x, float y, float z) { invoke<Void>(0x58A08847, modelHash, x, y, z); }
	static Object GET_REGISTERED_OBJECT_INDEX_POST_CUTSCENE(char* name) { return invoke<Object>(0x17F49810, name); } // unused
	static void REGISTER_OBJECT_PRE_SEAMLESS_CUTSCENE(Object object, char* name, BOOL p2) { invoke<Void>(0xF83BC836, object, name, p2); }
	static void REGISTER_OBJECT_POST_SEAMLESS_CUTSCENE(char* name) { invoke<Void>(0xE0367303, name); } // unused
	static void SET_PRE_CUTSCENE_OBJECT_NO_LONGER_NEEDED(Object* object) { invoke<Void>(0x2FB8D0E6, object); } // unused
	static Any DISPLAY_SEAMLESS_CUTSCENE_TRIGGER_AREA() { return invoke<Any>(0xA080611B); } // unused
	static void SET_SEAMLESS_CUTSCENE_TRIGGER_AREA(float x1, float y1, float z1, float x2, float y2, float z2) { invoke<Void>(0x96FF2315, x1, y1, z1, x1, x2, z2); } // unused
	static BOOL IS_PED_IN_SEAMLESS_TRIGGER_AREA() { return invoke<BOOL>(0xF6589F70); } // unused
	static void SET_SEAMLESS_CUTSCENE_COORDS(float x, float y, float z) { invoke<Void>(0xB7A469ED, x, y, z); } // unused
	static BOOL CAN_SET_ENTER_STATE_FOR_CUTSCENE_PED(char* name) { return invoke<BOOL>(0xE3F828A8, name); } // unused
	static BOOL CAN_SET_EXIT_STATE_FOR_CUTSCENE_PED(char* name) { return invoke<BOOL>(0xDD1F0C79, name); } // unused
	static BOOL CUTSCENE_EXIST(char* cutsceneName) { return invoke<BOOL>(0xE3978BF6, cutsceneName); }
	static void CUTSCENE_REGISTER_INTERACTIVE_SEQUENCE(char* name) { invoke<Void>(0x32062668, name); }
	static void CUTSCENE_REGISTER_ISEQ(Hash hash) { invoke<Void>(0x90CE65B1, hash); }
	static void CUTSCENE_REGISTER_PED_TELEPORT(Any p0, Any p1, Any p2, Any p3, Any p4) { invoke<Void>(0x7D0480F2, p0, p1, p2, p3, p4); }
	static void CUTSCENE_REGISTER_ACTION_TREE_PLAY_NODE(Any p0, Any p1) { invoke<Void>(0x14FC9F8B, p0, p1); }
	static void CUTSCENE_REGISTER_SET_PLAYER_IN_COVER(char* p0, char* p1, BOOL p2, BOOL p3) { invoke<Void>(0xDE14FB1B, p0, p1, p2, p3); }
	static void CUTSCENE_SET_COVER_CAMERA_DIRECTION(Any p0, Any p1) { invoke<Void>(0x041B496A, p0, p1); }
	static void CUTSCENE_REGISTER_PED_ATTACH_TO_VEHICLE(Any p0, Any p1, Any p2, Any p3, Any p4, Any p5, Any p6, Any p7, Any p8, Any p9) { invoke<Void>(0xA1C12621, p0, p1, p2, p3, p4, p5, p6, p7, p8, p9); }
	static void CUTSCENE_REGISTER_PED_WEAPON_HAND(Any p0, Any p1, Any p2) { invoke<Void>(0xE4D4A26B, p0, p1, p2); }
	static Weapon GET_REGISTERED_WEAPON_INDEX_POST_CUTSCENE(char* name) { return invoke<Weapon>(0xDB0F31B2, name); } // unused
	static void REGISTER_WEAPON_PRE_SEAMLESS_CUTSCENE(Weapon weapon, char* name, BOOL p2) { invoke<Void>(0xB2BFDAE4, weapon, name, p2); }
	static void REGISTER_WEAPON_POST_SEAMLESS_CUTSCENE(char* name) { invoke<Void>(0x83402B86, name); } // unused
	static void SET_PRE_CUTSCENE_WEAPON_NO_LONGER_NEEDED(Weapon* weapon) { invoke<Void>(0x4F144C0B, weapon); } // unused
	static void START_CUTSCENE_CAPTURE(char* cutsceneName) { invoke<Void>(0x5B705AC1, cutsceneName); }
	static void STOP_CUTSCENE_CAPTURE() { invoke<Void>(0x5BCC78E8); }
	static BOOL GET_CUTSCENE_CAPTURE_REQUEST(int bufferSize, char* buffer) { return invoke<BOOL>(0xB2A87EE9, bufferSize, buffer); }
	static void CUTSCENE_DISABLE_FADE_IN_GAME_AT_END(BOOL toggle) { invoke<Void>(0xBAC5D71B, toggle); }
	static void CUTSCENE_SET_OVERLAY_TYPE(int type) { invoke<Void>(0xC3E5AA5C, type); }
	static void CUTSCENE_OBJECT_OVERRIDE_VISIBILITY(char* objectName) { invoke<Void>(0x0C63BD13, objectName); }
	static void CUTSCENE_MODEL_NO_LONGER_NEEDED(Hash modelHash) { invoke<Void>(0xB8E657C2, modelHash); }
	static BOOL CUTSCENE_IS_LOADED(char* cutsceneName) { return invoke<BOOL>(0xDFC021D1, cutsceneName); }
	static BOOL CUTSCENE_NAMED_IS_LOADING(char* cutsceneName) { return invoke<BOOL>(0x9DE1B716, cutsceneName); }
	static BOOL CUTSCENE_IS_LOADING() { return invoke<BOOL>(0x8515977D); }
	static void CUTSCENE_REGISTER_SWITCH_TO_LEVEL(int levelIndex) { invoke<Void>(0x529E9877, levelIndex); } // unused
	static void CUTSCENE_REGISTER_SWITCH_TO_LEVEL_NAME(char* levelName) { invoke<Void>(0x459608C7, levelName); }
	static void CUTSCENE_REGISTER_PED_ACTION_INTENTION(Any p0, Any p1, Any p2, Any p3, Any p4, Any p5) { invoke<Void>(0x737F461C, p0, p1, p2, p3, p4, p5); }
	static BOOL CUTSCENE_SHOW_UNAPPROVED() { return invoke<BOOL>(0x0D17DDF9); } // unused
	static void CUTSCENE_SET_IS_UNAPPROVED() { invoke<Void>(0xF0CC36A5); } // unused
	static void CUTSCENE_REGISTER_STREAM_HELPER(Any p0, Any p1, Any p2) { invoke<Void>(0xA8181C23, p0, p1, p2); }
	static Any CUTSCENE_REGISTER_OBJECT_ANIM(Object object, char* animName, char* animDict, float p3, BOOL p4, BOOL p5) { return invoke<Any>(0x5D7E7FD3, object, animName, animDict, p3, p4, p5); }
	static void REGISTER_SCENE_PED_SEAMLESS_CUTSCENE(Any p0, Any p1) { invoke<Void>(0xDAAF0CC6, p0, p1); }
	static void CUTSCENE_DISABLE_CROSSHAIR() { invoke<Void>(0x78181012); }
	static void CUTSCENE_FORCE_GAMEPLAY_HEADING_PITCH_UPDATE() { invoke<Void>(0xA46CA588); }
	static void CUTSCENE_SET_WAIT_FOR_MOVIE(int p0) { invoke<Void>(0x8D86C813, p0); }
	static BOOL CUTSCENE_IS_WAITING_FOR_MOVIE() { return invoke<BOOL>(0x04C1C831); }
	static void CUTSCENE_ENABLE_SKIP(BOOL toggle) { invoke<Void>(0xE9BB90DF, toggle); }
	static void CUTSCENE_FORCE_PLAYER_INVISIBLE() { invoke<Void>(0xBB8277DA); } // unused
	static void CUTSCENE_REGISTER_SET_PED_IN_COVER(Ped ped, char* p1, char* p2, Ped ped2, BOOL p4) { invoke<Void>(0x7DCAE70A, ped, p1, p2, ped2, p4); }
	static void CUTSCENE_REGISTER_VEHICLE_COPY(Vehicle vehicle, char* name) { invoke<Void>(0xF18EBF23, vehicle, name); }
}

namespace CLOCK
{
	static void SET_TIME_ONE_DAY_FORWARD() { invoke<Void>(0xBB56C2E5); } // unused
	static void SET_TIME_ONE_DAY_BACK() { invoke<Void>(0x0DB2A037); } // unused
	static void GET_TIME_OF_DAY(int* hour, int* minute) { invoke<Void>(0x4E1DE7A5, hour, minute); }
	static int GET_HOURS_OF_DAY() { return invoke<int>(0xD455AF99); } // unused
	static int GET_MINUTES_OF_DAY() { return invoke<int>(0xDA92D2D5); } // unused
	static void SET_TIME_OF_DAY(int hour, int minute) { invoke<Void>(0xAD03186C, hour, minute); }
	static void SKIP_FORWARD_TO_TIME_OF_DAY(int hour, int minute) { invoke<Void>(0x8B1C8A57, hour, minute); } // unused
	static int GET_MINUTES_TO_TIME_OF_DAY(int hour, int minute) { return invoke<int>(0x57CDC0FF, hour, minute); } // unused
	static int GET_CURRENT_DAY_OF_WEEK() { return invoke<int>(0xD4C86DC4); } // unused
	static void GET_CURRENT_DATE(int* day, int* month) { invoke<Void>(0x781D7C7D, day, month); } // unused
	static int GET_DIFFERENCE_IN_DAYS_BETWEEN_DATES(int* p0, int* p1, int* p2, int* p3) { return invoke<int>(0x79A447E5, p0, p1, p2, p3); } // unused
	static void FREEZE_TIME_OF_DAY(int hour, int minute) { invoke<Void>(0x4ED46002, hour, minute); }
	static void RELEASE_TIME_OF_DAY() { invoke<Void>(0xC84E8398); }
	static BOOL IS_TIME_OF_DAY_FROZEN() { return invoke<BOOL>(0xE78ED130); }
}

namespace NETWORK
{
	static Any _0x7BBDFEDF() { return invoke<Any>(0x7BBDFEDF); }
	static Any _0x4B8657FE() { return invoke<Any>(0x4B8657FE); }
	static BOOL NETWORK_IS_GAME_IN_PROGRESS() { return invoke<BOOL>(0x09B88E3E); }
	static BOOL NETWORK_IS_ENABLED() { return invoke<BOOL>(0x9E8F9F53); } // unused
	static void NETWORK_SET_THIS_SCRIPT_IS_NETWORK_SCRIPT() { invoke<Void>(0x470810ED); }
	static BOOL NETWORK_IS_PLAYER_ACTIVE(Player player) { return invoke<BOOL>(0x43657B17, player); } // unused
	static BOOL NETWORK_IS_PLAYER_VALID(Player player) { return invoke<BOOL>(0x7F65AF0B, player); } // unused
	static BOOL NETWORK_IS_PLAYER_PHYSICAL(Player player) { return invoke<BOOL>(0x75645571, player); } // unused
	static BOOL NETWORK_IS_HOST() { return invoke<BOOL>(0xE46AC10F); }
	static BOOL NETWORK_IS_HOST_OF_SCRIPT(Hash scriptHash) { return invoke<BOOL>(0x553CF087, scriptHash); } // unused
	static BOOL NETWORK_IS_HOST_OF_THIS_SCRIPT() { return invoke<BOOL>(0x6970BA94); } // unused
	static void NETWORK_CREATE_PICKUP_FROM_WEAPONS(Any p0) { invoke<Void>(0x0186B190, p0); }
	static void NETWORK_CREATE_PED_CORPSE(Ped ped, int p1) { invoke<Void>(0x2DC1E880, ped, p1); }
	static void NETWORK_RESURRECT_PLAYER(Player player, float x, float y, float z, float heading) { invoke<Void>(0x3EEC5461, player, x, y, z, heading); } // unused
	static int NETWORK_GET_TIME_PLAYER_HAS_BEEN_DEAD_FOR(Player player) { return invoke<int>(0xFD0966E3, player); } // unused
	static BOOL NETWORK_HAS_PLAYER_HAS_DIED_RECENTLY(Player player) { return invoke<BOOL>(0x362078F3, player); } // unused
	static Player NETWORK_GET_KILLER_OF_PLAYER(Player player) { return invoke<Player>(0x9809FB6F, player); } // unused
	static BOOL NETWORK_HAS_PLAYER_COLLECTED_PICKUP(Player player, Any p1) { invoke<Void>(0xDA423334, player, p1); } // unused
	static void NETWORK_SET_NETWORK_PLAYER_AS_VIP(Player player, BOOL toggle) { invoke<Void>(0x42FEA7F6, player, toggle); } // unused
	static void NETWORK_GET_TEAM_RGB_COLOUR(int team, int* r, int* g, int* b) { invoke<Void>(0x1DA4FCE0, team, r, g, b); } // unused
	static void NETWORK_SET_TEAM_COLOUR(int team, int colorIndex) { invoke<Void>(0x91F51C10, team, colorIndex); }
	static int NETWORK_GET_FRIEND_COUNT() { return invoke<int>(0xA396ACDE); } // unused
	static void NETWORK_GET_FRIEND_NAME(int bufferSize, char* buffer, int friendIndex) { invoke<Void>(0x97420B6D, bufferSize, buffer, friendIndex); } // unused
	static BOOL NETWORK_IS_FRIEND_ONLINE(char* friendName) { return invoke<BOOL>(0xE0A42430, friendName); } // unused
	static BOOL NETWORK_IS_FRIEND_IN_SAME_TITLE(char* friendName) { return invoke<BOOL>(0xC54365C2, friendName); } // unused
	static void NETWORK_SHOW_FRIEND_PROFILE_UI(char* friendName) { invoke<Void>(0x58D0361F, friendName); } // unused
	static void NETWORK_SHOW_PLAYER_PROFILE_UI(Player player) { invoke<Void>(0x4F05A4BE, player); } // unused
	static int NETWORK_GET_NUM_PLAYERS_MET() { return invoke<int>(0xB04FC561); } // unused
	static void NETWORK_GET_MET_PLAYER_NAME(int bufferSize, char* buffer, int metPlayerIndex) { invoke<Void>(0xA70BA410, bufferSize, buffer, metPlayerIndex); } // unused
	static void NETWORK_SHOW_MET_PLAYER_PROFILE_UI(int metPlayerIndex) { invoke<Void>(0x2AB80821, metPlayerIndex); } // unused
	static void NETWORK_SHOW_MET_PLAYER_FEEDBACK_UI(int metPlayerIndex) { invoke<Void>(0x7759A85A, metPlayerIndex); } // unused
	static BOOL NETWORK_IS_SESSION_INVITABLE() { return invoke<BOOL>(0x91E81052); } // unused
	static BOOL NETWORK_INVITE_FRIEND(char* friendName, char* inviteMsg) { return invoke<BOOL>(0x81A2A4CA, friendName, inviteMsg); } // unused
	static BOOL NETWORK_DID_INVITE_FRIEND(char* friendName) { return invoke<BOOL>(0x9C8802DA, friendName); } // unused
	static Any NETWORK_CHECK_INVITE_ARRIVAL() { return invoke<Any>(0x686548FD); } // unused
	static Any NETWORK_CLEAR_INVITE_ARRIVAL() { return invoke<Any>(0x0CE1CB74); } // unused
	static Any NETWORK_GET_NUM_UNACCEPTED_INVITES() { return invoke<Any>(0xE691321E); } // unused
	static Any NETWORK_GET_UNACCEPTED_INVITER_NAME() { return invoke<Any>(0x34A7E847); } // unused
	static Any NETWORK_GET_UNACCEPTED_INVITE_GAME_MODE() { return invoke<Any>(0xF66BCD00); } // unused
	static BOOL NETWORK_ACCEPT_INVITE(int inviteIndex) { return invoke<BOOL>(0xFB31FA9C, inviteIndex); } // unused
	static BOOL NETWORK_HAVE_ACCEPTED_INVITE() { return invoke<BOOL>(0xD780795D); } // unused
	static BOOL NETWORK_IS_INVITEE_ONLINE() { return invoke<BOOL>(0x95B2C62F); } // unused
	static BOOL NETWORK_HAVE_SUMMONS() { return invoke<BOOL>(0x9060239E); } // unused
	static void NETWORK_CLEAR_SUMMONS() { invoke<Void>(0x95A210E9); } // unused
	static BOOL NETWORK_IS_PLAYER_TALKING(Player player) { return invoke<BOOL>(0xDA9FD9DB, player); } // unused
	static BOOL NETWORK_PLAYER_HAS_HEADSET(Player player) { return invoke<BOOL>(0x451FB6B6, player); } // unused
	static BOOL NETWORK_SET_PLAYER_MUTED(Player player, BOOL toggle) { return invoke<BOOL>(0xCE451908, player, toggle); } // unused
	static BOOL NETWORK_IS_PLAYER_MUTED_BY_ME(Player player) { return invoke<BOOL>(0x7A21050E, player); } // unused
	static BOOL NETWORK_AM_I_MUTED_BY_PLAYER(Player player) { return invoke<BOOL>(0xE128F2B0, player); } // unused
	static BOOL NETWORK_IS_PLAYER_BLOCKED_BY_ME(Player player) { return invoke<BOOL>(0xAE4F4560, player); } // unused
	static BOOL NETWORK_AM_I_BLOCKED_BY_PLAYER(Player player) { return invoke<BOOL>(0x953EF45E, player); } // unused
	static void NETWORK_SET_TALKER_FOCUS(Player player) { invoke<Void>(0xDCDAC012, player); } // unused
	static void NETWORK_SET_TALKER_PROXIMITY(float value) { invoke<Void>(0x67555C66, value); } // unused
	static void NETWORK_SET_TEAM_ONLY_CHAT(BOOL toggle) { invoke<Void>(0x3813019A, toggle); }
	static BOOL NETWORK_HAVE_ONLINE_PRIVILEGES() { return invoke<BOOL>(0xEF63BFDF); } // unused
	static BOOL NETWORK_FIND_GAME_PENDING() { return invoke<BOOL>(0x3AE44227); } // unused
	static int NETWORK_GET_NUMBER_OF_GAMES() { return invoke<int>(0x3429AFE6); } // unused
	static BOOL NETWORK_HOST_GAME(Any p0, BOOL p1, Any p2, Any p3, Any p4, Any p5) { return invoke<BOOL>(0x79A5F0C4, p0, p1, p2, p3, p4, p5); } // unused
	static BOOL NETWORK_IS_OPERATION_PENDING() { return invoke<BOOL>(0x6895F923); } // unused
	static BOOL NETWORK_JOIN_SUMMONS() { return invoke<BOOL>(0x68C293F4); } // unused
	static void NETWORK_READY_FOR_JIP() { invoke<Void>(0xBF325030); }
	static void _0x159BF0F1(BOOL p0) { invoke<Void>(0x159BF0F1, p0); } // unused
	static Any NETWORK_KICK_PLAYER() { return invoke<Any>(0x7EDD6266); } // unused
	static BOOL NETWORK_STORE_SINGLE_PLAYER_GAME() { return invoke<BOOL>(0xA52597AE); } // unused
	static void SHUTDOWN_AND_LAUNCH_SINGLE_PLAYER_GAME() { invoke<Void>(0x92B7351C); } // unused
	static void SHUTDOWN_AND_LAUNCH_NETWORK_GAME(int levelIndex) { invoke<Void>(0x691694D2, levelIndex); } // unused
	static BOOL IS_NETWORK_SESSION() { return invoke<BOOL>(0x1D8FEF54); } // unused
	static BOOL NETWORK_CHANGE_GAME_MODE(Any p0, Any p1, Any p2, Any p3) { return invoke<BOOL>(0xCB8178A3, p0, p1, p2, p3); } // unused
	static Any NETWORK_CHANGE_GAME_MODE_PENDING() { return invoke<Any>(0x8226F769); } // unused
	static Any NETWORK_CHANGE_GAME_MODE_SUCCEEDED() { return invoke<Any>(0xFBA800BC); } // unused
	static int NETWORK_GET_GAME_MODE() { return invoke<int>(0x542F6097); } // unused
	static int NETWORK_GET_MAX_SLOTS() { return invoke<int>(0xE7DA761C); }
	static int NETWORK_GET_MAX_PRIVATE_SLOTS() { return invoke<int>(0xFF2121DE); }
	static Any NETWORK_SET_FRIENDLY_FIRE_OPTION() { return invoke<Any>(0x6BAF95FA); } // unused
	static void NETWORK_SET_HEALTH_RETICULE_OPTION(BOOL toggle) { invoke<Void>(0x18319AA8, toggle); } // unused
	static BOOL NETWORK_IS_GAME_RANKED() { return invoke<BOOL>(0xAB1DB6B6); } // unused
	static Any NETWORK_SET_RICH_PRESENCE() { return invoke<Any>(0x932A6CED); } // unused
	static Any NETWORK_GET_COUNTOF_RICH_PRESENCE() { return invoke<Any>(0x1CE03E7B); } // unused
	static Any NETWORK_GET_RICH_PRESENCE_IS_VALID() { return invoke<Any>(0xD47D4C49); } // unused
	static Any NETWORK_GET_RICH_PRESENCE_ID() { return invoke<Any>(0x661455A9); } // unused
	static Any NETWORK_GET_RICH_PRESENCE_LABEL() { return invoke<Any>(0x2BF438BF); } // unused
	static Any NETWORK_GET_RICH_PRESENCE_FIELD_INDEX() { return invoke<Any>(0x3D42FEC4); } // unused
	static Any NETWORK_GET_RICH_PRESENCE_ID_FROM_INDEX() { return invoke<Any>(0x4F08B53D); } // unused
	static BOOL NETWORK_GET_PLAYER_STREAK_ACTIVE(Player player, int p1) { return invoke<BOOL>(0x1C4B4492, player, p1); } // unused
	static BOOL NETWORK_DOES_PLAYER_HAVE_ANY_STREAK_ACTIVE(Player player) { return invoke<BOOL>(0x75602443, player); } // unused
	static int NETWORK_GET_PLAYER_ACTIVE_STREAK(Player player) { return invoke<int>(0xFE3BB23A, player); } // unused
	static int NETWORK_GET_PLAYER_ACTIVE_STREAK_LEVEL(Player player) { return invoke<int>(0x71168B1F, player); } // unused
	static void NETWORK_RESET_PLAYER_STREAKS(Player player) { invoke<Void>(0x9B60B0AB, player); } // unused
	static void NETWORK_CLEAR_PLAYER_STREAK(Player player, int p1) { invoke<Void>(0x9F165014, player, p1); }
	static Any NETWORK_GET_PLAYER_STREAK_EFFECT(Any p0, Any p1) { return invoke<Any>(0x9E7A0C00, p0, p1); }
	static void NETWORK_SET_PLAYER_STREAK_EFFECT(Any p0, Any p1, Any p2) { invoke<Void>(0xCEB8449D, p0, p1, p2); }
	static void NETWORK_SET_PLAYER_STREAK_BLOCKED(Any p0, Any p1, Any p2) { invoke<Void>(0x3BDDEEE2, p0, p1, p2); }
	static Any NETWORK_GET_PLAYER_STREAK_BLOCKED(Any p0, Any p1) { return invoke<Any>(0x3663B7E0, p0, p1); }
	static void NETWORK_SET_PLAYER_STREAK_IN_SLOT(Any p0, Any p1, Any p2) { invoke<Void>(0xC0188F3F, p0, p1, p2); }
	static Any NETWORK_GET_PLAYER_STREAK_IN_SLOT(Any p0, Any p1) { return invoke<Any>(0x3201F4A2, p0, p1); }
	static Any NETWORK_GET_STREAK_TEXTURE(Any p0) { return invoke<Any>(0x0277FB8F, p0); }
	static void NETWORK_GET_STREAK_NAME(Any p0, Any p1, Any p2) { invoke<Void>(0xA973F1AB, p0, p1, p2); }
	static void NETWORK_ADD_PLAYER_EXPERIENCE(int amount, char* type) { invoke<Void>(0x1C3663D9, amount, type); }
	static void NETWORK_ADD_PLAYER_EXPERIENCE_POS(int amount, char* type, float x, float y, float z) { invoke<Void>(0xB7EB7A99, amount, type, x, y, z); }
	static void NETWORK_ADD_PLAYER_EXPERIENCE_PLAYER(int amount, char* type, Player player) { invoke<Void>(0xB956912A, amount, type, player); }
	static void NETWORK_ADD_INWORLD_TEXT(int value, char* text, int type) { invoke<Void>(0x836D59C3, value, text, type); }
	static void NETWORK_ADD_INWORLD_TEXT_POS(int value, char* text, int type, float x, float y, float z) { invoke<Void>(0xB3775AEA, value, text, type, x, y, z); }
	static void NETWORK_ADD_INWORLD_TEXT_PLAYER(int value, char* text, int type, Player player) { invoke<Void>(0x1001CFE8, value, text, type, player); }
	static void NETWORK_ADD_INWORLD_TEXT_PED(int value, char* text, int type, Ped ped) { invoke<Void>(0x0EB30678, value, text, type, ped); }
	static void NETWORK_ADD_INWORLD_TEXT_OBJECT(int value, char* text, int type, Object object) { invoke<Void>(0x925DE2A9, value, text, type, object); } // unused
	static void NETWORK_ADD_PLAYER_CASH(int amount, char* type) { invoke<Void>(0x044D320A, amount, type); }
	static void NETWORK_ADD_PLAYER_CASH_POS(int amount, char* type, float x, float y, float z) { invoke<Void>(0x431A0984, amount, type, x, y, z); } // unused
	static void NETWORK_ADD_PLAYER_CASH_PLAYER(int amount, char* type, Player player) { invoke<Void>(0xE544D336, amount, type, player); }
	static int NETWORK_GET_PLAYER_CASH() { return invoke<int>(0x9CE0F8F1); } // unused
	static void NETWORK_SET_TEAM_KILL_EXPERIENCE(int value) { invoke<Void>(0x58625E40, value); } // unused
	static BOOL NETWORK_JOINING_IN_PROGRESS_GAME() { return invoke<BOOL>(0x6D3ADAB3); }
	static void SET_THIS_MACHINE_RUNNING_SERVER_SCRIPT(BOOL toggle) { invoke<Void>(0x1626C5C3, toggle); } // unused
	static BOOL IS_SPHERE_VISIBLE_TO_ANOTHER_MACHINE(float x, float y, float z, float radius) { return invoke<BOOL>(0x23C5274E, x, y, z, radius); } // unused
	static float GET_NETWORK_TIMER() { return invoke<float>(0xF733052C); }
	static void SET_SYNC_WEATHER_AND_GAME_TIME(BOOL toggle) { invoke<Void>(0xB3A07403, toggle); } // unused
	static void NETWORK_SET_WEATHER(int weatherTypeId, int p1, BOOL persist) { invoke<Void>(0x85CCA432, weatherTypeId, p1, persist); } // unused
	static Any SET_IN_SPECTATOR_MODE() { return invoke<Any>(0x74DBC1BF); } // unused
	static BOOL IS_IN_SPECTATOR_MODE() { return invoke<BOOL>(0x1A8853B0); } // unused
	static void SET_IN_MP_TUTORIAL(BOOL toggle) { invoke<Void>(0x2FD05431, toggle); } // unused
	static void DISPLAY_PLAYER_NAMES(BOOL toggle) { invoke<Void>(0x8F01C7D0, toggle); } // unused
	static void NETWORK_PLAYER_FORCE_COLOR(Player player, int p1, BOOL p2) { invoke<Void>(0x501D54BA, player, p1, p2); }
	static void SET_MSG_FOR_LOADING_SCREEN(char* msg) { invoke<Void>(0x0C128376, msg); } // unused
	static void INVOKE_SPECTATOR_CAM() { invoke<Void>(0xCFD752C6); }
	static void RESET_GAMEPLAY_CAM() { invoke<Void>(0x809999E5); }
	static Any ADD_KILLXP_RULE() { return invoke<Any>(0x216F295D); } // unused
	static void ADD_KILLXP_RULE_ANYKILLER(Any p0, Any p1) { invoke<Void>(0xCEB6BD96, p0, p1); }
	static void ADD_KILLXP_RULE_ANYVICTIM(Any p0, Any p1) { invoke<Void>(0x3558D8E8, p0, p1); }
	static void CLEAR_KILLXP_RULES() { invoke<Void>(0x77886D8E); }
	static void REGISTER_KILL_IN_MULTIPLAYER_GAME(Player player, Player player2, Any p2) { invoke<Void>(0xFE86190E, player, player2, p2); } // unused
	static BOOL GET_IS_PLAYER_IN_BULLET_TIME(Player player) { return invoke<BOOL>(0x8E5084AD, player); }
	static int GET_PLAYER_BULLET_TIME_STATE(Player player) { return invoke<int>(0x0105C960, player); }
	static BOOL GET_IS_PLAYER_SHOOT_DODGING(Player player) { return invoke<BOOL>(0x1E8970C1, player); }
	static BOOL GET_IS_PLAYER_IN_AIR(Player player) { return invoke<BOOL>(0x02BDCB6E, player); }
	static BOOL GET_IS_PLAYER_IN_LAST_STAND(Player player) { return invoke<BOOL>(0x35EE1682, player); }
	static int GET_LOCAL_PLAYER_XP() { return invoke<int>(0x788C69A2); } // unused
	static int GET_NETWORK_PLAYER_XP(Player player, BOOL p1) { return invoke<int>(0xF8BC3984, player, p1); }
	static Player GET_PLAYER_KILLER(Player player) { return invoke<Player>(0x7A2356DA, player); } // unused
	static void GET_PLAYER_KILLER_NAME(int bufferSize, char* buffer, Player player) { invoke<Void>(0xF160FA80, bufferSize, buffer, player); } // unused
	static Hash GET_PLAYER_KILLER_WEAPON(Player player) { return invoke<Hash>(0x46299DFB, player); }
	static Hash GET_PLAYER_CAUSE_OF_DEATH(Player player) { return invoke<Hash>(0x007E3DE8, player); }
	static void SET_MP_GAME_DIFFICULTY(int difficulty) { invoke<Void>(0x86C7C8EF, difficulty); }
	static void SET_PLAYER_HEALTH_REGENERATION(BOOL toggle) { invoke<Void>(0xFB207BEA, toggle); }
	static void SET_PLAYER_HEALTH_REGENERATION_RATE(int mpRate, int spRate) { invoke<Void>(0x10182B3F, mpRate, spRate); }
	static void SET_PLAYER_HEALTH_REGENERATION_MAX(int maxValue) { invoke<Void>(0xA94E6088, maxValue); }
	static BOOL IS_OBJECT_REASSIGNMENT_IN_PROGRESS() { return invoke<BOOL>(0x127EE29C); } // unused
	static Any SAVE_SCRIPT_ARRAY_IN_SCRATCHPAD() { return invoke<Any>(0x8A3A3C98); } // unused
	static Any RESTORE_SCRIPT_ARRAY_FROM_SCRATCHPAD() { return invoke<Any>(0x5AB30FE1); } // unused
	static Any CLEAR_SCRIPT_ARRAY_FROM_SCRATCHPAD() { return invoke<Any>(0x50770E90); } // unused
	static BOOL NETWORK_PARAM_ALLOW_WIN_BUTTON() { return invoke<BOOL>(0x6C49E55C); }
	static BOOL NETWORK_PARAM_JUST_RESPAWN() { return invoke<BOOL>(0x2F09AA8A); } // unused
	static int NETWORK_GET_PARAM_NETTEST() { return invoke<int>(0x0186725B); }
	static int NETWORK_GET_PARAM_NETTEST_HOST() { return invoke<int>(0x6AA467E5); }
	static void NET_DEBUG(char* message) { invoke<Void>(0x0E1B51FE, message); } // unused
	static void NET_DEBUG_INT(char* message, int value) { invoke<Void>(0xADC31C4F, message, value); } // unused
	static void NET_DEBUG_FLOAT(char* message, float value) { invoke<Void>(0xC11C0E6E, message, value); } // unused
	static void NET_DEBUG_VECTOR(char* message, float x, float y, float z) { invoke<Void>(0x8D271B46, message, x, y, z); } // unused
	static void NET_DEBUG_STRING(char* message, char* str) { invoke<Void>(0x5D3F0923, message, str); } // unused
	static void NET_WARNING(char* message) { invoke<Void>(0x2242923E, message); }
	static void NET_WARNING_INT(char* message, int value) { invoke<Void>(0xF025F2F5, message, value); }
	static void NET_WARNING_FLOAT(char* message, float value) { invoke<Void>(0x0ACCEE78, message, value); } // unused
	static void NET_WARNING_VECTOR(char* message, float x, float y, float z) { invoke<Void>(0x378FD17A, message, x, y, z); } // unused
	static void NET_WARNING_STRING(char* message, char* str) { invoke<Void>(0x1F02B90E, message, str); } // unused
	static void NET_ERROR(char* message) { invoke<Void>(0xBD5919F3, message); } // unused
	static void NET_ERROR_INT(char* message, int value) { invoke<Void>(0x83ABB62E, message, value); }
	static void NET_ERROR_FLOAT(char* message, float value) { invoke<Void>(0xE3ED73BA, message, value); } // unused
	static void NET_ERROR_VECTOR(char* message, float x, float y, float z) { invoke<Void>(0x757A4E3C, message, x, y, z); } // unused
	static void NET_ERROR_STRING(char* message, char* str) { invoke<Void>(0xB8A3378F, message, str); } // unused
	static void ENABLE_FIRST_TIME_LOCK(BOOL toggle) { invoke<Void>(0x969CF927, toggle); } // unused
	static void ENABLE_SOFT_TARGETING(BOOL toggle) { invoke<Void>(0x7EEB362A, toggle); } // unused
	static void ENABLE_AIM_ASSIST(BOOL toggle) { invoke<Void>(0x1283F44C); } // unused
	static Any NETWORK_SET_PROFILESTATINTERVAL() { return invoke<Any>(0x863D8EE5); } // unused
	static void NETWORK_SET_BOT_PLAYER(BOOL toggle) { invoke<Void>(0x2ED349DE, toggle); }
	static void BOT_UPDATE_INPUT() { invoke<Void>(0x03C4F17C); }
	static void BOT_SET_INPUT(char* p0, float p1) { invoke<Void>(0x3D8F266F, p0, p1); }
	static void NETWORK_SET_PLAYER_TRACER_COLOUR(Any p0, Any p1) { invoke<Void>(0x34EDFF34, p0, p1); }
	static void NET_PLAYSTATS_GAMETYPE_STARTED(Any p0, Any p1, Any p2, Any p3, Any p4, Any p5) { invoke<Void>(0x3F507595, p0, p1, p2, p3, p4, p5); }
	static void NET_PLAYSTATS_GAMETYPE_ENDED(Any p0, Any p1, Any p2, Any p3, Any p4) { invoke<Void>(0xFACD7753, p0, p1, p2, p3, p4); }
	static void NET_PLAYSTATS_CLAN_FEUD(Any p0, Any p1, Any p2, Any p3) { invoke<Void>(0xF5BC8A87, p0, p1, p2, p3); }
	static void NET_PLAYSTATS_JOIN_TEAM(Any p0) { invoke<Void>(0x0BA80875, p0); }
	static void NET_PLAYSTATS_GAMETYPE_OBJECTIVE(Any p0, Any p1, Any p2, Any p3) { invoke<Void>(0x036B7CED, p0, p1, p2, p3); }
	static void NET_PLAYSTATS_PLAYER_SELECTED(Any p0) { invoke<Void>(0x1BD6A6D9, p0); }
	static void NET_PLAYSTATS_POST_MATCH_BLOB(Any p0, Any p1, Any p2, Any p3, Any p4, Any p5, Any p6) { invoke<Void>(0x21847D03, p0, p1, p2, p3, p4, p5, p6); }
	static void _NET_PLAYSTATS_UPDATE(Hash hash, int score) { invoke<Void>(0x05EDABB7, hash, score); } // unused
	static void DISALLOW_JOINERS() { invoke<Void>(0x878854A3); }
	static void NET_SHOW_GAMER_TAGS(BOOL toggle) { invoke<Void>(0x5C8CBCE5, toggle); }
	static BOOL IS_LOCAL_PLAYER_IN_SOCIAL_CLUB() { return invoke<BOOL>(0x167AF0DF); }
	static BOOL NET_GET_INT_ROS_GAMER_DATA(Hash hash, int* value) { return invoke<BOOL>(0x6670CF02, hash, value); } // unused
	static BOOL NET_GET_BOOL_ROS_GAMER_DATA(Hash hash) { return invoke<BOOL>(0xDBF081C9, hash); } // unused
	static BOOL NET_GET_FLOAT_ROS_GAMER_DATA(Hash hash, float* value) { return invoke<BOOL>(0xEF912D19, hash, value); } // unused
	static BOOL NET_GET_GAMER_ROS_XP_BONUS(float* value) { return invoke<BOOL>(0x60D4317D, value); }
	static BOOL NET_GET_IS_ROS_CHEATER() { return invoke<BOOL>(0x7ABA6A5E); } // unused
	static BOOL NET_GET_IS_ROCKSTAR_DEV() { return invoke<BOOL>(0xCFFFC689); } // unused
	static void _0x593E121A(BOOL toggle) { invoke<Void>(0x593E121A, toggle); }
	static void _0x20DA5574(Object object) { invoke<Void>(0x20DA5574, object); }
	static BOOL _0x4154648C(Player player) { return invoke<BOOL>(0x4154648C, player); }
}

namespace BRAIN
{
	static void ADD_SCRIPT_TO_RANDOM_PED(char* scriptName, Hash modelHash, int p2, BOOL p3) { invoke<Void>(0xECC76C3D, scriptName, modelHash, p2, p3); } // unused
	static void ADD_SCRIPT_TO_OBJECT(char* scriptName, Hash modelHash, int p2, float p3, BOOL p4) { invoke<Void>(0x68D34980, scriptName, modelHash, p2, p3, 4); } // unused
	static BOOL IS_OBJECT_WITHIN_BRAIN_ACTIVATION_RANGE(Object object) { return invoke<BOOL>(0xBA4CAA56, object); } // unused
	static void REGISTER_WORLD_POINT_SCRIPT_BRAIN(char* p0) { invoke<Void>(0x725D91F7, p0); } // unused
	static BOOL IS_WORLD_POINT_WITHIN_BRAIN_ACTIVATION_RANGE() { return invoke<BOOL>(0x2CF305A0); } // unused
	static void REGISTER_BRAIN_WITH_MISSION_OBJECT(Object object, char* p1) { invoke<Void>(0xF8DD6151, object, p1); } // unused
}

namespace LOADOUT
{
	static BOOL IS_LOADOUT_VALID(int index) { return invoke<BOOL>(0x5ACBCBF0, index); }
	static BOOL DOES_LOADOUT_SLOT_HAVE_CUSTOM_NAME(int index) { return invoke<BOOL>(0x6AC41269, index); }
}

namespace WATER
{
	static BOOL GET_WATER_HEIGHT(float x, float y, float z, float* height) { return invoke<BOOL>(0xD864E17C, x, y, z, height); } // unused
	static BOOL GET_WATER_HEIGHT_NO_WAVES(float x, float y, float z, float* height) { return invoke<BOOL>(0x262017F8, x, y, z, height); } // unused
	static BOOL SYNCH_RECORDING_WITH_WATER() { return invoke<BOOL>(0x74537488); } // unused
	static void SET_PUDDLES(float p0, float p1, float p2, float p3) { invoke<Void>(0x7B0E77C5, p0, p1, p2, p3); }
	static void OVERRIDE_WATER_SETTINGS(float p0, float p1, int p2) { invoke<Void>(0x6B4457D5, p0, p1, p2); }
	static void USE_DEFAULT_WATER_SETTINGS() { invoke<Void>(0x48C6519C); }
	static void RESET_WATER_SIMULATION() { invoke<Void>(0x33E9C756); } // unused
}

namespace XML
{
	static BOOL LOAD_XML_FILE(char* name) { return invoke<BOOL>(0x1C084D18, name); } // unused
	static void DELETE_XML_FILE() { invoke<Void>(0xCA3AF245); } // unused
	static int GET_NUMBER_OF_XML_NODES() { return invoke<int>(0x3CAACE0D); } // unused
	static void GET_NEXT_XML_NODE() { invoke<Void>(0xA9FDD7A1); } // unused
	static void GET_XML_NODE_NAME(int bufferSize, char* buffer) { invoke<Void>(0x8450DBA1, bufferSize, buffer); } // unused
	static int GET_NUMBER_OF_XML_NODE_ATTRIBUTES() { return invoke<int>(0xED658C76); } // unused
	static void GET_XML_NODE_ATTRIBUTE_NAME(int bufferSize, char* buffer, int attributeIndex) { invoke<Void>(0xC93DD4B8, bufferSize, buffer, attributeIndex); } // unused
	static int GET_INT_FROM_XML_NODE_ATTRIBUTE(int attributeIndex) { return invoke<int>(0x1C524DBB, attributeIndex); } // unused
	static float GET_FLOAT_FROM_XML_NODE_ATTRIBUTE(int attributeIndex) { return invoke<float>(0x9C58C97F, attributeIndex); } // unused
	static BOOL GET_BOOL_FROM_XML_NODE_ATTRIBUTE(int attributeIndex) { return invoke<BOOL>(0x2D285BBA, attributeIndex); } // unused
	static void GET_STRING_FROM_XML_NODE_ATTRIBUTE(int bufferSize, char* buffer, int attributeIndex) { invoke<Void>(0x60BF58D2, bufferSize, buffer, attributeIndex); } // unused
	static BOOL GET_XML_NAMED_NODE(char* nodeName) { return invoke<BOOL>(0x0E5855B5, nodeName); } // unused
}

namespace LOBBY
{
	static BOOL LOBBY_HAS_MATCH_STARTED() { return invoke<BOOL>(0xD5189EE8); } // unused
	static int LOBBY_GET_NUM_GAME_MODES() { return invoke<int>(0xE30A3B07); } // unused
	static void LOBBY_GET_GAME_MODE_NAME(int bufferSize, char* buffer, int gameMode) { invoke<Void>(0x3CE1674C, bufferSize, buffer, gameMode); } // unused
	static int LOBBY_GET_SELECTED_GAME_MODE() { return invoke<int>(0xE65EC1C1); }
	static int LOBBY_GET_NUM_ACTIVE_OPTIONS() { return invoke<int>(0x8DB907E0); } // unused
	static int LOBBY_GET_NUM_OPTIONS(int gameMode) { return invoke<int>(0x1DBC1E68, gameMode); } // unused
	static void LOBBY_GET_OPTION_NAME(int bufferSize, char* buffer, int gameMode, int option) { invoke<Void>(0x073F8D7A, bufferSize, buffer, gameMode, option); } // unused
	static int LOBBY_GET_OPTION_VALUE(int gameMode, int option) { return invoke<int>(0xFD0AF1D4, gameMode, option); }
	static int LOBBY_GET_NUM_SUB_OPTIONS(int gameMode, int option) { return invoke<int>(0x34332D95, gameMode, option); } // unused
	static void LOBBY_GET_SUB_OPTION_NAME(int bufferSize, char* buffer, int gameMode, int option) { invoke<Void>(0x8D6AB46A, bufferSize, buffer, gameMode, option); } // unused
	static BOOL LOBBY_GET_OPTION_IS_ACTIVE(int gameMode, int option) { return invoke<BOOL>(0xF79A7F40, gameMode, option); } // unused
	static BOOL LOBBY_GET_OPTION_IS_DEACTIVE(int gameMode, int option) { return invoke<BOOL>(0x600E3311); } // unused
	static BOOL LOBBY_GET_OPTION_IS_DISABLE(int gameMode, int option) { return invoke<BOOL>(0x664091E2); } // unused
	static BOOL LOBBY_GET_OPTION_IS_NUMBERS(int gameMode, int option) { return invoke<BOOL>(0xBF4965C0); } // unused
	static BOOL LOBBY_GET_OPTION_IS_LIST(int gameMode, int option) { return invoke<BOOL>(0x0428DCDB); } // unused
	static BOOL LOBBY_GET_OPTION_IS_KICK_LIST(int gameMode, int option) { return invoke<BOOL>(0x349BA811); } // unused
	static BOOL LOBBY_GET_OPTION_IS_MODEL(int gameMode, int option) { return invoke<BOOL>(0xEF2DEAA4); } // unused
	static BOOL LOBBY_GET_OPTION_EXISTS(int gameMode, int option) { return invoke<BOOL>(0xFF3B14E9); } // unused
	static int LOBBY_GET_MIN_PLAYERS() { return invoke<int>(0xC5731817); }
	static void GET_LAUNCH_SCRIPT(int bufferSize, char* buffer) { invoke<Void>(0xADB14C47, bufferSize, buffer); } // unused
}

namespace SEV
{
	static BOOL SEV_IS_PRIMARY() { return invoke<BOOL>(0x2147F5F2); }
	static void SEV_THREAD_THIS(Any p0) { invoke<Void>(0xD494158C, p0); }
	static void SEV_ISOLATE() { invoke<Void>(0xFC64AA42); }
	static void SEV_ISOLATE_OFF() { invoke<Void>(0x821594DD); }
	static void SEV_ISOLATED_ONLY() { invoke<Void>(0xBD5E1E6B); }
	static void SEV_CONNECTED_ONLY() { invoke<Void>(0x1BC7E9FB); }
	static Any SEV_BINDC(Any p0, Any p1, Any p2, Any p3, Any p4) { return invoke<Any>(0x4F8EBA7E, p0, p1, p2, p3, p4); }
	static void SEV_UNBIND(Any p0) { invoke<Void>(0x34AD4192, p0); }
	static void SEV_UNBIND_CATEGORY(Any p0) { invoke<Void>(0xEA305AC0, p0); }
	static void SEV_UNBIND_HANDLER(Any p0) { invoke<Void>(0xAA607425, p0); }
	static void SEV_ONCE_ONLY() { invoke<Void>(0x6DA448CC); }
	static void SEV_UNBIND_ALL_FOR_PED(Any p0) { invoke<Void>(0x7561DF34, p0); }
	static Any SEV_CONDITION(Any p0, Any p1, Any p2) { return invoke<Any>(0xBE758B0C, p0, p1, p2); }
	static void SEV_WAIT_FOR(Any p0) { invoke<Void>(0xCD3036F5, p0); }
	static void SEV_NEXT_EVENT(Any p0, Any p1) { invoke<Void>(0xAFB40502, p0, p1); }
	static Any SEV_CURRENT_EVENT(Any p0, Any p1) { return invoke<Any>(0x1D049619, p0, p1); }
	static int SEV_ID_TO_INDEX(int sevId) { return invoke<int>(0x374F72FE, sevId); }
	static int SEV_INDEX_TO_ID(int sevIndex) { return invoke<int>(0x66169946, sevIndex); }
	static void SEV_YIELD() { invoke<Void>(0x7DE3579B); }
	static Any SEV_INVALID_EVENT_ID() { return invoke<Any>(0xAE382401); }
	static Any SEV_CONSTRUCT_EVENT() { return invoke<Any>(0xA9A14FD3); }
	static void SEV_INDUCE_EVENT(Any p0) { invoke<Void>(0xF7669E49, p0); }
	static void SEV_INDUCE_GATHER_EVENT(Any p0) { invoke<Void>(0x7FD7CD71, p0); }
	static void SEV_INDUCE_EVENT_ARGS(Any p0, Any p1, Any p2) { invoke<Void>(0xF69FEF47, p0, p1, p2); }
	static void SEV_INDUCE_LOCAL_EVENT(Any p0) { invoke<Void>(0xF199C3EB, p0); }
	static void SEV_INDUCE_LOCAL_EVENT_ARGS(Any p0, Any p1, Any p2) { invoke<Void>(0xA2793188, p0, p1, p2); }
	static Any SEV_OBSERVE_INT(Any p0) { return invoke<Any>(0x55FCE28A, p0); }
	static Any SEV_OBSERVE_FLOAT(Any p0) { return invoke<Any>(0xB8084395, p0); }
	static Any SEV_WATCHER_TO_INT() { return invoke<Any>(0x11A30848); } // unused
	static Any SEV_INT_TO_WATCHER() { return invoke<Any>(0x98A92C54); } // unused
	static void SEV_CREATE_PED(Ped ped, Hash modelHash, float x, float y, float z, float heading, BOOL isNetwork, BOOL dontOwn) { invoke<Void>(0xF9F0D9BB, ped, modelHash, x, y, z, heading, isNetwork, dontOwn); }
	static void SEV_CREATE_VEHICLE(Vehicle vehicle, Hash modelHash, float x, float y, float z, float heading) { invoke<Void>(0xD421FF04, vehicle, modelHash, x, y, z, heading); }
	static void SEV_CREATE_OBJECT(Object object, Hash modelHash, float x, float y, float z) { invoke<Void>(0x7D9E2B5F, object, modelHash, x, y, z); }
	static void SEV_DELETE_OBJECT(Object object) { invoke<Void>(0xBEB0FDDE, object); }
	static void SEV_CREATE_PICKUP(Any p0, Any p1, Any p2, Any p3, Any p4, Any p5, Any p6, Any p7, Any p8, Any p9) { invoke<Void>(0x9DFDA816, p0, p1, p2, p3, p4, p5, p6, p7, p8, p9); }
	static Any SEV_PLAYER_INDEX_TO_SLOT(Any p0) { return invoke<Any>(0xD5BDAF17, p0); }
	static Any SEV_PLAYER_SLOT_TO_INDEX(Any p0) { return invoke<Any>(0x18E183E8, p0); }
	static Any SEV_PLAYER_IS_VALID_SLOT(Any p0) { return invoke<Any>(0x0D6E3E53, p0); }
	static Player SEV_GET_MY_PLAYER() { return invoke<Player>(0x43BE716F); }
	static Any SEV_MAP_PLAYER_PED(Any p0, Any p1) { return invoke<Any>(0x2E6A11AD, p0, p1); }
	static void SEV_SET_PLAYER_MODEL(Player player, Hash modelHash) { invoke<Void>(0x4BAA35E9, player, modelHash); }
	static Any SEV_SET_PLAYER_MODEL_DEFAULT_VARIATION() { return invoke<Any>(0x86F9D4FF); } // unused
	static void SEV_SET_PLAYER_AVATAR(Any p0, Any p1, Any p2) { invoke<Void>(0x1778B6B6, p0, p1, p2); }
	static Any SEV_GET_UNIQUE_PLAYER_MODEL_VARIATION() { return invoke<Any>(0xCD0F2DB8); } // unused
	static Any SEV_RESET_UNIQUE_PLAYER_MODEL_VARIATIONS() { return invoke<Any>(0x2772572D); } // unused
	static void SEV_RESURRECT_PLAYER(Any p0, Any p1, Any p2, Any p3, Any p4) { invoke<Void>(0xC0AC4551, p0, p1, p2, p3, p4); }
	static void SEV_RESURRECT_PLAYER_FINISH(Any p0, Any p1, Any p2) { invoke<Void>(0xD506CEF7, p0, p1, p2); }
	static void SEV_SET_PLAYER_FRIENDLY_FIRE(Any p0, Any p1) { invoke<Void>(0x1B65C378, p0, p1); }
	static Any SEV_GET_PLAYER_FRIENDLY_FIRE() { return invoke<Any>(0x52A421F3); } // unused
	static Any SEV_IS_SPHERE_VISIBLE_TO_OTHER_TEAM_PLAYERS() { return invoke<Any>(0x6A1BA8C6); } // unused
	static Any SEV_IS_SPHERE_VISIBLE_TO_PLAYER_LIST(Any p0, Any p1, Any p2, Any p3, Any p4, Any p5, Any p6, Any p7, Any p8, Any p9) { return invoke<Any>(0x48990418, p0, p1, p2, p3, p4, p5, p6, p7, p8, p9); }
	static Any SEV_IS_POINT_VISIBLE_TO_POSITION_LIST(Any p0, Any p1, Any p2, Any p3) { return invoke<Any>(0x7C932981, p0, p1, p2, p3); }
	static Any SEV_ON_TIMER(Any p0) { return invoke<Any>(0x02FFAB17, p0); }
	static Any SEV_ON_HOST_SYNC() { return invoke<Any>(0x3CF8A812); }
	static Any SEV_ON_ANY_PED_CREATED() { return invoke<Any>(0x9939785A); } // unused
	static Any SEV_ON_PED_CREATED() { return invoke<Any>(0xBD305A46); } // unused
	static Any SEV_ON_PED_INJURED(Any p0) { return invoke<Any>(0x2F4FA7AA, p0); }
	static Any SEV_ON_PED_RANK_UP(Any p0) { return invoke<Any>(0x7B6F3CA4, p0); }
	static Any SEV_ON_PED_ASSIST(Any p0) { return invoke<Any>(0xBD0068C6, p0); }
	static Any SEV_ON_PED_USE_STREAK(Any p0) { return invoke<Any>(0x43F36B61, p0); }
	static Any SEV_ON_ANY_PED_DIED() { return invoke<Any>(0x087EE778); }
	static Any SEV_ON_PED_DIED(Any p0) { return invoke<Any>(0x2C21F110, p0); }
	static Any SEV_ON_ANY_PED_DELETED() { return invoke<Any>(0xE47E14C1); } // unused
	static Any SEV_ON_PED_DELETED(Any p0) { return invoke<Any>(0xFA377D19, p0); }
	static Any SEV_ON_PED_TRIGGER_ENTERED(Any p0, Any p1, Any p2) { return invoke<Any>(0x37DF6A31, p0, p1, p2); }
	static Any SEV_ON_PED_TRIGGER_LEFT(Any p0, Any p1, Any p2) { return invoke<Any>(0xB18C949F, p0, p1, p2); }
	static Any SEV_ON_PED_TRIGGER_LIST_ENTERED(Any p0, Any p1, Any p2, Any p3) { return invoke<Any>(0xFCEC8FDF, p0, p1, p2, p3); }
	static Any SEV_ON_PED_TRIGGER_LIST_LEFT(Any p0, Any p1, Any p2, Any p3) { return invoke<Any>(0xA80054BD, p0, p1, p2, p3); }
	static Any SEV_ON_PED_LOOK_TRIGGER_START() { return invoke<Any>(0x91C64482); } // unused
	static Any SEV_ON_PED_LOOK_TRIGGER_END() { return invoke<Any>(0x360B2C36); } // unused
	static Any SEV_ON_PED_TASK_STARTED() { return invoke<Any>(0x298AEAB1); } // unused
	static Any SEV_ON_PED_TASK_FINISHED(Any p0, Any p1) { return invoke<Any>(0xF50C10DC, p0, p1); }
	static Any SEV_ON_ANY_PED_JOINED_NETGAME() { return invoke<Any>(0x04C3C6D6); }
	static Any SEV_ON_ANY_PED_LEFT_NETGAME() { return invoke<Any>(0xABA66068); }
	static Any _0x4B19168C() { return invoke<Any>(0x4B19168C); }
	static Any SEV_ON_PED_ENTERED_VEHICLE() { return invoke<Any>(0x93DAACB5); } // unused
	static Any SEV_ON_PED_LEFT_VEHICLE() { return invoke<Any>(0xA70DCA9C); } // unused
	static Any SEV_ON_PED_LMS_ACTIVATED(Any p0) { return invoke<Any>(0x48AFCC46, p0); }
	static Any SEV_ON_PED_LMS_DEACTIVATED(Any p0) { return invoke<Any>(0x0D198A2D, p0); }
	static Any SEV_ON_ANY_VEHICLE_CREATED() { return invoke<Any>(0x0BFEF843); } // unused
	static Any SEV_ON_VEHICLE_CREATED() { return invoke<Any>(0xE6097F09); } // unused
	static Any SEV_ON_VEHICLE_DAMAGED() { return invoke<Any>(0x98A611A6); } // unused
	static Any SEV_ON_ANY_VEHICLE_DESTROYED() { return invoke<Any>(0xB841C0D6); } // unused
	static Any SEV_ON_VEHICLE_DESTROYED() { return invoke<Any>(0xDAF25B5E); } // unused
	static Any SEV_ON_ANY_VEHICLE_DELETED() { return invoke<Any>(0x8A6CCF05); } // unused
	static Any SEV_ON_VEHICLE_DELETED() { return invoke<Any>(0x1E04C1A2); } // unused
	static Any SEV_ON_OBJECT_DAMAGED() { return invoke<Any>(0x7F5E8AD6); } // unused
	static Any SEV_ON_TIN_CAN_COLLISION() { return invoke<Any>(0x9AB7A935); }
	static Any SEV_ON_MP_ITEM_PICKUP_ACTION(Any p0) { return invoke<Any>(0x903D285A, p0); }
	static Any SEV_ON_MP_INTERACTION_SUCCEEDED() { return invoke<Any>(0xFAF50A5C); }
	static Any SEV_ON_HOST_STATS_TABLE_VALID() { return invoke<Any>(0x8B7EA849); }
}

namespace ISEQ
{
	static void I_SEQUENCE_LOAD_DATA(char* name) { invoke<Void>(0x5DEB82E0, name); }
	static void I_SEQUENCE_SETUP(char* name, char* p1, char* p2, char* p3) { invoke<Void>(0x73701072, name, p1, p2, p3); }
	static void I_SEQUENCE_START(char* name) { invoke<Void>(0x4B7BA507, name); }
	static void I_SEQUENCE_INTERRUPT(char* name) { invoke<Void>(0xA443351D, name); } // unused
	static void I_SEQUENCE_TERMINATE(char* name) { invoke<Void>(0xE7C99C4C, name); }
	static BOOL I_SEQUENCE_QUERY_STATE(char* name, int state) { return invoke<BOOL>(0xB4FE00D1, name, state); }
	static BOOL I_SEQUENCE_QUERY_ENTITY_STATE(char* name, char* entityName, int state) { return invoke<BOOL>(0x0F931337, name, entityName, state); }
	static BOOL I_SEQUENCE_IS_LOADED(char* name) { return invoke<BOOL>(0x94DBA0E6, name); }
	static BOOL I_SEQUENCE_REGISTER_ENTITY(char* name, char* entityName, Entity entity, int entityType) { return invoke<Any>(0xB11EA6E2, name, entityName, entity, entityType); }
	static void I_SEQUENCE_UNREGISTER_ENTITY(char* name, char* entityName) { invoke<Void>(0x760F4681, name, entityName); }
	static void I_SEQUENCE_PURGE_ALL() { invoke<Void>(0x45B60B4A); }
	static void ISEQ_REQUEST(Hash hash) { invoke<Void>(0xF0E61D78, hash); }
	static void ISEQ_START(Hash hash) { invoke<Void>(0x4160F67D, hash); }
	static void ISEQ_INTERRUPT(Hash hash) { invoke<Void>(0x64CE3D43, hash); } // unused
	static void ISEQ_TERMINATE(Hash hash) { invoke<Void>(0x9B0A93E3, hash); }
	static BOOL ISEQ_QUERY_STATE(Hash hash, int state) { return invoke<BOOL>(0x64BC279E, hash, state); }
	static int ISEQ_GET_STATE(Hash hash) { return invoke<int>(0xC8599BDE, hash); }
	static BOOL ISEQ_QUERY_ENTITY_STATE(Hash hash, char* entityName, int state) { return invoke<BOOL>(0xF6526797, hash, entityName, state); }
	static float ISEQ_QUERY_ENTITY_ANIMATION_PHASE(Hash hash, char* animDict, char* animName) { return invoke<float>(0x97141177, hash, animDict, animName); }
	static BOOL ISEQ_IS_LOADED(Hash hash) { return invoke<BOOL>(0x56DDD872, hash); }
	static BOOL ISEQ_REGISTER_ENTITY(Hash hash, char* entityName, Entity entity, int entityType) { return invoke<BOOL>(0xB52B39BB, hash, entityName, entity, entityType); }
	static void ISEQ_UNREGISTER_ENTITY(Hash hash, char* entityName) { invoke<Void>(0xAE50ACF9, hash, entityName); }
	static void ISEQ_GET_NAME(int bufferSize, char* buffer, Hash hash) { invoke<Void>(0x0E066B0F, bufferSize, buffer, hash); }
	static BOOL I_SEQUENCE_DOES_EXIST(char* name) { return invoke<BOOL>(0x50983774, name); } // unused
	static BOOL ISEQ_DOES_EXIST(Hash hash) { return invoke<BOOL>(0x7AA95EAB, hash); }
}

namespace COVER
{
	static void ENABLE_GRAVITY_WELL(char* p0, char* p1, BOOL p2, BOOL p3, BOOL p4, float p5) { invoke<Void>(0x684742A6, p0, p1, p2, p3, p4, p5); }
	static void ENABLE_NORMAL_LINE(char* p0, char* p1, BOOL p2) { invoke<Void>(0x09F3B1DC, p0, p1, p2); }
	static void ENABLE_NORMAL_LINE_BY_HASH(Hash p0, Hash p1, BOOL p2) { invoke<Void>(0xF9850EDB, p0, p1, p2); }
	static void ENABLE_COVERPOINTMP3(char* p0, char* p1, BOOL p2) { invoke<Void>(0xE01B6BF0, p0, p1, p2); }
	static void ENABLE_COVERPOINTMP3_GROUP(char* p0, char* p1, BOOL p2) { invoke<Void>(0x8C161165, p0, p1, p2); } // unused
	static void ENABLE_COVERPOINTMP3_GROUP_FROM_LINE(Hash p0, Hash p1, BOOL p2) { invoke<Void>(0x36ABEF8C, p0, p1, p2); }
	static void MARK_COVERPOINTMP3_SEARCHABLE(char* p0, char* p1, BOOL p2) { invoke<Void>(0xBF75FE38, p0, p1, p2); }
	static void MARK_COVEREDGEMP3_FORCE_FACE_LEFT_ON_ENTRY(char* p0, char* p1, BOOL p2) { invoke<Void>(0xF22304B7, p0, p1, p2); } // unused
	static void MARK_COVEREDGEMP3_FORCE_FACE_RIGHT_ON_ENTRY(char* p0, char* p1, BOOL p2) { invoke<Void>(0x0388489A, p0, p1, p2); }
	static void RESET_DESTROYED_COVER() { invoke<Void>(0x656B8235); }
}

namespace DATABASE
{
	static void BIND_SCRIPT_DATABASE(char* name) { invoke<Void>(0x56D42F14, name); } // unused
	static void UNBIND_SCRIPT_DATABASE(char* name) { invoke<Void>(0xC6F9A3CD, name); } // unused
	static BOOL IS_SCRIPT_DATABASE_BOUND(char* name) { return invoke<BOOL>(0x9168F4B2, name); } // unused
	static void DB_INSERT_INT(char* name, char* entryName, int value) { invoke<Void>(0x948427BA, name, entryName, value); } // unused
	static void DB_INSERT_FLOAT(char* name, char* entryName, float value) { invoke<Void>(0x093EDC0A, name, entryName, value); } // unused
	static void DB_INSERT_BOOL(char* name, char* entryName, BOOL value) { invoke<Void>(0x21DC485C, name, entryName, value); } // unused
	static void DB_DELETE_INT(char* name, char* entryName) { invoke<Void>(0x4EDB2D6B, name, entryName); } // unused
	static void DB_DELETE_FLOAT(char* name, char* entryName) { invoke<Void>(0xC2872F67, name, entryName); } // unused
	static void DB_DELETE_BOOL(char* name, char* entryName) { invoke<Void>(0x7487EDE0, name, entryName); } // unused
	static void DB_SET_INT(char* name, char* entryName, int value) { invoke<Void>(0x55C238F1, name, entryName, value); } // unused
	static void DB_SET_FLOAT(char* name, char* entryName, float value) { invoke<Void>(0x2495C847, name, entryName, value); } // unused
	static void DB_SET_BOOL(char* name, char* entryName, BOOL value) { invoke<Void>(0x5557AA76, name, entryName, value); } // unused
	static int DB_GET_INT(char* name, char* entryName) { return invoke<int>(0xC7A9D359, name, entryName); } // unused
	static float DB_GET_FLOAT(char* name, char* entryName) { return invoke<float>(0x7315F901, name, entryName); } // unused
	static BOOL DB_GET_BOOL(char* name, char* entryName) { return invoke<BOOL>(0x7195DC58, name, entryName); } // unused
	static BOOL DB_IS_INT_VALID(char* name, char* entryName) { return invoke<BOOL>(0x0206CC15, name, entryName); } // unused
	static BOOL DB_IS_FLOAT_VALID(char* name, char* entryName) { return invoke<BOOL>(0x85027555, name, entryName); } // unused
	static BOOL DB_IS_BOOL_VALID(char* name, char* entryName) { return invoke<BOOL>(0x991BC5CF, name, entryName); } // unused
}

namespace PHYSICS
{
	static Rope ADD_ROPE(Vector3* coords, Vector3* rot, float length, int ropeType) { return invoke<Rope>(0xA592EC74, coords, rot, length, ropeType); } // unused
	static void DELETE_ROPE(Rope* rope) { invoke<Void>(0x748D72AF, rope); } // unused
	static void BREAK_ROPE(Rope* rope, int* p1, int* p2, float p3, float p4) { invoke<Void>(0xA5691881, rope, p1, p2, p3, p4); } // unused
	static void PIN_ROPE_VERTEX(Rope rope, int vertex, Vector3* coords) { invoke<Void>(0xAE1D101B, rope, vertex, coords); } // unused
	static void UNPIN_ROPE_VERTEX(Rope rope, int vertex) { invoke<Void>(0xB30B552F, rope, vertex); } // unused
	static int GET_ROPE_VERTEX_COUNT(Rope rope) { return invoke<int>(0x5131CD2C, rope); } // unused
	static void ATTACH_OBJECTS_TO_ROPE(Rope rope, Object object1, Object object2, Vector3* offset1, Vector3* offset2, float p5, int p6, int p7) { invoke<Void>(0xFCE5C3CF, rope, object1, object2, offset1, offset2, p5, p6, p7); } // unused
	static void ATTACH_OBJECT_VEHICLE_TO_ROPE(Rope rope, Object object, Vehicle vehicle, Vector3* offset1, Vector3* offset2, float p5, int p6, int p7) { invoke<Void>(0x81F6E920, rope, object, vehicle, offset1, offset2, p5, p6, p7); } // unused
	static void ATTACH_VEHICLES_TO_ROPE(Rope rope, Vehicle vehicle1, Vehicle vehicle2, Vector3* offset1, Vector3* offset2, float p5, int p6, int p7) { invoke<Void>(0xA21BCE5F, rope, vehicle1, vehicle2, offset1, offset2, p5, p6, p7); } // unused
	static void ATTACH_ROPE_TO_OBJECT(Rope rope, Object object, Vector3* offset, int p3) { invoke<Void>(0x611D5E90, rope, object, offset, p3); } // unused
	static void DETACH_ROPE_FROM_OBJECT(Rope rope, Object object) { invoke<Void>(0x32C45586, rope, object); } // unused
	static void ROPE_SET_COLLISION_FLAGS(Rope rope, int flags1, int flags2) { invoke<Void>(0x5AE8C8E0, rope, flags1, flags2); } // unused
	static void SET_HIGH_RAGDOLL_LOD_LIMIT(int limit) { invoke<Void>(0x8E88A11B, limit); }
	static void SET_HIGH_RAGDOLL_LOD_LIMIT_TO_DEFAULT() { invoke<Void>(0xB6E56387); }
}

namespace DEATHRECORD
{
	static void NETWORK_ENABLE_ASSIST_XP(BOOL toggle) { invoke<Void>(0x69E75430, toggle); }
	static int DEATHRECORD_GET_NUM_KILLERS() { return invoke<int>(0x6DE9B0D2); }
	static void DEATHRECORD_GET_SUB_KILLER_NAME(int bufferSize, char* buffer, int p2) { invoke<Void>(0xE57A1FF2, bufferSize, buffer, p2); } // unused
	static Any DEATHRECORD_GET_SUB_KILLER_PLAYER_INDEX(Any p0) { return invoke<Any>(0x403EB684, p0); }
	static Any DEATHRECORD_GET_SUB_KILLER_PRIMARY() { return invoke<Any>(0x1885BC2D); } // unused
	static Any DEATHRECORD_GET_SUB_KILLER_SECONDARY() { return invoke<Any>(0x977DD5B6); } // unused
	static Any DEATHRECORD_GET_SUB_KILLER_PERCENT() { return invoke<Any>(0x664EC0F1); } // unused
	static Any DEATHRECORD_GET_SUB_KILLER_RANK() { return invoke<Any>(0x104186FD); } // unused
	static Any DEATHRECORD_ENABLE_ASSIST_XP() { return invoke<Any>(0x7B57BCB4); } // unused
	static void DEATHRECORD_CLEAR(int index) { invoke<Void>(0xFA6E6250, index); }
	static void DEATHRECORD_CLEAR_ALL() { invoke<Void>(0x758D584E); } // unused
	static Any DEATHRECORD_GET_NUM_SHOTS(Any p0) { return invoke<Any>(0x2440E150, p0); }
	static Any DEATHRECORD_GET_SHOT_INJURER(Any p0, Any p1) { return invoke<Any>(0xFECD86FE, p0, p1); }
	static Any DEATHRECORD_GET_SHOT_COMPONENT(Any p0, Any p1) { return invoke<Any>(0x627DC94C, p0, p1); }
	static Any DEATHRECORD_GET_SHOT_WEAPON(Any p0, Any p1) { return invoke<Any>(0x2EE4D113, p0, p1); }
	static Any DEATHRECORD_GET_SHOT_DAMAGE(Any p0, Any p1) { return invoke<Any>(0x3C46098C, p0, p1); }
	static Any DEATHRECORD_GET_SHOT_BULLETCOUNT(Any p0, Any p1) { return invoke<Any>(0x64D92447, p0, p1); }
	static Any DEATHRECORD_GET_SHOT_TIME(Any p0, Any p1) { return invoke<Any>(0x0F1CC37C, p0, p1); }
	static Any DEATHRECORD_GET_SHOT_FROM() { return invoke<Any>(0x56969A61); } // unused
	static Any DEATHRECORD_GET_SHOT_FLAGS() { return invoke<Any>(0x58F142F7); } // unused
	static Any DEATHRECORD_GET_SHOT_IS_CURRENT_LIFE(Any p0, Any p1) { return invoke<Any>(0xF2CD43F4, p0, p1); }
	static int DEATHRECORD_GET_NUM_RECORDS(int index) { return invoke<int>(0x8A3C385E, index); } // unused
	static Any DEATHRECORD_GET_RECORD_INJURER() { return invoke<Any>(0x15AD04A8); } // unused
	static Any DEATHRECORD_GET_RECORD_COMPONENT() { return invoke<Any>(0x3206476F); } // unused
	static Any DEATHRECORD_GET_RECORD_WEAPON() { return invoke<Any>(0x109F9168); } // unused
	static Any DEATHRECORD_GET_RECORD_DAMAGE() { return invoke<Any>(0x6E4BAE71); } // unused
	static Any DEATHRECORD_GET_RECORD_BULLETCOUNT() { return invoke<Any>(0x32DF7A7C); } // unused
	static Any DEATHRECORD_GET_RECORD_TIME() { return invoke<Any>(0x43885806); } // unused
	static Any DEATHRECORD_GET_RECORD_FROM() { return invoke<Any>(0x299D7260); } // unused
	static Any DEATHRECORD_GET_RECORD_FLAGS() { return invoke<Any>(0x6757C77E); } // unused
	static Any DEATHRECORD_GET_RECORD_IS_CURRENT_LIFE() { return invoke<Any>(0x856DC911); } // unused
	static void EXPERIENCE_SET_XP_PER_INJURY(int p0, int index, int value) { invoke<Void>(0x21C0A6F5, p0, index, value); } // unused
	static void EXPERIENCE_CLEAR_XP_PER_INJURY() { invoke<Void>(0x296B9C65); }
	static void EXPERIENCE_SET_POINT_PER_INJURY(int p0, int index, int value) { invoke<Void>(0x3FE362FC, p0, index, value); }
	static void EXPERIENCE_CLEAR_POINT_PER_INJURY() { invoke<Void>(0x04BD7929); }
	static Any GET_LAST_SHOT_BY_PLAYER(Any p0) { return invoke<Any>(0x9D48CB92, p0); } // unused
	static Any GET_LAST_SHOT_TO_PLAYER(Any p0) { return invoke<Any>(0x1279C3D4, p0); } // unused
	static void DEATHRECORDS_GET_PLAYERDETAILS_NAME(int bufferSize, char* buffer, int index) { invoke<Void>(0x9F80529A, bufferSize, buffer, index); } // unused
	static Any DEATHRECORDS_GET_PLAYERDETAILS_CLANTAG() { return invoke<Any>(0x5D9852F1); } // unused
	static Any DEATHRECORDS_GET_PLAYERDETAILS_TITLE() { return invoke<Any>(0xC0E77C55); } // unused
	static void DEATHRECORDS_CLEAR_KILLSHOTDATA() { invoke<Void>(0x1A7995E3); } // unused
	static BOOL _0x6A70F177(int index, Hash p1, int p2) { return invoke<BOOL>(0x6A70F177, index, p1, p2); }
}

namespace NETWORK_LEVEL_DATA
{
	static void NETWORK_REQUIRE_LEVEL_DATA(char* name) { invoke<Void>(0x378BA5C8, name); } // unused
	static void NETWORK_DUMP_LEVEL_DATA() { invoke<Void>(0x987381E7); } // unused
	static int NETWORK_LEVEL_DATA_GET_NUM_NODES(char* name) { return invoke<int>(0xD0FD0BA0, name); } // unused
	static Any NETWORK_LEVEL_DATA_GET_NODE() { return invoke<Any>(0x1D710204); } // unused
	static Any NETWORK_LEVEL_DATA_GET_NODE_FROM_NODE(Any p0, Any p1) { return invoke<Any>(0x78598AC7, p0, p1); }
	static Any NETWORK_LEVEL_DATA_GET_NUM_NODES_FROM_NODE(Any p0, Any p1) { return invoke<Any>(0xC208F633, p0, p1); }
	static Any NETWORK_LEVEL_DATA_GET_SIBLING_COUNT_AFTER_NODE(Any p0) { return invoke<Any>(0xD8F9D0B0, p0); }
	static Any NETWORK_LEVEL_DATA_GET_HASH() { return invoke<Any>(0x758DEB4D); } // unused
	static Any NETWORK_LEVEL_DATA_GET_HASH_FROM_NODE(Any p0, Any p1, Any p2) { return invoke<Any>(0xA0DF848C, p0, p1, p2); }
	static Any NETWORK_LEVEL_DATA_GET_STRING() { return invoke<Any>(0xCF99AF2B); } // unused
	static Any NETWORK_LEVEL_DATA_GET_STRING_FROM_NODE(Any p0, Any p1, Any p2, Any p3) { return invoke<Any>(0x1AB1ED65, p0, p1, p2, p3); }
	static Any NETWORK_LEVEL_DATA_GET_INT() { return invoke<Any>(0x05D7A7AD); } // unused
	static Any NETWORK_LEVEL_DATA_GET_INT_FROM_NODE(Any p0, Any p1, Any p2) { return invoke<Any>(0xEDA5D3AA, p0, p1, p2); }
	static Any NETWORK_LEVEL_DATA_GET_FLOAT() { return invoke<Any>(0x4EF6A91C); } // unused
	static Any NETWORK_LEVEL_DATA_GET_FLOAT_FROM_NODE(Any p0, Any p1, Any p2) { return invoke<Any>(0x0CA92A56, p0, p1, p2); }
	static Any NETWORK_LEVEL_DATA_GET_VECTOR() { return invoke<Any>(0x532EBA1B); } // unused
	static Any NETWORK_LEVEL_DATA_GET_VECTOR_FROM_NODE(Any p0, Any p1, Any p2) { return invoke<Any>(0x9209CE38, p0, p1, p2); }
	static Any NETWORK_LEVEL_DATA_GET_BOOL() { return invoke<Any>(0x282E20CB); } // unused
	static Any NETWORK_LEVEL_DATA_GET_BOOL_FROM_NODE(Any p0, Any p1, Any p2) { return invoke<Any>(0xC5F02A7E, p0, p1, p2); }
	static BOOL NETWORK_REQUIRE_STORED_QUERIES(char* fileName) { return invoke<BOOL>(0x1C183BC8, fileName); }
	static void NETWORK_DUMP_STORED_QUERIES() { invoke<Void>(0x53B6E465); }
	static Any NETWORK_LEVEL_DATA_RUN_STORED_QUERY_NODE(Any p0, Any p1, Any p2, Any p3) { return invoke<Any>(0xEE658568, p0, p1, p2, p3); }
	static Any NETWORK_LEVEL_DATA_RUN_STORED_QUERY_COUNT(Any p0, Any p1, Any p2, Any p3) { return invoke<Any>(0x7F3DAF76, p0, p1, p2, p3); }
	static Any NETWORK_LEVEL_DATA_RUN_STORED_QUERY_STRING(Any p0, Any p1, Any p2, Any p3, Any p4, Any p5) { return invoke<Any>(0x9DF1E416, p0, p1, p2, p3, p4, p5); }
	static Any NETWORK_LEVEL_DATA_RUN_STORED_QUERY_VECTOR() { return invoke<Any>(0xAC9F6193); } // unused
	static Any NETWORK_LEVEL_DATA_RUN_STORED_QUERY_FLOAT() { return invoke<Any>(0x7CBE1FD2); } // unused
	static Any NETWORK_LEVEL_DATA_RUN_STORED_QUERY_INT(Any p0, Any p1, Any p2, Any p3, Any p4) { return invoke<Any>(0x4DAE6959, p0, p1, p2, p3, p4); }
	static Any NETWORK_LEVEL_DATA_RUN_STORED_QUERY_HASH(Any p0, Any p1, Any p2, Any p3, Any p4) { return invoke<Any>(0x776215C9, p0, p1, p2, p3, p4); }
	static Any NETWORK_LEVEL_DATA_RUN_STORED_QUERY_BOOL() { return invoke<Any>(0x8DB64921); } // unused
}



# 65 "C:\\Users\\USER\\Documents\\Visual Studio 2013\\Projects\\mp3_plugin_PS3\\mp3_plugin_PS3\\main.cpp"
# 1 "C:\\Users\\USER\\Documents\\Visual Studio 2013\\Projects\\mp3_plugin_PS3\\mp3_plugin_PS3\\nativeMemory.h"
uint32_t* getGlobalPtr(int globalId)
{

	return 0;
}

uint8_t* getBlipAddress(Blip blip)
{

	return 0;
}
uint8_t* getInteriorAddress(Interior interior)
{

	return 0;
}
uint8_t* getObjectAddress(Object object)
{

	return 0;
}
uint8_t* getPedAddress(Ped ped)
{

	return 0;
}
uint8_t* getVehicleAddress(Vehicle vehicle)
{

	return 0;
}

int worldGetAllBlips(Blip* arr, int arrSize)
{

	return 0;
}
int worldGetAllInteriors(Interior* arr, int arrSize)
{

	return 0;
}
int worldGetAllObjects(Object* arr, int arrSize)
{

	return 0;
}
int worldGetAllPeds(Ped* arr, int arrSize)
{

	return 0;
}
int worldGetAllVehicles(Vehicle* arr, int arrSize)
{

	return 0;
}
# 66 "C:\\Users\\USER\\Documents\\Visual Studio 2013\\Projects\\mp3_plugin_PS3\\mp3_plugin_PS3\\main.cpp"
# 1 "C:\\Users\\USER\\Documents\\Visual Studio 2013\\Projects\\mp3_plugin_PS3\\mp3_plugin_PS3\\script.h"
inline uint32_t HashString(char* string)
{
	uint32_t hash = 0;

	for (; *string; ++string)
	{
		hash += _sys_tolower(*string);
		hash += (hash << 10);
		hash ^= (hash >> 6);
	}

	hash += (hash << 3);
	hash ^= (hash >> 11);
	hash += (hash << 15);

	return hash;
}

inline uint16_t GetEntityBoneNameHash(char* boneName)
{
	uint32_t hash = 0;

	for (; *boneName; ++boneName)
	{
		hash = _sys_toupper(*boneName) + 16 * hash;
		if (hash & 0xF0000000)
			hash ^= hash & 0xF0000000 ^ ((hash & 0xF0000000) >> 24);
	}

	return hash % 0xFE8F + 0x170;
}

static const char* weaponNames[] = {
	"VEHICLE_WEAPON_CAVEIRAO_GUN",
	"VEHICLE_WEAPON_CAVEIRAO_VAR_GUN",
	"VEHICLE_WEAPON_DUNE",
	"VEHICLE_WEAPON_HIND_GUN",
	"VEHICLE_WEAPON_HIND_ROCKET",
	"VEHICLE_WEAPON_TANK",
	"WEAPON_AMMO_BAG",
	"WEAPON_BEANBAG_LAUNCHER",
	"WEAPON_BLEEDOUT",
	"WEAPON_BOOBYTRAP",
	"WEAPON_C4",
	"WEAPON_C4_DETONATOR",
	"WEAPON_CATTLE_PROD",
	"WEAPON_CRUSH",
	"WEAPON_DROWNING",
	"WEAPON_DROWNING_IN_VEHICLE",
	"WEAPON_EXPLOSION",
	"WEAPON_FALL",
	"WEAPON_GRENADE_LAUNCHER",
	"WEAPON_GRENADE_LAUNCHER_BECKER",
	"WEAPON_GRENADE_LAUNCHER_FINALE",
	"WEAPON_GRENADE_LAUNCHER_G9",
	"WEAPON_HIT_BY_WATER_CANNON",
	"WEAPON_LAW",
	"WEAPON_MG_21E",
	"WEAPON_MG_RPD",
	"WEAPON_MONEY_BAG",
	"WEAPON_MP_BAG",
	"WEAPON_NIGHT_STICK",
	"WEAPON_PEPPER_SPRAY",
	"WEAPON_PISTOL_38",
	"WEAPON_PISTOL_BROWNING",
	"WEAPON_PISTOL_BROWNING_SILENCED",
	"WEAPON_PISTOL_COLT1911",
	"WEAPON_PISTOL_DEAGLE",
	"WEAPON_PISTOL_GLOCK18",
	"WEAPON_PISTOL_PT92",
	"WEAPON_PISTOL_PT92_BOTTLE",
	"WEAPON_PISTOL_TAURUS608",
	"WEAPON_RAMMED_BY_CAR",
	"WEAPON_RIFLE_97LC",
	"WEAPON_RIFLE_AK47",
	"WEAPON_RIFLE_AK47_UNDERBARREL_GRENADE",
	"WEAPON_RIFLE_FAL",
	"WEAPON_RIFLE_FAL_RUBBER",
	"WEAPON_RIFLE_G36K",
	"WEAPON_RIFLE_GALIL",
	"WEAPON_RIFLE_IA2",
	"WEAPON_RIFLE_L1A1",
	"WEAPON_RIFLE_L1A1_GRENADE",
	"WEAPON_RIFLE_M4",
	"WEAPON_RIFLE_RUG30",
	"WEAPON_RIFLE_RUG30_HELI",
	"WEAPON_RIFLE_TAR",
	"WEAPON_RIOT_SHIELD",
	"WEAPON_RPG",
	"WEAPON_RUN_OVER_BY_CAR",
	"WEAPON_SHOTGUN",
	"WEAPON_SHOTGUN_BENELLIM3",
	"WEAPON_SHOTGUN_DOUBLEBARREL",
	"WEAPON_SHOTGUN_HAMMERHEAD",
	"WEAPON_SHOTGUN_MOSSBERG590",
	"WEAPON_SHOTGUN_SPAS12",
	"WEAPON_SHOTGUN_SPAS15",
	"WEAPON_SHOTGUN_WINCHESTERSX3",
	"WEAPON_SMG_FAMAEMT40",
	"WEAPON_SMG_MAC10",
	"WEAPON_SMG_MP5",
	"WEAPON_SMG_MP5_UNDERBARREL_GRENADE",
	"WEAPON_SMG_PM12",
	"WEAPON_SMG_SKORPION",
	"WEAPON_SMG_UZI",
	"WEAPON_SNIPER_ENFORCER",
	"WEAPON_SNIPER_M24",
	"WEAPON_SNIPER_M82",
	"WEAPON_SNIPER_SG1",
	"WEAPON_SPEARGUN",
	"WEAPON_STINGER",
	"WEAPON_STUN_GUN",
	"WEAPON_TASER",
	"WEAPON_THROWN_BOUNCING_BETTY",
	"WEAPON_THROWN_FLASH",
	"WEAPON_THROWN_GRENADE",
	"WEAPON_THROWN_GRENADE_SCRIPT",
	"WEAPON_THROWN_GRENADE_SMALL",
	"WEAPON_THROWN_INCENDIARY",
	"WEAPON_THROWN_INCENDIARY_FAST",
	"WEAPON_THROWN_INCENDIARY_MP",
	"WEAPON_THROWN_SMOKE",
	"WEAPON_THROWN_TEAR_GAS",
	"WEAPON_THROWN_TEAR_GAS_INF",
	"WEAPON_THROWN_TIN_CAN",
	"WEAPON_THROWN_TRIPWIRE",
	"WEAPON_TRAM_TEAR_GAS",
	"WEAPON_UNARMED",
	"WEAPON_XMG_21E",
	"WEAPON_XPISTOL_DUMMY",
	"WEAPON_XRIFLE_97LC",
	"WEAPON_XRIFLE_RUG30",
	"WEAPON_XRPG",
	"WEAPON_XSMG_MAC10",
	"WEAPON_XSMG_PM12",
	"WEAPON_XSNIPER_DUMMY"
};

static const char* weatherTypeNames[] = {
	"EXTRASUNNY",
	"SUNNY",
	"SUNNY_WINDY",
	"CLOUDY",
	"FOGGY",
	"DRIZZLE",
	"RAIN",
	"STORMY"
};

static const char* unlockSemantics[] = {
	"16BIT_MAX",
	"1HITKILL",
	"ASSOC",
	"AVATAR_CUST_UL",
	"AVATAR_SLOT_AWODEN_HR",
	"AVATAR_SLOT_BACHMEYER",
	"AVATAR_SLOT_BAD_DAY_BECKER",
	"AVATAR_SLOT_BG_PASSOS",
	"AVATAR_SLOT_CLAUDIO",
	"AVATAR_SLOT_COMANDO_SOMBRE_F",
	"AVATAR_SLOT_COMANDO_SOMBRE_M",
	"AVATAR_SLOT_CRACHA_PRETO_F",
	"AVATAR_SLOT_CRACHA_PRETO_M",
	"AVATAR_SLOT_DE_MARCOS_F",
	"AVATAR_SLOT_DE_MARCOS_M",
	"AVATAR_SLOT_DR_FISCHER",
	"AVATAR_SLOT_FABIANA",
	"AVATAR_SLOT_FDO_F",
	"AVATAR_SLOT_FDO_M",
	"AVATAR_SLOT_GIOVANNA_BUS",
	"AVATAR_SLOT_IT_GUY",
	"AVATAR_SLOT_JACK_LUP_HR",
	"AVATAR_SLOT_MARCELO_YACHT",
	"AVATAR_SLOT_MAX_BOOZE_PILLS",
	"AVATAR_SLOT_MAX_PAYNE1_HR",
	"AVATAR_SLOT_MILO",
	"AVATAR_SLOT_MONA_SAX_HR",
	"AVATAR_SLOT_MP2_HR",
	"AVATAR_SLOT_NIC_HORNE_HR",
	"AVATAR_SLOT_NYBAR_GIRL",
	"AVATAR_SLOT_PASSOS_DOCKS",
	"AVATAR_SLOT_PASSOS_NY",
	"AVATAR_SLOT_PASSOS_PILOT",
	"AVATAR_SLOT_PUNCHINELLOS_F",
	"AVATAR_SLOT_PUNCHINELLOS_M",
	"AVATAR_SLOT_RODRIGO_CASUAL",
	"AVATAR_SLOT_RUDY",
	"AVATAR_SLOT_SPP_F",
	"AVATAR_SLOT_SPP_M",
	"AVATAR_SLOT_STRIP_BT",
	"AVATAR_SLOT_TERCEIRO_FALANGE_F",
	"AVATAR_SLOT_TERCEIRO_FALANGE_M",
	"AVATAR_SLOT_UFE_F",
	"AVATAR_SLOT_UFE_M",
	"AVATAR_SLOT_USP_F",
	"AVATAR_SLOT_USP_M",
	"AVATAR_SLOT_VAL_WINTERSON_HR",
	"AVATAR_SLOT_VICTOR_TUX",
	"AVATAR_SLOT_VIN_GOG_HR",
	"AVATAR_SLOT_VLAD_HR",
	"AVATAR_SLOT_YCHT_F",
	"AVATAR_SLOT_YCHT_M",
	"AV_UL_FEMALE",
	"AV_UL_MALE",
	"BECKER_HEAD",
	"BIKER",
	"BW_MAX",
	"CAPO",
	"CLST_KID",
	"CONSIG",
	"COOLBULLETS",
	"CREW_OUTFIT_UNLOCK",
	"CREW_OUTFIT_UNLOCK_DE_MARCO_MALE",
	"CUSTOM_MAX",
	"DC_UL_LOOKOUT",
	"DEALER",
	"DEMARCO_HEAD",
	"EXPAMMO",
	"FAV_GEN",
	"FLD_COP",
	"FTBALL",
	"GRINDS",
	"HEADSHOTSONLY",
	"HPREGEN",
	"INCAMMO",
	"INFAMMO",
	"INFBT",
	"INFPAYNEKILLERS",
	"INVISIBLE_UNLOCK",
	"IS_UL_CHEST",
	"IS_UL_GEAR_ONE",
	"IS_UL_GEAR_THREE",
	"IS_UL_GEAR_TWO",
	"IS_UL_HEAD",
	"LEVEL1GRIND",
	"LEVEL2GRIND",
	"LEVEL3GRIND",
	"LOADOUT_SLOT_1",
	"LOADOUT_SLOT_2",
	"LOADOUT_SLOT_3",
	"LOADOUT_SLOT_4",
	"LOADOUT_SLOT_5",
	"LOADOUT_WEIGHT_16",
	"LOADOUT_WEIGHT_17",
	"LOADOUT_WEIGHT_18",
	"LOADOUT_WEIGHT_19",
	"LOADOUT_WEIGHT_20",
	"LOADOUT_WEIGHT_21",
	"LOADOUT_WEIGHT_22",
	"LOADOUT_WEIGHT_23",
	"LOADOUT_WEIGHT_24",
	"LOADOUT_WEIGHT_25",
	"LOADOUT_WEIGHT_26",
	"LONEWOLF",
	"LOOKOUT",
	"LOWAMMO",
	"MAX_HEAD",
	"MAX_LEG1",
	"MAX_LEG10",
	"MAX_LEG10",
	"MAX_LEG2",
	"MAX_LEG3",
	"MAX_LEG4",
	"MAX_LEG5",
	"MAX_LEG6",
	"MAX_LEG6",
	"MAX_LEG7",
	"MAX_LEG7",
	"MAX_LEG8",
	"MAX_LEG8",
	"MAX_LEG9",
	"MAX_LEG9",
	"MOB_MEET",
	"MOON_DET",
	"MUGGER_HEAD",
	"NEVES_HEAD",
	"NGHT_OUT",
	"NOIREMODE",
	"OLSKLARCADE",
	"PATCH_1",
	"PATCH_2",
	"PATCH_3",
	"PATCH_4",
	"PL_UL_DLC",
	"PL_UL_DM_HCL",
	"PL_UL_DM_HL",
	"PL_UL_DM_ML",
	"PL_UL_DM_TF",
	"PL_UL_DM_TL",
	"PL_UL_GSTOP_FR",
	"PL_UL_GSTOP_LK",
	"PL_UL_GWS_H",
	"PL_UL_GWS_HC",
	"PL_UL_GWS_M",
	"PL_UL_LMS_H",
	"PL_UL_LMS_M",
	"PL_UL_PK_H",
	"PL_UL_PK_M",
	"PL_UL_SDM_FA",
	"PL_UL_SDM_SL",
	"PL_UL_STDM_FA",
	"PL_UL_STDM_SL",
	"PL_UL_TDM_HCL",
	"PL_UL_TDM_HL",
	"PL_UL_TDM_ML",
	"PL_UL_TDM_TF",
	"PL_UL_TDM_TL",
	"PRESTIGE_UP",
	"PUNCH_HEAD",
	"REPLAY_A1",
	"REPLAY_A10",
	"REPLAY_A11",
	"REPLAY_A12",
	"REPLAY_A13",
	"REPLAY_A14",
	"REPLAY_A15",
	"REPLAY_A16",
	"REPLAY_A17",
	"REPLAY_A18",
	"REPLAY_A19",
	"REPLAY_A2",
	"REPLAY_A20",
	"REPLAY_A21",
	"REPLAY_A22",
	"REPLAY_A23",
	"REPLAY_A24",
	"REPLAY_A25",
	"REPLAY_A26",
	"REPLAY_A27",
	"REPLAY_A28",
	"REPLAY_A29",
	"REPLAY_A3",
	"REPLAY_A30",
	"REPLAY_A4",
	"REPLAY_A5",
	"REPLAY_A6",
	"REPLAY_A7",
	"REPLAY_A8",
	"REPLAY_A9",
	"REPLAY_B1",
	"REPLAY_B10",
	"REPLAY_B11",
	"REPLAY_B12",
	"REPLAY_B13",
	"REPLAY_B14",
	"REPLAY_B15",
	"REPLAY_B16",
	"REPLAY_B17",
	"REPLAY_B18",
	"REPLAY_B19",
	"REPLAY_B2",
	"REPLAY_B20",
	"REPLAY_B21",
	"REPLAY_B22",
	"REPLAY_B23",
	"REPLAY_B24",
	"REPLAY_B25",
	"REPLAY_B26",
	"REPLAY_B27",
	"REPLAY_B28",
	"REPLAY_B29",
	"REPLAY_B3",
	"REPLAY_B30",
	"REPLAY_B4",
	"REPLAY_B5",
	"REPLAY_B6",
	"REPLAY_B7",
	"REPLAY_B8",
	"REPLAY_B9",
	"REPLAY_C1",
	"REPLAY_C10",
	"REPLAY_C11",
	"REPLAY_C12",
	"REPLAY_C13",
	"REPLAY_C14",
	"REPLAY_C15",
	"REPLAY_C16",
	"REPLAY_C17",
	"REPLAY_C18",
	"REPLAY_C19",
	"REPLAY_C2",
	"REPLAY_C20",
	"REPLAY_C21",
	"REPLAY_C22",
	"REPLAY_C23",
	"REPLAY_C24",
	"REPLAY_C25",
	"REPLAY_C26",
	"REPLAY_C27",
	"REPLAY_C28",
	"REPLAY_C29",
	"REPLAY_C3",
	"REPLAY_C30",
	"REPLAY_C4",
	"REPLAY_C5",
	"REPLAY_C6",
	"REPLAY_C7",
	"REPLAY_C8",
	"REPLAY_C9",
	"SC_MEMBER_PLAYLIST",
	"SERRANO_HEAD",
	"SPCL_OP",
	"SPP_DASILVA_HEAD",
	"SPP_MAX_PAYNE_HEAD",
	"TZ_DJ",
	"T_UL_15_CORONEL",
	"T_UL_1_SARGENTO",
	"T_UL_1_TENENTE",
	"T_UL_2_SARGENTO",
	"T_UL_2_TENENTE",
	"T_UL_3_SARGENTO",
	"T_UL_3_TENENTE",
	"T_UL_9_LIVES",
	"T_UL_AMBIDEXTROUS",
	"T_UL_ASPIRANTE",
	"T_UL_BULLETPROOF",
	"T_UL_CABO",
	"T_UL_CADETE",
	"T_UL_CAPTAIN",
	"T_UL_CHIEF",
	"T_UL_CHIEF",
	"T_UL_COMMANDO",
	"T_UL_DEADEYE",
	"T_UL_DEDICATED",
	"T_UL_DEFENDER",
	"T_UL_DIFFUSER",
	"T_UL_DIVE_BOMBER",
	"T_UL_DOCTOR",
	"T_UL_DOMINATOR",
	"T_UL_DUALIST",
	"T_UL_EXECUTIONER",
	"T_UL_FEARLESS",
	"T_UL_FUGITIVE",
	"T_UL_GATE_CRASHER",
	"T_UL_GLADIATOR",
	"T_UL_GOLDEN",
	"T_UL_GOLDEN",
	"T_UL_GRIM_REAPER",
	"T_UL_GUN_COLLECTOR",
	"T_UL_HARD_KNUCKLED",
	"T_UL_HEAD_OF_CLASS",
	"T_UL_HIGHSTRUNG",
	"T_UL_INDOMIDABLE",
	"T_UL_INVISIBLE",
	"T_UL_JUGGERNAUT",
	"T_UL_KLEPTO",
	"T_UL_K_CAPPER",
	"T_UL_LIGHTNING",
	"T_UL_LIVINGLEGEND",
	"T_UL_LUCKY",
	"T_UL_MAJOR",
	"T_UL_MARKED",
	"T_UL_MARKED",
	"T_UL_MASTER_OF_ARMS",
	"T_UL_MONEYBAGS",
	"T_UL_NINJA",
	"T_UL_ONE_MAN_ARMY",
	"T_UL_OT_SPOT",
	"T_UL_PACKRAT",
	"T_UL_PATIENT",
	"T_UL_PEERLESS",
	"T_UL_PEERLESS",
	"T_UL_PLAYBOY",
	"T_UL_POSTMASTER",
	"T_UL_PYRO",
	"T_UL_QUATERMASTER",
	"T_UL_RENOWNED",
	"T_UL_RESPECTED",
	"T_UL_SLIPPERY",
	"T_UL_SMOKEY",
	"T_UL_SNAKE",
	"T_UL_SOLDADO",
	"T_UL_SPEEDY",
	"T_UL_SPOTTER",
	"T_UL_STEAMROLLER",
	"T_UL_SUB_TENETE",
	"T_UL_SURESHOT",
	"T_UL_SURVIVALIST",
	"T_UL_SURVIVOR",
	"T_UL_TACTITIAN",
	"T_UL_THEFEARED",
	"T_UL_TRUSTWORTHY",
	"T_UL_UNRIVALED",
	"T_UL_UNRIVALED",
	"T_UL_UNSTOPBLE",
	"T_UL_VENGEFUL",
	"T_UL_WARLORD",
	"T_UL_WAR_CRIMINAL",
	"T_UL_X_RAY",
	"UFE_CMBT_SPPT",
	"UL_ARMOUR_BOMB_SUIT",
	"UL_ARMOUR_HEAVY",
	"UL_ARMOUR_HELMET",
	"UL_ARMOUR_HELMET_HEAVY",
	"UL_ARMOUR_MAX",
	"UL_ARMOUR_STANDARD",
	"UL_BADGEOFHONOR",
	"UL_BOOBY_TRAP",
	"UL_DLC_3_PACK",
	"UL_GAS_MASK",
	"UL_HOLLOWPOINTS",
	"UL_IDCARD",
	"UL_LMS_BT_ACTIVATOR",
	"UL_MANUFACTURER_GUARANTEE",
	"UL_MAX_PRESTIGE_LEVEL",
	"UL_MILITARY_GOGGLES",
	"UL_MP_SPECIAL_AMMO_HOOVER",
	"UL_MP_SPECIAL_AMMO_POUCH",
	"UL_MP_SPECIAL_ANTISTUNGUN",
	"UL_MP_SPECIAL_BALACLAVA",
	"UL_MP_SPECIAL_BETTING_SLIP",
	"UL_MP_SPECIAL_BOUNTY_ORDERS",
	"UL_MP_SPECIAL_CALCULATOR",
	"UL_MP_SPECIAL_CANCERSTICKS",
	"UL_MP_SPECIAL_FIELDBANDAGES",
	"UL_MP_SPECIAL_FIREPROOF_SPRAY",
	"UL_MP_SPECIAL_HIP_FLASK",
	"UL_MP_SPECIAL_INTIMIDATION",
	"UL_MP_SPECIAL_LIGHT_FINGERS",
	"UL_MP_SPECIAL_LOCKBOX",
	"UL_MP_SPECIAL_LUCKY_COIN",
	"UL_MP_SPECIAL_PILLBOTTLE",
	"UL_MP_SPECIAL_POKERCHIP",
	"UL_MP_SPECIAL_QUICK_HOLSTER",
	"UL_MP_SPECIAL_SC_ARCANE_SKULL",
	"UL_MP_SPECIAL_SC_DEAD_SKULL",
	"UL_MP_SPECIAL_SC_DEMON_SKULL",
	"UL_MP_SPECIAL_SC_HUMAN_SKULL",
	"UL_MP_SPECIAL_SC_WEDD_SKULL",
	"UL_MP_SPECIAL_SMARTPHONE",
	"UL_MP_SPECIAL_SNIPER_DETECTOR",
	"UL_MP_SPECIAL_SPRAYCAN",
	"UL_MP_SPECIAL_STEALTH_BOOTS",
	"UL_MP_SPECIAL_STICKY_TAPE",
	"UL_MP_SPECIAL_SUTURES",
	"UL_MP_SPECIAL_TRACKINGDEVICE",
	"UL_MP_SPECIAL_WALKIE_TALKIE",
	"UL_MP_SPECIAL_WRESTLEMASK",
	"UL_MP_STREAK_BB_LVL2",
	"UL_MP_STREAK_BB_LVL3",
	"UL_MP_STREAK_BIGDOG",
	"UL_MP_STREAK_BIGDOG_LVL2",
	"UL_MP_STREAK_BIGDOG_LVL3",
	"UL_MP_STREAK_BT_LVL2",
	"UL_MP_STREAK_BT_LVL3",
	"UL_MP_STREAK_BULLETTIME",
	"UL_MP_STREAK_BURSTBUBBLE",
	"UL_MP_STREAK_DEATHSQUAD",
	"UL_MP_STREAK_DEATHSQUAD_LVL2",
	"UL_MP_STREAK_DEATHSQUAD_LVL3",
	"UL_MP_STREAK_EXPLOSIVES",
	"UL_MP_STREAK_EX_LVL2",
	"UL_MP_STREAK_EX_LVL3",
	"UL_MP_STREAK_FB_LVL2",
	"UL_MP_STREAK_FB_LVL3",
	"UL_MP_STREAK_FRESHBLOOD",
	"UL_MP_STREAK_GRNDED_LVL2",
	"UL_MP_STREAK_GRNDED_LVL3",
	"UL_MP_STREAK_GROUNDED",
	"UL_MP_STREAK_HANGOVER",
	"UL_MP_STREAK_HANGOVER_LVL2",
	"UL_MP_STREAK_HANGOVER_LVL3",
	"UL_MP_STREAK_INTUITION",
	"UL_MP_STREAK_INT_LVL2",
	"UL_MP_STREAK_INT_LVL3",
	"UL_MP_STREAK_PARANOIA",
	"UL_MP_STREAK_PARANOIA_LVL2",
	"UL_MP_STREAK_PARANOIA_LVL3",
	"UL_MP_STREAK_SC_LVL2",
	"UL_MP_STREAK_SC_LVL3",
	"UL_MP_STREAK_SLIPPERYCHARACTER",
	"UL_MP_STREAK_SNEAKY",
	"UL_MP_STREAK_SNEAKY_LVL2",
	"UL_MP_STREAK_SNEAKY_LVL3",
	"UL_MP_STREAK_TRIGGERHAPPY",
	"UL_MP_STREAK_TRIGGERHAPPY_LVL2",
	"UL_MP_STREAK_TRIGGERHAPPY_LVL3",
	"UL_MP_STREAK_UNSTOPPABLE",
	"UL_MP_STREAK_UNSTOPPABLE_LVL2",
	"UL_MP_STREAK_UNSTOPPABLE_LVL3",
	"UL_MP_STREAK_WDD_LVL2",
	"UL_MP_STREAK_WDD_LVL3",
	"UL_MP_STREAK_WD_LVL2",
	"UL_MP_STREAK_WD_LVL3",
	"UL_MP_STREAK_WEAPONDEALER",
	"UL_MP_STREAK_WEAPONDOUBLEDEALER",
	"UL_PAID_DLC4",
	"UL_PAID_DLC5",
	"UL_PAID_DLC6",
	"UL_POCKETWATCH",
	"UL_PRECINCT_DLC",
	"UL_SPECIAL_EDITION",
	"UL_SWISS_ARMY_KNIFE",
	"UL_URBAN_CAMO",
	"UL_VAMPIRIC",
	"UL_WEAPON_CATTLE_PROD",
	"UL_WEAPON_GRENADE_LAUNCHER",
	"UL_WEAPON_GRENADE_LAUNCHER_G9",
	"UL_WEAPON_LAW",
	"UL_WEAPON_MG_21E",
	"UL_WEAPON_MG_RPD",
	"UL_WEAPON_NIGHT_STICK",
	"UL_WEAPON_PEPPER_SPRAY",
	"UL_WEAPON_PISTOL_38",
	"UL_WEAPON_PISTOL_COLT1911",
	"UL_WEAPON_PISTOL_DEAGLE",
	"UL_WEAPON_PISTOL_GLOCK18",
	"UL_WEAPON_PISTOL_PT92",
	"UL_WEAPON_PISTOL_TAURUS608",
	"UL_WEAPON_RIFLE_97LC",
	"UL_WEAPON_RIFLE_AK47",
	"UL_WEAPON_RIFLE_FAL",
	"UL_WEAPON_RIFLE_G36K",
	"UL_WEAPON_RIFLE_GALIL",
	"UL_WEAPON_RIFLE_IA2",
	"UL_WEAPON_RIFLE_M24",
	"UL_WEAPON_RIFLE_M4",
	"UL_WEAPON_RIFLE_RUG30",
	"UL_WEAPON_RIFLE_TAR",
	"UL_WEAPON_RPG",
	"UL_WEAPON_SHOTGUN_BENELLIM3",
	"UL_WEAPON_SHOTGUN_DOUBLEBARREL",
	"UL_WEAPON_SHOTGUN_HAMMERHEAD",
	"UL_WEAPON_SHOTGUN_MOSSBERG590",
	"UL_WEAPON_SHOTGUN_SPAS15",
	"UL_WEAPON_SHOTGUN_WINCHESTERSX3",
	"UL_WEAPON_SMG_FAMAEMT40",
	"UL_WEAPON_SMG_MAC10",
	"UL_WEAPON_SMG_MP5",
	"UL_WEAPON_SMG_PM12",
	"UL_WEAPON_SMG_UZI",
	"UL_WEAPON_SNIPER_M82",
	"UL_WEAPON_SNIPER_SG1",
	"UL_WEAPON_STUN_GUN",
	"UL_WEAPON_THROWN_BOUNCING_BETTY",
	"UL_WEAPON_THROWN_FLASH",
	"UL_WEAPON_THROWN_GRENADE",
	"UL_WEAPON_THROWN_INCENDIARY_MP",
	"UL_WEAPON_THROWN_SMOKE",
	"UL_WEAPON_THROWN_TEAR_GAS",
	"UL_WEAPON_THROWN_TIN_CAN",
	"UN_REP",
	"URBN_CMBT",
	"VENDETTAS",
	"WAGERS",
	"WEAPON_CATTLE_PROD_WEAPON_ATTACHMENT_CHROME",
	"WEAPON_CATTLE_PROD_WEAPON_ATTACHMENT_GOLD",
	"WEAPON_GRENADE_LAUNCHER_G9_WEAPON_ATTACHMENT_CHROME",
	"WEAPON_GRENADE_LAUNCHER_G9_WEAPON_ATTACHMENT_GOLD",
	"WEAPON_GRENADE_LAUNCHER_WEAPON_ATTACHMENT_CHROME",
	"WEAPON_GRENADE_LAUNCHER_WEAPON_ATTACHMENT_GOLD",
	"WEAPON_LAW_WEAPON_ATTACHMENT_CHROME",
	"WEAPON_LAW_WEAPON_ATTACHMENT_GOLD",
	"WEAPON_MG_21E_WEAPON_ATTACHMENT_BARREL_UPGRADES",
	"WEAPON_MG_21E_WEAPON_ATTACHMENT_CHROME",
	"WEAPON_MG_21E_WEAPON_ATTACHMENT_GAS_BLOCK",
	"WEAPON_MG_21E_WEAPON_ATTACHMENT_GAS_SYSTEMS",
	"WEAPON_MG_21E_WEAPON_ATTACHMENT_GOLD",
	"WEAPON_MG_21E_WEAPON_ATTACHMENT_MAG_GUIDE",
	"WEAPON_MG_RPD_WEAPON_ATTACHMENT_BARREL_UPGRADES",
	"WEAPON_MG_RPD_WEAPON_ATTACHMENT_CHROME",
	"WEAPON_MG_RPD_WEAPON_ATTACHMENT_GAS_BLOCK",
	"WEAPON_MG_RPD_WEAPON_ATTACHMENT_GAS_SYSTEMS",
	"WEAPON_MG_RPD_WEAPON_ATTACHMENT_GOLD",
	"WEAPON_MG_RPD_WEAPON_ATTACHMENT_MAG_GUIDE",
	"WEAPON_NIGHT_STICK_WEAPON_ATTACHMENT_CHROME",
	"WEAPON_NIGHT_STICK_WEAPON_ATTACHMENT_GOLD",
	"WEAPON_PEPPER_SPRAY_WEAPON_ATTACHMENT_CHROME",
	"WEAPON_PEPPER_SPRAY_WEAPON_ATTACHMENT_GOLD",
	"WEAPON_PISTOL_38_DUAL_WIELD",
	"WEAPON_PISTOL_38_WEAPON_ATTACHMENT_BARREL_UPGRADES",
	"WEAPON_PISTOL_38_WEAPON_ATTACHMENT_CHROME",
	"WEAPON_PISTOL_38_WEAPON_ATTACHMENT_COMPENSATOR",
	"WEAPON_PISTOL_38_WEAPON_ATTACHMENT_GAS_BLOCK",
	"WEAPON_PISTOL_38_WEAPON_ATTACHMENT_GOLD",
	"WEAPON_PISTOL_COLT1911_DUAL_WIELD",
	"WEAPON_PISTOL_COLT1911_WEAPON_ATTACHMENT_CHROME",
	"WEAPON_PISTOL_COLT1911_WEAPON_ATTACHMENT_COMPENSATOR",
	"WEAPON_PISTOL_COLT1911_WEAPON_ATTACHMENT_GAS_BLOCK",
	"WEAPON_PISTOL_COLT1911_WEAPON_ATTACHMENT_GAS_SYSTEMS",
	"WEAPON_PISTOL_COLT1911_WEAPON_ATTACHMENT_GOLD",
	"WEAPON_PISTOL_COLT1911_WEAPON_ATTACHMENT_HIGH_CAPACITY_CLIP",
	"WEAPON_PISTOL_COLT1911_WEAPON_ATTACHMENT_LASER_SIGHT",
	"WEAPON_PISTOL_COLT1911_WEAPON_ATTACHMENT_MAG_GUIDE",
	"WEAPON_PISTOL_COLT1911_WEAPON_ATTACHMENT_SUPPRESSOR",
	"WEAPON_PISTOL_DEAGLE_DUAL_WIELD",
	"WEAPON_PISTOL_DEAGLE_WEAPON_ATTACHMENT_CHROME",
	"WEAPON_PISTOL_DEAGLE_WEAPON_ATTACHMENT_GAS_BLOCK",
	"WEAPON_PISTOL_DEAGLE_WEAPON_ATTACHMENT_GAS_SYSTEMS",
	"WEAPON_PISTOL_DEAGLE_WEAPON_ATTACHMENT_GOLD",
	"WEAPON_PISTOL_DEAGLE_WEAPON_ATTACHMENT_MAG_GUIDE",
	"WEAPON_PISTOL_DEAGLE_WEAPON_ATTACHMENT_RED_DOT_SCOPE",
	"WEAPON_PISTOL_GLOCK18_DUAL_WIELD",
	"WEAPON_PISTOL_GLOCK18_WEAPON_ATTACHMENT_BARREL_UPGRADES",
	"WEAPON_PISTOL_GLOCK18_WEAPON_ATTACHMENT_CHROME",
	"WEAPON_PISTOL_GLOCK18_WEAPON_ATTACHMENT_GAS_BLOCK",
	"WEAPON_PISTOL_GLOCK18_WEAPON_ATTACHMENT_GAS_SYSTEMS",
	"WEAPON_PISTOL_GLOCK18_WEAPON_ATTACHMENT_GOLD",
	"WEAPON_PISTOL_GLOCK18_WEAPON_ATTACHMENT_HIGH_CAPACITY_CLIP",
	"WEAPON_PISTOL_GLOCK18_WEAPON_ATTACHMENT_LASER_SIGHT",
	"WEAPON_PISTOL_GLOCK18_WEAPON_ATTACHMENT_MAG_GUIDE",
	"WEAPON_PISTOL_PT92_DUAL_WIELD",
	"WEAPON_PISTOL_PT92_WEAPON_ATTACHMENT_CHROME",
	"WEAPON_PISTOL_PT92_WEAPON_ATTACHMENT_COMPENSATOR",
	"WEAPON_PISTOL_PT92_WEAPON_ATTACHMENT_GAS_BLOCK",
	"WEAPON_PISTOL_PT92_WEAPON_ATTACHMENT_GAS_SYSTEMS",
	"WEAPON_PISTOL_PT92_WEAPON_ATTACHMENT_GOLD",
	"WEAPON_PISTOL_PT92_WEAPON_ATTACHMENT_HIGH_CAPACITY_CLIP",
	"WEAPON_PISTOL_PT92_WEAPON_ATTACHMENT_LASER_SIGHT",
	"WEAPON_PISTOL_PT92_WEAPON_ATTACHMENT_MAG_GUIDE",
	"WEAPON_PISTOL_PT92_WEAPON_ATTACHMENT_SUPPRESSOR",
	"WEAPON_PISTOL_TAURUS608_DUAL_WIELD",
	"WEAPON_PISTOL_TAURUS608_WEAPON_ATTACHMENT_BARREL_UPGRADES",
	"WEAPON_PISTOL_TAURUS608_WEAPON_ATTACHMENT_CHROME",
	"WEAPON_PISTOL_TAURUS608_WEAPON_ATTACHMENT_COMPENSATOR",
	"WEAPON_PISTOL_TAURUS608_WEAPON_ATTACHMENT_GOLD",
	"WEAPON_PISTOL_TAURUS608_WEAPON_ATTACHMENT_LASER_SIGHT",
	"WEAPON_RIFLE_97LC_WEAPON_ATTACHMENT_BARREL_UPGRADES",
	"WEAPON_RIFLE_97LC_WEAPON_ATTACHMENT_CHROME",
	"WEAPON_RIFLE_97LC_WEAPON_ATTACHMENT_GAS_BLOCK",
	"WEAPON_RIFLE_97LC_WEAPON_ATTACHMENT_GAS_SYSTEMS",
	"WEAPON_RIFLE_97LC_WEAPON_ATTACHMENT_GOLD",
	"WEAPON_RIFLE_97LC_WEAPON_ATTACHMENT_HIGH_CAPACITY_CLIP",
	"WEAPON_RIFLE_97LC_WEAPON_ATTACHMENT_LASER_SIGHT",
	"WEAPON_RIFLE_97LC_WEAPON_ATTACHMENT_MAG_GUIDE",
	"WEAPON_RIFLE_97LC_WEAPON_ATTACHMENT_SUPPRESSOR",
	"WEAPON_RIFLE_AK47_WEAPON_ATTACHMENT_BARREL_UPGRADES",
	"WEAPON_RIFLE_AK47_WEAPON_ATTACHMENT_CHROME",
	"WEAPON_RIFLE_AK47_WEAPON_ATTACHMENT_GAS_BLOCK",
	"WEAPON_RIFLE_AK47_WEAPON_ATTACHMENT_GAS_SYSTEMS",
	"WEAPON_RIFLE_AK47_WEAPON_ATTACHMENT_GOLD",
	"WEAPON_RIFLE_AK47_WEAPON_ATTACHMENT_HIGH_CAPACITY_CLIP",
	"WEAPON_RIFLE_AK47_WEAPON_ATTACHMENT_LASER_SIGHT",
	"WEAPON_RIFLE_AK47_WEAPON_ATTACHMENT_MAG_GUIDE",
	"WEAPON_RIFLE_AK47_WEAPON_ATTACHMENT_SUPPRESSOR",
	"WEAPON_RIFLE_FAL_WEAPON_ATTACHMENT_BARREL_UPGRADES",
	"WEAPON_RIFLE_FAL_WEAPON_ATTACHMENT_CHROME",
	"WEAPON_RIFLE_FAL_WEAPON_ATTACHMENT_COMPENSATOR",
	"WEAPON_RIFLE_FAL_WEAPON_ATTACHMENT_GAS_BLOCK",
	"WEAPON_RIFLE_FAL_WEAPON_ATTACHMENT_GAS_SYSTEMS",
	"WEAPON_RIFLE_FAL_WEAPON_ATTACHMENT_GOLD",
	"WEAPON_RIFLE_FAL_WEAPON_ATTACHMENT_HIGH_CAPACITY_CLIP",
	"WEAPON_RIFLE_FAL_WEAPON_ATTACHMENT_LASER_SIGHT",
	"WEAPON_RIFLE_FAL_WEAPON_ATTACHMENT_MAG_GUIDE",
	"WEAPON_RIFLE_FAL_WEAPON_ATTACHMENT_RED_DOT_SCOPE",
	"WEAPON_RIFLE_G36K_WEAPON_ATTACHMENT_BARREL_UPGRADES",
	"WEAPON_RIFLE_G36K_WEAPON_ATTACHMENT_CHROME",
	"WEAPON_RIFLE_G36K_WEAPON_ATTACHMENT_GAS_BLOCK",
	"WEAPON_RIFLE_G36K_WEAPON_ATTACHMENT_GAS_SYSTEMS",
	"WEAPON_RIFLE_G36K_WEAPON_ATTACHMENT_GOLD",
	"WEAPON_RIFLE_G36K_WEAPON_ATTACHMENT_LASER_SIGHT",
	"WEAPON_RIFLE_G36K_WEAPON_ATTACHMENT_MAG_GUIDE",
	"WEAPON_RIFLE_G36K_WEAPON_ATTACHMENT_SUPPRESSOR",
	"WEAPON_RIFLE_GALIL_WEAPON_ATTACHMENT_BARREL_UPGRADES",
	"WEAPON_RIFLE_GALIL_WEAPON_ATTACHMENT_CHROME",
	"WEAPON_RIFLE_GALIL_WEAPON_ATTACHMENT_GAS_BLOCK",
	"WEAPON_RIFLE_GALIL_WEAPON_ATTACHMENT_GAS_SYSTEMS",
	"WEAPON_RIFLE_GALIL_WEAPON_ATTACHMENT_GOLD",
	"WEAPON_RIFLE_GALIL_WEAPON_ATTACHMENT_HIGH_CAPACITY_CLIP",
	"WEAPON_RIFLE_GALIL_WEAPON_ATTACHMENT_LASER_SIGHT",
	"WEAPON_RIFLE_GALIL_WEAPON_ATTACHMENT_MAG_GUIDE",
	"WEAPON_RIFLE_GALIL_WEAPON_ATTACHMENT_RED_DOT_SCOPE",
	"WEAPON_RIFLE_GALIL_WEAPON_ATTACHMENT_SUPPRESSOR",
	"WEAPON_RIFLE_IA2_WEAPON_ATTACHMENT_BARREL_UPGRADES",
	"WEAPON_RIFLE_IA2_WEAPON_ATTACHMENT_CHROME",
	"WEAPON_RIFLE_IA2_WEAPON_ATTACHMENT_COMPENSATOR",
	"WEAPON_RIFLE_IA2_WEAPON_ATTACHMENT_GAS_BLOCK",
	"WEAPON_RIFLE_IA2_WEAPON_ATTACHMENT_GAS_SYSTEMS",
	"WEAPON_RIFLE_IA2_WEAPON_ATTACHMENT_GOLD",
	"WEAPON_RIFLE_IA2_WEAPON_ATTACHMENT_HIGH_CAPACITY_CLIP",
	"WEAPON_RIFLE_IA2_WEAPON_ATTACHMENT_LASER_SIGHT",
	"WEAPON_RIFLE_IA2_WEAPON_ATTACHMENT_MAG_GUIDE",
	"WEAPON_RIFLE_IA2_WEAPON_ATTACHMENT_SNIPER_SCOPE",
	"WEAPON_RIFLE_M4_CHROME",
	"WEAPON_RIFLE_M4_WEAPON_ATTACHMENT_BARREL_UPGRADES",
	"WEAPON_RIFLE_M4_WEAPON_ATTACHMENT_CHROME",
	"WEAPON_RIFLE_M4_WEAPON_ATTACHMENT_COMPENSATOR",
	"WEAPON_RIFLE_M4_WEAPON_ATTACHMENT_GAS_BLOCK",
	"WEAPON_RIFLE_M4_WEAPON_ATTACHMENT_GAS_SYSTEMS",
	"WEAPON_RIFLE_M4_WEAPON_ATTACHMENT_GOLD",
	"WEAPON_RIFLE_M4_WEAPON_ATTACHMENT_HIGH_CAPACITY_CLIP",
	"WEAPON_RIFLE_M4_WEAPON_ATTACHMENT_MAG_GUIDE",
	"WEAPON_RIFLE_M4_WEAPON_ATTACHMENT_RED_DOT_SCOPE",
	"WEAPON_RIFLE_M4_WEAPON_ATTACHMENT_SUPPRESSOR",
	"WEAPON_RIFLE_RUG30_WEAPON_ATTACHMENT_BARREL_UPGRADES",
	"WEAPON_RIFLE_RUG30_WEAPON_ATTACHMENT_CHROME",
	"WEAPON_RIFLE_RUG30_WEAPON_ATTACHMENT_COMPENSATOR",
	"WEAPON_RIFLE_RUG30_WEAPON_ATTACHMENT_GAS_BLOCK",
	"WEAPON_RIFLE_RUG30_WEAPON_ATTACHMENT_GAS_SYSTEMS",
	"WEAPON_RIFLE_RUG30_WEAPON_ATTACHMENT_GOLD",
	"WEAPON_RIFLE_RUG30_WEAPON_ATTACHMENT_HIGH_CAPACITY_CLIP",
	"WEAPON_RIFLE_RUG30_WEAPON_ATTACHMENT_MAG_GUIDE",
	"WEAPON_RIFLE_RUG30_WEAPON_ATTACHMENT_SNIPER_SCOPE",
	"WEAPON_RIFLE_RUG30_WEAPON_ATTACHMENT_SUPPRESSOR",
	"WEAPON_RIFLE_TAR_WEAPON_ATTACHMENT_BARREL_UPGRADES",
	"WEAPON_RIFLE_TAR_WEAPON_ATTACHMENT_CHROME",
	"WEAPON_RIFLE_TAR_WEAPON_ATTACHMENT_COMPENSATOR",
	"WEAPON_RIFLE_TAR_WEAPON_ATTACHMENT_GAS_BLOCK",
	"WEAPON_RIFLE_TAR_WEAPON_ATTACHMENT_GAS_SYSTEMS",
	"WEAPON_RIFLE_TAR_WEAPON_ATTACHMENT_GOLD",
	"WEAPON_RIFLE_TAR_WEAPON_ATTACHMENT_HIGH_CAPACITY_CLIP",
	"WEAPON_RIFLE_TAR_WEAPON_ATTACHMENT_LASER_SIGHT",
	"WEAPON_RIFLE_TAR_WEAPON_ATTACHMENT_MAG_GUIDE",
	"WEAPON_RIFLE_TAR_WEAPON_ATTACHMENT_RED_DOT_SCOPE",
	"WEAPON_RIFLE_TAR_WEAPON_ATTACHMENT_SUPPRESSOR",
	"WEAPON_RPG_WEAPON_ATTACHMENT_CHROME",
	"WEAPON_RPG_WEAPON_ATTACHMENT_GOLD",
	"WEAPON_SHOTGUN_BENELLIM3_WEAPON_ATTACHMENT_BARREL_UPGRADES",
	"WEAPON_SHOTGUN_BENELLIM3_WEAPON_ATTACHMENT_CHROME",
	"WEAPON_SHOTGUN_BENELLIM3_WEAPON_ATTACHMENT_GAS_BLOCK",
	"WEAPON_SHOTGUN_BENELLIM3_WEAPON_ATTACHMENT_GAS_SYSTEMS",
	"WEAPON_SHOTGUN_BENELLIM3_WEAPON_ATTACHMENT_GOLD",
	"WEAPON_SHOTGUN_BENELLIM3_WEAPON_ATTACHMENT_LASER_SIGHT",
	"WEAPON_SHOTGUN_DOUBLEBARREL_DUAL_WIELD",
	"WEAPON_SHOTGUN_DOUBLEBARREL_WEAPON_ATTACHMENT_CHROME",
	"WEAPON_SHOTGUN_DOUBLEBARREL_WEAPON_ATTACHMENT_GOLD",
	"WEAPON_SHOTGUN_HAMMERHEAD_WEAPON_ATTACHMENT_BARREL_UPGRADES",
	"WEAPON_SHOTGUN_HAMMERHEAD_WEAPON_ATTACHMENT_CHROME",
	"WEAPON_SHOTGUN_HAMMERHEAD_WEAPON_ATTACHMENT_GAS_BLOCK",
	"WEAPON_SHOTGUN_HAMMERHEAD_WEAPON_ATTACHMENT_GAS_SYSTEMS",
	"WEAPON_SHOTGUN_HAMMERHEAD_WEAPON_ATTACHMENT_GOLD",
	"WEAPON_SHOTGUN_HAMMERHEAD_WEAPON_ATTACHMENT_LASER_SIGHT",
	"WEAPON_SHOTGUN_MOSSBERG590_WEAPON_ATTACHMENT_BARREL_UPGRADES",
	"WEAPON_SHOTGUN_MOSSBERG590_WEAPON_ATTACHMENT_CHROME",
	"WEAPON_SHOTGUN_MOSSBERG590_WEAPON_ATTACHMENT_GAS_BLOCK",
	"WEAPON_SHOTGUN_MOSSBERG590_WEAPON_ATTACHMENT_GAS_SYSTEMS",
	"WEAPON_SHOTGUN_MOSSBERG590_WEAPON_ATTACHMENT_GOLD",
	"WEAPON_SHOTGUN_MOSSBERG590_WEAPON_ATTACHMENT_LASER_SIGHT",
	"WEAPON_SHOTGUN_MOSSBERG590_WEAPON_ATTACHMENT_RED_DOT_SCOPE",
	"WEAPON_SHOTGUN_SPAS15_WEAPON_ATTACHMENT_BARREL_UPGRADES",
	"WEAPON_SHOTGUN_SPAS15_WEAPON_ATTACHMENT_CHROME",
	"WEAPON_SHOTGUN_SPAS15_WEAPON_ATTACHMENT_GAS_BLOCK",
	"WEAPON_SHOTGUN_SPAS15_WEAPON_ATTACHMENT_GAS_SYSTEMS",
	"WEAPON_SHOTGUN_SPAS15_WEAPON_ATTACHMENT_GOLD",
	"WEAPON_SHOTGUN_SPAS15_WEAPON_ATTACHMENT_LASER_SIGHT",
	"WEAPON_SHOTGUN_SPAS15_WEAPON_ATTACHMENT_RED_DOT_SCOPE",
	"WEAPON_SHOTGUN_WINCHESTERSX3_WEAPON_ATTACHMENT_BARREL_UPGRADES",
	"WEAPON_SHOTGUN_WINCHESTERSX3_WEAPON_ATTACHMENT_CHROME",
	"WEAPON_SHOTGUN_WINCHESTERSX3_WEAPON_ATTACHMENT_GAS_BLOCK",
	"WEAPON_SHOTGUN_WINCHESTERSX3_WEAPON_ATTACHMENT_GAS_SYSTEMS",
	"WEAPON_SHOTGUN_WINCHESTERSX3_WEAPON_ATTACHMENT_GOLD",
	"WEAPON_SHOTGUN_WINCHESTERSX3_WEAPON_ATTACHMENT_LASER_SIGHT",
	"WEAPON_SHOTGUN_WINCHESTERSX3_WEAPON_ATTACHMENT_RED_DOT_SCOPE",
	"WEAPON_SMG_FAMAEMT40_WEAPON_ATTACHMENT_BARREL_UPGRADES",
	"WEAPON_SMG_FAMAEMT40_WEAPON_ATTACHMENT_CHROME",
	"WEAPON_SMG_FAMAEMT40_WEAPON_ATTACHMENT_COMPENSATOR",
	"WEAPON_SMG_FAMAEMT40_WEAPON_ATTACHMENT_GAS_BLOCK",
	"WEAPON_SMG_FAMAEMT40_WEAPON_ATTACHMENT_GAS_SYSTEMS",
	"WEAPON_SMG_FAMAEMT40_WEAPON_ATTACHMENT_GOLD",
	"WEAPON_SMG_FAMAEMT40_WEAPON_ATTACHMENT_LASER_SIGHT",
	"WEAPON_SMG_FAMAEMT40_WEAPON_ATTACHMENT_MAG_GUIDE",
	"WEAPON_SMG_FAMAEMT40_WEAPON_ATTACHMENT_SUPPRESSOR",
	"WEAPON_SMG_MAC10_DUAL_WIELD",
	"WEAPON_SMG_MAC10_WEAPON_ATTACHMENT_BARREL_UPGRADES",
	"WEAPON_SMG_MAC10_WEAPON_ATTACHMENT_CHROME",
	"WEAPON_SMG_MAC10_WEAPON_ATTACHMENT_COMPENSATOR",
	"WEAPON_SMG_MAC10_WEAPON_ATTACHMENT_GAS_BLOCK",
	"WEAPON_SMG_MAC10_WEAPON_ATTACHMENT_GAS_SYSTEMS",
	"WEAPON_SMG_MAC10_WEAPON_ATTACHMENT_GOLD",
	"WEAPON_SMG_MAC10_WEAPON_ATTACHMENT_HIGH_CAPACITY_CLIP",
	"WEAPON_SMG_MAC10_WEAPON_ATTACHMENT_LASER_SIGHT",
	"WEAPON_SMG_MAC10_WEAPON_ATTACHMENT_SUPPRESSOR",
	"WEAPON_SMG_MP5_WEAPON_ATTACHMENT_BARREL_UPGRADES",
	"WEAPON_SMG_MP5_WEAPON_ATTACHMENT_CHROME",
	"WEAPON_SMG_MP5_WEAPON_ATTACHMENT_GAS_BLOCK",
	"WEAPON_SMG_MP5_WEAPON_ATTACHMENT_GAS_SYSTEMS",
	"WEAPON_SMG_MP5_WEAPON_ATTACHMENT_GOLD",
	"WEAPON_SMG_MP5_WEAPON_ATTACHMENT_HIGH_CAPACITY_CLIP",
	"WEAPON_SMG_MP5_WEAPON_ATTACHMENT_LASER_SIGHT",
	"WEAPON_SMG_MP5_WEAPON_ATTACHMENT_MAG_GUIDE",
	"WEAPON_SMG_MP5_WEAPON_ATTACHMENT_SUPPRESSOR",
	"WEAPON_SMG_PM12_DUAL_WIELD",
	"WEAPON_SMG_PM12_WEAPON_ATTACHMENT_BARREL_UPGRADES",
	"WEAPON_SMG_PM12_WEAPON_ATTACHMENT_CHROME",
	"WEAPON_SMG_PM12_WEAPON_ATTACHMENT_GAS_BLOCK",
	"WEAPON_SMG_PM12_WEAPON_ATTACHMENT_GAS_SYSTEMS",
	"WEAPON_SMG_PM12_WEAPON_ATTACHMENT_GOLD",
	"WEAPON_SMG_PM12_WEAPON_ATTACHMENT_HIGH_CAPACITY_CLIP",
	"WEAPON_SMG_PM12_WEAPON_ATTACHMENT_MAG_GUIDE",
	"WEAPON_SMG_UZI_DUAL_WIELD",
	"WEAPON_SMG_UZI_WEAPON_ATTACHMENT_CHROME",
	"WEAPON_SMG_UZI_WEAPON_ATTACHMENT_COMPENSATOR",
	"WEAPON_SMG_UZI_WEAPON_ATTACHMENT_GAS_BLOCK",
	"WEAPON_SMG_UZI_WEAPON_ATTACHMENT_GAS_SYSTEMS",
	"WEAPON_SMG_UZI_WEAPON_ATTACHMENT_GOLD",
	"WEAPON_SMG_UZI_WEAPON_ATTACHMENT_HIGH_CAPACITY_CLIP",
	"WEAPON_SMG_UZI_WEAPON_ATTACHMENT_LASER_SIGHT",
	"WEAPON_SMG_UZI_WEAPON_ATTACHMENT_MAG_GUIDE",
	"WEAPON_SMG_UZI_WEAPON_ATTACHMENT_SUPPRESSOR",
	"WEAPON_SNIPER_M24_WEAPON_ATTACHMENT_BARREL_UPGRADES",
	"WEAPON_SNIPER_M24_WEAPON_ATTACHMENT_CHROME",
	"WEAPON_SNIPER_M24_WEAPON_ATTACHMENT_GAS_BLOCK",
	"WEAPON_SNIPER_M24_WEAPON_ATTACHMENT_GAS_SYSTEMS",
	"WEAPON_SNIPER_M24_WEAPON_ATTACHMENT_GOLD",
	"WEAPON_SNIPER_M24_WEAPON_ATTACHMENT_HIGH_CAPACITY_CLIP",
	"WEAPON_SNIPER_M24_WEAPON_ATTACHMENT_MAG_GUIDE",
	"WEAPON_SNIPER_M24_WEAPON_ATTACHMENT_SUPPRESSOR",
	"WEAPON_SNIPER_M82_WEAPON_ATTACHMENT_BARREL_UPGRADES",
	"WEAPON_SNIPER_M82_WEAPON_ATTACHMENT_CHROME",
	"WEAPON_SNIPER_M82_WEAPON_ATTACHMENT_COMPENSATOR",
	"WEAPON_SNIPER_M82_WEAPON_ATTACHMENT_GAS_BLOCK",
	"WEAPON_SNIPER_M82_WEAPON_ATTACHMENT_GAS_SYSTEMS",
	"WEAPON_SNIPER_M82_WEAPON_ATTACHMENT_GOLD",
	"WEAPON_SNIPER_M82_WEAPON_ATTACHMENT_HIGH_CAPACITY_CLIP",
	"WEAPON_SNIPER_M82_WEAPON_ATTACHMENT_MAG_GUIDE",
	"WEAPON_SNIPER_SG1_WEAPON_ATTACHMENT_BARREL_UPGRADES",
	"WEAPON_SNIPER_SG1_WEAPON_ATTACHMENT_CHROME",
	"WEAPON_SNIPER_SG1_WEAPON_ATTACHMENT_GAS_BLOCK",
	"WEAPON_SNIPER_SG1_WEAPON_ATTACHMENT_GAS_SYSTEMS",
	"WEAPON_SNIPER_SG1_WEAPON_ATTACHMENT_GOLD",
	"WEAPON_SNIPER_SG1_WEAPON_ATTACHMENT_HIGH_CAPACITY_CLIP",
	"WEAPON_SNIPER_SG1_WEAPON_ATTACHMENT_MAG_GUIDE",
	"WEAPON_STUN_GUN_WEAPON_ATTACHMENT_CHROME",
	"WEAPON_STUN_GUN_WEAPON_ATTACHMENT_GOLD"
};

static const Hash profileSettingHashes[] = {
	0x002C5D94,
	0x003327FC,
	0x02041719, // Voice Chat Talking Enabled (0 = Off, 1 = On)
	0x0278EDEB,
	0x03BD2DCC,
	0x03CC561B,
	0x05034C6B,
	0x067E3D12, // Gamepad Aiming Acceleration (1 - 10)
	0x06F0C30B, // Voice Chat Microphone Sensitivity (0 - 10)
	0x07EB6EF6,
	0x08B15025, // Gamepad Configuration (0 = Type 1, 1 = Type 2, 2 = Type 3, 3 = Type 4)
	0x09D0A733,
	0x0D129969,
	0x0DB72E68,
	0x0DD39DE4, // Gamepad Vertical Aiming Speed (1 - 10)
	0x0F755F93,
	0x104114E0,
	0x10E336FF,
	0x1265DE3C,
	0x1428D037,
	0x1588EC2A,
	0x15AB1A2F,
	0x16352426,
	0x1868B3A2,
	0x1A746B2B,
	0x1A77A188,
	0x1A9E6B57, // Sound Effects Volume (0 - 9)
	0x1D40CAB9,
	0x21EDFA60,
	0x228D33B0,
	0x22C597A2,
	0x22E3C03B, // Outline Pickups (0 = Off, 1 = On)
	0x23541117,
	0x2435D98A,
	0x2538C364,
	0x27EE4A36,
	0x2AF19527,
	0x2DA50EE4, // Bullet Time FX (0 = Off, 1 = On)
	0x2E188466,
	0x2EFD64DF, // Gamepad Vibration (0 = Off, 1 = On)
	0x2FB34367,
	0x309D3AAE, // Reticle Type (0 = Weapon Specific, 1 = Always White, 2 = Default)
	0x31A6A855,
	0x3235691B,
	0x33417882,
	0x33D7A8F0,
	0x3661E0BD,
	0x3693BC63,
	0x39F9769E,
	0x3D2F6692,
	0x3DC3237C,
	0x3F52BB08,
	0x3FDDFDBD,
	0x3FE4999E, // Display Contrast (0 - 15)
	0x42566993,
	0x43C87D2D,
	0x44C98022,
	0x45FBAE77, // Mouse Horizontal Aiming Speed (1 - 10)
	0x479CDBD8,
	0x485366B9,
	0x48F6AD77,
	0x4B55F932, // Replay Mode Difficulty (1 = Easy, 2 = Medium, 3 = Hard)
	0x4B9B417A,
	0x4D2F41F6,
	0x4D5E3B21,
	0x4DB76EB1,
	0x4F5665EB,
	0x4FA52B02,
	0x50469DBF, // Voice Chat (0 = Off, 1 = On)
	0x516F63E8,
	0x526032D2,
	0x53E76C7D,
	0x58815D51,
	0x5A37C9F2,
	0x5A62AC99,
	0x5B3C396C,
	0x5C366591,
	0x5C79772F,
	0x5F6D3863,
	0x5FA13B6D,
	0x60AD5B05,
	0x6230CC8D, // Mouse Acceleration (0 = Off, 1 = On)
	0x62E83B9D,
	0x64BCDDB0,
	0x65167E7E,
	0x66581809,
	0x66C7928C, // Voice Chat Sound Volume (0 - 100)
	0x68C62AB0,
	0x6AC88C9E,
	0x6BBDB259,
	0x6BCF7AD9,
	0x6D8117CF,
	0x6EA06D85,
	0x6EB7A700,
	0x72BFB39B,
	0x732CAEE2,
	0x74C4E84A,
	0x75839196,
	0x76AC7BAB,
	0x78B5C76F,
	0x7909F088,
	0x79943CB3,
	0x7C446C3F,
	0x7CCB4272,
	0x7D4DECE8,
	0x80941CCA,
	0x8166E782,
	0x839396E0, // Kill Indicator (0 = Off, 1 = On)
	0x856B3738,
	0x8748DA5D,
	0x88D7C78D,
	0x8A013F38,
	0x8ACA1F6D,
	0x8B9B4936, // Voice Chat Microphone Volume (0 - 100)
	0x8B9D0781,
	0x8BB3CDEE,
	0x8D021C19,
	0x8FEEE257, // Display Brightness (0 - 15)
	0x9080DE47,
	0x90F749A1,
	0x90FA918F,
	0x91738223,
	0x92CA70F0,
	0x92F12890, // Music Volume (0 - 9)
	0x938D185C,
	0x94460682,
	0x9482EF81, // Subtitles (0 = Off, 1 = On)
	0x9591340D,
	0x95D830AB,
	0x95ED8395,
	0x961050C7, // Golden Gun Effects (0 = Off, 1 = On)
	0x9835B79A,
	0x9A9379D3,
	0x9AE69488,
	0xA0B89735,
	0xA301C041,
	0xA37ABF38,
	0xA535D78D,
	0xA6A15F24,
	0xA7DD5C4B,
	0xA894F50D, // Gamepad Invert Vertical Look (0 = Off, 1 = On)
	0xABF3FA41,
	0xAC1F4639, // Target Tracking (0 = Off, 1 = On)
	0xAC821F61, // MP Game Difficulty (1 = Easy, 2 = Medium, 3 = Hard)
	0xAD605BE6,
	0xAEFD40DD, // Voice Chat Output Device (0 = Default)
	0xB017B11F,
	0xB0D35F5E,
	0xB165393A,
	0xB2221AAF,
	0xB24AE515,
	0xB54F61FA,
	0xB8F263B8,
	0xB9444A15,
	0xBA067756,
	0xBB48D695, // Gamepad Invert Horizontal Look (0 = Off, 1 = On)
	0xBC50E82D, // Target Slowdown (0 = Off, 1 = On)
	0xBD9A0493,
	0xBFDD0BAD, // Gamepad Targeting (0 = Hard Lock, 1 = Soft Lock, 2 = Free Aim)
	0xC3562A04,
	0xC37E728F, // Voice Chat Input Device (0 = Default)
	0xC63CC639,
	0xC850ECD6,
	0xC9CB92C3,
	0xC9F7C06F, // Game Difficulty (1 = Easy, 2 = Medium, 3 = Hard)
	0xCACCE34B,
	0xCB172E30,
	0xCC96A601,
	0xCE4D486E,
	0xCFA3929C,
	0xD21A2A10, // Audio Output (0 = Stereo, 1 = Surround Side, 2 = Surround Rear, 3 = Headphones)
	0xD27877F3,
	0xD464262F,
	0xD47CAA6F,
	0xD51D9DB3,
	0xD5F9F3AE,
	0xD6426AA4, // Mouse Vertical Aiming Speed (1 - 10)
	0xD65B1768, // Gamepad Horizontal Aiming Speed (1 - 10)
	0xD6B4F130,
	0xD6F5C4BD,
	0xD753BB28,
	0xD87B9AEB,
	0xD9D151A9,
	0xDA456A49,
	0xDD0B0AF2, // Invert Mouse Look (0 = Off, 1 = On)
	0xE0C47748,
	0xE19FEAF3, // Voice Chat Output Volume (0 - 100)
	0xE1A44622,
	0xE1FF9376,
	0xE4B3082F,
	0xE4CAFBDB,
	0xE5A90D5D,
	0xE6C9C60A,
	0xEA509C79, // Voice Chat Mode (0 = Voice Activated, 1 = Push To Talk)
	0xEBDFBEF5,
	0xEC7EF8D1,
	0xECCDFFBC,
	0xECE6E2A5,
	0xEE1F2222,
	0xEE9F65E1,
	0xEF234C82, // Voice Chat Music Volume (0 - 100)
	0xF2121B49,
	0xF3554A46,
	0xF621009C,
	0xF673C721,
	0xF73A0618,
	0xF78FDA07,
	0xF7BF082C,
	0xF81C63C7,
	0xF8299660,
	0xF9CCB8C7,
	0xFAF59DCD, // Southpaw Mode (0 = Off, 1 = On)
	0xFB4FBA51,
	0xFB7124C6, // Lowest Used Difficulty
	0xFEA632BB,
	0xFF15BE0F
};
# 67 "C:\\Users\\USER\\Documents\\Visual Studio 2013\\Projects\\mp3_plugin_PS3\\mp3_plugin_PS3\\main.cpp"




static const int __begin_of_section_lib_ent[1] __attribute__((aligned(4),section(".lib.ent.top", "a"),unused)) = {0}; static const int __end_of_section_lib_ent[1] __attribute__((aligned(4),section(".lib.ent.btm", "a"),unused)) = {0}; static const int __begin_of_section_lib_stub[1] __attribute__((aligned(4),section(".lib.stub.top", "a"),unused)) = {0}; static const int __end_of_section_lib_stub[1] __attribute__((aligned(4),section(".lib.stub.btm", "a"),unused)) = {0}; extern SceModuleInfo __psp_moduleinfo __attribute__((aligned(4),section(".rodata.sceModuleInfo","a"),unused)) = { 0, { 1, 1 }, "mp3_plugin_PS3", 0, static_cast<void* >(0), static_cast<const void* >(__begin_of_section_lib_ent+1), static_cast<const void* >(__end_of_section_lib_ent), static_cast<const void* >(__begin_of_section_lib_stub+1), static_cast<const void* >(__end_of_section_lib_stub) }; __asm__( ".pushsection   .psp_lib_markimport_" "" ",\"aw\",@progbits\n" "        .align 3\n" "        .quad  " "__psp_moduleinfo" "\n" "        .popsection\n"); __asm__( ".pushsection   .psp_lib_mark_" "" ",\"aw\",@progbits\n" "        .align 2\n" "        .type __PSPEXP_" "" "_" "module_info" ", @object\n" "        .size __PSPEXP_" "" "_" "module_info" ", 8\n" "__PSPEXP_" "" "_" "module_info" ":\n" "          .long  1, " "1" "\n" "        .type __PSPREN_" "" "_" "module_info" "_" "__psp_moduleinfo" ", @object\n" "        .size __PSPREN_" "" "_" "module_info" "_" "__psp_moduleinfo" ", 8\n" "__PSPREN_" "" "_" "module_info" "_" "__psp_moduleinfo" ":\n" "          .long  1, " "0" "\n" "        .popsection\n");
__asm__( ".pushsection   .psp_lib_markimport_" "" ",\"aw\",@progbits\n" "        .align 3\n" "        .quad  " "MODULE_START" "\n" "        .popsection\n"); __asm__( ".pushsection   .psp_lib_mark_" "" ",\"aw\",@progbits\n" "        .align 2\n" "        .type __PSPEXP_" "" "_" "module_start" ", @object\n" "        .size __PSPEXP_" "" "_" "module_start" ", 8\n" "__PSPEXP_" "" "_" "module_start" ":\n" "          .long  1, " "0" "\n" "        .type __PSPREN_" "" "_" "module_start" "_" "MODULE_START" ", @object\n" "        .size __PSPREN_" "" "_" "module_start" "_" "MODULE_START" ", 8\n" "__PSPREN_" "" "_" "module_start" "_" "MODULE_START" ":\n" "          .long  1, " "0" "\n" "        .popsection\n");
__asm__( ".pushsection   .psp_lib_markimport_" "" ",\"aw\",@progbits\n" "        .align 3\n" "        .quad  " "MODULE_STOP" "\n" "        .popsection\n"); __asm__( ".pushsection   .psp_lib_mark_" "" ",\"aw\",@progbits\n" "        .align 2\n" "        .type __PSPEXP_" "" "_" "module_stop" ", @object\n" "        .size __PSPEXP_" "" "_" "module_stop" ", 8\n" "__PSPEXP_" "" "_" "module_stop" ":\n" "          .long  1, " "0" "\n" "        .type __PSPREN_" "" "_" "module_stop" "_" "MODULE_STOP" ", @object\n" "        .size __PSPREN_" "" "_" "module_stop" "_" "MODULE_STOP" ", 8\n" "__PSPREN_" "" "_" "module_stop" "_" "MODULE_STOP" ":\n" "          .long  1, " "0" "\n" "        .popsection\n");
__asm__( ".pushsection   .psp_lib_markimport_" "" ",\"aw\",@progbits\n" "        .align 3\n" "        .quad  " "MODULE_EXIT" "\n" "        .popsection\n"); __asm__( ".pushsection   .psp_lib_mark_" "" ",\"aw\",@progbits\n" "        .align 2\n" "        .type __PSPEXP_" "" "_" "module_exit" ", @object\n" "        .size __PSPEXP_" "" "_" "module_exit" ", 8\n" "__PSPEXP_" "" "_" "module_exit" ":\n" "          .long  1, " "0" "\n" "        .type __PSPREN_" "" "_" "module_exit" "_" "MODULE_EXIT" ", @object\n" "        .size __PSPREN_" "" "_" "module_exit" "_" "MODULE_EXIT" ", 8\n" "__PSPREN_" "" "_" "module_exit" "_" "MODULE_EXIT" ":\n" "          .long  1, " "0" "\n" "        .popsection\n");




//credits
// https://github.com/UnknownModder/mp3-plugin-sdk
//unknownmodder
//jedijosh920
//dirk
//therouletteboi

void(*ORG_NATIVE_GET_PLAYER_ID)(NativeContext*);










void scriptMain()
{
	if (PLAYER::DOES_MAIN_PLAYER_EXIST())
	{
		Player player = PLAYER::GET_PLAYER_ID();
		Ped playerPed = PLAYER::GET_PLAYER_PED(player);

		PLAYER::SET_PLAYER_INVINCIBLE(player, true);

		int num = PLAYER::GET_PAYNEKILLER_AMT();
		if (num < 9)
		{
			PLAYER::SET_PAYNEKILLER_AMT(9);
		}

		if (PAD::IS_CONTROL_JUST_PRESSED(2, INPUT_FRONTEND_LEFT))
		{
			if (!WEAPON::HAS_PED_GOT_WEAPON(playerPed, WEAPON_SMG_MP5))
				WEAPON::GIVE_WEAPON_TO_PED(playerPed, WEAPON_SMG_MP5, 25000, true);
		}

		if (PAD::IS_CONTROL_JUST_PRESSED(2, INPUT_FRONTEND_RIGHT))
		{
			const int ARR_SIZE = 256;

			Ped peds[ARR_SIZE];
			int count = worldGetAllPeds(peds, ARR_SIZE);

			for (int i = 0; i < count; i++)
			{
				if (peds[i] != playerPed)
				{
					Vector3 coords = PED::GET_PED_COORDS(peds[i]);
					FIRE::ADD_EXPLOSION(coords.x, coords.y, coords.z, EXP_TAG_MOLOTOV, 1.0f, true, false, 1.0f);
				}
			}
		}
	}
}


void MY_NATIVE_GET_PLAYER_ID(NativeContext *cxt)
{
	scriptMain();
	ORG_NATIVE_GET_PLAYER_ID(cxt);
}





extern "C" int MODULE_START(void)
{
	native_table_address = 0x1D96D00;
	native_table_modulator = native_table_address + 0x4;
	g_Natives = (unsigned int*)native_table_address;


	nativeHook(0x1CC648EA, (unsigned int)MY_NATIVE_GET_PLAYER_ID);


    return 0;
}

extern "C" int MODULE_STOP(void)
{

	return 0;
}

extern "C" int MODULE_EXIT(void)
{

	return 0;
}

